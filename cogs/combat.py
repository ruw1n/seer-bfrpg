from __future__ import annotations
import os
import re
import random
import configparser
import difflib
import nextcord
import math
import asyncio
import sys
import time
from nextcord.ext import commands
from math import ceil
from decimal import Decimal, ROUND_HALF_UP
from pathlib import Path
from dataclasses import dataclass, field
from typing import Optional, List, Tuple, Dict, Any
from cogs.initiative import (
    _load_battles, _parse_combatants, _write_combatants,
    _sorted_entries, _section_id, _format_tracker_block,
    _life_bar, _slot, _save_battles,
    _add_oil_burn, _apply_stoneskin_absorb, _choose_slot_for_effects,
    _find_ci_or_partial_name,
)
from utils.players import get_active
from utils.ini import read_cfg, get_compat, getint_compat, write_cfg


def _safe_monster_ini_path(mtype: str) -> str | None:
    """
    Return a safe, repo-relative path to a monster template INI, or None.
    Disallows traversal; only letters, digits, _ and -; trims dots.
    """
    base = re.sub(r'[^a-z0-9_-]+', '', str(mtype or '').lower()).strip('._-')
    if not base:
        return None
    candidates = [
        os.path.join("monsters", f"{base}.ini"),
        os.path.join("mon",       f"{base}.ini"),
        f"{base}.ini",
    ]
    for p in candidates:
        ap = os.path.abspath(p)
        if os.path.commonpath([ap, os.getcwd()]) != os.getcwd():
            continue
        if os.path.isfile(ap):
            return ap
    return None


BATTLE_FILE = "battle.lst"

                                                                                                       
_TURN_UNDEAD_TABLE = {
    1:  [13,17,19,None,None,None,None,None,None],
    2:  [11,15,18,20, None,None,None,None,None],
    3:  [ 9,13,17,19, None,None,None,None,None],
    4:  [ 7,11,15,18, 20, None,None,None,None],
    5:  [ 5, 9,13,17, 19, None,None,None,None],
    6:  [ 3, 7,11,15, 18, 20, None,None,None],
    7:  [ 2, 5, 9,13, 17, 19, None,None,None],
    8:  ['T',3, 7,11, 15, 18, 20, None,None],
    9:  ['T',2, 5, 9, 13, 17, 19, None,None],
    10: ['T','T',3, 7, 11, 15, 18, 20, None],
    11: ['D','T',2, 5,  9, 13, 17, 19, None],
    12: ['D','T','T',3, 7, 11, 15, 18, 20],
    13: ['D','D','T',2, 5,  9, 13, 17, 19],
    14: ['D','D','T','T',3, 7, 11, 15, 18],
    15: ['D','D','D','T',2, 5,  9, 13, 17],
    16: ['D','D','D','T','T',3, 7, 11, 15],
    17: ['D','D','D','D','T',2, 5,  9, 13],
    18: ['D','D','D','D','T','T',3, 7, 11],
    19: ['D','D','D','D','D','T',2, 5,  9],
    20: ['D','D','D','D','D','T','T',3, 7],
}
_UNDEAD_COL = {
    'skeleton':0, 'zombie':1, 'ghoul':2, 'wight':3, 'wraith':4,
    'mummy':5, 'spectre':6, 'specter':6, 'vampire':7, 'ghost':8,
}
_COL_NAME = ["Skeleton","Zombie","Ghoul","Wight","Wraith","Mummy","Spectre","Vampire","Ghost (9+ HD)"]

_UNDEAD_TOKENS = {"undead","skeleton","zombie","ghoul","wight","wraith","mummy","spectre","specter","vampire","ghost"}

_PRESET_MAP = {
                                                
                                                         
    "classic": {
        "base": False,
        "overrides": {
            "classic_vancian_prep": True,      
            "magethief_illusionist_list": False,                                           
        },
    },
    "house": {
        "base": True,
        "overrides": {
            "classic_vancian_prep": False,      
            "magethief_illusionist_list": True,                   
        },
    },
}

_ADV_FLAGS = {
    "adv","advantage","flank","flanking","rear","rear-attack","rearattack","behind","backstab"
}

def _sanity_patch_builtins() -> None:
    """If any built-in rows are wrong (from stale code), fix them in-place."""
    want_f1 = {"poi":12, "wand":13, "para":14, "breath":15, "spell":17}
    bad = False
    cur = globals().get("_DEFAULT_F1", {})
    if tuple(cur.get(k) for k in ("poi","wand","para","breath","spell")) !=\
       tuple(want_f1[k] for k in ("poi","wand","para","breath","spell")):
        globals()["_DEFAULT_F1"] = want_f1.copy()
        bad = True
    frow = globals().get("_BUILTIN_L1", {}).get("fighter", {})
    if tuple(frow.get(k) for k in ("poi","wand","para","breath","spell")) !=\
       tuple(want_f1[k] for k in ("poi","wand","para","breath","spell")):
        _BUILTIN_L1["fighter"] = want_f1.copy()
        bad = True
    if bad:
                  
        pass
                                                
SAVE_KEYS = ("poi", "wand", "para", "breath", "spell")

                                           
_BUILTIN_L1 = {
    "fighter":   {"poi": 12, "wand": 13, "para": 14, "breath": 15, "spell": 17},
    "cleric":    {"poi": 11, "wand": 12, "para": 14, "breath": 16, "spell": 15},
    "magicuser": {"poi": 13, "wand": 14, "para": 13, "breath": 16, "spell": 15},
}
_DEFAULT_F1 = _BUILTIN_L1["fighter"]

              
_CLASS_SAVES: Optional[Dict[str, Dict[str, List[int]]]] = None
_CLASS_SAVES_SOURCE: Optional[str] = None                                     
_CLASS_SAVES_OVERRIDE_PATH: Optional[str] = None    
_CLASS_LST_ENV = "SEER_CLASS_LST"

_SAVE_KEY_CANON = {
    "poi": "poi", "poison": "poi", "death": "poi",
    "wand": "wand", "wands": "wand",
    "para": "para", "paralyze": "para", "paralysis": "para", "petrify": "para",
    "breath": "breath", "dragonbreath": "breath",
    "spell": "spell", "spells": "spell"
}

_BLUDGEON_KWS = {
    "slam","fist","punch","kick","hoof","tentacle","butt","bump","trample","rock","tail"
}
_SLASH_KWS = {
    "claw","claws","cane","bonehook","talon","fin","pincer","whip","blade"
}
_PIERCE_KWS = {
    "bite","wolfbite","snakebite","pantherbite","horn","fork","beak","tusk","sting","stinger","gore","swarm"
}
    
def _canon_vs(v: str) -> str:
    k = (str(v) or "").lower().replace(" ", "")
    return _SAVE_KEY_CANON.get(k, k)

def _norm_class_name(name: str) -> str:
    n = (name or "").strip().lower().replace("_", " ").replace("-", " ")
                                 
    exact = {
        "fighter": "fighter",
        "fightermage": "fightermage", "fighter mage": "fightermage",
        "magic user": "magic-user", "magic-user": "magic-user", "mu": "magic-user", "mage": "magic-user", "wizard": "magic-user",
        "cleric": "cleric", "druid": "druid", "thief": "thief", "assassin": "assassin",
        "ranger": "ranger", "paladin": "paladin", "barbarian": "barbarian",
        "illusionist": "illusionist", "necromancer": "necromancer", "spellcrafter": "spellcrafter",
        "nm": "nm", "normal man": "nm", "normalman": "nm",
    }
    return exact.get(n, n)

def _section_for_class(klass: str) -> str | None:
    """Return the exact class section (no prefix/fuzzy)."""
    k = _norm_class_name(klass)
    by_norm = { _norm_class_name(sec): sec for sec in _CLASS_SAVES.keys() }
    return by_norm.get(k)


def _find_class_lst_with_traces() -> Tuple[Optional[str], List[str]]:
    """Find class.lst using override, env, CWD, data, and file dir."""
    tried: List[str] = []
    if _CLASS_SAVES_OVERRIDE_PATH:
        p = os.path.abspath(_CLASS_SAVES_OVERRIDE_PATH)
        tried.append(p)
        if os.path.exists(p): return p, tried
    envp = os.environ.get(_CLASS_LST_ENV)
    if envp:
        p = os.path.abspath(envp)
        tried.append(p)
        if os.path.exists(p): return p, tried
    here = os.path.dirname(__file__)
    for p in [
        os.path.join(os.getcwd(), "class.lst"),
        os.path.join(os.getcwd(), "data", "class.lst"),
        os.path.join(here, "class.lst"),
        "class.lst",
    ]:
        tried.append(p)
        if os.path.exists(p): return p, tried
    return None, tried

def load_class_saves(path: Optional[str]) -> Dict[str, Dict[str, List[int]]]:
    """Parse class.lst into {class: {poi|wand|para|breath|spell: [20 ints]}}."""
    if not path: return {}
    cfg = configparser.ConfigParser()
    cfg.optionxform = str.lower
    with open(path, "r", encoding="utf-8") as f:
        cfg.read_file(f)
    out: Dict[str, Dict[str, List[int]]] = {}
    for sect in cfg.sections():
        vals = cfg[sect]
        row: Dict[str, List[int]] = {}
        for src in SAVE_KEYS:
            if src in vals:
                nums = [int(x) for x in re.findall(r"-?\d+", vals[src])]
                if not nums: continue
                if len(nums) < 20: nums = nums + [nums[-1]] * (20 - len(nums))
                row[src] = nums[:20]
        if row:
            out[_norm_class_name(sect)] = row
    return out

def _ensure_tables_loaded(force: bool=False) -> Optional[str]:
    """Load or reload tables. Returns the source path used (or None for builtin)."""
    global _CLASS_SAVES, _CLASS_SAVES_SOURCE
    if _CLASS_SAVES is not None and not force:
        return _CLASS_SAVES_SOURCE
    path, _tried = _find_class_lst_with_traces()
    tables = load_class_saves(path) if path else {}
    if tables:
        _CLASS_SAVES = tables
        _CLASS_SAVES_SOURCE = os.path.abspath(path) if path else None
    else:
        _CLASS_SAVES = {}
        _CLASS_SAVES_SOURCE = None
    return _CLASS_SAVES_SOURCE

def _get_f1_row() -> Dict[str, int]:
    """Fighter 1 row, from file if present; else builtin."""
    _ensure_tables_loaded()
    if _CLASS_SAVES and "fighter" in _CLASS_SAVES:
        row = _CLASS_SAVES["fighter"]
        return {k: int(row[k][0]) for k in SAVE_KEYS if k in row}
    return dict(_DEFAULT_F1)

def _parse_saveas(self, s: str) -> tuple[str, int]:
    """
    Accepts:
      • 'Fighter 5', 'fighter 05'
      • 'NM', 'Normal Man'
      • 'Fighter' (defaults to level 1)
    Returns (klass, level). Level may be ignored by special classes like NM.
    """
    t = (str(s) or "").strip()
    if not t:
        return "", 0
    norm = t.lower().replace("_", " ").replace("-", " ").strip()
    if norm in {"nm", "normal man", "normalman"}:
        return "NM", 1

    m = re.match(r"\s*([A-Za-z][A-Za-z\-\s]+?)\s+(\d+)\s*$", t)
    if m:
        return m.group(1).strip(), int(m.group(2))

    return t.title(), 1


def _class_save_target(self, klass: str, level: int, vs: str):
    v = _canon_vs(vs)
    k = _norm_class_name(klass)

    if k == "nm":
        base = self._class_save_target("fighter", 1, v)
        return (base + 1) if isinstance(base, int) else None

    sec = _section_for_class(k)
    if not sec:
        return None

    arr = _CLASS_SAVES.get(sec, {}).get(v, [])
    if not isinstance(arr, list) or not arr:
        return None

    idx = max(0, min(int(level) - 1, len(arr) - 1))
    try:
        return int(arr[idx])
    except Exception:
        return None

def _get_saveas_from_cfg(t_cfg) -> Optional[str]:
    """Try to read 'saveas' from [base]/[stats]/[info] (case-insensitive)."""
    for sec in ("base","stats","info"):
        try:
            try:
                v = get_compat(t_cfg, sec, "saveas", fallback=None)
            except Exception:
                v = t_cfg.get(sec, "saveas", fallback=None) if hasattr(t_cfg, "get") else None
            if v:
                s = str(v).strip()
                if s:
                    return s
        except Exception:
            pass
    return None
    
def osr_mod(score: int) -> int:
    s = max(1, int(score))
    if s <= 3:   return -3
    if s <= 5:   return -2
    if s <= 8:   return -1
    if s <= 12:  return 0
    if s <= 15:  return +1
    if s <= 17:  return +2
    return +3
    
def _dice_sum(expr: str) -> int:
    try:
        expr = (expr or "").strip()
        if not expr:
            return 0
        if re.fullmatch(r"[+-]?\d+", expr):
            return int(expr)
        s, _rolls, flat = roll_dice(expr)
        return max(0, s + flat)
    except Exception:
        try:
            return int(expr)
        except Exception:
            return 0

def _effect_tokens_for_attack(cfg, attack_key: str) -> dict:
    attack_key = (attack_key or "").strip().lower()
    if not attack_key:
        return {}
    text = ""
    for sec in ("base", "info", "stats"):
        try:
            v = (cfg.get(sec, f"effect_{attack_key}", fallback="") or "").strip()
        except Exception:
            v = ""
        if v:
            text = v; break
    if not text:
        return {}
    out = {}
    for tok in text.split():
        if "=" in tok:
            k, v = tok.split("=", 1)
            out[k.strip().lower()] = v.strip()
        else:
            out[tok.strip().lower()] = True
    return out

try:
    eff = _effect_tokens_for_attack(atk_cfg, chosen_attack or "")
    if eff:
        extra_eff = {**extra_eff, **eff}
except Exception:
    pass

                
def _is_undead_cfg(t_cfg, pretty_name: str = "") -> bool:
    txt = " ".join(filter(None, [
        str(get_compat(t_cfg, "info",  "monster_type", fallback="")),
        str(get_compat(t_cfg, "base",  "type",         fallback="")),
        str(get_compat(t_cfg, "stats", "type",         fallback="")),
        (pretty_name or "")
    ])).lower()
    return any(tok in txt for tok in _UNDEAD_TOKENS)

def _turn_entry(level:int, col:int):
    lvl = max(1, min(20, int(level)))
    row = _TURN_UNDEAD_TABLE[lvl]
    return row[col]

def _sign(n: int) -> str:
    return f"+ {n}" if n >= 0 else f"- {abs(n)}"

    
def _is_enchanted_for_items(self, chan_id: str, pretty_target: str) -> bool:
    try:
        bcfg = _load_battles()
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, pretty_target) or pretty_target
            s = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
            return bcfg.getint(chan_id, f"{s}.inw_ench", fallback=0) > 0
    except Exception:
        pass
    return False


def _pick_col_for_target(tcfg, disp_name:str):
    """Return (col_idx, label, is_undead_flag, hd_for_pool)."""
    mt = (get_compat(tcfg, "info", "monster_type", fallback="") or "") + " " +\
         (get_compat(tcfg, "stats", "type", fallback="") or "")
    nm = (disp_name or "").lower()
    txt = (mt + " " + nm).lower()

    for key, col in _UNDEAD_COL.items():
        if key in txt:
            hd = getint_compat(tcfg, "cur", "level", fallback=1)
            return col, _COL_NAME[col], True, max(1, hd)

    is_undead = ("undead" in txt)
    hd = getint_compat(tcfg, "cur", "level", fallback=1)
    if is_undead:
        col = 8 if hd >= 9 else max(0, min(7, hd-1))
        return col, f"{hd} HD Undead", True, max(1, hd)

    return None, "", False, max(1, hd)

def _find_ci_name(names, q):
    ql = (q or "").lower().strip()
    for n in names:
        if n.lower() == ql:
            return n
    for n in names:
        if n.lower().strip() == ql.replace("_"," "):
            return n
    return None

def _save_battles(cfg):
    with open(BATTLE_FILE, "w", encoding="utf-8") as f:
        cfg.write(f)


SAVE_KEYS = ("poi", "wand", "para", "breath", "spell")

def load_class_saves(path: str = "class.lst") -> dict[str, dict[str, list[int]]]:
    """
    Parse save tables from class.lst.
    Returns: { "Fighter": {"poi":[...], "wand":[...], ...}, ... }
    """
    cp = configparser.ConfigParser()
    cp.optionxform = str
    cp.read(path)

    out: dict[str, dict[str, list[int]]] = {}
    for section in cp.sections():
        saves_for_class: dict[str, list[int]] = {}
        for k, v in cp.items(section):
            kl = k.lower().strip()
            if kl in SAVE_KEYS:
                nums: list[int] = []
                for tok in str(v).replace(",", " ").split():
                    try:
                        nums.append(int(tok))
                    except Exception:
                        pass
                saves_for_class[kl] = nums
        if saves_for_class:
            out[section] = saves_for_class
    return out

def _poly_clear_overlay(tcfg):
    if tcfg.has_section("poly"):
        tcfg.remove_section("poly")

def _get_str_mod_from_cfg(cfg) -> int:
    return _osr_mod_from_cfg(cfg, "str")

def _get_ab_from_cfg_or_table(cfg, classes_tbl: dict, fallback_class: str, fallback_level: int) -> int:
    """
    Prefer [stats].ab if present and a valid int; otherwise pull from classes_tbl[class]['ab'][level-1].
    Safely clamps level into [1..len(list)].
    """
    raw = get_compat(cfg, "stats", "ab", fallback="")
    try:
        if str(raw).strip() != "":
            return int(raw)
    except Exception:
        pass

    char_class = (get_compat(cfg, "info", "class", fallback=fallback_class) or fallback_class).strip().lower()
    level = max(1, int(fallback_level or 1))
    ab_list = ((classes_tbl.get(char_class, {}) or {}).get("ab", []) or [])
    if not ab_list:
        return 0
    idx = min(level - 1, len(ab_list) - 1)
    try:
        return int(ab_list[idx])
    except Exception:
        return 0
        
_DRAIN_PAT = re.compile(r"\b(?:energy\s*drain|level\s*drain|leveldrain|energydrain|drain)(?::?\s*(\d+))?\b", re.I)

def _extract_level_drain(dmg_spec: str, extra_eff: dict | None) -> int:
    n = 0
    try:
        if extra_eff:
            for k in ("leveldrain", "drain"):
                v = extra_eff.get(k, 0)
                if isinstance(v, int) and v > 0:
                    n = max(n, v)
    except Exception:
        pass
    m = _DRAIN_PAT.search((dmg_spec or ""))
    if m:
        n = max(n, int(m.group(1) or "1"))
    return max(0, n)


def _apply_queued_blind_after_paralysis(cfg, chan_id: str, slot: str) -> tuple[int, str, str]:
    """
    If a queued blind (from Color Cloud or Color Spray) exists and paralysis is gone,
    apply it now. Returns (applied_rounds, source_key, by_name).
    """
    cc_pend = cfg.getint(chan_id, f"{slot}.cc_blind_pending", fallback=0)
    cs_pend = cfg.getint(chan_id, f"{slot}.cs_blind_pending", fallback=0)

    src, pend = ("", 0)
    by = ""

    if cc_pend > 0:
        src, pend = ("colorcloud", cc_pend)
        by = cfg.get(chan_id, f"{slot}.cc_blind_by", fallback="")
    elif cs_pend > 0:
        src, pend = ("colorspray", cs_pend)
        by = cfg.get(chan_id, f"{slot}.cs_blind_by", fallback="")

    if pend <= 0:
        return (0, "", "")

    for k in (f"{slot}.cs_blind_pending", f"{slot}.cs_blind_by",
              f"{slot}.cc_blind_pending", f"{slot}.cc_blind_by"):
        if cfg.has_option(chan_id, k):
            cfg.remove_option(chan_id, k)

                         
    cur_bl = cfg.getint(chan_id, f"{slot}.blind", fallback=0)
    new_bl = max(cur_bl, pend)
    cfg.set(chan_id, f"{slot}.blind", str(new_bl))
    cfg.set(chan_id, f"{slot}.blind_src", src)
    if by:
        cfg.set(chan_id, f"{slot}.blind_by", by)

    return (new_bl, src, by)

def _is_melee_attack(is_rangedish: bool, is_oil: bool, is_holy: bool, want_wrestle: bool) -> bool:
    return not is_rangedish and not is_oil and not is_holy and not want_wrestle

def _parse_drain_count(spec: str, default: int = 1) -> int:
    """Accepts 'drain', 'drain 2', 'drain:2', 'drain=2', 'drain2'."""
    if not spec:
        return default
    s = spec.strip().lower()
    m = re.search(r"drain\s*[:=]?\s*(\d+)", s) or re.search(r"drain(\d+)", s)
    try:
        return int(m.group(1)) if m else default
    except Exception:
        return default


def _is_club_or_staff_equipped(cfg) -> bool:
    """
    Optional: enforce 'must be holding club or staff' for Shillelagh.
    Your [eq] usually has weapon1/2/3 names and 'weapon = N' as active index.
    """
    try:
        active_idx = int(get_compat(cfg, "eq", "weapon", fallback=0) or 0)
    except Exception:
        active_idx = 0
    names = [
        (get_compat(cfg, "eq", "weapon1", fallback="") or "").strip().lower(),
        (get_compat(cfg, "eq", "weapon2", fallback="") or "").strip().lower(),
        (get_compat(cfg, "eq", "weapon3", fallback="") or "").strip().lower(),
    ]
    wn = names[active_idx - 1] if 1 <= active_idx <= 3 else ""
    return any(k in wn for k in ("club", "quarterstaff", "staff"))


def load_classes_ab(path="class.lst"):
    """
    Returns { 'fighter': {'ab':[...], ...}, ... } with AB parsed to list[int].
    """
    cfg = configparser.ConfigParser()
    cfg.optionxform = str
    cfg.read(path)

    out = {}
    for section in cfg.sections():
        sec = section.lower()
        out[sec] = {}
        for k, v in cfg.items(section):
            if k.lower() == "ab":
                try:
                    out[sec]["ab"] = [int(x) for x in v.split()]
                except Exception:
                    out[sec]["ab"] = []
            else:
                out[sec][k.lower()] = v
    return out

def _load_battles():
    cfg = configparser.ConfigParser()
    cfg.optionxform = str
    cfg.read(BATTLE_FILE)
    return cfg

def normalize_name(s) -> str:
    if not isinstance(s, str):
        return ""
    return "".join(ch.lower() for ch in s if ch.isalnum())

def _normalize_name(s: str) -> str:
    return "".join(ch.lower() for ch in str(s) if ch.isalnum())


def _norm(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

def _is_metal_armor_name(name: str) -> bool:
    n = (name or "").lower()
    return any(k in n for k in (
        "chain", "mail", "plate",
    ))

_PROT_PAT_SPACED = re.compile(r"(belt|cloak|pendant|ring)\s*of\s*protection\s*\+([123])", re.I)
_PROT_PAT_TIGHT  = re.compile(r"(belt|cloak|pendant|ring)ofprotection\+([123])", re.I)

def _equipped_protection_bonus(t_cfg) -> int:
    """
    Returns the highest +N from any equipped Belt/Cloak/Pendant/Ring of Protection.
    Only the most powerful one applies (no stacking).
    """
    try:
        eq = dict((k.lower(), (get_compat(t_cfg, "eq", k, fallback="") or "")) for k in (
            "belt","cloak","neck","pendant","ring","ring1","ring2"
        ))
    except Exception:
        eq = {}

    best = 0
    for name in (eq.get("belt",""), eq.get("cloak",""), eq.get("pendant","") or eq.get("neck",""),
                 eq.get("ring",""), eq.get("ring1",""), eq.get("ring2","")):
        n = (name or "").replace("_", " ").strip()
        m = _PROT_PAT_SPACED.search(n) or _PROT_PAT_TIGHT.search(n.replace(" ", ""))
        if m:
            try:
                best = max(best, int(m.group(2)))
            except Exception:
                pass
    return best
def _target_armor_name(t_cfg) -> str:
                                                                     
    for k in ("armor", "armor1"):
        v = get_compat(t_cfg, "eq", k, fallback="")
        if v: return v
    return ""

_CANNOT_SUBDUAL = {
    "dagger","spear","2hspear","arrow","bolt","bullet"
}

def _weapon_allows_subdual(canon_name: str, item: dict) -> bool:
    n = _norm(canon_name)
    if n in _CANNOT_SUBDUAL: return False
    wtyp = (item.get("type","") or "").lower()
    if wtyp in {"missile","ranged","bow","xbow","thrown"}: return False
    return True


def _parse_combatants(cfg, chan_id):
    names_line = cfg.get(chan_id, "list", fallback="")
    names = [n for n in names_line.split() if n]
    scores = {}
    for n in names:
        try:
            scores[n] = int(cfg.get(chan_id, n, fallback="0"))
        except ValueError:
            scores[n] = 0
    return names, scores
    
def hp_bar(cur: int, max_hp: int, width: int = 10) -> str:
    if max_hp is None or max_hp <= 0:
        return "[----------] ?/?"            
    cur = max(0, min(cur, max_hp))
    filled = round(width * (cur / max_hp))
    filled = max(0, min(width, filled))
    return f"[{'█'*filled}{'░'*(width - filled)}] {cur}/{max_hp}"
    
        
_SMALL_RACES = {"halfling", "kobold", "goblin"}

def _pc_is_small(t_cfg) -> bool:
    kind = (get_compat(t_cfg, "info", "class", fallback="") or "").strip().lower()
    if kind == "monster":
        return False

    race = (get_compat(t_cfg, "info", "race", fallback="") or "").strip().lower()
    if race in _SMALL_RACES:
        return True

    sk = " ".join([
        (get_compat(t_cfg, "info",   "skills", fallback="") or ""),
        (get_compat(t_cfg, "traits", "skills", fallback="") or "")
    ]).lower()
    return "small" in sk
        
        
def _add_oil_burn(cfg_b, chan_id: str, name: str, n: int = 1):
    try:
        slot = _slot(name)
    except Exception:
        slot = name.replace(" ", "_")
    key = f"{slot}.oil"
    cur = 0
    try:
        cur = cfg_b.getint(chan_id, key, fallback=0)
    except Exception:
        cur = 0
    cfg_b.set(chan_id, key, str(cur + max(1, n)))
    _save_battles(cfg_b)

def _take_oil_burn(cfg_b, chan_id: str, name: str) -> int:
    """Consume all pending oil burns for this name, return the count consumed."""
    try:
        slot = _slot(name)
    except Exception:
        slot = name.replace(" ", "_")
    key = f"{slot}.oil"
    try:
        n = cfg_b.getint(chan_id, key, fallback=0)
    except Exception:
        n = 0
    if cfg_b.has_option(chan_id, key):
        cfg_b.remove_option(chan_id, key)
        _save_battles(cfg_b)
    return max(0, n)


def _item_lookup(self, name: str):
    """Return (canon_name, item_dict) or (None, None) from item.lst, case-insensitive."""
    key = normalize_name(name)
    canon = self.item_index.get(key)
    if not canon:
        return None, None
    return canon, self.items.get(canon, {})

def _item_ac(self, item: dict) -> int | None:
    v = item.get("AC") if "AC" in item else item.get("ac")
    if v is None or str(v).strip() == "":
        return None
    try:
        return int(str(v).strip())
    except Exception:
        return None

def _item_weight(self, item: dict) -> float:
    """Return the item weight as a float. Accepts 'weight', 'wt', or 'w'."""
    for k in ("weight", "wt", "w"):
        if k in item:
            try:
                return float(str(item[k]).strip())
            except Exception:
                pass
    return 0.0


def _is_slashing_weapon(canon_name: str, item: dict) -> bool:
    fields = []
    for k in ("type", "tags", "damage_type", "dmgtype", "dmg_type"):
        v = str(item.get(k, "")).lower()
        if v:
            fields.append(v)
    fields.append(canon_name.lower())
    blob = " ".join(fields)
    toks = re.split(r"[,\s/;|+]+", blob)

    if any(t in {"slash", "slashing"} for t in toks):
        return True

    name = canon_name.lower()
    if any(w in name for w in (
        "sword","sabre","saber","scimitar","falchion","katana",
        "axe","hatchet","handaxe","battleaxe",
        "sickle","scythe","claw","talon"
    )):
        return True

    return False

def _item_is_shield(self, item: dict) -> bool:
    flag = item.get("armor2") or item.get("ARMOR2")
    return str(flag).strip().lower() in {"$true", "true", "yes", "y", "1"}

def _item_hands(self, item: dict) -> int:
    h = item.get("hands") or item.get("HANDS") or "1"
    try:
        return int(str(h).strip())
    except Exception:
        return 1

def _eq_weapon_names_from_cfg(self, cfg) -> list[str]:
    out = []
    try:
        if cfg.has_option("eq", "weapon1"):
            n = cfg.get("eq", "weapon1").strip()
            if n: out.append(n)
    except Exception: pass
    try:
        if cfg.has_option("eq", "weapon2"):
            n = cfg.get("eq", "weapon2").strip()
            if n: out.append(n)
    except Exception: pass
    return out

def _coin_weight_from_cfg(cfg) -> float:
    """Each coin weighs 0.02."""
    pp = getint_compat(cfg, "cur", "pp", fallback=0)
    gp = getint_compat(cfg, "cur", "gp", fallback=0)
    ep = getint_compat(cfg, "cur", "ep", fallback=0)
    sp = getint_compat(cfg, "cur", "sp", fallback=0)
    cp = getint_compat(cfg, "cur", "cp", fallback=0)
    return (pp + gp + ep + sp + cp) * 0.02


def _carry_slot_qty(self, cfg, slot_key: str, canon: str) -> int:
    """Prefer explicit per-slot qty; fallback to inventory count; else 1."""
    try:
        raw = cfg.get("eq", f"{slot_key}_qty", fallback=None)
        if raw is not None:
            q = int(str(raw).lstrip("x").strip())
            return max(1, q)
    except Exception:
        pass
    try:
        inv_key = canon.lower()
        raw = cfg.get("item", inv_key, fallback=None)
        if raw is not None:
            q = int(str(raw).lstrip("x").strip())
            return max(1, q)
    except Exception:
        pass
    return 1

def _slots_for_class_level(class_cp: configparser.ConfigParser, class_section: str, level: int) -> dict[int, int]:
    """
    Returns {1:slots_at_lvl1, 2:..., ... 7:...}. Missing = 0
    """
    sec_key = None
    for sec in class_cp.sections():
        if sec.lower() == class_section.lower():
            sec_key = sec
            break
    result = {i: 0 for i in range(1, 8)}
    if not sec_key:
        return result

    for spell_lvl in range(1, 8):
        key = f"spell{spell_lvl}"
        if key in class_cp[sec_key]:
            try:
                arr = [int(x) for x in class_cp[sec_key][key].split()]
                result[spell_lvl] = arr[min(max(1, level) - 1, len(arr) - 1)]
            except Exception:
                result[spell_lvl] = 0
    return result

def _extract_user_id(val: str | None) -> str | None:
    """Return a numeric Discord ID from a raw value (ID or <@!ID> mention), else None."""
    if not val:
        return None
    m = re.search(r'(\d{15,25})', str(val))
    return m.group(1) if m else None

async def _find_member_id_by_name(ctx, name: str | None) -> str | None:
    """Try to resolve a guild member by display name / username (case-insensitive)."""
    if not (ctx and ctx.guild and name):
        return None
    target = name.strip().lower()
    for m in ctx.guild.members:
        
        if m.display_name and m.display_name.strip().lower() == target:
            return str(m.id)
        
        if m.name and m.name.strip().lower() == target:
            return str(m.id)
    return None

async def _controller_id_for_monster(ctx, bcfg, chan_id: str, disp_name: str) -> str | None:
    """
    Who controls this monster? Accept controller/owner/etc. from battle state OR from the .coe,
    and handle IDs, mentions, or plain names.
    """
    try:
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, disp_name) or disp_name
        slot = _slot(key)
    except Exception:
        slot = (disp_name or "").replace(" ", "_")

    for field in ("controller", "owner", "summoner", "hired_by", "employer"):
        raw = (bcfg.get(chan_id, f"{slot}.{field}", fallback="") or "").strip()
        uid = _extract_user_id(raw)
        if uid:
            return uid
        if raw: 
            uid = await _find_member_id_by_name(ctx, raw)
            if uid:
                return uid

    try:
        disp, path = _resolve_char_ci(disp_name)
        if path:
            cfg = read_cfg(path)
            for sec in ("cur", "info", "base"):
                raw = (get_compat(cfg, sec, "owner_id", fallback="") or "").strip()
                uid = _extract_user_id(raw)
                if uid:
                    return uid
                for key in ("controller", "owner", "summoner", "hired_by", "employer"):
                    raw = (get_compat(cfg, sec, key, fallback="") or "").strip()
                    uid = _extract_user_id(raw)
                    if uid:
                        return uid
                    if raw:
                        uid = await _find_member_id_by_name(ctx, raw)
                        if uid:
                            return uid
    except Exception:
        pass

    return None

async def _controller_user_for_monster(ctx, cfg, chan_id: str, name: str):
    """Fetch nextcord.User for the monster's controller if known, else None."""
    oid = _controller_id_for_monster(cfg, chan_id, name)
    if not oid:
        return None
    user = ctx.bot.get_user(int(oid))
    if user:
        return user
    try:
        return await ctx.bot.fetch_user(int(oid))
    except Exception:
        return None

def _load_class_cache(path: str = "class.lst"):
    cfg = configparser.ConfigParser()
    cfg.optionxform = str
    cfg.read(path)

    cache = {}
    for section in cfg.sections():
        cache[section] = {}
        for k, v in cfg.items(section):
            v = v.strip()
            if v and " " in v:
                parts = v.split()
                if all(p.lstrip("-").isdigit() for p in parts):
                    cache[section][k] = [int(p) for p in parts]
                else:
                    cache[section][k] = v
            else:
                if v.lstrip("-").isdigit():
                    cache[section][k] = int(v)
                else:
                    cache[section][k] = v
    return cache


_CLASS_CACHE = _load_class_cache()

def roll_dice(spec: str):
    """
    Parse 'XdY' with optional +/- Z, e.g. '2d6+3', '1d8-1'.
    Returns (sum_of_rolls, individual_rolls, flat_modifier).
    """
    m = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+-]\s*\d+)?\s*", spec.strip().lower())
    if not m:
        raise ValueError(f"Bad dice spec: {spec}")
    n = int(m.group(1))
    sides = int(m.group(2))
    flat = int(m.group(3).replace(" ", "")) if m.group(3) else 0
    rolls = [random.randint(1, sides) for _ in range(n)]
    return sum(rolls), rolls, flat
    
    
def _parse_saveas(self, s: str) -> tuple[str, int]:
    
    m = re.match(r"\s*([A-Za-z\-]+)\s+(\d+)\s*$", str(s))
    if not m:
        return "", 0
    return m.group(1).title(), int(m.group(2))

def _class_save_target(self, klass: str, level: int, vs: str):
    key_map = {
        "poi": "poi",
        "wand": "wand",
        "para": "para", "parapet": "para",
        "breath": "breath",
        "spell": "spell",
    }
    block = _CLASS_SAVES.get(klass, {}) or _CLASS_SAVES.get(klass.title(), {})
    if not block:
        return None
    arr = block.get(key_map.get(vs, vs), [])
    if not isinstance(arr, list) or not arr:
        return None
    idx = max(0, min(int(level) - 1, len(arr) - 1))
    try:
        return int(arr[idx])
    except Exception:
        return None

def _has_mummy_rot(cfg) -> bool:
    try:
        return getint_compat(cfg, "cur", "mummy_rot", fallback=0) > 0
    except Exception:
        return False

def _set_mummy_rot(cfg, path):
    if not cfg.has_section("cur"):
        cfg.add_section("cur")
    cfg.set("cur", "mummy_rot", "1")
    write_cfg(path, cfg)

def _clear_mummy_rot(cfg, path):
    if cfg.has_section("cur"):
        if cfg.has_option("cur", "mummy_rot"):
            cfg.remove_option("cur", "mummy_rot")
    write_cfg(path, cfg)

    
def _class_hitdie_sides(cls_name: str) -> int:
    """
    Return the class' base hit die sides, e.g. Fighter/Paladin → 8, Cleric → 6, Thief/Mage → 4.
    Uses your _CLASS_CACHE hp9 like '1d8'. Fallbacks are sane B/X defaults.
    """
    if not cls_name:
        return 8
    sec = _CLASS_CACHE.get(cls_name.title(), {}) or _CLASS_CACHE.get(cls_name.lower(), {})
    spec = (sec.get("hp9") or sec.get("hp", "") or "").strip().lower()
    m = re.fullmatch(r"\s*(\d+)d(\d+)\s*", spec)
    if m:
        return int(m.group(2))
    c = cls_name.strip().lower()
    if c in {"fighter","paladin","ranger","barbarian"}: return 8
    if c in {"cleric","druid"}: return 6
    if c in {"thief","scout","assassin","magethief"}: return 4
    if c in {"mage","wizard","magicuser","illusionist"}: return 4
    return 8


def _format_lock_pieces(locks: dict[int, int]) -> str:
    if not locks:
        return "—"
    return ", ".join(f"L{L}×{n}" for L, n in sorted(locks.items(), reverse=True))


def _ensure_slots_for(cfg, totals: dict[int, int]) -> None:
    if not cfg.has_section("slots"):
        cfg.add_section("slots")
    for L in totals.keys():
        key = f"l{L}_spent"
        if not cfg.has_option("slots", key):
            cfg.set("slots", key, "0")


def _match_slayer_type(mon_type: str, want: str) -> bool:
    s = (mon_type or "").strip().lower()
    if not s:
        return False
    if want == "dragon":
        return "dragon" in s
    if want == "undead":
        return "undead" in s
    if want == "lycanthrope":
        return ("lycan" in s) or ("were" in s)
    if want == "enchanted":
        return any(tok in s for tok in ("enchanted", "fey", "magical", "magicalbeast"))
    if want == "ooze":
        return any(tok in s for tok in ("ooze", "slime", "pudding", "gelatinous"))
    return want in s


def _effective_max_hp(cfg) -> int:
    """Max HP reduced by semi-permanent drain pool."""
    mhp = getint_compat(cfg, "max", "hp", fallback=0)
    lost = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
    return max(0, mhp - max(0, lost))

def _clamp_hp_to_cap(cfg, path: str) -> None:
    """Ensure cur.hp ≤ effective cap after heals/edits."""
    cap = _effective_max_hp(cfg)
    cur = getint_compat(cfg, "cur", "hp", fallback=0)
    if cur > cap:
        if not cfg.has_section("cur"):
            cfg.add_section("cur")
        cfg["cur"]["hp"] = str(cap)
        write_cfg(path, cfg)
def _try_num(s):
    try:
        if "." in s:
            return float(s)
        return int(s)
    except Exception:
        return s

def load_items(path="item.lst"):
    """
    Returns {
      'longsword': {'dmg':'1d8','stat':'str','short':None,'med':None,'long':None,...},
      ...
    }
    Normalizes keys to lowercase section names; also normalizes 'medium' -> 'med'.
    """
    cfg = configparser.ConfigParser()
    cfg.optionxform = str
    cfg.read(path)

    items = {}
    for section in cfg.sections():
        data = {}
        for k, v in cfg.items(section):
            key = k.lower().strip()
            if key == "medium":
                key = "med"
            if key in {"short", "med", "long"}:
                try:
                    data[key] = int(v)
                except Exception:
                    data[key] = None
            elif key in {"price", "weight"}:
                data[key] = _try_num(v)
            else:
                data[key] = v.strip()
        data.setdefault("stat", "str")
        data.setdefault("dmg", "1d4")
        items[section.lower()] = data
    return items

def normalize_name(s: str) -> str:
    """normalize for matching: lowercase & alnum only"""
    return "".join(ch.lower() for ch in s if ch.isalnum())


def ability_mod(val) -> int:
    """
    OSR/BX-style ability modifiers:
      3:-3, 4-5:-2, 6-8:-1, 9-12:0, 13-15:+1, 16-17:+2, 18:+3
    """
    try:
        s = int(val)
    except Exception:
        return 0
    if s <= 3:   return -3
    if s <= 5:   return -2
    if s <= 8:   return -1
    if s <= 12:  return  0
    if s <= 15:  return  1
    if s <= 17:  return  2
    return 3

def _norm_item_name(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", str(s or "").lower())

def _str_item_override(cfg) -> tuple[int | None, str | None]:
    """
    Returns (override_mod, source_label) if a worn item sets the STR *modifier*.
    Priority: Girdle > Gauntlets. Returns (None, None) if no override.
    """
    hands = get_compat(cfg, "eq", "hands", fallback="")
    belt  = get_compat(cfg, "eq", "belt",  fallback="")

    hn = _norm_item_name(hands)
    bn = _norm_item_name(belt)

    if "girdleofgiantstrength" in bn:
        return 5, "Girdle of Giant Strength"
    if "gauntletsofogrepower" in hn:
        return 4, "Gauntlets of Ogre Power"
    return None, None

def _effective_str_mod(cfg) -> int:
    """Item overrides take precedence over the normal OSR STR mod."""
    base = _osr_mod_from_cfg(cfg, "str")
    ov, _ = _str_item_override(cfg)
    return ov if (ov is not None) else base

def _osr_mod_from_cfg(cfg, stat_key: str, *, fallback_score: int = 10) -> int:
    """
    Read stats.<stat_key> (e.g., 'str', 'dex') and return the OSR/BX modifier
    via ability_mod(). We DO NOT trust stats.<stat_key>_modifier (may be 5e-style).
    """
    score = getint_compat(cfg, "stats", stat_key, fallback=fallback_score)
    return ability_mod(score)

def _osr_str_dex_mods(cfg) -> tuple[int, int]:
    return _effective_str_mod(cfg), _osr_mod_from_cfg(cfg, "dex")

def _truthy(v: str | None) -> bool:
    if v is None: return False
    return str(v).strip().lower() in {"$true", "true", "yes", "y", "1"}

def _get_ci(d: dict, key: str, default=None):
    """Case-insensitive dict get (for keys like AC/ac)."""
    if key in d: return d[key]
    kl = key.lower()
    for k, v in d.items():
        if k.lower() == kl:
            return v
    return default

def _as_int(val, default=0):
    try:
        return int(str(val).strip())
    except Exception:
        return default

def _has_true_seeing(self, bcfg, chan_id: str, slot_att: str) -> bool:
    for k in ("ts", "trueseeing", "x_trueseeing"):
        if bcfg.getint(chan_id, f"{slot_att}.{k}", fallback=0) > 0:
            return True
    return False

def _is_invisible(self, bcfg, chan_id: str, slot_def: str) -> bool:
    return (bcfg.getint(chan_id, f"{slot_def}.inv", fallback=0) > 0
            or bcfg.getint(chan_id, f"{slot_def}.inv_perm", fallback=0) > 0)

def _blur_active_for(self, bcfg, chan_id: str, slot_def: str) -> bool:
    return (bcfg.getint(chan_id, f"{slot_def}.x_blur", fallback=0) > 0
            or bcfg.getint(chan_id, f"{slot_def}.x_blur_perm", fallback=0) > 0)

def _blur_clear_marks_for_attacker(self, bcfg, chan_id: str, slot_att: str):
    """Clear this attacker’s per-turn blur 'first attack' markers."""
    try:
        for opt_key, _ in list(bcfg.items(chan_id)):
            if opt_key.startswith(f"{slot_att}.blur_vs_"):
                bcfg.remove_option(chan_id, opt_key)
        _save_battles(bcfg)
    except Exception:
        pass

def _blur_penalty_for_attack(self, bcfg, chan_id: str, atk_name: str, slot_att: str, tgt_name: str):
    """
    Returns (penalty_int, note_text or None). Applies −4 for first attempt by this attacker vs this target
    this turn, then marks so future attempts this turn are −2.
    Suppressed if attacker has True Seeing or cannot see the target (e.g., target Invisible).
    """
    names, _ = _parse_combatants(bcfg, chan_id)
    name_key = _find_ci_name(names, tgt_name) or tgt_name
    try:
        slot_def = _slot(name_key)
    except Exception:
        slot_def = name_key.replace(" ", "_")

    if not self._blur_active_for(bcfg, chan_id, slot_def):
        return 0, None
    if self._has_true_seeing(bcfg, chan_id, slot_att):
        return 0, "Attacker has **True Seeing** — Blur ignored."
    if self._is_invisible(bcfg, chan_id, slot_def):
        return 0, "Defender is **Invisible** — Blur irrelevant."

    used_key = f"{slot_att}.blur_vs_{slot_def}"
    if bcfg.has_option(chan_id, used_key):
        return -2, "Defender is **BLURRED** (−2 to this successive attack)."
    bcfg.set(chan_id, used_key, "1"); _save_battles(bcfg)
    return -4, "Defender is **BLURRED** (−4 to the first attack this turn)."

_TYPE_SYNONYMS = {
    "slash": "slashing", "slashing": "slashing",
    "pierce": "piercing", "piercing": "piercing",
    "bludgeon": "bludgeoning", "bludgeoning": "bludgeoning",
    "elec": "lightning", "electric": "lightning", "lightning": "lightning",
    "radiant": "holy", "holy": "holy",
    "acid": "acid", "cold": "cold", "fire": "fire", "poison": "poison",
    "necrotic": "necrotic", "psychic": "psychic", "force": "force", "thunder": "thunder",
    "nonmagical": "nonmagical", "mundane": "nonmagical", "normal": "nonmagical",
}

def _split_types(s: str) -> set[str]:
    if not s: return set()
    raw = re.split(r"[,\s/;]+", str(s).strip())
    out = set()
    for tok in raw:
        tok = tok.strip().lower()
        if not tok: 
            continue
        out.add(_TYPE_SYNONYMS.get(tok, tok))
    return out

def _defender_traits_from_cfg(cfg) -> tuple[set[str], set[str]]:
    """Return (immune_set, resist_set) from either .ini or .coe files."""
    imm = set()
    res = set()
    for k in ("immune", "immunity", "immune_types"):
        imm |= _split_types(get_compat(cfg, "stats", k, fallback=""))
    for k in ("resist", "resistance", "resist_types"):
        res |= _split_types(get_compat(cfg, "stats", k, fallback=""))
    return (imm, res)


def roll_dice(spec: str):
    """
    Parse 'XdY' with optional +/- Z, e.g. '2d6+3', '1d8-1'.
    Returns (sum_of_rolls, individual_rolls, flat_modifier).
    """
    m = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+-]\s*\d+)?\s*", spec.strip().lower())
    if not m:
        raise ValueError(f"Bad dice spec: {spec}")
    n = int(m.group(1))
    sides = int(m.group(2))
    flat = int(m.group(3).replace(" ", "")) if m.group(3) else 0
    rolls = [random.randint(1, sides) for _ in range(n)]
    return sum(rolls), rolls, flat


def range_band(dist, short, med, long):
    if short and dist <= short:
        return "Short"
    if med and dist <= med:
        return "Medium"
    if long and dist <= long:
        return "Long"
    return "Out of range"
    

def normalize_name(s: str) -> str:
    """normalize for matching: lowercase & alnum only"""
    return "".join(ch.lower() for ch in s if ch.isalnum())    

def _combat_mods_from_potions(bcfg, chan_id: str, slot: str):
    """
    Returns (atk_bonus, dmg_bonus, ac_bonus) from *active* potions/effects.
    A bonus only applies if its timer/flag is active.
    """
    try:
        if not (bcfg and bcfg.has_section(chan_id)):
            return (0, 0, 0)

        atk = dmg = ac = 0

        gs_bonus = bcfg.getint(chan_id, f"{slot}.gs_bonus", fallback=0)
        gs_left  = bcfg.getint(chan_id, f"{slot}.gs", fallback=0)
        gs_active = (gs_left > 0) or bcfg.has_option(chan_id, f"{slot}.x_giantstrength")
        if not gs_active:
            gs_bonus = 0
        atk += gs_bonus; dmg += gs_bonus

        gr_bonus = bcfg.getint(chan_id, f"{slot}.growth_bonus", fallback=0)
        gr_left  = bcfg.getint(chan_id, f"{slot}.growth", fallback=0)
        gr_active = (gr_left > 0) or bcfg.has_option(chan_id, f"{slot}.x_growth")
        if not gr_active:
            gr_bonus = 0
        atk += gr_bonus; dmg += gr_bonus

        he_bonus = bcfg.getint(chan_id, f"{slot}.atkmod_heroism", fallback=0)
        he_left  = bcfg.getint(chan_id, f"{slot}.heroism", fallback=0)
        he_active = (he_left > 0) or bcfg.has_option(chan_id, f"{slot}.x_heroism")
        if not he_active:
            he_bonus = 0
        atk += he_bonus

        pot_ac = bcfg.getint(chan_id, f"{slot}.pot_ac", fallback=0)
        inw_left = bcfg.getint(chan_id, f"{slot}.inw", fallback=0)
        inw_active = (inw_left > 0) or bcfg.has_option(chan_id, f"{slot}.x_invulnerability")
        if not inw_active:
            pot_ac = 0
        ac += pot_ac

        return (atk, dmg, ac)
    except Exception:
        return (0, 0, 0)

def _has_adv_flag(tokens: list[str]) -> bool:
    return any(t in {"adv", "advantage", "flank"} for t in tokens or [])


def _potion_bonus_lines(bcfg, chan_id: str, slot: str) -> list[str]:
    """
    Human-friendly lines for active potion bonuses on this slot.
    Mirrors the same keys used by _combat_mods_from_potions.
    """
    if not (bcfg and bcfg.has_section(chan_id)):
        return []
    lines = []
    gs = bcfg.getint(chan_id, f"{slot}.gs_bonus",     fallback=0)
    gr = bcfg.getint(chan_id, f"{slot}.growth_bonus", fallback=0)
    he = bcfg.getint(chan_id, f"{slot}.atkmod_heroism", fallback=0)
    ac = bcfg.getint(chan_id, f"{slot}.pot_ac",       fallback=0)

    if gs: lines.append(f"Giant Strength: +{gs} to hit / +{gs} dmg")
    if gr: lines.append(f"Growth: +{gr} to hit / +{gr} dmg")
    if he: lines.append(f"Heroism: +{he} to hit")
    if ac: lines.append(f"Invulnerability: +{ac} AC")

    return lines


def load_items(file_path: str):
    """
    Load item.lst and return (items_by_canon, index_by_normalized).
    Optional 'aliases' key per item may contain comma/space-separated synonyms.
    """
    cfg = configparser.ConfigParser()
    cfg.optionxform = str
    cfg.read(file_path)

    items = {}                                 
    index = {}                                                                          

    for section in cfg.sections():
        data = dict(cfg.items(section))
                                                                                                 
        items[section] = data

                                          
        index[normalize_name(section)] = section

                                                                    
        aliases = re.split(r'[,\s]+', data.get("aliases", "").strip())
        for alias in filter(None, aliases):
            index[normalize_name(alias)] = section

    return items, index
    
def _norm_type_token(t: str | None) -> str:
    t = (t or "").strip().lower()
    if t in {"elec","electricity","lightning"}: return "electric"
    if t in {"acidic"}: return "acid"
    return t

def _collect_absorb_types(t_cfg) -> set[str]:
    
    def _tokset(s):
        return {x.strip().lower() for x in re.split(r"[,\s]+", str(s or "")) if x.strip()}

    def _merge_keys(cfg, section, *keys):
        out = set()
        for k in keys:
            out |= _tokset(get_compat(cfg, section, k, fallback=""))
        return out

    absorb = (_merge_keys(t_cfg, "base","absorb","absorb_types")
           |  _merge_keys(t_cfg, "stats","absorb","absorb_types")
           |  _merge_keys(t_cfg, "info","absorb","absorb_types"))

                                                                 
    try:
        mtype = (get_compat(t_cfg, "info", "monster_type", fallback="")
                 or get_compat(t_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            base_cfg = read_cfg(p)
            absorb |= (_merge_keys(base_cfg,"base","absorb","absorb_types")
                    |  _merge_keys(base_cfg,"stats","absorb","absorb_types")
                    |  _merge_keys(base_cfg,"info","absorb","absorb_types"))

    except Exception:
        pass

    return {_norm_type_token(x) for x in absorb if x}

    
def _is_monster_file(path: str) -> bool:
    if not os.path.exists(path):
        return False
    cfg = read_cfg(path)
    return str(get_compat(cfg, "info", "class", fallback="")).strip().lower() == "monster"

def _monster_pick_attack(cfg) -> tuple[str, str]:
    """
    Return (attack_name, damage_spec). If no attacknames are stored,
    fall back to the single 'damage' spec and name it 'attack'.
    """
    names_raw = (get_compat(cfg, "stats", "attacknames", fallback="") or "").strip().lower()
    if names_raw:
        names = [n for n in names_raw.split() if n]
        if names:
            choice = random.choice(names)
            spec = get_compat(cfg, "stats", f"atk_{choice}", fallback="").strip()
            if spec:
                return choice, spec
              
    return "attack", _monster_damage_spec(cfg)


def load_monster_ab(path: str = "class.lst") -> dict[int, int]:
    """
    Parse [monster] hdN=AB from class.lst -> {N: AB}.
    """
    cp = configparser.ConfigParser()
    cp.optionxform = str
    cp.read(path)
    sec = None
    if cp.has_section("monster"):
        sec = "monster"
    elif cp.has_section("Monster"):
        sec = "Monster"
    if not sec:
        return {}

    out = {}
    for k, v in cp.items(sec):
        kL = k.lower().strip()
        if kL.startswith("hd"):
            try:
                n = int(kL[2:])
                out[n] = int(v.strip())
            except Exception:
                pass
    return out

def _resolve_char_ci(name: str) -> tuple[str | None, str | None]:
    """
    Find '<name>.coe' case-insensitively, returning (canon_name, path).
    Accepts names with spaces; file uses underscores.
    """
    base = name.replace(" ", "_")
    target = f"{base}.coe".lower()
    for fn in os.listdir("."):
        if fn.lower() == target:
                                                                    
            path = fn
            try:
                cfg = read_cfg(path)
                real = get_compat(cfg, "info", "name", fallback=None)
                if real:
                    return real, path
            except Exception:
                pass
            return fn[:-4].replace("_", " "), path
    return None, None

def _is_monster_file(path: str) -> bool:
    try:
        cfg = read_cfg(path)
        return get_compat(cfg, "info", "class", fallback="").strip().lower() == "monster"
    except Exception:
        return False

def _nonmagical_weapon(self, wep_name: str) -> bool:
    return _magic_plus_from_name(wep_name) <= 0
    
def _monster_damage_spec(cfg) -> str:
                                                          
    dmg = get_compat(cfg, "stats", "damage", fallback="1d6")
    return dmg if str(dmg).strip() else "1d6"


def _split_tokens(val: str) -> set[str]:
    """
    Split a space/comma-separated token string (case-insensitive).
    Returns a set of lowercase tokens; empty set if blank.
    """
    if not val:
        return set()
    return {t for t in re.split(r"[,\s]+", str(val).lower().strip()) if t}

def _get_defense_sets(t_cfg) -> tuple[set[str], set[str], set[str]]:
    """
    Read resist/reduce1/immune from target file.
    Prefer [stats], then also allow [base] for backwards compatibility.
    """
    def _get(sec, key):
        return _split_tokens(get_compat(t_cfg, sec, key, fallback=""))

                 
    resist  = _get("stats", "resist")
    reduce1 = _get("stats", "reduce1")
    immune  = _get("stats", "immune")

                         
    resist  |= _get("base", "resist")
    reduce1 |= _get("base", "reduce1")
    immune  |= _get("base", "immune")

    return resist, reduce1, immune


def _resolve_effect_slot(bcfg, chan_id, name):
    try:
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, name) or name
        return _slot(key) if '_slot' in globals() else key.replace(" ", "_"), key
    except Exception:
        return name.replace(" ", "_"), name

def _apply_sickened(self, bcfg, chan_id, target_disp: str, by: str, rounds: int, penalty: int = -2):
    slotT, _ = _resolve_effect_slot(bcfg, chan_id, target_disp)
                                                           
    bcfg.set(chan_id, f"{slotT}.sick",     str(max(0, int(rounds))))
    bcfg.set(chan_id, f"{slotT}.sick_pen", str(int(penalty)))               
    bcfg.set(chan_id, f"{slotT}.sick_label", "")
    bcfg.set(chan_id, f"{slotT}.sick_emoji", "🤢")
    bcfg.set(chan_id, f"{slotT}.sick_by",  by)

def _start_maggots(self, bcfg, chan_id, target_disp: str, by: str, rounds: int, dmg_spec: str = "1d4"):
    slotT, _ = _resolve_effect_slot(bcfg, chan_id, target_disp)
    bcfg.set(chan_id, f"{slotT}.x_maggots",        str(max(0, int(rounds))))
    bcfg.set(chan_id, f"{slotT}.x_maggots_code",   "MS")
    bcfg.set(chan_id, f"{slotT}.x_maggots_label",  "Maggots (1d4/rd)")
    bcfg.set(chan_id, f"{slotT}.x_maggots_emoji",  "🪱")
    bcfg.set(chan_id, f"{slotT}.x_maggots_dmg",    dmg_spec)
    bcfg.set(chan_id, f"{slotT}.x_maggots_by",     by)


def _attacker_sickened_penalty(self, bcfg, chan_id: str, attacker_display: str) -> tuple[int, str | None]:
    """
    Returns (penalty, note). Penalty will be negative (e.g., -2) when Sickened is active, else 0.
    Works with either:
      • timers like <slot>.sickened / .sick with optional <slot>.sick_pen / .sickpen, or
      • x_* badges whose _code == "SK" and optional <base>_pen.
    """
    try:
        names, _ = _parse_combatants(bcfg, chan_id)
    except Exception:
        return 0, None
    key = _find_ci_name(names, attacker_display) or attacker_display
    try:
        slot = _slot(key)
    except Exception:
        slot = key.replace(" ", "_")

                                                 
    left = 0
    for k in (f"{slot}.sickened", f"{slot}.sick", f"{slot}.sicken"):
        left = max(left, bcfg.getint(chan_id, k, fallback=0))
    if left > 0:
        pen = bcfg.getint(chan_id, f"{slot}.sick_pen", fallback=bcfg.getint(chan_id, f"{slot}.sickpen", fallback=-2))
        return pen, f"Sickened {left}r: {pen:+} to hit"

                                                
    try:
        for opt in list(bcfg.options(chan_id)):
            if not opt.startswith(f"{slot}.x_") or not opt.endswith("_code"):
                continue
            if bcfg.get(chan_id, opt, fallback="").strip().upper() != "SK":
                continue
            base = opt[:-5]                 
            left = bcfg.getint(chan_id, base, fallback=0)
            pen  = bcfg.getint(chan_id, f"{base}_pen", fallback=-2)
            return pen, f"Sickened {left}r: {pen:+} to hit"
    except Exception:
        pass

    return 0, None

def _monster_has_harpysong(att_cfg, att_path):
    """
    Return True if the monster lists harpy song in its specials.
    Looks for tokens like 'harpysong', 'harpy song', or 'song (charm)' on the instance or its template.
    Used only to warn (not to block).
    """
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if any(k in s1 for k in ("harpysong","harpy song","song (charm)","charm song")):
            return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if any(k in s2 for k in ("harpysong","harpy song","song (charm)","charm song")):
                return True

    except Exception:
        pass
    return False

def _monster_has_enslave(att_cfg, att_path):
    """
    Return True if the monster lists enslave in its specials.
    Used only to warn (not to block).
    """
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if any(k in s1 for k in ("enslave")):
            return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if any(k in s2 for k in ("enslave")):
                return True

    except Exception:
        pass
    return False
    
def _monster_has_spore(att_cfg, att_path):
    """
    Return True if the monster lists a spore ability.
    Looks for the token 'spore' in [base]/[info] special on the instance or its template.
    """
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "spore" in s1:
            return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "spore" in s2:
                return True
    except Exception:
        pass
    return False

def _monster_has_gibbering(att_cfg, att_path):
    """
    Return True if the monster lists a gibbering/confusion aura in its specials.
    Looks for 'gibber' tokens on the instance or its template. Used only to warn (not to block).
    """
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if any(k in s1 for k in ("gibber", "gibbering", "gibbering mouther")):
            return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if any(k in s2 for k in ("gibber", "gibbering", "gibbering mouther")):
                return True
    except Exception:
        pass
    return False



def _is_living_creature(t_cfg) -> bool:
    """
    Treat the obvious non-living types as immune to Harpy Song.
    """
    ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) 
          or str(get_compat(t_cfg, "info", "type", fallback=""))).lower()
    nonliving = ("undead","construct","golem","elemental","ooze","slime","plant")
    return not any(k in ty for k in nonliving)


def _monster_has_lightning_throw(att_cfg, att_path):
    """
    True if monster lists a 'lightning' special (instance or its template).
    Used only to warn (not to hard-block).
    """
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "lightning" in s1:
            return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "lightning" in s2:
                return True
    except Exception:
        pass
    return False


def _monster_has_golemslow(att_cfg, att_path):
    """
    Return True if the monster lists the stone golem slow ability.
    Looks for the token 'golemslow' in [base]/[info] special on the instance or its template.
    """
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "golemslow" in s1:
            return True

                                             
        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "golemslow" in s2:
                return True
    except Exception:
        pass
    return False


def _monster_has_gaze(att_cfg, att_path):
    
    try:
                              
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "gaze" in s1: return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "gaze" in s2: return True
    except Exception:
        pass
    return False


def _monster_has_spit(att_cfg, att_path):
    try:
                              
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "spit" in s1: return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "spit" in s2: return True
    except Exception:
        pass
    return False

def _magic_plus_from_name(name: str) -> int:
    
    s = (name or "").replace(" ", "")
    m = re.search(r"\+(\d+)\b", s)
    try:
        return int(m.group(1)) if m else 0
    except Exception:
        return 0

def _monster_has_goo(att_cfg, att_path):
    
    try:
                                           
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "goo" in s1:
            return True

                                                                       
        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "goo" in s2:
                return True
    except Exception:
        pass
    return False

def _monster_has_spray(att_cfg, att_path):
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "spray" in s1:                      
            return True
        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "spray" in s2:
                return True
    except Exception:
        pass
    return False

def _monster_has_breath(att_cfg, att_path):
    
    try:
        s1 = " ".join([
            (get_compat(att_cfg, "base", "special", fallback="") or ""),
            (get_compat(att_cfg, "info", "special", fallback="") or "")
        ]).lower()
        if "breath" in s1:
            return True

        mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
                 or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            mcfg = read_cfg(p)
            s2 = " ".join([
                (get_compat(mcfg, "base", "special", fallback="") or ""),
                (get_compat(mcfg, "info", "special", fallback="") or "")
            ]).lower()
            if "breath" in s2:
                return True
    except Exception:
        pass
    return False

def _read_monster_breath_spec(att_cfg, att_path: str) -> tuple[str, str]:
    """
    Return (raw_spec, source) where raw_spec is the breath string like
    '3d4 fire' or 'poison', and source is 'instance' or a filepath.
    Tries the instance first, then monsters/<monster_type>.ini, then <monster_type>.ini
    """
    
                                                        
    for sec in ("base", "stats", "info"):
        v = (get_compat(att_cfg, sec, "breath", fallback="") or "").strip()
        if v:
            return v, "instance"

                                           
    mtype = (get_compat(att_cfg, "info", "monster_type", fallback="")
             or get_compat(att_cfg, "info", "type", fallback="")).strip().lower()
    p = _safe_monster_ini_path(mtype)
    if p:
        try:
            mcfg = read_cfg(p)
            for sec in ("base", "stats", "info"):
                v = (get_compat(mcfg, sec, "breath", fallback="") or "").strip()
                if v:
                    return v, p
        except Exception:
            pass


    return "", ""


def _weapon_spec_key(name: str) -> str:
    """Normalize a weapon string to a family key: no +N, no () suffixes, alnum-only."""
    if not name:
        return ""
    s = name.lower()
    s = re.sub(r"\(.*?\)", "", s)                                    
    s = re.sub(r"\+\s*\d+\b", "", s)                           
    s = re.sub(r"[^a-z0-9]", "", s)                           
    return s


def _apply_mitigation(raw, weapon_name="", weapon_type="", t_cfg=None, is_magical=None,
                      chan_id=None, target_name=None):
    """
    Apply target-based damage mitigation and return (final_damage, note).

    Inputs
    - raw (int): incoming damage before mitigation
    - weapon_name (str): display name like "Longsword", "Oil", "Holy Water"
    - weapon_type (str): tokens describing damage type(s): e.g. "slashing", "fire", "holy"
                         multiple tokens allowed, separated by space/comma
    - t_cfg: config for the target (expects helpers like get_compat/read_cfg to exist)
    - is_magical (bool|None): if None, inferred from weapon_type tokens
    - chan_id (str|None): battle channel id for initiative-based INW rule
    - target_name (str|None): target display name for INW lookup

    Returns
    - (int, str): (final damage after mitigation, short reason string)
    """

    def _tokset(s):
                                            
        return {x.strip().lower() for x in re.split(r"[,\s]+", str(s or "")) if x.strip()}

    def _merge_keys(cfg, section, *keys):
        out = set()
        for k in keys:
            out |= _tokset(get_compat(cfg, section, k, fallback=""))
        return out

    def _norm_tok(t):
        t = (t or "").lower()
        if t in {"elec", "electricity", "lightning"}: return "electric"
        if t in {"acidic"}: return "acid"
        return t

    PHYS = {"slashing", "piercing", "bludgeoning"}
    MAGICAL_TYPE_HINTS = {"force", "holy", "electric", "magical"}

    imm   = _merge_keys(t_cfg, "base", "immune","immunity","immune_types")   | _merge_keys(t_cfg,"stats","immune","immunity","immune_types")
    res   = _merge_keys(t_cfg, "base", "resist","resistance","resist_types") | _merge_keys(t_cfg,"stats","resist","resistance","resist_types")
    weak  = (_merge_keys(t_cfg,"base","weak","weakness","weak_types","vulnerable","vulnerability","vuln")
          |  _merge_keys(t_cfg,"stats","weak","weakness","weak_types","vulnerable","vulnerability","vuln")
          |  _merge_keys(t_cfg,"info","weak","weakness","weak_types","vulnerable","vulnerability","vuln"))
    absorb = (_merge_keys(t_cfg,"base","absorb","absorb_types")
           |  _merge_keys(t_cfg,"stats","absorb","absorb_types")
           |  _merge_keys(t_cfg,"info","absorb","absorb_types"))

    reduce1 = (_merge_keys(t_cfg, "base", "reduce1", "reduce", "reduce_types")
            |  _merge_keys(t_cfg, "stats","reduce1", "reduce", "reduce_types")
            |  _merge_keys(t_cfg, "info", "reduce1", "reduce", "reduce_types"))

    try:
        mtype = (get_compat(t_cfg, "info", "monster_type", fallback="")
                 or get_compat(t_cfg, "info", "type", fallback="")).strip().lower()
        p = _safe_monster_ini_path(mtype)
        if p:
            base_cfg = read_cfg(p)
            imm   |= (_merge_keys(base_cfg,"base","immune","immunity","immune_types")
                   |  _merge_keys(base_cfg,"stats","immune","immunity","immune_types"))
            res   |= (_merge_keys(base_cfg,"base","resist","resistance","resist_types")
                   |  _merge_keys(base_cfg,"stats","resist","resistance","resist_types"))
            weak  |= (_merge_keys(base_cfg,"base","weak","weakness","weak_types","vulnerable","vulnerability","vuln")
                   |  _merge_keys(base_cfg,"stats","weak","weakness","weak_types","vulnerable","vulnerability","vuln")
                   |  _merge_keys(base_cfg,"info","weak","weakness","weak_types","vulnerable","vulnerability","vuln"))
            absorb |= (_merge_keys(base_cfg,"base","absorb","absorb_types")
                    |   _merge_keys(base_cfg,"stats","absorb","absorb_types")
                    |   _merge_keys(base_cfg,"info","absorb","absorb_types"))
    except Exception:
        pass


    wtokens = {_norm_tok(x) for x in _tokset(weapon_type)}
    absorb  = {_norm_tok(x) for x in absorb}
    imm     = {_norm_tok(x) for x in imm}
    res     = {_norm_tok(x) for x in res}
    weak    = {_norm_tok(x) for x in weak}
    reduce1 = {_norm_tok(x) for x in reduce1}

    if is_magical is None:
        wt = (weapon_type or "").lower()
        is_magical = wt.startswith("mag") or ("magical" in wt)
    if not is_magical:
                                                                                            
        if wtokens & MAGICAL_TYPE_HINTS:
            is_magical = True


    def _has_eq_resist(cfg, elem: str) -> bool:
        try:
            if cfg.has_section("eq"):
                for _k, _v in cfg.items("eq"):
                    nm = (str(_v) or "").lower().replace(" ", "")
                    if elem == "fire" and "fireresistance" in nm:
                        return True
                    if elem == "cold" and "coldresistance" in nm:
                        return True
        except Exception:
            pass
        return False

    def _has_timer_resist(elem: str) -> bool:
        try:
            if not (chan_id and target_name):
                return False
            bcfg = _load_battles()
            if not bcfg or not bcfg.has_section(chan_id):
                return False
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, target_name) or target_name
            try:
                s = _slot(key)
            except Exception:
                s = key.replace(" ", "_")
            for suff in (f"{s}.x_{elem}resistance", f"{s}.x_resist{elem}"):
                try:
                    if bcfg.getint(chan_id, suff, fallback=0) > 0:
                        return True
                except Exception:
                    pass
        except Exception:
            pass
        return False


    _virt_res = set()
    if "fire" in wtokens and (_has_eq_resist(t_cfg, "fire") or _has_timer_resist("fire")):
        if not is_magical:
            return 0, "immune (normal fire)"
        _virt_res.add("fire")
    if "cold" in wtokens and (_has_eq_resist(t_cfg, "cold") or _has_timer_resist("cold")):
        if not is_magical:
            return 0, "immune (normal cold)"
        _virt_res.add("cold")


    if _virt_res:
        res |= _virt_res

    

    try:
        if chan_id and target_name:
            bcfg = _load_battles()
        else:
            bcfg = None
    except Exception:
        bcfg = None

    def _slot_for_target(bcfg, sec, name):
        try:
            names, _ = _parse_combatants(bcfg, sec)
            key = _find_ci_name(names, name) or name
            return _slot(key) if '_slot' in globals() else key.replace(" ", "_")
        except Exception:
            return (name or "").replace(" ", "_")

    if bcfg:
        secs = [chan_id] if bcfg.has_section(chan_id or "") else []
    else:
        secs = []

    for sec in secs:
        s = _slot_for_target(bcfg, sec, target_name or "")
        if "fire" in wtokens:
            if not is_magical:
                return 0, "immune (normal fire)"
            pool = bcfg.getint(sec, f"{s}.pff_pool", fallback=0)
            if pool > 0:
                left = max(0, pool - int(raw))
                bcfg.set(sec, f"{s}.pff_pool", str(left))
                if left <= 0:
                    for k in (f"{s}.pff_pool", f"{s}.pff_self"):
                        if bcfg.has_option(sec, k):
                            bcfg.remove_option(sec, k)
                _save_battles(bcfg)
                return 0, f"Protection from Fire absorbs ({left} left)"
        if ("electric" in wtokens) or ("lightning" in wtokens):
            if not is_magical:
                return 0, "immune (normal lightning)"
            pool = bcfg.getint(sec, f"{s}.pfl_pool", fallback=0)
            if pool > 0:
                left = max(0, pool - int(raw))
                bcfg.set(sec, f"{s}.pfl_pool", str(left))
                if left <= 0:
                    for k in (f"{s}.pfl_pool", f"{s}.pfl_self"):
                        if bcfg.has_option(sec, k):
                            bcfg.remove_option(sec, k)
                _save_battles(bcfg)
                return 0, f"Protection from Lightning absorbs ({left} left)"
                                                                                         
                                    
    try:
        cand_name = (target_name
                     or get_compat(t_cfg, "info", "name", fallback="")
                     or "")
        bcfg = _load_battles()
        if bcfg:
            sections = [chan_id] if chan_id and bcfg.has_section(chan_id) else bcfg.sections()
            for sec in sections:
                try:
                    names, _ = _parse_combatants(bcfg, sec)
                    key = _find_ci_name(names, cand_name) or cand_name
                    if key in names:
                        s = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                        inw_left = bcfg.getint(sec, f"{s}.inw", fallback=0)
                        if inw_left > 0:
                                                                      
                            wname = (weapon_name or "").lower()
                            if (not is_magical) and (wname not in {"oil", "holy water"}):
                                return 0, "immune (nonmagical)"
                        break
                except Exception:
                    continue
    except Exception:
        pass

    fos = getint_compat(t_cfg, "base", "fossilized", fallback=0) or getint_compat(t_cfg, "stats", "fossilized", fallback=0)
    if fos:
        wn = (weapon_name or "").lower()
                                                                         
        if (("arrow" in wn) or ("bolt" in wn) or ("bullet" in wn)
            or wn in {"shortbow", "longbow", "sling", "lightxbow", "heavyxbow"}) and not is_magical:
            return 0, "immune (normal missiles)"

                                                                       
        if "slashing" in wtokens:
            return (1 if raw > 0 else 0), "fossilized bones (slashing → 1)"

                                                                                
        if wtokens & PHYS:
            return math.floor(raw / 2), "resists weapons"

                                                                      
    match_abs = absorb & wtokens
    if match_abs and is_magical:
        key = next(iter(match_abs))
        heal = max(0, raw // 3)
        if heal > 0:
            return -heal, f"absorbs {key} (magical) → heals {heal}"
        else:
            return 0, f"absorbs {key} (magical)"

    if "nonmagical" in imm and not is_magical:
        wname = (weapon_name or "").lower()
        if wname not in {"oil", "holy water"}:
            return 0, "immune (nonmagical)"

    match_imm = imm & wtokens
    if match_imm:
        key = next(iter(match_imm))
        return 0, f"immune ({key})"

    if reduce1:
                                              
        is_weaponish = bool(wtokens & PHYS)

                                                                                 
        wname_raw  = (weapon_name or "").lower().strip()
        wname_base = re.sub(r"\s*\+.*$", "", wname_raw)                                     
        wname_norm = re.sub(r"[^a-z0-9]+", "", wname_base)                              
        reduce1_norm = {re.sub(r"[^a-z0-9]+","", x) for x in reduce1}

        is_bow   = ("bow" in wname_raw) and ("xbow" not in wname_raw and "crossbow" not in wname_raw)
        is_xbow  = ("xbow" in wname_raw) or ("crossbow" in wname_raw)
        is_sling = ("sling" in wname_raw)

        name_match = (
            (wname_norm in reduce1_norm) or
            ("bow" in reduce1 and is_bow) or
            (("xbow" in reduce1 or "crossbow" in reduce1) and is_xbow) or
            ("sling" in reduce1 and is_sling)
        )

        match_reduce = (
            ("any" in reduce1) or ("all" in reduce1) or
            (("weapon" in reduce1) or ("physical" in reduce1)) and is_weaponish or
            ("nonmagical" in reduce1 and not is_magical) or
            ("magical" in reduce1 and is_magical) or
            bool(reduce1 & wtokens) or
            name_match                                                              
        )

        if match_reduce:
            return (1 if raw > 0 else 0), "reduced to 1"


    match_res = res & wtokens
    if match_res:
        key = next(iter(match_res))
        return math.floor(raw / 2), f"resists {key}"

    match_weak = weak & wtokens
    if match_weak:
        key = next(iter(match_weak))
        return raw * 2, f"weak to {key}"

    return raw, ""


def _poly_active(cfg) -> bool:
    try:
        return cfg.has_section("poly") and bool(get_compat(cfg, "poly", "form", fallback="").strip())
    except Exception:
        return False

def _poly_kind(cfg): return cfg.get("poly", "kind", fallback="")

def _poly_attacks(cfg):
    raw = (cfg.get("poly", "attacks", fallback="") or "").strip()
    out = []
    for seg in re.split(r"[|,]", raw):
        seg = seg.strip()
        if ":" in seg:
            n, d = seg.split(":", 1)
            out.append((n.strip(), d.strip()))
    return out


def _poly_ac(cfg):
    return cfg.getint("poly", "ac", fallback=None)

def _poly_saveas(cfg):
    if _poly_kind(cfg) == "other":
        return cfg.get("poly", "saveas", fallback="")
    return ""


def _clear_battle_poly_flags(bcfg, chan_id: str, init_name: str):
    """Remove any initiative-side polymorph markers for this creature."""
    try:
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, init_name) or init_name
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")
        for k in (f"{slot}.poly", f"{slot}.polyself", f"{slot}.polyself_by", f"{slot}.polyform"):
            if bcfg.has_option(chan_id, k):
                bcfg.remove_option(chan_id, k)
        _save_battles(bcfg)
    except Exception:
        pass
        
        
def _clear_control_timer(bcfg, chan_id: str, slot: str, key: str):
    """key is like 'controlhuman' / 'controldragon' (without x_)"""
    base = f"{slot}.x_{key}"
                                 
    for suf in ("", "_label", "_code", "_emoji", "_by"):
        opt = base + suf
        if bcfg.has_option(chan_id, opt):
            bcfg.remove_option(chan_id, opt)
                       
    uopt = f"{slot}.{key}_uses"
    if bcfg.has_option(chan_id, uopt):
        bcfg.remove_option(chan_id, uopt)
        
        
def _attacker_invis_bonus_and_clear(bcfg, chan_id: str, attacker_display: str, attacker_slot: str, atk_cfg):
    """
    Returns (inv_atk_bonus, inv_type_atk, inv_group_note), and clears invis if appropriate.
    inv_type_atk: "imp"|"group"|"stalker"|"perm"|"norm"
    """
    inv_atk_bonus = 0
    inv_type_atk = "norm"
    inv_group_note = None
    try:
        inv_left = bcfg.getint(chan_id, f"{attacker_slot}.inv", fallback=0)
        inv_perm = bcfg.getint(chan_id, f"{attacker_slot}.inv_perm", fallback=0)

        if inv_left > 0 or inv_perm > 0:
            inv_atk_bonus = 4
            inv_type_atk = (bcfg.get(chan_id, f"{attacker_slot}.inv_type", fallback="").strip().lower()
                            or ("perm" if inv_perm > 0 else "norm"))

            def _clear_inv(slot: str):
                bcfg.set(chan_id, f"{slot}.inv", "0")
                for suf in ("inv_by", "inv_type", "inv_gid", "inv_leader", "inv_perm"):
                    opt = f"{slot}.{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)

            if inv_type_atk in {"imp", "improved"}:
                pass                                      
            elif inv_type_atk == "group":
                gid = bcfg.get(chan_id, f"{attacker_slot}.inv_gid", fallback="")
                is_leader = bcfg.getint(chan_id, f"{attacker_slot}.inv_leader", fallback=0) > 0
                if is_leader and gid:
                    names_all, _ = _parse_combatants(bcfg, chan_id)
                    for nm in names_all:
                        try:
                            s = _slot(nm)
                        except Exception:
                            s = nm.replace(" ", "_")
                        if bcfg.getint(chan_id, f"{s}.inv", fallback=0) > 0 and\
                           bcfg.get(chan_id, f"{s}.inv_gid", fallback="") == gid:
                            _clear_inv(s)
                    inv_group_note = "**Leader** of Invisible10 — this attack ends invisibility for the **entire group**."
                    _save_battles(bcfg)
                else:
                    _clear_inv(attacker_slot)
                    inv_group_note = "This attack ends **your** Invisible10 (others remain invisible)."
                    _save_battles(bcfg)
            else:
                                                                                     
                _clear_inv(attacker_slot)
                _save_battles(bcfg)

                                                         
        if inv_atk_bonus == 0 and atk_cfg is not None:
            mtype = (get_compat(atk_cfg, "info", "monster_type", fallback="") or "").strip().lower()
            if mtype in {"invisiblestalker", "invisible_stalker"}:
                inv_atk_bonus = 4
                inv_type_atk = "stalker"
    except Exception:
        pass

    return inv_atk_bonus, inv_type_atk, inv_group_note
  

def _parse_protection_bonus_from_name(name: str) -> int:
    """
    Returns +N for items like 'Ring of Protection +2', 'CloakofProtection+1', etc.
    Looks only for the continuous 'Protection' effect; max +3.
    Accepts: 'Ring of Protection +1', 'CloakofProtection+2', 'Pendant of Protection+3', etc.
    """
    try:
        s = str(name or "")
    except Exception:
        return 0
    m = re.search(r'protection\s*\+?\s*([1-3])', s, flags=re.I)
    if not m:
        return 0
    try:
        return max(0, min(3, int(m.group(1))))
    except Exception:
        return 0

def _equipped_protection_bonus(cfg) -> int:
    """
    Inspect [eq] keys and return the highest Protection bonus found (0..3).
    Rules: Only one such continuous effect applies; if multiple are worn (ring/cloak/belt/pendant),
    only the most powerful functions → we take the max.
    """
    best = 0
    try:
        if cfg and cfg.has_section("eq"):
            for _, v in cfg.items("eq"):
                b = _parse_protection_bonus_from_name(v)
                if b > best:
                    best = b
    except Exception:
        pass
    return best


_PFED_SET = {
    "beltofprotectionfromenergydrain",
    "cloakofprotectionfromenergydrain",
    "pendantofprotectionfromenergydrain",
    "ringofprotectionfromenergydrain",
}

def _pfed_norm(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower()).split("@", 1)[0]

def _pfed_norm_token(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

def _pfed_cleanup_if_none_left(cfg, storage_names: list[str], canon_or_base: str):
    """
    If no PFED item of this core remains (not equipped, not in bag), remove its pfed_* keys.
    storage_names = split('item.storage')
    canon_or_base = base item name (e.g., 'BeltofProtectionfromEnergyDrain')
    """
    try:
        base = (canon_or_base or "").split(" (", 1)[0]
        core = _pfed_norm(base)  
    except Exception:
        
        core = re.sub(r"[^a-z0-9]+", "", (canon_or_base or "").lower()).split("@", 1)[0]

    if core not in _PFED_SET:
        return

    
    have = False
    try:
        if cfg.has_section("eq"):
            for _, v in cfg.items("eq"):
                base_eq = (v or "").split(" (", 1)[0]
                if _pfed_norm(base_eq) == core:
                    have = True
                    break
    except Exception:
        pass

    
    if not have:
        try:
            cnt = int(str(cfg.get("item", core, fallback="0")).strip() or "0")
        except Exception:
            cnt = 0
        if cnt > 0:
            have = True
        else:
            for tok in storage_names or []:
                base_tok = tok.split("@", 1)[0]
                if _pfed_norm(base_tok) == core:
                    have = True
                    break

    
    if not have and cfg.has_section("pfed"):
        for kind in ("cur", "max"):
            opt = f"pfed_{core}_{kind}"
            if cfg.has_option("pfed", opt):
                cfg.remove_option("pfed", opt)


def _pfed_key(core: str, kind: str) -> str:
    
    return f"pfed_{core}_{kind}"  

def _pfed_ensure_section(cfg):
    try:
        if not cfg.has_section("pfed"):
            cfg.add_section("pfed")
    except Exception:
        pass

def _pfed_find_equipped(cfg):
    """Return (slot, disp_name, core) for first equipped PFED item, else None."""
    try:
        if not cfg.has_section("eq"):
            return None
        for slot, val in cfg.items("eq"):
            base = (val or "").strip()
            if not base:
                continue
            core = _pfed_norm(base.split(" (", 1)[0])
            if core in _PFED_SET:
                return slot, base, core
    except Exception:
        pass
    return None

def _pfed_read_fuzzy(cfg, path: str, core: str):
    """
    Read (cur, max) from [pfed] using SAFE keys, migrating any legacy forms:
      • [pfed] 'pfed::<core>_cur' / 'pfed::<core>_max'
      • bizarre 'pfed = :<core>_cur = N' artifacts
      • [charges] 'pfed::<core> = cur/max'
    Writes migrated values back to [pfed] with SAFE keys.
    """
    cur = mx = None

    
    if cfg.has_section("pfed"):
        if cfg.has_option("pfed", _pfed_key(core, "cur")):
            raw = (cfg.get("pfed", _pfed_key(core, "cur"), fallback="") or "").strip()
            if raw != "":
                try: cur = int(raw)
                except: cur = None
        if cfg.has_option("pfed", _pfed_key(core, "max")):
            raw = (cfg.get("pfed", _pfed_key(core, "max"), fallback="") or "").strip()
            if raw != "":
                try: mx = int(raw)
                except: mx = None

    migrated = False

    
    if (cur is None or mx is None) and cfg.has_section("charges"):
        for opt, val in list(cfg.items("charges")):
            if opt.strip().lower() == f"pfed::{core}".lower():
                txt = (val or "").strip()
                try:
                    parts = txt.split("/")
                    legacy_cur = int(parts[0])
                    legacy_mx  = int(parts[1]) if len(parts) > 1 else legacy_cur
                    if cur is None: cur = legacy_cur
                    if mx  is None: mx  = legacy_mx
                    cfg.remove_option("charges", opt)
                    migrated = True
                except Exception:
                    pass

    
    if (cur is None or mx is None) and cfg.has_section("pfed"):
        for opt, val in list(cfg.items("pfed")):
            lo = opt.strip().lower()
            if lo == f"pfed::{core}_cur".lower():
                try:
                    cur = int(str(val).strip()); cfg.remove_option("pfed", opt); migrated = True
                except Exception:
                    pass
            if lo == f"pfed::{core}_max".lower():
                try:
                    mx = int(str(val).strip()); cfg.remove_option("pfed", opt); migrated = True
                except Exception:
                    pass

    
    if (cur is None or mx is None) and cfg.has_section("pfed"):
        for opt, val in list(cfg.items("pfed")):
            line = f"{opt} = {val}".strip()
            if f":{core}_cur" in line:
                try:
                    cur = int(str(val).strip()); cfg.remove_option("pfed", opt); migrated = True
                except Exception:
                    pass
            if f":{core}_max" in line:
                try:
                    mx = int(str(val).strip()); cfg.remove_option("pfed", opt); migrated = True
                except Exception:
                    pass

    
    if migrated and (cur is not None or mx is not None):
        _pfed_ensure_section(cfg)
        if cur is not None:
            cfg.set("pfed", _pfed_key(core, "cur"), str(max(0, int(cur))))
        if mx is not None:
            cfg.set("pfed", _pfed_key(core, "max"), str(max(0, int(mx))))
        from utils.ini import write_cfg
        write_cfg(path, cfg)

    return (cur, mx)

def _pfed_write(cfg, path: str, core: str, cur: int, mx: int):
    _pfed_ensure_section(cfg)
    cfg.set("pfed", _pfed_key(core, "cur"), str(max(0, int(cur))))
    cfg.set("pfed", _pfed_key(core, "max"), str(max(0, int(mx))))
    from utils.ini import write_cfg
    write_cfg(path, cfg)

def _pfed_seed_if_missing(cfg, path: str, core: str):
    """
    Ensure the PFED device has an initialized pool in [pfed].
    If missing OR both values are 0, roll 2d6 and seed cur=max.
    Returns (cur, max).
    """
    cur, mx = _pfed_read_fuzzy(cfg, path, core)  
    
    if cur is None or mx is None or ((cur or 0) <= 0 and (mx or 0) <= 0):
        
        total = random.randint(1, 6) + random.randint(1, 6)  
        if cur is None or cur <= 0:
            cur = total
        if mx  is None or mx  <= 0:
            mx  = total
        _pfed_write(cfg, path, core, cur, mx)

    return int(cur), int(mx)

def _pfed_consume(cfg, path: str, core: str, use: int) -> tuple[int, int]:
    cur, mx = _pfed_seed_if_missing(cfg, path, core)
    cur = max(0, int(cur) - max(0, int(use)))
    _pfed_write(cfg, path, core, cur, mx)
    return cur, mx

def _pfed_storage_remove_token(cfg, disp_name: str) -> bool:
    try:
        if not cfg.has_section("item"):
            return False
        raw = (cfg.get("item", "storage", fallback="") or "").strip()
        if not raw:
            return False
        toks = [t for t in raw.split() if t.strip()]
        target = re.sub(r"[^a-z0-9]+", "", (disp_name or "").lower())
        new = [t for t in toks if re.sub(r"[^a-z0-9]+", "", t.lower()) != target]
        if len(new) != len(toks):
            cfg.set("item", "storage", " ".join(new))
            return True
    except Exception:
        pass
    return False

def _pfed_disintegrate(cfg, path: str, slot: str, disp_name: str, core: str):
    """Remove device when charges hit 0 (unequip & decrement inventory); keep 0/0 in [pfed]."""
    try:
        if cfg.has_section("eq") and cfg.has_option("eq", slot):
            if (cfg.get("eq", slot, fallback="") or "").strip():
                cfg.set("eq", slot, "")
        if cfg.has_section("item"):
            base_norm = re.sub(r"[^a-z0-9]+", "", (disp_name or "").lower())
            for key in (core, base_norm):
                raw = cfg.get("item", key, fallback=None)
                if raw is None:
                    continue
                try:
                    n = max(0, int(str(raw).strip()) - 1)
                except Exception:
                    n = 0
                if n <= 0:
                    try: cfg.remove_option("item", key)
                    except Exception: pass
                    _pfed_storage_remove_token(cfg, disp_name)
                else:
                    cfg.set("item", key, str(n))
                break
        _pfed_write(cfg, path, core, 0, 0)  
        write_cfg(path, cfg)
    except Exception:
        pass



    
class Combat(commands.Cog):

              

    def __init__(self, bot):
        self.bot = bot
        spells = bot.get_cog("Spells")
        self._class_cp = getattr(spells, "_class_cp", {})

        self.classes = load_classes_ab("class.lst")
        self.items, self.item_index = load_items("item.lst")
        self._index = dict(self.item_index)
                               
        self.mon_ab = load_monster_ab("class.lst")
                                        
        self.class_saves = load_class_saves("class.lst")


              

    @commands.command(name="spec")
    async def set_weaponspec(self, ctx, *, weapon_name: str | None = None):
        """
        Set, view, or toggle your weapon specialization.
        Usage:
          !spec               -> show current specialization + level bonuses + ON/OFF status
          !spec longsword     -> set specialization to Longsword (if eligible)
          !spec off           -> disable specialization bonuses (keeps the chosen weapon)
          !spec on            -> re-enable specialization bonuses
        """
                                  
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` f""irst.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

                   
        if not weapon_name:
            spec = self._get_spec_weapon(cfg)
            lvl  = getint_compat(cfg, "cur", "level", fallback=1)
            enabled = self._weaponspec_enabled_for(cfg)
            status = "ON" if enabled else "OFF"
            if not spec:
                await ctx.send(f"ℹ️ Weapon specialization is **{status}**, but no weapon is set. Use `!spec <weapon>`.")
                return
            hit_b, dmg_b, atks = self._spec_mods_for_level(lvl)                    
            suffix = "" if enabled else "  _(bonuses currently **OFF**)_)"
            await ctx.send(
                f"🛡️ **{char_name}** specializes in **{spec}** → level {lvl} bonuses: "
                f"**+{hit_b} to hit**, **+{dmg_b} damage**, **{atks} attacks/turn**.  "
                f"**Status: {status}**{suffix}"
            )
            return

                                                                         
        key = weapon_name.strip().lower()
        if key in {"off", "disable", "disabled"}:
            self._set_weaponspec_enabled(cfg, False)
            write_cfg(path, cfg)
            await ctx.send(f"🛑 Weapon specialization for **{char_name}** is now **OFF**. No spec bonuses will apply.")
            return
        if key in {"on", "enable", "enabled"}:
            self._set_weaponspec_enabled(cfg, True)
            write_cfg(path, cfg)
            await ctx.send(f"✅ Weapon specialization for **{char_name}** is now **ON**.")
            return

                                                         
        if not self._has_weaponspec(cfg):
            await ctx.send("❌ Your character isn’t allowed to specialize. (Fighter or 'weaponspec' skill required.)")
            return

        race_lc, class_lc = self._get_char_race_class(cfg)

                       
        canon, item = self.find_item(weapon_name)
        if canon is None:
            virt_name, virt_item = self._virtual_weapon_for(race_lc, weapon_name)
            if virt_name:
                canon, item = virt_name, virt_item
        if canon is None:
            sugg = item                       
            msg = f"❌ Unknown item **{weapon_name}**."
            if sugg:
                msg += " Did you mean: " + ", ".join(f"`{s}`" for s in sugg)
            await ctx.send(msg)
            return

        if not self._item_is_weapon(item):
            await ctx.send(f"❌ **{canon}** isn’t a weapon.")
            return

                                
        self._set_spec_weapon(cfg, canon)
        write_cfg(path, cfg)

        lvl = getint_compat(cfg, "cur", "level", fallback=1)
        hit_b, dmg_b, atks = self._spec_mods_for_level(lvl)
        enabled = self._weaponspec_enabled_for(cfg)
        status = "ON" if enabled else "OFF"
        note = "" if enabled else "\n⚠️ Note: specialization is currently **OFF** — use `!spec on` to enable bonuses."
        await ctx.send(
            f"✅ **{char_name}** now specializes in **{canon}**.\n"
            f"Level {lvl} bonuses: **+{hit_b} to hit**, **+{dmg_b} damage**, **{atks} attacks/turn**.  "
            f"**Status: {status}**{note}"
        )


    def _resolve_partial_target(self, bcfg, chan_id: str, token: str):
        """
        Resolve a target name by exact CI match, then prefix, then substring.
        Also supports "normalized" matching (strip non-alphanum) so WO-5 == "wo5".
        Finally, falls back to a tiny fuzzy match (edit distance) to forgive 1–2 typos.
        Returns (resolved_name | None, suggestions_list_if_ambiguous).
        """
        tok = (token or "").strip()
        if not tok:
            return None, []
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            return None, []

        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", str(s).lower())

        tl = tok.lower()
        nt = _norm(tok)

        for n in names:
            if n.lower() == tl or _norm(n) == nt:
                return n, []

        prefix = [n for n in names if n.lower().startswith(tl) or _norm(n).startswith(nt)]
        if len(prefix) == 1:
            return prefix[0], []
        if len(prefix) > 1:
            return None, prefix[:8]

        subs = [n for n in names if (tl in n.lower()) or (nt and nt in _norm(n))]
        if len(subs) == 1:
            return subs[0], []
        if len(subs) > 1:
            return None, subs[:8]

        def _lev(a: str, b: str) -> int:
            if a == b:
                return 0
            la, lb = len(a), len(b)
            if la == 0 or lb == 0:
                return max(la, lb)
            dp = list(range(lb + 1))
            for i in range(1, la + 1):
                prev = dp[0]
                dp[0] = i
                ca = a[i-1]
                for j in range(1, lb + 1):
                    temp = dp[j]
                    cost = 0 if ca == b[j-1] else 1
                    dp[j] = min(dp[j] + 1, dp[j-1] + 1, prev + cost)
                    prev = temp
            return dp[lb]

        scored = []
        for n in names:
            ln = n.lower()
            nn = _norm(n)
            s1 = _lev(tl, ln[:len(tl)]) if ln else 99
            s2 = _lev(nt, nn[:len(nt)]) if nt else 99
            s3 = _lev(tl, ln)
            score = min(s1, s2, s3)
            scored.append((score, n))

        if not scored:
            return None, []

        scored.sort(key=lambda x: (x[0], len(x[1])))
        best = scored[0][0]
        threshold = 1 if len(tl) <= 4 else 2
        if best <= threshold:
            ties = [n for d, n in scored if d == best]
            if len(ties) == 1:
                return ties[0], []
            return None, ties[:8]

        return None, []


    @commands.command(name="a")
    async def attack(self, ctx, weapon: str, *opts):
        """
        Attack with your active character.
        Usage:
          !a longsword
          !a longsword go1                      # implicit target
          !a spear go1 go2                      # primary + splash
          !a lightxbow goblin long -b 2 -d 1d8+3
          !a shortsword -t bu1 sneak            # -t still works

        Options:
          -t / -target <name>        : check vs target AC
          short | long                : range stand-ins → short:+1 to hit; long:–2 to hit
          -b / -bonus <int>          : add to-hit modifier (e.g., -b 5 or -b -2)
          -d / -dmg / -damage <X>   : add extra damage (integer or dice like 1d8+5)
          sneak | -s | -sneak        : Thief-only (+4 to hit; ×2 dmg on hit)
          charge | -c | -charge      : Any class (+2 to hit; ×2 dmg; you suffer –2 AC until your next turn)
          called | -k | -called      : –4 to hit; no damage; target saves vs Paralyze (–spec dmg)
        """
        char_name = get_active(ctx.author.id)               
        attacker_name = char_name
        if not attacker_name:
            bcfg = _load_battles()
            ch = str(ctx.channel.id)
            if bcfg.has_section(ch):
                attacker_name = bcfg.get(ch, "turn", fallback="")
        prim_disp: str | None = None
        prim_path: str | None = None

        try:
            bcfgT = _load_battles()
            chanT = str(ctx.channel.id)
            if bcfgT and bcfgT.has_section(chanT) and attacker_name:
                namesT, _ = _parse_combatants(bcfgT, chanT)
                akeyT = _find_ci_name(namesT, attacker_name) or attacker_name
                try:
                    slotT = _slot(akeyT)
                except Exception:
                    slotT = akeyT.replace(" ", "_")
                tree_left = max(
                    bcfgT.getint(chanT, f"{slotT}.tree",    fallback=0),
                    bcfgT.getint(chanT, f"{slotT}.x_tree",  fallback=0),
                )
                if tree_left > 0:
                    await ctx.send("⛔ You are in **Tree Form** — you can’t attack. Use `!conc drop` to dismiss it.")
                    return
        except Exception:
            pass

        try:
            bcfg = _load_battles()
            chan = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan) and attacker_name:
                names, _ = _parse_combatants(bcfg, chan)
                akey = _find_ci_name(names, attacker_name) or attacker_name
                try:
                    slot_me = _slot(akey)
                except Exception:
                    slot_me = akey.replace(" ", "_")

                now_r = bcfg.getint(chan, "round", fallback=0)

                                                                                    
                if bcfg.getint(chan, f"{slot_me}.strike_nd6", fallback=0) > 0:
                    primed_on = bcfg.getint(chan, f"{slot_me}.strike_expire_round", fallback=-1)
                    if primed_on != now_r:
                        for suf in ("strike_nd6", "strike_expire_round"):
                            opt = f"{slot_me}.{suf}"
                            if bcfg.has_option(chan, opt):
                                bcfg.remove_option(chan, opt)
                        _save_battles(bcfg)

                                                                                         
                until = bcfg.getint(chan, f"{slot_me}.strike_spell_until", fallback=0)
                per   = bcfg.getint(chan, f"{slot_me}.strike_spell_nd6",   fallback=1)               
                if until and now_r <= until and per > 0:
                    primed_on = bcfg.getint(chan, f"{slot_me}.strike_expire_round", fallback=-1)
                                                                     
                    if primed_on != now_r:
                        bcfg.set(chan, f"{slot_me}.strike_nd6", str(per))
                        bcfg.set(chan, f"{slot_me}.strike_expire_round", str(now_r))
                        _save_battles(bcfg)

                                                                                          
                if until and now_r > until:
                    for suf in (
                        "strike_spell_until",
                        "strike_spell_nd6",
                        "strike_weapon",                                    
                        "strike_weapon_key"                                 
                    ):
                        opt = f"{slot_me}.{suf}"
                        if bcfg.has_option(chan, opt):
                            bcfg.remove_option(chan, opt)
                    _save_battles(bcfg)
        except Exception:
            pass


                                                             
        weapon_key = (weapon or "").strip().lower()
        wkey = re.sub(r"[^a-z0-9]+", "", (weapon or "").lower())

        is_oil_kw  = wkey in {"oil","flaskoil","oilflask"}
        is_holy_kw = wkey in {"holywater","holy_water","holywaterflask","flaskholywater","holy"}

        is_oil = is_oil_kw
        is_holy = is_holy_kw


        canon_name = None
        item = {}

        if is_oil_kw:
            canon_name = "Oil"
            item = {"type": "thrown", "stat": "dex"}                                               
        elif is_holy_kw:
            canon_name = "Holy Water"
            item = {"type": "thrown", "stat": "dex"}                                                      
        
        wrestle_aliases = {"wrestle", "grapple", "-w", "-wrestle"}
        want_wrestle = weapon_key in wrestle_aliases
        want_subdual = False                     
        is_brawl = False                                  
        brawl_kind = None                              
        brawl_hit_pen = 0                              

        brawl_aliases = {"punch","fist","unarmed","kick"}
        if (weapon_key in brawl_aliases) or (_norm(weapon) in brawl_aliases):
            is_brawl = True
            brawl_kind = "kick" if ("kick" in weapon_key or _norm(weapon) == "kick") else "punch"
            want_wrestle = False                           
            want_subdual = True                                   

                               
        primary_target = None
        splash_targets: list[str] = []
        is_weapon_subdual = False
        is_brawl_subdual = False
                       
        shield_bonus_applied = 0
        target_name = None
        want_sneak = False
        want_charge = False
        want_called = False
        want_flank = False                                                      
        want_twf   = False                                                           
        want_rage = False
        want_fav = False
        want_snipe = False
        want_snake = False
        want_assassinate = False       
                                                                                   
        raw_primary_target = None
        raw_splash_targets = []
        blind_hit_penalty = 0
        blind_ac_penalty = 0
        
        by_attacker = None
        try:
                                                                                           
            by_attacker = char_name
        except NameError:
            pass
        if not by_attacker:
            try:
                by_attacker = atk_name
            except NameError:
                by_attacker = None
        if not by_attacker:
                                                            
            bcfg = _load_battles()
            ch = str(ctx.channel.id)
            if bcfg.has_section(ch):
                by_attacker = bcfg.get(ch, "turn", fallback="")

                                                 
        attacker_name = by_attacker or get_active(ctx.author.id)
        if not attacker_name:
            bcfg = _load_battles()
            ch = str(ctx.channel.id)
            if bcfg.has_section(ch):
                attacker_name = bcfg.get(ch, "turn", fallback="")

                                                         
                                                            
        conc_dropped_due_to_attack = False

                            
        extra_hit_bonus = 0                              
        extra_dmg_spec  = None                                                   
        extra_dmg_value = 0                                                        
        extra_dmg_rolls = []                                                            
        rng_short = False                                    
        rng_long  = False                                    
        repeat_times = 1                                   

                                                                        
        if primary_target is None and target_name:
            primary_target = target_name

        i = 0
        flag_tokens = {
            "short","long","sneak","-s","-sneak","backstab","charge","-c","-charge",
            "called","-k","-called","-b","-bonus","-d","-dmg","-damage",
            "-t","-target","-splash","-sp","wrestle","-w","-wrestle","grapple",
            "-rr","-repeat","-attacks",
            "flank","adv","twf",
            "rage","-r","-rage",
            "fav","-fav","favored","-favored",
            "snipe","shot","-sn",
            "kill","death","-as","assassinate","-assassinate","deathstrike","-ds","-deathstrike",
            "snake", "-snake",
            "sub","-sub","-sub","nl","-nl","-nl","nonlethal","-nonlethal","-nonlethal",
            "punch","fist","unarmed","kick",

        }
        while i < len(opts):
            token = str(opts[i]).lower()     
                         
            if token in ("-splash", "-sp"):
                i += 1
                while i < len(opts) and str(opts[i]).lower() not in flag_tokens:
                    splash_targets.append(opts[i]); i += 1
                continue


            if token in ("-t", "-target"):
                                                                  
                i += 1
                while i < len(opts) and str(opts[i]).lower() not in flag_tokens:
                    if primary_target is None:
                        primary_target = opts[i]
                    else:
                        splash_targets.append(opts[i])
                    i += 1
                continue


            if token in ("-rr","-repeat","-attacks") and i + 1 < len(opts):
                try:
                    repeat_times = int(str(opts[i + 1]))
                    repeat_times = max(1, min(10, repeat_times))                          
                except Exception:
                    repeat_times = 1
                i += 2
                continue

            if token in ("fav","-fav","favored","-favored"):
                want_fav = True
                i += 1
                continue
                
                                       
            if token in ("kill","death","-as","assassinate","-assassinate","deathstrike","-ds","-deathstrike"):
                want_assassinate = True
                i += 1
                continue
                
            if token in ("sub","-sub","-sub","nl","-nl","-nl","nonlethal","-nonlethal","-nonlethal"):
                want_subdual = True
                i += 1
                continue


                                  
            if token == "short":
                rng_short = True; rng_long = False
                i += 1; continue
            if token == "long":
                rng_long = True; rng_short = False
                i += 1; continue

                                            
            if token in ("-b", "-bonus") and i + 1 < len(opts):
                try:
                    extra_hit_bonus = int(str(opts[i + 1]).replace("+","").strip())
                except Exception:
                    extra_hit_bonus = 0
                i += 2; continue

                                             
            if token in ("-d", "-dmg", "-damage") and i + 1 < len(opts):
                raw = str(opts[i + 1]).strip()
                extra_dmg_spec = raw
                                                                
                m = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+-]\s*\d+)?\s*", raw.lower())
                if m:
                    try:
                        s, rolls, flat = roll_dice(raw)
                        extra_dmg_value = s + flat
                        extra_dmg_rolls = rolls
                    except Exception:
                        extra_dmg_value = 0
                        extra_dmg_rolls = []
                else:
                    try:
                        extra_dmg_value = int(raw.replace("+",""))
                    except Exception:
                        extra_dmg_value = 0
                i += 2; continue

                                                                                                
            if token in ("snake", "-snake") or (token == "-s" and self._is_snake_staff_name(weapon)):
                want_snake = True
                i += 1
                continue

            if token in ("sneak", "-s", "-sneak", "backstab"):
                want_sneak = True
                i += 1; continue

            if token in ("snipe", "-sn", "shot"):
                want_snipe = True
                i += 1; continue

            if token in ("flank","adv"):
                want_flank = True
                i += 1
                continue

            if token == "twf":
                want_twf = True
                i += 1
                continue

            if token in ("rage","-r","-rage"):
                want_rage = True
                i += 1; continue

            if token in ("charge", "-c", "-charge"):
                want_charge = True
                i += 1; continue

            if token in ("called", "-k", "-called"):
                want_called = True
                i += 1; continue

            if token in ("wrestle","-w","-wrestle","grapple"):
                want_wrestle = True
                i += 1; continue


                                                                                    
                                                                     
                                                                                
            primary_target = primary_target or opts[i]
            if primary_target != opts[i]:
                splash_targets.append(opts[i])
            i += 1
            continue
                                                                   

                                                           
        raw_primary_target = primary_target
        raw_splash_targets = splash_targets[:]

        def _resolve_targets(primary, splashes):
            bcfg_local = _load_battles()
            chan_local = str(ctx.channel.id)

            def _one(tok: str | None):
                if not tok:
                    return None, []
                name, suggestions = self._resolve_partial_target(bcfg_local, chan_local, tok)
                return (name or tok), suggestions

            p_res, p_sugg = _one(primary)
            if p_sugg:
                raise ValueError("Ambiguous target '{}': {}".format(
                    primary, ", ".join(f"`{s}`" for s in p_sugg)
                ))

            s_res = []
            for t in splashes:
                r, s = _one(t)
                if s:
                    raise ValueError("Ambiguous target '{}': {}".format(
                        t, ", ".join(f"`{x}`" for x in s)
                    ))
                s_res.append(r)

            return p_res, s_res

        try:
            primary_target, splash_targets = _resolve_targets(raw_primary_target, raw_splash_targets)
        except ValueError as e:
            await ctx.send(f"⚠️ {e}")
            return

        target_name = primary_target
        display_target = primary_target


        names_to_wake = []
        if raw_primary_target:
            names_to_wake.append(raw_primary_target)
        if raw_splash_targets:
            names_to_wake.extend(raw_splash_targets)

                                                                   
        try:
            self._hyp_break_if_targeted(str(ctx.channel.id), names_to_wake)
            self._conf_mark_if_targeted(str(ctx.channel.id), names_to_wake, by_attacker)
        except Exception:
            pass

        bcfg = _load_battles(); chan = str(ctx.channel.id)
        if attacker_name and bcfg and bcfg.has_section(chan):
            names, _ = _parse_combatants(bcfg, chan)
            who_key  = _find_ci_name(names, attacker_name) or attacker_name
            slot     = _choose_slot_for_effects(bcfg, chan, who_key) if '_choose_slot_for_effects' in globals() else _slot(who_key)
            if bcfg.getint(chan, f"{slot}.gas", fallback=0) > 0:
                await ctx.send("⛔ You cannot attack while in **Gaseous Form**!")
                return


                                                                          
        if want_called:
            want_sneak = False
            want_charge = False
            want_rage = False
            
                                                                                            
        if want_wrestle:
            want_sneak = False
            want_charge = False
            extra_dmg_spec = None
            extra_dmg_value = 0

                                                                               
        if want_snake:
            want_sneak = False
            want_charge = False
            extra_dmg_spec = None
            extra_dmg_value = 0

                                                                           
        if primary_target is None and target_name:
            primary_target = target_name
        if target_name is None and primary_target:
            target_name = primary_target

        prim_disp, prim_path = (None, None)
        if display_target:
            prim_disp, prim_path = _resolve_char_ci(display_target)
            if not prim_path:
                await ctx.send(f"⚠️ Target **{display_target}** not found on disk; rolling without AC check.")
                primary_target = None
                target_name = None
                display_target = None


        display_target = prim_disp or primary_target                          

                                                                                    
        tgt_disp = prim_disp
        tgt_path = prim_path

        target_has_metal_armor = False
        if is_brawl and tgt_path:
            _t_cfg = read_cfg(tgt_path)
            target_has_metal_armor = _is_metal_armor_name(_target_armor_name(_t_cfg))

        ac_penalty_applied = False
        ac_defense_applied = 0
        weaken_armor_applied = False
        weaken_armor_left = 0
        base_target_ac = None
        ac_parts = []
        growth_animals_applied = False
        growth_animals_left = 0
        subdual_now_counts_as_lethal = False


                                  
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        coe = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(coe):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(coe)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        race_lc, class_lc = self._get_char_race_class(cfg)

                                                                                  
        is_natural = False
        if canon_name is None and not item:
            virt = self._virtual_weapon_for(race_lc, weapon, cfg=cfg)
            if virt:
                virt_name, virt_item = virt
                is_natural = True
                canon_name, item = virt_name, virt_item
            else:
                nat = self._pc_natural_attack_for(cfg, wkey)
                if nat:
                    is_natural = True
                    canon_name, item = nat


        if is_brawl:
            is_natural = True
            canon_name = "Kick" if brawl_kind == "kick" else "Punch"
            item = {"type":"natural", "stat":"str", "dmg": ("1d4 bludgeoning" if brawl_kind=="kick" else "1d3 bludgeoning")}
            brawl_hit_pen = (-2 if brawl_kind == "kick" else 0)


                                                                                                     


        atk_name, atk_path = _resolve_char_ci(char_name)
        atk_cfg = read_cfg(atk_path)
        atk_level = getint_compat(atk_cfg, "cur", "level", fallback=1)
                                                          
        is_attacker_undead = False
        try:
            is_attacker_undead = _is_undead_cfg(atk_cfg, atk_name)
        except Exception:
            is_attacker_undead = False

                                                                      
                                                                       
        sh_targets: list[str] = []
        if raw_primary_target:
            sh_targets.append(raw_primary_target)
        if raw_splash_targets:
            sh_targets.extend(raw_splash_targets)

        allow_out_of_turn = (wkey in {
            "colorcloud","cc","color_cloud","cloudkill","ck","stinkingcloud","stink","sc",
            "symbolofpain","sop","symbolpain","symbol_of_pain",
            "symboloffear","sof","symbolfear","symbol_of_fear",
            "symbolofdeath","sod","symboldeath","symbol_of_death"
        })


                                                                                           
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if bcfg.has_section(chan_id):
            names, _scores = _parse_combatants(bcfg, chan_id)
            turn_name = bcfg.get(chan_id, "turn", fallback="")
                                                                                        
                                                                                                        
                       
                                                                      
            if char_name == turn_name:
                try:
                    slot_self = _slot(char_name)
                except Exception:
                    slot_self = char_name.replace(" ", "_")

            
                                    
                opt = f"{slot_self}.acpen"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
                opt2 = f"{slot_self}.acbuf"
                if bcfg.has_option(chan_id, opt2):
                    bcfg.remove_option(chan_id, opt2)


        if wkey == "sword":
            CASTER_CLASSES = {"necromancer","spellcrafter","fightermage","magic-user","magethief","cleric","druid","illusionist"}
            if class_lc not in CASTER_CLASSES:
                                                        
                equipped = list(self._eq_get_weapons(cfg))                                                 
                pick = None

                                  
                prios = ("greatsword", "longsword", "shortsword", "sword")
                low = [w.lower() for w in equipped]
                for needle in prios:
                    for i, w in enumerate(low):
                        if needle in w:
                            pick = equipped[i]                                       
                            break
                    if pick:
                        break

                if not pick:
                    await ctx.send("🗡️ You don’t have a sword equipped. Equip one first.")
                    return

                                                                           
                weapon = pick                                                         
                if "greatsword" in pick.lower(): wkey = "great"
                elif "longsword" in pick.lower(): wkey = "long"
                elif "shortsword" in pick.lower(): wkey = "short"
                else: wkey = "long"                      

        if wkey in {"controlhuman", "charmgaze", "ch"}:
            await self._attack_controlhuman(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"controlanimal", "ca"}:
            await self._attack_controlanimal(ctx, atk_cfg, atk_name, atk_level, sh_targets); return
        if wkey in {"controlgiant", "cg"}:
            await self._attack_controlgiant(ctx, atk_cfg, atk_name, atk_level, sh_targets); return
        if wkey in {"controldragon", "cd"}:
            await self._attack_controldragon(ctx, atk_cfg, atk_name, atk_level, sh_targets); return
        if wkey in {"controlplant", "cp"}:
            await self._attack_controlplant(ctx, atk_cfg, atk_name, atk_level, sh_targets); return
        if wkey in {"controlundead", "cu"}:
            await self._attack_controlundead(ctx, atk_cfg, atk_name, atk_level, sh_targets); return
            
        if wkey in {"spiritualhammer","spirituallhammer","spirit_hammer","spirithammer","sh"}:
            await self._attack_spiritual_hammer(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"sword"}:
            await self._attack_sword(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
                                                                                   
                                                                                       
                                                                                        
             
        if wkey in {"produce", "pfc"}:
            await self._attack_produce(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"poisontouch", "touch", "pt"}:
            await self._attack_poisontouch(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"stench","stn"}:
            await self._attack_stench(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"symbolofpain","sop","symbolpain","symbol_of_pain"}:
            await self._attack_symbolofpain(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return    
        if wkey in {"symboloffear","sof","symbolfear","symbol_of_fear"}:
            await self._attack_symboloffear(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"symbolofdeath","sod","symboldeath","symbol_of_death"}:
            await self._attack_symbolofdeath(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return 
        if wkey in {"chill","chl"}:
            await self._attack_chill(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return               
        if wkey in {"eyebite", "eye_bite", "eb"}:
            await self._attack_eyebite(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"delayedblastfireball","delayed","dbf"}:
            await self._attack_delayedblastfireball(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"stinkingcloud","stink","sc"}:
            await self._attack_stinkingcloud(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return      
        if wkey in {"shillelagh", "shl"}:
            await self._attack_shillelagh(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"colorcloud", "cc", "color_cloud"}:
            await self._attack_colorcloud(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"calllightning", "cl", "callightning", "call_lightning"}:
            await self._attack_calllightning(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"cloudkill", "ck", "cloud_kill"}:
            await self._attack_cloudkill(ctx, atk_cfg, atk_name, atk_level, sh_targets)
            return
        if wkey in {"ghoulishhands","ghoulhands","ghh","ghoulclaw","ghoulclaws"}:
                                                                     
            gh_targets: list[str] = []
            if raw_primary_target:
                gh_targets.append(raw_primary_target)
            if raw_splash_targets:
                gh_targets.extend(raw_splash_targets)

            await self._attack_ghoulish_hands(ctx, atk_cfg, atk_name, atk_level, gh_targets)
            return
            
        await self._apply_start_of_turn_stoneskin(ctx, bcfg, chan_id, char_name, coe)


                                                                                  
        if want_wrestle:
            canon_name, item = "Wrestle", {}
        elif not is_natural:
                                                                           
            canon_name, item = self._item_lookup(weapon)
            if not item:
                                                                                               
                canon_name, item = await self._resolve_weapon_from_partial(ctx, cfg, weapon, ctx.author)
            if not item:
                                                                            
                canon_name, item = self.find_item(weapon)
                if canon_name is None:
                    sugg = item
                    msg = f"❌ Unknown item/weapon **{weapon}**."
                    if sugg:
                        msg += " Did you mean: " + ", ".join(f"`{s}`" for s in sugg)
                    await ctx.send(msg)
                    return


                                                         
        is_oil = normalize_name(canon_name) in {"oil","flaskoil","flaskofoil","oilflask"}
        is_holy = normalize_name(canon_name) in {"holywater","holy_water","holywaterflask","flaskholywater"}


        sleep_auto_hit = False
        try:
            if bcfg and bcfg.has_section(chan_id) and (prim_path or display_target):
                names, _ = _parse_combatants(bcfg, chan_id)
                cand = (prim_disp or primary_target or display_target or "").strip()
                key  = _find_ci_name(names, cand) or cand
                s_t  = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                if bcfg.getint(chan_id, f"{s_t}.sleep", fallback=0) > 0:
                    sleep_auto_hit = True
        except Exception:
            pass


                                            
        halfling_missile_bonus = 0
        if race_lc == "halfling" and not (is_oil or is_holy or want_wrestle):
            if self._is_halfling_missile_weapon(canon_name, item):
                halfling_missile_bonus = 1
                
        remaining = None
        if is_oil or is_holy:
                                                                   
            carried_ok, carried_total = self._has_carried_item(cfg, canon_name)
            if not carried_ok:
                pretty = "Oil" if is_oil else "Holy Water"
                await ctx.send(f"❌ You must have **{pretty}** in your **carried gear** to throw it. Try `!carry {pretty}` first.")
                return

                                           
            if not self._consume_carried_item(cfg, canon_name, qty=1):
                await ctx.send("⚠️ Carry stack desynced — it looks like you’re out of that item.")
                return

                                                                                           
            self._recompute_eq_weight(cfg)
            self._recompute_move(cfg)
            write_cfg(coe, cfg)

                                                                                   
            try:
                bcfg_q = _load_battles()
                ch_q = str(ctx.channel.id)
                if bcfg_q.has_section(ch_q):
                    names_q, _ = _parse_combatants(bcfg_q, ch_q)
                    if char_name in names_q:
                        msg_id = bcfg_q.getint(ch_q, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg_q, ch_q)
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

                                                                                       
            try:
                _ok, remaining = self._consume_inventory_item(cfg, coe, canon_name, qty=1)
            except Exception:
                remaining = None


                                                                                  
        if repeat_times > 1 and (want_wrestle or want_called or is_oil or is_holy):
            repeat_times = 1

        is_virtual_natural = (item and item.get("type","").lower() == "natural")
        if _poly_active(cfg):
            if cfg.getint("poly","nogear",fallback=0) == 1 and not is_virtual_natural:
                await ctx.send("⛔ Your gear doesn’t fit this form. Use your **natural attacks** (e.g., `claw`, `bite`).")
                return

        equipped_names = {normalize_name(w) for w in self._eq_get_weapons(cfg)}
        if not (is_oil_kw or is_holy_kw or want_wrestle or is_natural):
            if normalize_name(canon_name) not in equipped_names:
                canon2, item2 = await self._resolve_weapon_from_partial(ctx, cfg, weapon, ctx.author)
                if item2:
                    canon_name, item = canon2, item2
                else:
                    current = " / ".join(self._eq_get_weapons(cfg)) or "none"
                    await ctx.send(f"❌ That weapon isn’t equipped. Equip it first. Currently equipped: `{current}`")
                    return

                                       
        shield_name = get_compat(cfg, "eq", "armor2", fallback="").strip()
        if shield_name:
            _csh, it_sh = self._item_lookup(shield_name)
            if it_sh and self._item_is_shield(it_sh):
                eff_h = self._effective_hands(item, race_lc)
                if eff_h >= 2:
                    size = self._item_size(item)
                    small_2h = (self._race_is_small(race_lc) and size == "m")
                    note = " (Small races must use Medium weapons two-handed)" if small_2h else ""
                    await ctx.send(f"❌ You can’t attack with **{canon_name}** while a shield is equipped{note}.")
                    return


        weapon_type = (item.get("type", "") or "").strip().lower()
        is_magical_attack = False
        wtok = (weapon_type or "").lower()

                                           
        if wtok.startswith("mag") or "magical" in wtok:
            is_magical_attack = True
        try:
            wpn_plus = int(item.get("bonus", item.get("plus", 0)) or 0)
        except Exception:
            wpn_plus = 0
        if str(item.get("magic", "")).lower() in {"1","true","yes"}:
            is_magical_attack = True
            
        if wpn_plus > 0: is_magical_attack = True

                                                              
        try:
            bcfg = _load_battles()
            if bcfg.has_section(str(ctx.channel.id)):
                slot_me = _slot(char_name) if '_slot' in globals() else char_name.replace(" ", "_")
                mw_left = bcfg.getint(str(ctx.channel.id), f"{slot_me}.magwep", fallback=0)
                if mw_left > 0:
                    mw_name = bcfg.get(str(ctx.channel.id), f"{slot_me}.magwep_name", fallback="")
                    if mw_name and normalize_name(canon_name) == normalize_name(mw_name):
                        is_magical_attack = True
        except Exception:
            pass


        enh_wep_hit = enh_wep_dmg = 0
        weak_wep_hit = weak_wep_dmg = 0
        try:
            bcfg_e = _load_battles()
            ch_e = str(ctx.channel.id)
            if bcfg_e and bcfg_e.has_section(ch_e):
                names_e, _ = _parse_combatants(bcfg_e, ch_e)
                me_key = _find_ci_name(names_e, char_name) or char_name
                try:
                    slot_me = _slot(me_key)
                except Exception:
                    slot_me = me_key.replace(" ", "_")

                                         
                enh_left = bcfg_e.getint(ch_e, f"{slot_me}.enhwep", fallback=0)
                if enh_left > 0:
                    wname = (bcfg_e.get(ch_e, f"{slot_me}.enhwep_name", fallback="") or "").strip()
                    if not wname or normalize_name(wname) == normalize_name(canon_name):
                        enh_bonus = max(1, bcfg_e.getint(ch_e, f"{slot_me}.enhwep_bonus", fallback=1))
                        enh_wep_hit = enh_bonus
                        enh_wep_dmg = enh_bonus

                                                                                             
                weak_left = bcfg_e.getint(ch_e, f"{slot_me}.weakwep", fallback=0)
                if weak_left > 0:
                    wname = (bcfg_e.get(ch_e, f"{slot_me}.weakwep_name", fallback="") or "").strip()
                    if not wname or normalize_name(wname) == normalize_name(canon_name):
                        weak_bonus = max(1, bcfg_e.getint(ch_e, f"{slot_me}.weakwep_bonus", fallback=1))
                        weak_wep_hit = -weak_bonus
                        weak_wep_dmg = -weak_bonus
        except Exception:
            pass


        is_barbarian = (class_lc == "barbarian")
        is_ranger = (class_lc == "ranger")
        is_scout = (class_lc == "scout")
        is_assassin = (class_lc == "assassin")

                                                                       
        weapon_slot_for_corrosion = None
        if not (is_natural or is_oil or is_holy or want_wrestle):
            weapon_slot_for_corrosion = self._eq_find_weapon_slot(cfg, canon_name)


                                                      
        bow_canon = normalize_name(canon_name)
        is_ranger_bow = (is_ranger and bow_canon in {"shortbow", "longbow"})
        is_scout_bow = (is_scout and bow_canon in {"shortbow", "longbow", "lightxbow", "heavyxbow", "sling"})
                                                           
        ranger_bow_hit_bonus = 2 if is_ranger_bow else 0
        scout_bow_hit_bonus = 1 if is_scout_bow else 0
                                                                                                        
        path = f"{char_name.replace(' ','_')}.coe"
        ccfg = read_cfg(path)
        level = getint_compat(ccfg, "cur", "level", fallback=1)
                                                                                                    
                                                


                    
        char_class = get_compat(cfg, "info", "class", fallback="Fighter")
        is_thief = str(char_class).strip().lower() in {"thief", "magethief"}
        level      = getint_compat(cfg, "cur", "level", fallback=1)
        STR        = getint_compat(cfg, "stats", "str", fallback=10)
        DEX        = getint_compat(cfg, "stats", "dex", fallback=10)
        str_mod, dex_mod = _osr_str_dex_mods(cfg)

        ab_list = self.classes.get(char_class.lower(), {}).get("ab", [])
        ab = ab_list[min(level - 1, len(ab_list) - 1)] if ab_list else 0

                        
        spec_hit = spec_dmg = 0
        spec_attacks = 1
        spec_applied = False

        try:
            if self._has_weaponspec(cfg):
                spec_wpn = (self._get_spec_weapon(cfg) or "").strip()
                if spec_wpn and self._weaponspec_enabled_for(cfg):
                    spec_key = _weapon_spec_key(spec_wpn)

                                                                   
                    cur_keys = {_weapon_spec_key(canon_name)}
                                                                         
                    for k in ("base", "family", "base_name", "type_base"):
                        v = (item.get(k) or "").strip()
                        if v:
                            cur_keys.add(_weapon_spec_key(v))

                    if spec_key in cur_keys:
                        spec_hit, spec_dmg, spec_attacks = self._spec_mods_for_level(level)
                        spec_applied = True
        except Exception:
            pass


                       
        dmg_spec    = item.get("dmg", "1d4")
                                                                            
        try:
            att_key = re.sub(r"[^a-z0-9]+","", (canon_name or "")).lower()
            eff_tok = get_compat(atk_cfg, "base", f"effect_{att_key}", fallback="")
            if eff_tok:
                dmg_spec = f"{dmg_spec} {eff_tok}".strip()                                
        except Exception:
            pass

        used_stat   = str(item.get("stat", "str")).lower().strip()
        short       = item.get("short")
        med         = item.get("med")
        longr       = item.get("long")
        atk_mod     = str_mod if used_stat == "str" else dex_mod
        weapon_type = (item.get("type", "") or "").strip().lower()
                                                                                               
        try:
            m = re.match(r"\s*\d+d\d+(?:\s*[+-]\s*\d+)?\s+([A-Za-z][\w-]*)\s*$", str(dmg_spec))
            if m:
                trailing = m.group(1).lower()
                                                                                      
                TYPE_TOKENS = {
                    "slashing","piercing","bludgeoning",
                    "fire","cold","acid","holy","electric","lightning",
                    "necrotic","force","psychic","thunder","silver","magic","magical"
                }

                if trailing in TYPE_TOKENS:
                    weapon_type = f"{(weapon_type or '').strip()} {trailing}".strip()
                    dmg_spec = re.sub(r"\s+[A-Za-z][\w-]*\s*$", "", str(dmg_spec)).strip()

        except Exception:
            pass        
        is_flaming = False
        try:
                                                                          
            special_tokens = f"{item.get('special','')} {item.get('flags','')}".lower()
            is_flaming = ("flame" in special_tokens) or ("flaming" in special_tokens)\
                         or str(item.get("flame","")).lower() in {"1","true","yes"}
        except Exception:
            is_flaming = False

        if is_flaming:
                                                                                       
            weapon_type = "fire"
        weapon_drains = 0                                             
        try:
            specials_blob = " ".join([
                str(item.get("special", "")),
                str(item.get("flags", "")),
                str(item.get("effects", "")),
                str(item.get("notes", "")),
            ]).lower()

                                                                                                     
            m_drain = re.search(r"(?:\blevel\s*drain\b|\benergy\s*drain\b|\bdrain\b)(?::?\s*(\d+))?", specials_blob)
            if m_drain:
                weapon_drains = max(1, int(m_drain.group(1) or 1))
        except Exception:
            weapon_drains = 0


        missile_tags = {"missile","ranged","bow","xbow","thrown"}
        is_rangedish = ((weapon_type or "").lower() in missile_tags) or any(bool(x) for x in (short, med, longr)) or rng_long
        barb_melee = (is_barbarian and used_stat == "str" and not (is_rangedish or is_oil or is_holy or want_wrestle))


        if want_wrestle:
            is_oil = False
            is_holy = False
            used_stat = "str"                                      
            atk_mod   = str_mod
            spec_hit = 0                                                
            spec_dmg = 0                          
            weapon_type = "special"                                
            
        if is_oil:
            used_stat = "dex"
            atk_mod   = dex_mod
            if not weapon_type:
                weapon_type = "fire"                              

        if is_holy:
            used_stat = "dex"
            atk_mod   = dex_mod
            if not weapon_type:
                weapon_type = "holy"                              


        ammo_name = None
        ammo_remaining_after_first = None

        _ammo_map = {
            "shortbow":  "Arrow",
            "longbow":   "Arrow",
            "lightxbow": "Bolt",
            "heavyxbow": "Bolt",
            "sling":     "Bullet",
        }

        def _ammo_for_weapon(item: dict, canon_name: str) -> str | None:
                                                                
            candidates = [
                normalize_name(item.get("base", "")),
                normalize_name(item.get("family", "")),
                                                                 
                re.sub(r"\+.*$", "", normalize_name(canon_name or "")),
                normalize_name(canon_name or ""),
            ]
            for key in candidates:
                if key in _ammo_map:
                    return _ammo_map[key]
            return None

        canon_norm = normalize_name(canon_name)
        needs_ammo = _ammo_for_weapon(item, canon_name)


                                                                                                          
        if needs_ammo and not (is_oil or is_holy or want_wrestle or is_natural) and not _is_monster_file(atk_path):
                                     
            carried_ok, carried_total = self._has_carried_item(cfg, needs_ammo)
            if not carried_ok or carried_total < 1:
                await ctx.send(
                    f"❌ You must have **{needs_ammo}** in your **carried gear** to fire **{canon_name}**. "
                    f"Try `!carry {needs_ammo}` first."
                )
                return

                                                                                
            if not self._consume_carried_item(cfg, needs_ammo, qty=1):
                await ctx.send("⚠️ Carry stack desynced — it looks like you’re out of ammunition.")
                return

                                         
            self._recompute_eq_weight(cfg)
            self._recompute_move(cfg)
            write_cfg(coe, cfg)

                                                                    
            try:
                _ok, ammo_remaining_after_first = self._consume_inventory_item(cfg, coe, needs_ammo, qty=1)
            except Exception:
                ammo_remaining_after_first = None


        base_target_ac = None
        ac_parts = []                                        

        if prim_path:
            t_cfg = read_cfg(prim_path)
            raw_ac = get_compat(t_cfg, "stats", "ac", fallback="")
            try:
                base_target_ac = int(raw_ac) if str(raw_ac).strip() != "" else 10
            except Exception:
                base_target_ac = 11

                                       
            try:
                if _poly_active(t_cfg):
                    ac_ovr = _poly_ac(t_cfg)
                    if ac_ovr is not None:
                        base_target_ac = ac_ovr
                        ac_parts.append(f"{ac_ovr} (polymorph)")
            except Exception:
                pass

        target_ac = base_target_ac

        if bcfg.has_section(chan_id) and (prim_path or display_target):
            names, _ = _parse_combatants(bcfg, chan_id)
            cand = (prim_disp or primary_target or display_target or "").strip()
            name_key = _find_ci_name(names, cand) or cand
            s_tgt = _slot(name_key) if '_slot' in globals() else name_key.replace(" ", "_")

                                                                              
            charge_pen = 0
            opt = f"{s_tgt}.acpen"
            if bcfg.has_option(chan_id, opt):
                charge_pen = -2
                target_ac = (target_ac if target_ac is not None else 10) + charge_pen
                ac_parts.append("−2 (charging)")
                ac_penalty_applied = True

                                          
            try:
                if bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0) > 0:
                    target_ac = (target_ac if target_ac is not None else 10) - 4
                    ac_parts.append("−4 (blinded)")
                    blind_ac_penalty = -4
            except Exception:
                pass

                                                
            shield_bonus_applied = 0
            try:
                sh_left = bcfg.getint(chan_id, f"{s_tgt}.shield", fallback=0)
                if sh_left > 0:
                    is_missile = False
                    wtyp = (weapon_type or "").lower()
                    if wtyp in {"missile","ranged","bow","xbow","thrown"}:
                        is_missile = True
                    if not is_missile and any(bool(x) for x in (short, med, longr)) or rng_long:
                        is_missile = True
                    shield_bonus_applied = 6 if is_missile else 3
                    target_ac = (target_ac if target_ac is not None else 10) + shield_bonus_applied
                    ac_parts.append(f"+{shield_bonus_applied} (Shield)")
            except Exception:
                pass

                                             
            ac_defense_applied = 0
            try:
                acbuf_val = bcfg.getint(chan_id, f"{s_tgt}.acbuf", fallback=0)
                if acbuf_val:
                    target_ac = (target_ac if target_ac is not None else 10) + acbuf_val
                    ac_defense_applied = acbuf_val
                    ac_parts.append(f"+{acbuf_val} (defense)")
            except Exception:
                pass

                                                                              
            try:
                wa_legacy = bcfg.getint(chan_id, f"{s_tgt}.weakarmor",     fallback=0)
                wa_timer  = bcfg.getint(chan_id, f"{s_tgt}.x_weakenarmor",  fallback=0)
                wa_left   = max(wa_legacy, wa_timer)
                if wa_left > 0:
                    target_ac = (target_ac if target_ac is not None else 10) - 1
                    ac_parts.append("−1 (Weaken Armor)")
                    weaken_armor_applied = True
                    weaken_armor_left = wa_left
            except Exception:
                pass

                                      
            try:
                goa_left = max(
                    bcfg.getint(chan_id, f"{s_tgt}.growthanimals",      fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt}.growthofanimals",    fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt}.x_growthanimals",    fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt}.x_growthofanimals",  fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt}.goa",                fallback=0),
                )
                if goa_left > 0:
                    target_ac = (target_ac if target_ac is not None else 10) + 2
                    ac_parts.append("+2 (Growth of Animals)")
                    growth_animals_applied = True
                    growth_animals_left = goa_left
            except Exception:
                pass


                                   
            namesX, _ = _parse_combatants(bcfg, chan_id)
            keyX  = _find_ci_name(namesX, display_target) or display_target
            try:
                slot_tgtX = _slot(keyX)
            except Exception:
                slot_tgtX = keyX.replace(" ", "_")

            _, _, p_ac = _combat_mods_from_potions(bcfg, chan_id, slot_tgtX)
            target_ac = (target_ac or 11) + p_ac                                                  


        slayer_note = None
        try:
                                                      
            base_plus = wpn_plus

                                                                  
            mtype = ""
            if tgt_path:
                tcfg_for_type = read_cfg(tgt_path)
                mtype = (get_compat(tcfg_for_type, "base", "type", fallback="") or
                         get_compat(tcfg_for_type, "info", "type", fallback="") or
                         get_compat(tcfg_for_type, "info", "monster_type", fallback="")).strip()

                                                             
            special_keys = ("dragon", "undead", "lycanthrope", "enchanted", "ooze")
            best_vs = base_plus
            best_key = None
            for k in special_keys:
                if str(item.get(k, "")).strip() != "":
                    try:
                        val = int(str(item.get(k)))
                    except Exception:
                        continue
                    if val > best_vs and _match_slayer_type(mtype, k):
                        best_vs = val
                        best_key = k

                                                                              
            if best_key is not None and best_vs != base_plus:
                wpn_plus = best_vs                                             
                pretty = {
                    "dragon": "Dragons",
                    "undead": "Undead",
                    "lycanthrope": "Lycanthropes",
                    "enchanted": "Enchanted (fey/magical beasts)",
                    "ooze": "Oozes",
                }.get(best_key, best_key.capitalize())
                slayer_note = f"Slayer vs **{pretty}**: weapon counts as **+{best_vs}** (base +{base_plus})."
        except Exception:
                                                           
            pass


        sneak_hit_bonus   = 4 if (want_sneak and is_thief) else 0
        charge_hit_bonus  = 2 if want_charge else 0
        called_hit_penalty = -4 if want_called else 0
        range_hit_bonus   = (1 if rng_short else 0) + (-2 if rng_long else 0)
        manual_hit_bonus  = extra_hit_bonus

        twf_penalty = 0
        if want_twf:
            twf_penalty = -3 + max(0, dex_mod)
            if twf_penalty > 0:
                twf_penalty = 0                                                        


                                                                                  
        inv_atk_bonus = 0
        inv_type_atk = "norm"
        inv_group_note = None
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id) and attacker_name:
                names, _ = _parse_combatants(bcfg, chan_id)
                k_att = _find_ci_name(names, attacker_name) or attacker_name
                s_att = _slot(k_att) if '_slot' in globals() else k_att.replace(" ", "_")

                inv_left = bcfg.getint(chan_id, f"{s_att}.inv", fallback=0)
                inv_perm = bcfg.getint(chan_id, f"{s_att}.inv_perm", fallback=0)

                if inv_left > 0 or inv_perm > 0:
                    inv_atk_bonus = 4

                                                                    
                    inv_type_atk = (bcfg.get(chan_id, f"{s_att}.inv_type", fallback="").strip().lower()
                                    or ("perm" if inv_perm > 0 else "norm"))

                    def _clear_inv(slot: str):
                        bcfg.set(chan_id, f"{slot}.inv", "0")
                        for suf in ("inv_by", "inv_type", "inv_gid", "inv_leader", "inv_perm"):
                            opt = f"{slot}.{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)

                    if inv_type_atk in {"imp", "improved"}:
                                                                         
                        pass
                    elif inv_type_atk == "group":
                        gid = bcfg.get(chan_id, f"{s_att}.inv_gid", fallback="")
                        is_leader = bcfg.getint(chan_id, f"{s_att}.inv_leader", fallback=0) > 0
                        if is_leader and gid:
                            names_all, _ = _parse_combatants(bcfg, chan_id)
                            for nm in names_all:
                                s = _slot(nm) if '_slot' in globals() else nm.replace(" ", "_")
                                if bcfg.getint(chan_id, f"{s}.inv", fallback=0) > 0 and\
                                   bcfg.get(chan_id, f"{s}.inv_gid", fallback="") == gid:
                                    _clear_inv(s)
                            inv_group_note = "**Leader** of Invisible10 — this attack ends invisibility for the **entire group**."
                            _save_battles(bcfg)
                        else:
                            _clear_inv(s_att)
                            inv_group_note = "This attack ends **your** Invisible10 (others remain invisible)."
                            _save_battles(bcfg)
                    else:
                                                                                             
                        _clear_inv(s_att)
                        _save_battles(bcfg)
        except Exception:
            pass


        try:
                                                                          
            if inv_atk_bonus == 0 and 'atk_cfg' in locals() and atk_cfg is not None:
                mtype = (get_compat(atk_cfg, "info", "monster_type", fallback="") or "").strip().lower()
                if mtype in {"invisiblestalker", "invisible_stalker"}:
                    inv_atk_bonus = 4
                    inv_type_atk = "stalker"                                   
                    inv_group_note = None
        except Exception:
            pass


             
                                   
                                          
                                                                     
                                                            
                                                                             
                     
                                         
                                  
                                                    

                                                                                         
                                                                               
                                                                           
                                                                
                                    
                                                                  
                                                                         
                                                                   
                                                                                              

                                
                                                                                                                 
                                                          
                          
                                                                          
                 

        flank_hit_bonus = 2 if want_flank else 0
        sneak_hit_bonus = 4 if (want_sneak and is_thief) else 0
        flank_suppressed = False
        if flank_hit_bonus and sneak_hit_bonus:
                                                                      
            flank_hit_bonus = 0
            flank_suppressed = True

        rage_hit_bonus = 2 if (want_rage and is_barbarian) else 0
                                                
        deathstrike_blocked_reason = None
        if want_assassinate:
            melee_ok = _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle)

            # Weapons like daggers, spears, and hand-axes have range bands but are
            # still perfectly good one-handed melee weapons. For Death Strike, treat
            # “rangedish but not bow/sling/xbow” as melee.
            canon_lc = (canon_name or weapon_name or "").strip().lower()
            missileish_names = ("bow", "crossbow", "xbow", "sling")
            pure_missile = any(tok in canon_lc for tok in missileish_names)

            if not pure_missile and is_rangedish and not (is_oil or is_holy or want_wrestle):
                melee_ok = True

            try:
                eff_hands = self._effective_hands(item, race_lc)
            except Exception:
                # Fall back to simple item-based hands if the helper isn’t available.
                try:
                    eff_hands = self._item_hands(item)
                except Exception:
                    eff_hands = 1

            if not melee_ok or eff_hands >= 2:
                want_assassinate = False
                deathstrike_blocked_reason = "Death Strike requires a one-handed melee weapon."

        deathstrike_hit_bonus = 4 if (want_assassinate and is_assassin) else 0


        d20 = random.randint(1, 20)
        is_crit = (d20 == 20)
        is_nat1 = (d20 == 1)
                                                      
        neg_levels = getint_compat(cfg, "cur", "neg_levels", fallback=0)
        drain_hit_penalty = -neg_levels


        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                me_key = _find_ci_name(names, char_name) or char_name
                s_me = _slot(me_key) if '_slot' in globals() else me_key.replace(" ", "_")
                if bcfg.getint(chan_id, f"{s_me}.blind", fallback=0) > 0:
                    blind_hit_penalty = -4
        except Exception:
            pass


        sick_hit_penalty = 0
        sick_pen_shown = 0
        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                me_key = _find_ci_name(names, char_name) or char_name
                s_me = _slot(me_key) if '_slot' in globals() else me_key.replace(" ", "_")
                if bcfg.getint(chan_id, f"{s_me}.sick", fallback=0) > 0:
                    raw_pen = str(bcfg.get(chan_id, f"{s_me}.sick_pen", fallback="-2")).strip()
                    try:
                        val = int(raw_pen)
                    except Exception:
                        val = -2
                    sick_hit_penalty = val if val <= 0 else -abs(val)
                    sick_pen_shown = abs(sick_hit_penalty)
        except Exception:
            pass


        pain_att_pen = 0             
        pain_dmg_pen = 0             
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                me_key = _find_ci_name(names, char_name) or char_name
                s_me = _slot(me_key) if '_slot' in globals() else me_key.replace(" ", "_")

                                                                                
                pain_att_pen = -abs(bcfg.getint(chan_id, f"{s_me}.pain_pen",     fallback=0))
                pain_dmg_pen = -abs(bcfg.getint(chan_id, f"{s_me}.pain_dmg_pen", fallback=0))
        except Exception:
            pass

        pain_txt = f" {pain_att_pen}" if pain_att_pen else ""


                                 
        try:
            slot_att = _slot(char_name)
        except Exception:
            slot_att = char_name.replace(" ", "_")

        p_atk, p_dmg, _ = _combat_mods_from_potions(bcfg, chan_id, slot_att)
        p_atk_all, p_dmg_all = p_atk, p_dmg
  
                                            
        starlight_on = False
        try:
            bcfg = _load_battles()
            ch = str(ctx.channel.id)
            if bcfg and bcfg.has_section(ch):
                slot_att = _slot(char_name) if '_slot' in globals() else char_name.replace(" ","_")
                starlight_on = bcfg.getint(ch, f"{slot_att}.x_starlight", fallback=0) > 0
        except Exception:
            starlight_on = False

        bless_bane_hit = 0
        bb_note = []
        bb_str = ""
        try:
            bcfg_bb = _load_battles()
            ch_bb = str(ctx.channel.id)
            if bcfg_bb and bcfg_bb.has_section(ch_bb):
                names_bb, _ = _parse_combatants(bcfg_bb, ch_bb)
                me_key = _find_ci_name(names_bb, char_name) or char_name
                try: s_me = _slot(me_key)
                except Exception: s_me = me_key.replace(" ", "_")

                if bcfg_bb.getint(ch_bb, f"{s_me}.x_bless", fallback=0) > 0:
                    val = max(1, bcfg_bb.getint(ch_bb, f"{s_me}.bless_hit", fallback=1))
                    bless_bane_hit += val
                    bb_note.append(f"Bless: +{val} to hit")
                if bcfg_bb.getint(ch_bb, f"{s_me}.x_bane", fallback=0) > 0:
                    val = max(1, bcfg_bb.getint(ch_bb, f"{s_me}.bane_hit", fallback=1))
                    bless_bane_hit -= val
                    bb_note.append(f"Bane: −{val} to hit")

                if bless_bane_hit:
                    bb_str = (" + " if bless_bane_hit > 0 else " - ") + str(abs(bless_bane_hit))
        except Exception:
            pass


        inv_def_hit_penalty = 0
        inv_def_seen = False
        try:
            if bcfg and bcfg.has_section(chan_id) and (prim_path or display_target):
                names, _ = _parse_combatants(bcfg, chan_id)
                cand = (prim_disp or primary_target or display_target or "").strip()
                key  = _find_ci_name(names, cand) or cand
                s_tgt = _slot(key) if '_slot' in globals() else key.replace(" ", "_")

                inv_left = bcfg.getint(chan_id, f"{s_tgt}.inv", fallback=0)
                inv_perm = bcfg.getint(chan_id, f"{s_tgt}.inv_perm", fallback=0)

                if inv_left > 0 or inv_perm > 0:
                                                                         
                    if attacker_name:
                        k_att = _find_ci_name(names, attacker_name) or attacker_name
                        s_att = _slot(k_att) if '_slot' in globals() else k_att.replace(" ", "_")
                        for opt in (
                            f"{s_att}.seeinv", f"{s_att}.see_invisible", f"{s_att}.x_seeinvisible",
                            f"{s_att}.truesee", f"{s_att}.truesight", f"{s_att}.x_trueseeing"
                        ):
                            try:
                                if bcfg.getint(chan_id, opt, fallback=0) > 0:
                                    inv_def_seen = True
                                    break
                            except Exception:
                                pass

                    if not inv_def_seen:
                        inv_def_hit_penalty = -4
        except Exception:
            pass

        subdual_hit_pen = (-4 if (want_subdual and not is_brawl) else 0)

        total_to_hit = (d20 + ab + atk_mod + spec_hit
                + sneak_hit_bonus + charge_hit_bonus + rage_hit_bonus
                + called_hit_penalty + range_hit_bonus
                + halfling_missile_bonus
                + manual_hit_bonus
                + flank_hit_bonus
                + ranger_bow_hit_bonus
                + scout_bow_hit_bonus
                + twf_penalty
                + deathstrike_hit_bonus
                + drain_hit_penalty
                + blind_hit_penalty
                + sick_hit_penalty
                + inv_atk_bonus
                + inv_def_hit_penalty
                + pain_att_pen
                + wpn_plus
                + p_atk
                + enh_wep_hit
                + weak_wep_hit
                + bless_bane_hit
                + subdual_hit_pen
                + brawl_hit_pen)

        hit = None
        if target_ac is not None:
            if sleep_auto_hit:
                hit = True                                              
            elif is_nat1:
                hit = False                                              
            else:
                hit = (is_crit or (total_to_hit >= target_ac))


                                                                        
        margin = (total_to_hit - target_ac) if target_ac is not None else None

                            
        d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
        ab_str   = f"+ {ab}" if ab >= 0 else f"{ab}"
        mod_str  = f"+ {atk_mod}" if atk_mod > 0 else ""
        spec_str = f" + {spec_hit}" if spec_hit else ""
        sneak_str  = f" + {sneak_hit_bonus}" if sneak_hit_bonus else ""
        charge_str = f" + {charge_hit_bonus}" if charge_hit_bonus else ""
        called_str = " - 4" if want_called else ""
        rng_str    = (" + 1" if rng_short else (" - 2" if rng_long else ""))
        half_str = " + 1" if halfling_missile_bonus else ""
        ranger_bow_str = " + 2" if ranger_bow_hit_bonus else ""
        scout_bow_str = " + 1" if scout_bow_hit_bonus else ""
        user_str   = (f" + {manual_hit_bonus}" if manual_hit_bonus > 0
                      else (f" - {abs(manual_hit_bonus)}" if manual_hit_bonus < 0 else ""))
        flank_str = " + 2" if (want_flank and not flank_suppressed) else ""
        rage_str = " + 2" if rage_hit_bonus else ""
        twf_str   = (f" - {abs(twf_penalty)}" if twf_penalty < 0 else "")
        deathstrike_str = " + 4" if deathstrike_hit_bonus else ""       
        drain_str = (f" - {neg_levels} (Drain)" if neg_levels > 0 else "")
        blind_str = " - 4" if blind_hit_penalty else ""
        sick_str = (f" - {sick_pen_shown}" if sick_hit_penalty else "")
        inv_str = " + 4" if inv_atk_bonus else ""
        wpn_plus_str = f" {_sign(wpn_plus)}" if wpn_plus else ""
        p_str = f" + {p_atk}" if p_atk else ""
        enh_hit_str = f" + {enh_wep_hit}" if enh_wep_hit else ""
        weak_hit_str = f" - {abs(weak_wep_hit)}" if weak_wep_hit else ""
        bb_piece = bb_str                        
        inv_def_str = " - 4" if inv_def_hit_penalty else ""
        brawl_hit_pen_str = (f" - {abs(brawl_hit_pen)}" if brawl_hit_pen else "")
        subdual_hit_pen_str = (" - 4" if subdual_hit_pen else "")
        
        attack_line = (
            f"{d20_face} {ab_str} {mod_str}{spec_str}{sneak_str}{charge_str}{rage_str}"
            f"{called_str}{rng_str}{half_str}{ranger_bow_str}{scout_bow_str}{user_str}{flank_str}{twf_str}"
            f"{deathstrike_str}{drain_str}{blind_str}{sick_str}{inv_str}{inv_def_str}{pain_txt}{wpn_plus_str}{p_str}"
            f"{enh_hit_str}{weak_hit_str}{bb_piece}{brawl_hit_pen_str}{subdual_hit_pen_str} = ``{total_to_hit}``"
        )


        if is_oil:
            pretty_primary = display_target or (primary_target or "")
            if display_target:
                title = f"{char_name} throws Oil at {pretty_primary}!"
            else:
                title = f"{char_name} throws Oil!"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
            embed.add_field(name="Inventory", value=f"(Oil –1; remaining: {remaining if remaining is not None else '—'})", inline=True)            
            embed.add_field(name="Attack roll", value=attack_line, inline=True)
            if target_ac is not None:
                embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                                                                          

                                                        
            portrait_url = (
                get_compat(atk_cfg, "info", "portrait", fallback="")
                or get_compat(cfg, "info", "portrait", fallback="")
            ).strip()
            if portrait_url:
                try:
                    embed.set_thumbnail(url=portrait_url)                   
                except Exception:
                    pass


                                                  
            if self._pnm_active_for(bcfg, chan_id, display_target or primary_target):
                embed.add_field(name="Protection from Normal Missiles",
                                value="Oil is **negated** by Protection from Normal Missiles — no effect.",
                                inline=False)
                await ctx.send(embed=embed)
                return

            if display_target:
                consumed, left = self._mi_consume_if_present(ctx, display_target)
                if consumed:
                    embed.add_field(
                        name="Mirror Image",
                        value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                        inline=False
                    )
                    await ctx.send(embed=embed)
                    return

            if not hit:
                embed.add_field(name="Oil", value="Misses — no effect.", inline=False)
                await ctx.send(embed=embed)
                return

                                                                    
            if prim_path:
                t_cfg = read_cfg(prim_path)
                s, rolls, flat = roll_dice("1d8")
                raw = s + flat
                final, note = _apply_mitigation(raw, weapon_name="Oil", weapon_type="fire", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty_primary)

                                               
                try:
                                                        
                    name_for_slot = (display_target or primary_target or target_name or "")
                    names_keyed, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names_keyed, name_for_slot) or name_for_slot
                    slot_tgt = _slot(key) if '_slot' in globals() else key.replace(" ", "_")


                                                               
                    try:
                        dmg_after, absorbed, remain, discharged = self._ss_soak(
                            bcfg, chan_id, slot_tgt, final                              
                        )
                        if absorbed > 0:
                            embed.add_field(
                                name="Stoneskin",
                                value=(f"Stoneskin absorbs **{absorbed}**. " +
                                       ("**DISCHARGED!**" if discharged else f"Remaining buffer: **{remain}**.")),
                                inline=False,
                            )
                            final = dmg_after                          
                    except Exception as e:
                                                                              
                        embed.add_field(name="Stoneskin (error)", value=f"{type(e).__name__}", inline=False)
                except Exception:
                    pass

                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                max_hp_cap = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                new_hp = old_hp - final
                new_hp = max(0, min(max_hp_cap, new_hp))                                                    

                t_cfg["cur"]["hp"] = str(new_hp)
                write_cfg(prim_path, t_cfg)


                line = f"Primary {pretty_primary}: 1d8 [{', '.join(str(r) for r in rolls)}]"
                line += (f" → **{final}** ({note})" if note else f" → **{final}**")
                embed.add_field(name="🔥 Oil impact", value=line, inline=False)

                                                                                         
                if new_hp > 0 and bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    name_key = _find_ci_name(names, pretty_primary) or pretty_primary
                    _add_oil_burn(bcfg, chan_id, name_key, 1)                                                  
                    embed.add_field(name="Ongoing", value=f"{pretty_primary} will take **1d8 fire** at the start of their next turn.", inline=False)

                        
                is_mon = _is_monster_file(prim_path)
                if is_mon:
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    before = _life_bar(old_hp, mhp, width=10)
                    after  = _life_bar(new_hp, mhp, width=10)
                    dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                    embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
                else:
                    dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                    embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}**{dead_note}", inline=False)

                                                                                           
                if new_hp <= 0 and _is_monster_file(tgt_path):
                    try:
                        bcfg = _load_battles()
                        if bcfg.has_section(chan_id):
                            names, scores = _parse_combatants(bcfg, chan_id)
                            key = _find_ci_name(names, primary_target) or primary_target
                            if key in names:
                                names = [n for n in names if n != key]
                                if bcfg.has_option(chan_id, key):
                                    bcfg.remove_option(chan_id, key)
                                slot = _slot(key)
                                for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                    opt = f"{slot}{suf}"
                                    if bcfg.has_option(chan_id, opt):
                                        bcfg.remove_option(chan_id, opt)
                                _write_combatants(bcfg, chan_id, names, scores)
                                if bcfg.get(chan_id, "turn", fallback="") == key:
                                    ents = _sorted_entries(bcfg, chan_id)
                                    bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                                _save_battles(bcfg)
                        try: os.remove(os.path.abspath(tgt_path))
                        except Exception: pass
                    except Exception: pass

                                                   
            if splash_targets:
                lines = []
                for sname in splash_targets:
                    disp, spath = _resolve_char_ci(sname)
                    pretty = disp or sname
                    if not spath:
                        lines.append(f"{pretty}: *(not found)*")
                        continue
                    scfg = read_cfg(spath)
                    ok, roll, dc, pen = self._roll_save(scfg, vs="poi", penalty=0)
                    if ok:
                        lines.append(f"{pretty}: Save vs Death/Poison {roll} vs {dc} → **RESISTED**")
                    else:
                        s6, r6, f6 = roll_dice("1d6")
                        raw = s6 + f6
                        final, note = _apply_mitigation(raw, weapon_name="Oil", weapon_type="fire", t_cfg=scfg, chan_id=str(ctx.channel.id), target_name=pretty)
                        old = getint_compat(scfg, "cur", "hp", fallback=0)
                        max_hp_cap = getint_compat(scfg, "max", "hp", fallback=old)
                        new = old - final
                        new = max(0, min(max_hp_cap, new))
                        scfg["cur"]["hp"] = str(new)
                        write_cfg(spath, scfg)


                        seg = f"{pretty}: Save {roll} vs {dc} → **FAIL** → 1d6 [{', '.join(str(r) for r in r6)}]"
                        if note: seg += f" → **{final}** ({note})"
                        else:    seg += f" → **{final}**"
                                                                   
                        if new <= 0:
                            seg += " ☠️ **DEAD!**"
                        lines.append(seg)

                                                              
                        if new <= 0 and _is_monster_file(spath):
                            try:
                                bcfg = _load_battles()
                                if bcfg.has_section(chan_id):
                                    names, scores = _parse_combatants(bcfg, chan_id)
                                    key = _find_ci_name(names, pretty) or pretty
                                    if key in names:
                                        names = [n for n in names if n != key]
                                        if bcfg.has_option(chan_id, key):
                                            bcfg.remove_option(chan_id, key)
                                        slot = _slot(key)
                                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                            opt = f"{slot}{suf}"
                                            if bcfg.has_option(chan_id, opt):
                                                bcfg.remove_option(chan_id, opt)
                                        _write_combatants(bcfg, chan_id, names, scores)
                                        if bcfg.get(chan_id, "turn", fallback="") == key:
                                            ents = _sorted_entries(bcfg, chan_id)
                                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                                        _save_battles(bcfg)
                                try: os.remove(os.path.abspath(spath))
                                except Exception: pass
                            except Exception:
                                pass

                if lines:
                    embed.add_field(name="Splash", value="\n".join(lines), inline=False)


                                                            
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

            await ctx.send(embed=embed)
            return                     

        if is_holy:
            pretty_primary = display_target or (primary_target or "")
            if display_target:
                title = f"{char_name} throws Holy Water at {pretty_primary}!"
            else:
                title = f"{char_name} throws Holy Water!"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
            embed.add_field(name="Inventory", value=f"(Holy Water –1; remaining: {remaining if remaining is not None else '—'})", inline=True)
            embed.add_field(name="Attack roll", value=attack_line, inline=True)
            if target_ac is not None:
                embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)
            if sleep_auto_hit:
                embed.add_field(name="Sleep", value="Target is asleep — **automatic hit**.", inline=False)
                
                                                                                          

                                                        
            portrait_url = (
                get_compat(atk_cfg, "info", "portrait", fallback="")
                or get_compat(cfg, "info", "portrait", fallback="")
            ).strip()
            if portrait_url:
                try:
                    embed.set_thumbnail(url=portrait_url)                   
                except Exception:
                    pass

    
            if display_target:
                consumed, left = self._mi_consume_if_present(ctx, display_target)
                if consumed:
                    embed.add_field(
                        name="Mirror Image",
                        value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                        inline=False
                    )
                    await ctx.send(embed=embed)
                    return

            if not hit:
                embed.add_field(name="Holy Water", value="Misses — no effect.", inline=False)
                await ctx.send(embed=embed)
                return

                                          
            if prim_path:
                t_cfg = read_cfg(prim_path)
                if _is_undead_cfg(t_cfg, pretty_primary):
                    s, rolls, flat = roll_dice("1d8")                                        
                    raw = s + flat
                                                                                    
                    final, note = _apply_mitigation(raw, weapon_name="Holy Water", weapon_type="holy", t_cfg=t_cfg)

                    old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                    new_hp = max(0, old_hp - final)
                    t_cfg["cur"]["hp"] = str(new_hp)
                    write_cfg(prim_path, t_cfg)

                    line = f"Primary {pretty_primary}: 1d8 [{', '.join(str(r) for r in rolls)}]"
                    line += (f" → **{final}** ({note})" if note else f" → **{final}**")
                    embed.add_field(name="💧 Holy impact", value=line, inline=False)

                            
                    is_mon = _is_monster_file(prim_path)
                    if is_mon:
                        mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                        before = _life_bar(old_hp, mhp, width=10)
                        after  = _life_bar(new_hp, mhp, width=10)
                        dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                        embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
                    else:
                        dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                        embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}**{dead_note}", inline=False)

                                                                                          
                    if new_hp <= 0 and _is_monster_file(prim_path):
                        try:
                            bcfg = _load_battles()
                            if bcfg.has_section(chan_id):
                                names, scores = _parse_combatants(bcfg, chan_id)
                                key = _find_ci_name(names, pretty_primary) or pretty_primary
                                if key in names:
                                    names = [n for n in names if n != key]
                                    if bcfg.has_option(chan_id, key):
                                        bcfg.remove_option(chan_id, key)
                                    slot = _slot(key)
                                    for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                        opt = f"{slot}{suf}"
                                        if bcfg.has_option(chan_id, opt):
                                            bcfg.remove_option(chan_id, opt)
                                    _write_combatants(bcfg, chan_id, names, scores)
                                    if bcfg.get(chan_id, "turn", fallback="") == key:
                                        ents = _sorted_entries(bcfg, chan_id)
                                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                                    _save_battles(bcfg)
                            try: os.remove(os.path.abspath(prim_path))
                            except Exception: pass
                        except Exception:
                            pass
                else:
                    embed.add_field(name="Holy Water", value=f"{pretty_primary} is not undead — no effect.", inline=False)

                                                             
            if splash_targets:
                lines = []
                for sname in splash_targets:
                    disp, spath = _resolve_char_ci(sname)
                    pretty = disp or sname
                    if not spath:
                        lines.append(f"{pretty}: *(not found)*")
                        continue

                    scfg = read_cfg(spath)
                    if not _is_undead_cfg(scfg, pretty):
                        lines.append(f"{pretty}: not undead — no effect.")
                        continue

                    s6, r6, f6 = roll_dice("1d6")
                    raw = s6 + f6
                    final, note = _apply_mitigation(raw, weapon_name="Holy Water", weapon_type="holy", t_cfg=scfg)

                    old = getint_compat(scfg, "cur", "hp", fallback=0)
                    new = max(0, old - final)
                    scfg["cur"]["hp"] = str(new)
                    write_cfg(spath, scfg)

                    seg = f"{pretty}: 1d6 [{', '.join(str(r) for r in r6)}]"
                    seg += (f" → **{final}** ({note})" if note else f" → **{final}**")
                                                               
                    if new <= 0:
                        seg += " ☠️ **DEAD!**"
                    lines.append(seg)

                                                          
                    if new <= 0 and _is_monster_file(spath):
                        try:
                            bcfg = _load_battles()
                            if bcfg.has_section(chan_id):
                                names, scores = _parse_combatants(bcfg, chan_id)
                                key = _find_ci_name(names, pretty) or pretty
                                if key in names:
                                    names = [n for n in names if n != key]
                                    if bcfg.has_option(chan_id, key):
                                        bcfg.remove_option(chan_id, key)
                                    slot = _slot(key)
                                    for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                        opt = f"{slot}{suf}"
                                        if bcfg.has_option(chan_id, opt):
                                            bcfg.remove_option(chan_id, opt)
                                    _write_combatants(bcfg, chan_id, names, scores)
                                    if bcfg.get(chan_id, "turn", fallback="") == key:
                                        ents = _sorted_entries(bcfg, chan_id)
                                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                                    _save_battles(bcfg)
                            try: os.remove(os.path.abspath(spath))
                            except Exception: pass
                        except Exception:
                            pass

                if lines:
                    embed.add_field(name="Splash", value="\n".join(lines), inline=False)

                                                            
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

            await ctx.send(embed=embed)
            return                            

        pure_drain = False
        drain_n = 0
        m_pure = re.fullmatch(
            r"(?:drain|energydrain|energy\s*drain|leveldrain)(?::?\s*(\d+))?",
            str(item.get("dmg", dmg_spec)).strip().lower()
        )
        if m_pure:
            pure_drain = True
            drain_n = int(m_pure.group(1)) if m_pure.group(1) else 1
            dmg_spec = "0"                                                                  


                                                           
        pc_extra_eff = {}
        if not pure_drain:
            try:
                dmg_formula, pc_extra_eff = self._parse_monster_attack_spec(dmg_spec) or (dmg_spec, {})
                if not isinstance(pc_extra_eff, dict):
                    pc_extra_eff = {}
            except Exception:
                dmg_formula, pc_extra_eff = dmg_spec, {}
            dice_sum, dmg_rolls, flat_mod = roll_dice(dmg_formula)
            precrit = dice_sum + flat_mod
        else:
            dice_sum, dmg_rolls, flat_mod = 0, [], 0
            precrit = 0

                                                                      
        if is_attacker_undead and pc_extra_eff:
            has_mummy = bool(
                pc_extra_eff.get("mummyrot") or pc_extra_eff.get("mummy_rot") or
                (isinstance(pc_extra_eff.get("disease"), str) and "mummy" in pc_extra_eff["disease"].lower())
            )
            if has_mummy:
                pc_extra_eff["disease"] = True
                pc_extra_eff["disease_kind"] = "mummyrot"
                                                                  
                pc_extra_eff.setdefault(
                    "disease_chance",
                    int(pc_extra_eff.get("mummyrot_chance", pc_extra_eff.get("disease_chance", 100)) or 100)
                )


                                                         
        if used_stat == "str":
            precrit += (str_mod * (2 if barb_melee else 1))

        if spec_applied and spec_dmg:
            precrit += spec_dmg
        if extra_dmg_value and not want_called:
            precrit += extra_dmg_value

        if (want_rage and is_barbarian) and not want_called:
            precrit += 2

        precrit += wpn_plus
        precrit += p_dmg
        precrit += enh_wep_dmg                               
        precrit += weak_wep_dmg                              
        
                                              
        base_damage = max(0, precrit)

                                                                 
        mult = 1
        if is_crit:
            mult *= 2
        sneak_applied = bool(want_sneak and is_thief and (hit is True))
        snipe_applied = bool(want_snipe and is_scout and (hit is True))
        charge_applied = bool(want_charge and (hit is True))
        if sneak_applied:
            mult *= 2
        if snipe_applied:
            mult *= 2            
        if charge_applied:
            mult *= 2
        applied_damage = base_damage * mult
        fav_bonus = 3 if (want_fav and is_ranger and not want_called) else 0
        raw_for_mitigation = applied_damage + fav_bonus

                                     
        mod_parts_base = []
        if flat_mod:
            mod_parts_base.append(f"{'+' if flat_mod > 0 else '-'} {abs(flat_mod)}")
        if used_stat == "str" and str_mod:
            val = str_mod * (2 if barb_melee else 1)
            lbl = " (2×STR)" if barb_melee else ""
            mod_parts_base.append(f"{'+' if val > 0 else '-'} {abs(val)}{lbl}")
        if spec_applied and spec_dmg:
            mod_parts_base.append(f"+ {spec_dmg}")
        if want_rage and is_barbarian and not want_called:
            mod_parts_base.append("+ 2 (Rage)")
        if wpn_plus:
            mod_parts_base.append(f"+ {wpn_plus}")
        if extra_dmg_value and not want_called:
            mod_parts_base.append(f"{'+ ' if extra_dmg_value>0 else '- '}{abs(extra_dmg_value)}")
                                          
        if p_dmg:
            mod_parts_base.append(f"+ {p_dmg}")
        if enh_wep_dmg:
            mod_parts_base.append(f"+ {enh_wep_dmg}")
        if weak_wep_dmg:
            mod_parts_base.append(f"- {abs(weak_wep_dmg)}")
                                                                                   
        if pain_dmg_pen:
            mod_parts_base.append(f"- {abs(pain_dmg_pen)} (Pain)")
            raw_for_mitigation = max(0, raw_for_mitigation + pain_dmg_pen)


        if display_target:
            title = f"{char_name} attacks {display_target} with {canon_name}!"
        else:
            title = f"{char_name} attacks with {canon_name}!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
                                                          
        if needs_ammo and not _is_monster_file(atk_path):
            rem = ammo_remaining_after_first if ammo_remaining_after_first is not None else "—"
            embed.add_field(name="Inventory", value=f"({needs_ammo} –1; remaining: {rem})", inline=True)

                                                                                      

                                                    
        portrait_url = (
            get_compat(atk_cfg, "info", "portrait", fallback="")
            or get_compat(cfg, "info", "portrait", fallback="")
        ).strip()
        if portrait_url:
            try:
                embed.set_thumbnail(url=portrait_url)                   
            except Exception:
                pass


                                                  
        target_gas_left = 0
        try:
            if bcfg and bcfg.has_section(chan_id) and (prim_path or display_target):
                names, _ = _parse_combatants(bcfg, chan_id)
                cand = (prim_disp or primary_target or display_target or "").strip()
                name_key = _find_ci_name(names, cand) or cand
                s_tgt = _slot(name_key) if '_slot' in globals() else name_key.replace(" ", "_")
                target_gas_left = bcfg.getint(chan_id, f"{s_tgt}.gas", fallback=0)
        except Exception:
            pass

                       
        notes = []
        if spec_applied:
            notes.append(f"+{spec_hit} to hit / +{spec_dmg} dmg (Attacks/turn: {spec_attacks})")
        if spec_applied and class_lc in {"fighter", "fightermage"} and self._hr_enabled(ctx.channel, "heroic_called_shot", default=True):
            notes.append("Specialization: beat AC by ≥4 → auto called shot (plus damage)")

        if want_sneak and not is_thief:
            notes.append("sneak ignored (only Thieves)")
        elif sneak_hit_bonus:
            notes.append("Sneak: +4 to hit; ×2 dmg on hit")
        if want_snipe and not is_scout:
            notes.append("snipe ignored (only Scouts)")
        if want_snipe and is_scout:
            notes.append("Snipe: ×2 dmg on hit")
        if want_charge:
            notes.append("Charge: +2 to hit; ×2 dmg on hit; you suffer –2 AC until your next turn")
        if want_rage:
            if is_barbarian:
                notes.append("Rage: +2 to hit; +2 dmg; you suffer –2 AC until your next turn (Barbarian)")
            else:
                notes.append("Rage ignored (Barbarian only)")
        if target_gas_left > 0:
            notes.append("Target is **Gaseous** — **AC 22 vs magical**; **immune to nonmagical weapons**")
        if conc_dropped_due_to_attack:
            notes.append("Attacking **broke Concentration** — your conjured elemental(s) are now **hostile**.")

        if want_subdual and not is_brawl:
            if not _weapon_allows_subdual(canon_name, item):
                notes.append("Subduing **not possible** with this weapon (piercing-only / all edges).")
            else:
                notes.append("Subduing: −4 to hit; **half damage**; knocking to 0 HP → **KO**, not dead.")

        if is_brawl:
            if brawl_kind == "kick":
                notes.append("Brawling (kick): 1d4 subduing; −2 to hit.")
            else:
                notes.append("Brawling (punch): 1d3 subduing.")
            notes.append("Punch/Kick vs **metal armor**: damage reflects to **you**.")

                                      
        if is_magical_attack:
            notes.append("Weapon counts as **magical** for this attack")
        if slayer_note:
            notes.append(slayer_note)
        if is_flaming:
            notes.append("Flaming: all damage counts as fire; +1 dmg vs fire-weak foes")
        if enh_wep_hit or enh_wep_dmg:
            notes.append(f"Enhanced Weapon: **+{enh_wep_hit or enh_wep_dmg}** to hit & damage")
        if weak_wep_hit or weak_wep_dmg:
            notes.append(f"Weakened Weapon: **−{abs(weak_wep_hit or weak_wep_dmg)}** to hit & damage")
        if starlight_on:
            notes.append("StarlightBlade: **+1d6+1 holy vs undead** on weapon hits; you may `!turn` as a **5th-level cleric**.")
        if bb_note:
            notes.append("; ".join(bb_note))


                                                                                              
        pot_lines = _potion_bonus_lines(bcfg, chan_id, slot_att)
        if pot_lines:
            notes.extend(pot_lines)
        try:
            bcfg = _load_battles()
            if bcfg.has_section(chan_id):
                slot_me = _slot(char_name) if '_slot' in globals() else char_name.replace(" ","_")
                if bcfg.getint(chan_id, f"{slot_me}.db", fallback=0) > 0:
                    notes.append("Drainblade **ready** (melee slashing vs living: +1 dmg; heal 1)")
        except Exception:
            pass


        if want_called:
            notes.append("Called shot: –4 to hit; no damage; target saves vs Paralyze (–spec dmg)")
                                                         
                                                   
                                                                       
        if rng_short:
            notes.append("Short range: +1 to hit")
        if rng_long:
            notes.append("Long range: –2 to hit")
        if halfling_missile_bonus:
            notes.append("Halfling (missile): +1 to hit")
        if is_ranger_bow:
            notes.append("Ranger bow expert: +2 to hit (short/longbow)")
            if level >= 9 and not (want_wrestle or want_called or is_oil or is_holy):
                notes.append("Bow expert (L9+): Attacks/turn: 2")
        if is_scout_bow:
            notes.append("Scout accuracy: +1 to hit (ranged weapons)")      
        if want_assassinate and not is_assassin:
            notes.append("Death Strike ignored (Assassin only)")
        elif want_assassinate:
            notes.append("Death Strike: +4 to hit; on hit target saves vs Death Ray or **dies**.")
        elif deathstrike_blocked_reason:
            notes.append(f"Death Strike: {deathstrike_blocked_reason} (treated as normal attack).")

      
        if want_fav and is_ranger:
            notes.append("Favored Enemy: +3 damage")
        elif want_fav and not is_ranger:
            notes.append("Favored Enemy ignored (Ranger only)")
            
        if blind_ac_penalty != 0:
            notes.append("Defender is **BLINDED** (−4 AC)")
        if blind_hit_penalty != 0:
            notes.append("Attacker is **BLINDED** (−4 to hit)")

        if sick_hit_penalty:
            notes.append(f"Attacker is **SICKENED** (−{sick_pen_shown} to hit)")

        if inv_atk_bonus:
            if inv_type_atk == "imp":
                notes.append("Attacker is **INVISIBLE** (+4 to hit); **does not** break on attack (Improved Invisibility).")
            elif inv_type_atk == "group":
                if inv_group_note:
                    notes.append(f"Attacker is **INVISIBLE** (+4 to hit). {inv_group_note}")
                else:
                    notes.append("Attacker is **INVISIBLE** (+4 to hit).")
            elif inv_type_atk == "stalker":
                    notes.append("Attacker is **INVISIBLE** (Invisible Stalker): +4 to hit; **does not** break on attack.")        
            else:
                notes.append("Attacker is **INVISIBLE** (+4 to hit). Invisibility ends after this attack.")

        if inv_def_hit_penalty:
            notes.append("Defender is **INVISIBLE** — attackers **−4 to hit**.")
        elif (bcfg and bcfg.has_section(chan_id) and (prim_path or display_target)):
                                                                        
            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                cand = (prim_disp or primary_target or display_target or "").strip()
                key  = _find_ci_name(names, cand) or cand
                s_tgt = _slot(key) if '_slot' in globals() else key.replace(" ","_")
                if bcfg.getint(chan_id, f"{s_tgt}.inv", fallback=0) > 0 or bcfg.getint(chan_id, f"{s_tgt}.inv_perm", fallback=0) > 0:
                    if inv_def_seen:
                        notes.append("Defender is **INVISIBLE**, but you have **See Invisible/True Seeing** — no penalty.")
            except Exception:
                pass

        if pain_att_pen or pain_dmg_pen:
            embed.add_field(name="Condition",
                            value="Attacker is in **PAIN** (−4 to hit/damage/saves).",
                            inline=False)


        if want_flank:
            if flank_suppressed:
                notes.append("Flanking/Advantage present but **does not stack** with Sneak’s +4 to-hit (Sneak applied).")
            else:
                notes.append("Flanking/Advantage: +2 to hit")

        if want_twf:
            shown = abs(twf_penalty)
            notes.append(f"Two-Weapon Fighting: −3 to hit (mitigated by Dex bonus {dex_mod:+}); final penalty: −{shown}" if shown else
                         "Two-Weapon Fighting: Dex bonus negates the −3 → **no penalty**")

        if manual_hit_bonus:
            sign = "+" if manual_hit_bonus > 0 else "–"
            notes.append(f"Manual bonus: {sign}{abs(manual_hit_bonus)} to hit")
        if extra_dmg_spec:
            if want_called:
                notes.append(f"Extra damage ({extra_dmg_spec}) ignored (called shot)")
            else:
                if extra_dmg_rolls:
                    rolls_txt = "[" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
                    notes.append(f"Extra damage: {extra_dmg_spec} {rolls_txt} → +{extra_dmg_value}")
                else:
                    sign = "+" if extra_dmg_value >= 0 else "–"
                    notes.append(f"Extra damage: {extra_dmg_spec} → {sign}{abs(extra_dmg_value)}")

        if notes:
            embed.add_field(name="Bonuses", value="\n".join(notes), inline=False)

        embed.add_field(name="Attack roll", value=attack_line, inline=True)

        if target_ac is not None:
            ac_note = " (charging –2)" if ac_penalty_applied else ""
                                                                                                     
            embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                                                                        
        pnm_on = self._pnm_active_for(bcfg, chan_id, display_target or primary_target)
        if pnm_on and self._pc_attack_is_normal_missile(canon_name, item, is_oil=False, is_holy=False,
                                                weapon_type=weapon_type, short=short, med=med, longr=longr,
                                                rng_long=rng_long, is_magical_attack=is_magical_attack):
            embed.add_field(name="Protection from Normal Missiles",
                            value="Normal missile is **negated** — no effect.",
                            inline=False)
            await ctx.send(embed=embed)
            return

        if display_target:
            consumed, left = self._mi_consume_if_present(ctx, display_target)
            if consumed:
                embed.add_field(
                    name="Mirror Image",
                    value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                    inline=False
                )
                await ctx.send(embed=embed)
                return

                                                  
        if shield_bonus_applied:
            embed.add_field(
                name="Note",
                value=f"Target is under **Shield** (+{shield_bonus_applied} AC).",
                inline=False
            )
        if ac_defense_applied:
            embed.add_field(
                name="Note",
                value=f"Target has a defensive stance (+{ac_defense_applied} AC).",
                inline=False
            )
                                   
        if weaken_armor_applied:
            rounds_txt = f", {weaken_armor_left} rounds left" if weaken_armor_left else ""
            embed.add_field(
                name="Note",
                value=f"Target’s armor is **WEAKENED** (−1 AC{rounds_txt}).",
                inline=False
            )            
        if growth_animals_applied:
            rounds_txt = f", {growth_animals_left} rounds left" if growth_animals_left else ""
            embed.add_field(
                name="Note",
                value=f"Target is under **Growth of Animals** (+2 AC{rounds_txt}).",
                inline=False
            )
            
                                                                     
        try:
            bcfg_inw = _load_battles()
            if bcfg_inw and bcfg_inw.has_section(chan_id) and (prim_path or display_target):
                names_inw, _ = _parse_combatants(bcfg_inw, chan_id)
                cand_inw = (prim_disp or primary_target or display_target or "").strip()
                key_inw  = _find_ci_name(names_inw, cand_inw) or cand_inw
                s_tgt_inw = _slot(key_inw) if '_slot' in globals() else key_inw.replace(" ", "_")
                if bcfg_inw.getint(chan_id, f"{s_tgt_inw}.inw", fallback=0) > 0:
                    embed.add_field(
                        name="Note",
                        value="Target is under **Invulnerability** (immune to **nonmagical weapons**).",
                        inline=False
                    )
        except Exception:
            pass

        if pure_drain:
            if not hit:
                embed.add_field(name="Energy Drain", value="Missed — no effect.", inline=False)
            elif not tgt_path:
                embed.add_field(name="Energy Drain", value="No target file — cannot apply.", inline=False)
            else:
                t_cfg = read_cfg(tgt_path)

                                                                                         
                try:
                    bcfg = _load_battles(); ch = str(ctx.channel.id)
                    if bcfg and bcfg.has_section(ch) and display_target:
                        names_ss, _ = _parse_combatants(bcfg, ch)
                        key_ss = _find_ci_name(names_ss, display_target) or display_target
                        try:    slot_tgt = _slot(key_ss)
                        except: slot_tgt = key_ss.replace(" ", "_")
                        _, absorbed, remain, discharged = self._ss_soak(bcfg, ch, slot_tgt, 1)
                        if absorbed > 0:
                            embed.add_field(
                                name="Stoneskin",
                                value=("Stoneskin blocks the draining touch. " +
                                       ("**DISCHARGED!**" if discharged else f"Remaining buffer: **{remain}**.")),
                                inline=False
                            )
                            await ctx.send(embed=embed)
                            return
                except Exception:
                    pass

                                                                      
                try:
                    is_living = self._is_living_cfg(t_cfg)
                except Exception:
                    is_living = True

                if not is_living:
                    embed.add_field(name="Energy Drain", value="No effect (nonliving/undead).", inline=False)
                else:
                    await self._auto_apply_negative_levels(
                        ctx,
                        display_target or primary_target,
                        t_cfg, tgt_path,
                        n_levels=drain_n,
                        source=f"{canon_name} (drain touch)",
                        embed=embed,
                    )
            await ctx.send(embed=embed)
            return


        if want_assassinate and is_assassin:
            if not hit:
                embed.add_field(name="Death Strike", value="Missed — no effect.", inline=False)
                await ctx.send(embed=embed)
                return
            if not tgt_path:
                embed.add_field(name="Death Strike", value="No target file — cannot resolve save.", inline=False)
                await ctx.send(embed=embed)
                return

            t_cfg = read_cfg(tgt_path)

            def _target_power(cfg_target, path_target):
                if _is_monster_file(path_target):
                    raw = str(get_compat(cfg_target, "base", "hd", fallback="") or "").strip().lower()
                    if not raw:
                        return float(getint_compat(cfg_target, "cur", "level", fallback=1))
                    m_frac = re.fullmatch(r"(\d+)\s*/\s*(\d+)", raw)
                    if m_frac:
                        try:
                            return float(int(m_frac.group(1)) / int(m_frac.group(2)))
                        except Exception:
                            pass
                    m_int = re.match(r"(\d+)", raw)
                    if m_int:
                        try:
                            return float(int(m_int.group(1)))
                        except Exception:
                            pass
                    return float(getint_compat(cfg_target, "cur", "level", fallback=1))
                return float(getint_compat(cfg_target, "cur", "level", fallback=1))

            ass_lvl   = float(atk_level)
            tgt_power = _target_power(t_cfg, tgt_path)

            auto_kill = (ass_lvl - tgt_power) >= 2.0
            if auto_kill:
                label = "HD" if _is_monster_file(tgt_path) else "level"
                pretty = display_target or primary_target or "target"

                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)

                if _is_monster_file(tgt_path):
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    bar_before = _life_bar(old_hp, mhp, width=10)
                    bar_after  = _life_bar(0,   mhp, width=10)
                    embed.add_field(
                        name="Death Strike",
                        value=(f"Assassin {int(ass_lvl)} vs {label} {tgt_power:g} → **SAVE DENIED**\n"
                               f"🥷 **ASSASSINATED**"),
                        inline=False
                    )
                    embed.add_field(name="Target HP", value=f"{bar_before} → **{bar_after}** ☠️ **DEAD!**", inline=False)
                else:
                    embed.add_field(
                        name="Death Strike",
                        value=(f"Assassin {int(ass_lvl)} vs {label} {tgt_power:g} → **SAVE DENIED**\n"
                               f"🥷 **ASSASSINATED**"),
                        inline=False
                    )
                    embed.add_field(
                        name="Target HP",
                        value=f"{old_hp} → **0** ☠️ **DEAD!**",
                        inline=False
                    )

                try:
                    bcfg = _load_battles()
                    if bcfg.has_section(str(ctx.channel.id)):
                        names, scores = _parse_combatants(bcfg, str(ctx.channel.id))
                        key = _find_ci_name(names, display_target) or display_target
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(str(ctx.channel.id), key):
                                bcfg.remove_option(str(ctx.channel.id), key)
                            slot = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(str(ctx.channel.id), opt):
                                    bcfg.remove_option(str(ctx.channel.id), opt)
                            _write_combatants(bcfg, str(ctx.channel.id), names, scores)
                            if bcfg.get(str(ctx.channel.id), "turn", fallback="") == key:
                                ents = _sorted_entries(bcfg, str(ctx.channel.id))
                                bcfg.set(str(ctx.channel.id), "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)

                    if _is_monster_file(tgt_path):
                        try:
                            os.remove(os.path.abspath(tgt_path))
                        except Exception:
                            pass

                    try:
                        bcfg2 = _load_battles()
                        if bcfg2.has_section(str(ctx.channel.id)):
                            msg_id = bcfg2.getint(str(ctx.channel.id), "message_id", fallback=0)
                            if msg_id:
                                block = _format_tracker_block(bcfg2, str(ctx.channel.id))
                                msg = await ctx.channel.fetch_message(msg_id)
                                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                    except Exception:
                        pass
                except Exception:
                    pass

                await ctx.send(embed=embed)
                return

            sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="poi", penalty=0)
            line = f"Save vs Death Ray: {sv_roll} vs {sv_target} → "
            if not sv_ok:
                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)

                if _is_monster_file(tgt_path):
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    bar_before = _life_bar(old_hp, mhp, width=10)
                    bar_after  = _life_bar(0,   mhp, width=10)
                    embed.add_field(name="Death Strike", value=line + "**FAIL** — 🥷 **ASSASSINATED**", inline=False)
                    embed.add_field(name="Target HP", value=f"{bar_before} → **{bar_after}** ☠️ **DEAD!**", inline=False)
                else:
                    embed.add_field(name="Death Strike", value=line + "**FAIL** — 🥷 **ASSASSINATED**", inline=False)
                    embed.add_field(name="Target HP", value=f"{old_hp} → **0** ☠️ **DEAD!**", inline=False)

                try:
                    bcfg = _load_battles()
                    if bcfg.has_section(str(ctx.channel.id)):
                        names, scores = _parse_combatants(bcfg, str(ctx.channel.id))
                        key = _find_ci_name(names, display_target) or display_target
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(str(ctx.channel.id), key):
                                bcfg.remove_option(str(ctx.channel.id), key)
                            slot = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(str(ctx.channel.id), opt):
                                    bcfg.remove_option(str(ctx.channel.id), opt)
                            _write_combatants(bcfg, str(ctx.channel.id), names, scores)
                            if bcfg.get(str(ctx.channel.id), "turn", fallback="") == key:
                                ents = _sorted_entries(bcfg, str(ctx.channel.id))
                                bcfg.set(str(ctx.channel.id), "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)

                    if _is_monster_file(tgt_path):
                        try:
                            os.remove(os.path.abspath(tgt_path))
                        except Exception:
                            pass
                except Exception:
                    pass

                try:
                    bcfg2 = _load_battles()
                    if bcfg2.has_section(str(ctx.channel.id)):
                        msg_id = bcfg2.getint(str(ctx.channel.id), "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg2, str(ctx.channel.id))
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

                await ctx.send(embed=embed)
                return
            else:
                embed.add_field(name="Death Strike", value=line + "**RESISTED** — attack deals normal damage.", inline=False)



        if want_snake and self._is_snake_staff_name(canon_name or weapon):
            pretty_primary = display_target or (primary_target or "")
            title = f"{char_name} commands the Snake Staff!"
            if display_target:
                title += f" (vs {pretty_primary})"

            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
            embed.add_field(name="Attack roll", value=attack_line, inline=True)
            if target_ac is not None:
                embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                               
            if class_lc not in {"cleric", "druid"}:
                embed.add_field(name="Restriction", value="Only **Clerics** or **Druids** can command the Snake Staff.", inline=False)
                await ctx.send(embed=embed); return

                                                                                             
            if not raw_primary_target:
                bcfg = _load_battles(); chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    att_key = _find_ci_name(names, char_name) or char_name
                    try: s_att = _slot(att_key)
                    except Exception: s_att = att_key.replace(" ", "_")
                    cur = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                    if cur:
                        try: s_def = _slot(cur)
                        except Exception: s_def = cur.replace(" ", "_")
                        if bcfg.has_option(chan_id, f"{s_def}.heldby"):
                            bcfg.remove_option(chan_id, f"{s_def}.heldby")
                        if bcfg.has_option(chan_id, f"{s_def}.snakehold"):
                            bcfg.remove_option(chan_id, f"{s_def}.snakehold")
                        bcfg.remove_option(chan_id, f"{s_att}.holds")
                        _save_battles(bcfg)
                        embed.add_field(name="Recall", value=f"🐍 The snake uncoils from **{cur}** and snaps back into a staff.", inline=False)
                                                            
                        try:
                            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                            if msg_id:
                                block = _format_tracker_block(bcfg, chan_id)
                                msg = await ctx.channel.fetch_message(msg_id)
                                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                        except Exception:
                            pass
                        await ctx.send(embed=embed); return
                    else:
                        embed.add_field(name="Recall", value="Nothing is currently held.", inline=False)
                        await ctx.send(embed=embed); return

                                                         
            if display_target:
                consumed, left = self._mi_consume_if_present(ctx, display_target)
                if consumed:
                    embed.add_field(
                        name="Mirror Image",
                        value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                        inline=False
                    )
                    await ctx.send(embed=embed)
                    return

            if not hit or not tgt_path:
                embed.add_field(
                    name="Snake",
                    value=("Miss — no effect." if not hit else "No target file — cannot apply a hold."),
                    inline=False
                )
                await ctx.send(embed=embed)
                return

                                          
            t_cfg = read_cfg(tgt_path)
            sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="spl", penalty=0)
            if sv_target is None:
                                                                         
                sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="poi", penalty=0)

            if sv_ok:
                embed.add_field(
                    name="Save vs Spells",
                    value=f"{sv_roll} vs {sv_target} → **RESISTED** — the snake recoils to staff form.",
                    inline=False
                )
                await ctx.send(embed=embed)
                return

                                                                  
            s, rolls, flat = roll_dice("1d4")
            turns = s + flat
            rounds = turns * 60                                   

            bcfg = _load_battles(); chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                att_key = _find_ci_name(names, char_name) or char_name
                def_key = _find_ci_name(names, pretty_primary) or pretty_primary

                try: s_att = _slot(att_key)
                except Exception: s_att = att_key.replace(" ", "_")
                try: s_def = _slot(def_key)
                except Exception: s_def = def_key.replace(" ", "_")

                                                                                          
                prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                if prev:
                    try: s_prev = _slot(prev)
                    except Exception: s_prev = prev.replace(" ", "_")
                    if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                        bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                    bcfg.remove_option(chan_id, f"{s_att}.holds")

                                        
                bcfg.set(chan_id, f"{s_att}.holds", def_key)
                bcfg.set(chan_id, f"{s_def}.heldby", att_key)
                bcfg.set(chan_id, f"{s_def}.snakehold", str(rounds))
                _save_battles(bcfg)

                embed.add_field(
                    name="Constriction!",
                    value=(f"🪄 Save vs **Spells**: {sv_roll} vs {sv_target} → **FAIL**\n"
                           f"🐍 **HOLD ESTABLISHED!** {pretty_primary} is **HELD** by **{char_name}** for "
                           f"**{turns} turn{'s' if turns != 1 else ''}** ({rounds} rounds) [{', '.join(map(str, rolls))}].\n"
                           f"Use `!escape` as usual to try to break free; the hold also ends when the duration expires "
                           f"or the wielder recalls the snake with `!a snakestaff -s`."),
                    inline=False
                )

                                        
                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

            await ctx.send(embed=embed)
            return

        if want_wrestle:
            pretty_primary = display_target or (primary_target or "")
            title = f"{char_name} attempts a Wrestle!"
            if display_target:
                title += f" (vs {pretty_primary})"

            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
            embed.add_field(name="Attack roll", value=attack_line, inline=True)
            if target_ac is not None:
                embed.add_field(name="Result", value=("✅ **GRAB!**" if hit else "❌ **MISS**"), inline=True)
            if display_target:
                consumed, left = self._mi_consume_if_present(ctx, display_target)
                if consumed:
                    embed.add_field(
                        name="Mirror Image",
                        value=f"You grab a figment — *poof!* Images remaining: **{left}**.",
                        inline=False
                    )
                    await ctx.send(embed=embed)
                    return

            if not hit or not prim_path:
                embed.add_field(name="Wrestling", value=("Miss — no effect."
                                  if not hit else "No target file — cannot apply a hold."), inline=False)
                await ctx.send(embed=embed)
                return

                                                 
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)

                                                   
                att_key = _find_ci_name(names, char_name) or char_name
                def_key = _find_ci_name(names, pretty_primary) or pretty_primary

                       
                try:
                    s_att = _slot(att_key)
                except Exception:
                    s_att = att_key.replace(" ","_")
                try:
                    s_def = _slot(def_key)
                except Exception:
                    s_def = def_key.replace(" ","_")

                                                                                    
                prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                if prev:
                    try:
                        s_prev = _slot(prev)
                    except Exception:
                        s_prev = prev.replace(" ","_")
                    if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                        bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                    bcfg.remove_option(chan_id, f"{s_att}.holds")

                                     
                bcfg.set(chan_id, f"{s_att}.holds", def_key)
                bcfg.set(chan_id, f"{s_def}.heldby", att_key)
                _save_battles(bcfg)

                                            
                embed.add_field(
                    name="Wrestling",
                    value=f"🤼 **HOLD ESTABLISHED!** {pretty_primary} is now **HELD** by **{char_name}**.\n"
                          f"Held creatures can’t attack or cast spells (GM adjudicates).",
                    inline=False
                )

                                                                               
                if ac_penalty_applied:
                    embed.add_field(name="Note", value="Target AC shown includes a temporary charge penalty.", inline=False)

                                                                                 
                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
                except Exception:
                    pass

            await ctx.send(embed=embed)
            return

        flame_plus_applied = False
        raw_for_mitigation2 = raw_for_mitigation

        if is_flaming and (hit is True) and tgt_path:
            t_cfg = read_cfg(tgt_path)
                                                                                           
            _probe, probe_note = _apply_mitigation(
                1, weapon_name="probe", weapon_type="fire", t_cfg=t_cfg, is_magical=True, chan_id=str(ctx.channel.id), target_name=primary_target)
            
            if (probe_note or "").lower().find("weak to fire") != -1:
                raw_for_mitigation2 += 1
                flame_plus_applied = True
  
        if want_called:
                                                                            
                                                          
            if hit is True:
                embed.add_field(name="Damage", value="(no damage — called shot)", inline=False)

            if display_target and (hit is True) and tgt_path:
                t_cfg = read_cfg(tgt_path)
                spec_pen = spec_dmg if spec_applied and spec_dmg > 0 else 0
                sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="para", penalty=spec_pen)

                                                                   
                effect_success = (not sv_ok)
                result_word = "CALLED SHOT GOES OFF" if effect_success else "RESISTED"
                pen_txt = f" - {sv_pen}" if sv_pen else ""
                save_line = f"Save vs Paralyze: {sv_roll}{pen_txt} vs {sv_target} → **{result_word}**"
                embed.add_field(name="Called shot", value=save_line, inline=False)
            elif hit is False:
                embed.add_field(name="Called shot", value="Missed — no effect.", inline=False)
            else:
                                                  
                embed.add_field(name="Called shot", value="No target file — cannot resolve save.", inline=False)

                                                                
        else:
                                                            
            mod_parts = list(mod_parts_base)
            if flame_plus_applied:
                mod_parts.append("+ 1")

            mod_text = (" " + " ".join(mod_parts)) if mod_parts else ""
            display_base_total = applied_damage + (1 if flame_plus_applied else 0)

            rolls_str = "[" + ", ".join(str(r) for r in dmg_rolls) + "]"
            head = None
            if mult == 8: head = "🔥 **CRIT + SNEAK + CHARGE!**"
            elif mult == 4 and is_crit: head = "🔥 **CRITICAL + (SNEAK/CHARGE)!**"
            elif is_crit: head = "🔥 **CRITICAL HIT!**"
            elif sneak_applied and charge_applied: head = "🗡️ **SNEAK + CHARGE!**"
            elif sneak_applied: head = "🗡️ **SNEAK ATTACK!**"
            elif snipe_applied: head = "🏹 **SNIPER SHOT!**"
            elif charge_applied: head = "🏃 **CHARGE!**"

            if head:
                base_line = f"{head} {dmg_spec} {rolls_str}{mod_text} × {mult} = ``{display_base_total}``"
            else:
                base_line = f"{dmg_spec} {rolls_str}{mod_text} = ``{display_base_total}``"


            final_damage = raw_for_mitigation
            mitig_note = ""
            if display_target and (hit is True) and tgt_path:
                t_cfg = read_cfg(tgt_path)

                                                                           
                                         
                final_damage = raw_for_mitigation2
                mitig_note = ""
                if display_target and (hit is True) and tgt_path:
                    t_cfg = read_cfg(tgt_path)


                    final_damage, mitig_note = _apply_mitigation(
                        raw_for_mitigation2,
                        weapon_name=canon_name,
                        weapon_type=weapon_type,
                        t_cfg=t_cfg,
                        is_magical=(is_magical_attack or is_flaming),
                        chan_id=str(ctx.channel.id),
                        target_name=(display_target or primary_target or target_name),
                    )
                    
            if is_brawl and hit is True and target_has_metal_armor:
                                                                              
                a_old = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                a_max = getint_compat(atk_cfg, "max", "hp", fallback=a_old)
                a_new = max(0, min(a_max, a_old - max(0, final_damage)))
                atk_cfg["cur"]["hp"] = str(a_new); write_cfg(atk_path, atk_cfg)

                                                       
                embed.add_field(
                    name="Brawling vs Metal",
                    value=f"Target’s armor is metal — the blow hurts **you** instead → `{final_damage}`. "
                          f"Your HP: {a_old} → **{a_new}**.",
                    inline=False
                )
                                                             
                if repeat_times > 1 and a_new <= 0:
                    embed.add_field(name="Repeat", value="⛔ You knocked yourself out — stopping repeats.", inline=False)
                    repeat_times = 1

                await ctx.send(embed=embed)
                return


            strike_added_total = 0
            strike_lines = []
            if (hit is True) and tgt_path and (not want_called) and (not want_wrestle) and (not is_oil) and (not is_holy):
                try:
                    t_cfg_for_strike = read_cfg(tgt_path)
                                                            
                    bcfgS = _load_battles(); chS = str(ctx.channel.id)
                    namesS, _ = _parse_combatants(bcfgS, chS)
                    att_keyS = _find_ci_name(namesS, char_name) or char_name
                    try:
                        slot_meS = _slot(att_keyS)
                    except Exception:
                        slot_meS = att_keyS.replace(" ", "_")

                                                                                                          
                    is_melee_now = _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle)

                                                                                        
                    nd6 = bcfgS.getint(chS, f"{slot_meS}.strike_nd6", fallback=0)
                    if nd6 > 0 and is_melee_now:
                        s, rolls, flat = roll_dice(f"{nd6}d6")
                        raw = s + flat
                        s_final, s_note = _apply_mitigation(
                            raw, weapon_name="Striking", weapon_type="magic",
                            t_cfg=t_cfg_for_strike, is_magical=True,
                            chan_id=str(ctx.channel.id),
                            target_name=(display_target or primary_target or target_name),
                        )

                        strike_added_total += s_final
                        msg = f"Striking: {nd6}d6 [{', '.join(map(str, rolls))}] → `{s_final}`"
                        if s_note: msg += f" ({s_note})"
                        strike_lines.append(msg)
                                                
                        for suf in ("strike_nd6", "strike_expire_round"):
                            opt = f"{slot_meS}.{suf}"
                            if bcfgS.has_option(chS, opt):
                                bcfgS.remove_option(chS, opt)
                        _save_battles(bcfgS)

                                                                                                    
                    until = bcfgS.getint(chS, f"{slot_meS}.strike_spell_until", fallback=0)
                    now_r = bcfgS.getint(chS, "round", fallback=0)
                    if until and now_r <= until:
                        spell_wpn = (bcfgS.get(chS, f"{slot_meS}.strike_weapon", fallback="") or "").strip()
                        if spell_wpn and normalize_name(spell_wpn) == normalize_name(canon_name):
                            s, rolls, flat = roll_dice("1d6")
                            raw = s + flat
                            s_final, s_note = _apply_mitigation(
                                raw, weapon_name="Striking", weapon_type="magic",
                                t_cfg=t_cfg_for_strike, is_magical=True,
                                chan_id=str(ctx.channel.id),
                                target_name=(display_target or primary_target or target_name),
                            )

                            strike_added_total += s_final
                            msg = f"Striking (spell): 1d6 [{', '.join(map(str, rolls))}] → `{s_final}`"
                            if s_note: msg += f" ({s_note})"
                            strike_lines.append(msg)
                                                                     
                        if now_r > until:
                            for suf in ("strike_spell_until", "strike_weapon"):
                                opt = f"{slot_meS}.{suf}"
                                if bcfgS.has_option(chS, opt):
                                    bcfgS.remove_option(chS, opt)
                            _save_battles(bcfgS)
                except Exception:
                    pass


            starlight_added_total = 0
            starlight_lines = []
            if (hit is True) and tgt_path and starlight_on:
                try:
                    t_cfg_st = read_cfg(tgt_path)
                    if _is_undead_cfg(t_cfg_st, display_target or primary_target):
                        s, rolls, flat = roll_dice("1d6+1")
                        raw = s + flat
                        st_final, st_note = _apply_mitigation(
                            raw, weapon_name="StarlightBlade", weapon_type="holy",
                            t_cfg=t_cfg_st, is_magical=True,
                            chan_id=str(ctx.channel.id),
                            target_name=(display_target or primary_target or target_name),
                        )

                        starlight_added_total += st_final
                        msg = f"StarlightBlade: 1d6+1 [{', '.join(map(str, rolls))}] → `{st_final}`"
                        if st_note: msg += f" ({st_note})"
                        starlight_lines.append(msg)
                except Exception:
                    pass


            try:
                if (hit is True) and (display_target or primary_target) and (tgt_path or prim_path):
                    names_i, _ = _parse_combatants(bcfg, chan_id)
                    cand_i = (prim_disp or primary_target or display_target or "").strip()
                    key_i  = _find_ci_name(names_i, cand_i) or cand_i
                    s_i    = _slot(key_i) if '_slot' in globals() else key_i.replace(" ", "_")

                    gas_on = bcfg.getint(chan_id, f"{s_i}.gas", fallback=0) > 0
                    inw_on = bcfg.getint(chan_id, f"{s_i}.inw", fallback=0) > 0

                                                                                    
                    if (gas_on or inw_on) and (not is_magical_attack) and (not is_oil) and (not is_holy):
                        final_damage = 0
                        extra_note = "immune (Gaseous Form)"
                        mitig_note = (f"{mitig_note}; {extra_note}" if mitig_note else extra_note)
            except Exception:
                pass

            db_post_notes = []
            db_applied = False

                                                 
            is_melee    = _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle)
            is_slashing = _is_slashing_weapon(canon_name, item)
            db_on = False
            is_living = False
            healed = 0                                              

            try:
                if hit is True and tgt_path:
                    bcfg_db = _load_battles()
                    ch_db = str(ctx.channel.id)

                                                                            
                    if bcfg_db and bcfg_db.has_section(ch_db):
                        names, _ = _parse_combatants(bcfg_db, ch_db)
                        me_key = _find_ci_name(names, char_name) or char_name
                        try:
                            slot_me = _slot(me_key)
                        except Exception:
                            slot_me = me_key.replace(" ", "_")
                        db_on = (bcfg_db.getint(ch_db, f"{slot_me}.db", fallback=0) > 0)

                                                                    
                    try:
                        is_living = self._is_living_cfg(read_cfg(tgt_path))
                    except Exception:
                        is_living = False

                    if db_on and is_melee and is_slashing and is_living:
                                                    
                        final_damage += 1
                        db_applied = True

                                                                          
                        a_old = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                        a_max = getint_compat(atk_cfg, "max", "hp", fallback=a_old)
                        if a_old < a_max:
                            healed = 1
                            atk_cfg["cur"]["hp"] = str(min(a_max, a_old + healed))
                            write_cfg(atk_path, atk_cfg)

                        db_post_notes.append(f"🩸 Drainblade: +1")
                    elif db_on and not is_living:
                        db_post_notes.append("Drainblade: no effect (nonliving)")
            except Exception:
                                                                                    
                pass


            dmg_line = base_line
            if fav_bonus:
                dmg_line += f"\n+ 3 (Favored Enemy) → ``{raw_for_mitigation}``"
            if mitig_note:
                dmg_line += f"\n→ **{mitig_note}** → ``{final_damage}``"
            if db_post_notes:
                                          
                dmg_line += "\n" + " | ".join(db_post_notes)
            if strike_added_total and strike_lines:
                                                                        
                dmg_line += "\n" + "\n".join(f"+ {line}" for line in strike_lines)    
                                                                                                     
            if not mitig_note and not fav_bonus and (db_applied):
                dmg_line += f"\n→ ``{final_damage}``"
            if strike_added_total:
                final_damage += strike_added_total
                                                                 
            if starlight_added_total and 'dmg_line' in locals():
                dmg_line += "\n" + "\n".join(f"+ {line}" for line in starlight_lines)
                final_damage += starlight_added_total    
            if hit:
                if is_weapon_subdual and not subdual_now_counts_as_lethal:
                    dmg_line += f"\n→ **halved (subduing)** → ``{final_damage}``"
                elif is_brawl_subdual and not subdual_now_counts_as_lethal:
                                                                                  
                                                                          
                    pass
    
            if hit:
                embed.add_field(name="Damage", value=dmg_line, inline=False)


            new_hp = None
            target_hp_field = None
            ko_applied = False
            suppress_target_hp = False                                                            
            drain_kill = False                                                             

            if display_target and (hit is True) and tgt_path:
                t_cfg = read_cfg(tgt_path)
                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                                                    
                names_keyed, _ = _parse_combatants(bcfg, chan_id)
                name_key = (_find_ci_name(names_keyed, target_name) or target_name) if names_keyed else target_name
                try:
                    slot_tgt = _slot(name_key)
                except Exception:
                    slot_tgt = name_key.replace(" ", "_")

                try:
                                                                                              
                    names_keyed, _ = _parse_combatants(bcfg, chan_id)
                    name_key = (_find_ci_name(names_keyed, target_name) or target_name) if names_keyed else target_name
                    try:
                        slot_tgt = _slot(name_key)
                    except Exception:
                        slot_tgt = name_key.replace(" ", "_")

                                                                                  
                    damage_in = final if 'final' in locals() else final_damage

                    dmg_after, absorbed, remain, discharged = self._ss_soak(
                        bcfg, chan_id, slot_tgt, damage_in
                    )
                    if absorbed > 0:
                        embed.add_field(
                            name="Stoneskin",
                            value=(f"Stoneskin absorbs **{absorbed}**. " +
                                   ("**DISCHARGED!**" if discharged else f"Remaining buffer: **{remain}**.")),
                            inline=False,
                        )
                        if 'final' in locals():
                            final = dmg_after
                        else:
                            final_damage = dmg_after
                except Exception as e:
                                                                                             
                    embed.add_field(name="Stoneskin (error)", value=f"{type(e).__name__}: {e}", inline=False)

                                                                                                
                is_weapon_subdual = (want_subdual and _weapon_allows_subdual(canon_name, item))
                is_brawl_subdual  = is_brawl
                using_subdual     = is_weapon_subdual or is_brawl_subdual

                tgt_slot_for_sub = None
                if bcfg and bcfg.has_section(chan_id) and (display_target or primary_target):
                    names_sd, _ = _parse_combatants(bcfg, chan_id)
                    key_sd = _find_ci_name(names_sd, (display_target or primary_target)) or (display_target or primary_target)
                    try:    tgt_slot_for_sub = _slot(key_sd)
                    except: tgt_slot_for_sub = key_sd.replace(" ", "_")

                subdual_now_counts_as_lethal = False
                if using_subdual and tgt_slot_for_sub:
                    if bcfg.getint(chan_id, f"{tgt_slot_for_sub}.ko", fallback=0) > 0:
                        subdual_now_counts_as_lethal = True

                                                                    
                if is_weapon_subdual and not subdual_now_counts_as_lethal:
                    final_damage = max(0, final_damage // 2)

                              
                if tgt_slot_for_sub:
                    if using_subdual and not subdual_now_counts_as_lethal:
                        cur = bcfg.getint(chan_id, f"{tgt_slot_for_sub}.subdmg", fallback=0)
                        bcfg.set(chan_id, f"{tgt_slot_for_sub}.subdmg", str(cur + max(0, final_damage)))
                    else:
                        cur = bcfg.getint(chan_id, f"{tgt_slot_for_sub}.normdmg", fallback=0)
                        bcfg.set(chan_id, f"{tgt_slot_for_sub}.normdmg", str(cur + max(0, final_damage)))
                    _save_battles(bcfg)


                max_hp_cap = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                new_hp = old_hp - final_damage
                new_hp = max(0, min(max_hp_cap, new_hp))
                t_cfg["cur"]["hp"] = str(new_hp)
                write_cfg(tgt_path, t_cfg)

                if using_subdual and not subdual_now_counts_as_lethal and hit:
                    dmg_line += f"\n→ **halved (subduing)** → ``{final_damage}``"


                ko_applied = False
                if (hit is True) and tgt_path and (new_hp <= 0) and tgt_slot_for_sub:
                    t_cfg_for_ko = read_cfg(tgt_path)
                    max_hp_cap = getint_compat(t_cfg_for_ko, "max", "hp", fallback=0)
                    total_sub = bcfg.getint(chan_id, f"{tgt_slot_for_sub}.subdmg", fallback=0)
                    total_norm = bcfg.getint(chan_id, f"{tgt_slot_for_sub}.normdmg", fallback=0)

                    if total_sub > 0 and total_norm < max_hp_cap:
                                               
                        now_r = bcfg.getint(chan_id, "round", fallback=0)
                        t_turns, t_rolls, _ = roll_dice("1d4")                                
                        r_rounds, r_rolls, _ = roll_dice("2d10")                            

                        ko_rounds = (t_turns * 60)
                        bcfg.set(chan_id, f"{tgt_slot_for_sub}.ko",         str(ko_rounds))
                        bcfg.set(chan_id, f"{tgt_slot_for_sub}.ko_ready",   str(now_r + r_rounds))
                                                                                     
                        cur_sleep = bcfg.getint(chan_id, f"{tgt_slot_for_sub}.sleep", fallback=0)
                        cur_para  = bcfg.getint(chan_id, f"{tgt_slot_for_sub}.paralyzed", fallback=0)
                        bcfg.set(chan_id, f"{tgt_slot_for_sub}.sleep",     str(max(cur_sleep, ko_rounds)))
                        bcfg.set(chan_id, f"{tgt_slot_for_sub}.paralyzed", str(max(cur_para,  ko_rounds)))
                        _save_battles(bcfg)

                        ko_applied = True

                                                                                                     
                                                                            
                        ko_text = (f"🌀 **KNOCKED OUT (subdual)** — not dead.\n"
                                   f"Natural wake: **{t_turns} turn{'s' if t_turns!=1 else ''}** "
                                   f"({ko_rounds} rounds). Can be `!rouse`d **after {r_rounds} rounds**.")
                        embed.add_field(name="Knockout", value=ko_text, inline=False)
                        suppress_target_hp = True
                        
                                                                                                
                                                                                    
                        is_mon = _is_monster_file(tgt_path)
                        old_hp = getint_compat(t_cfg_for_ko, "cur", "hp", fallback=0)
                        if is_mon:
                            mhp = getint_compat(t_cfg_for_ko, "max", "hp", fallback=old_hp)
                            embed.add_field(name="Target HP", value=f"{_life_bar(old_hp, mhp, 10)} → **{_life_bar(0, mhp, 10)}** **KO**", inline=False)
                        else:
                            embed.add_field(name="Target HP", value=f"{old_hp} → **0** **KO**", inline=False)


                if (hit is True) and tgt_path and weapon_drains > 0:
                    t_cfg = read_cfg(tgt_path)

                                                                                         
                    is_living = True
                    try:
                        is_living = self._is_living_cfg(t_cfg)
                    except Exception:
                        pass

                    if not is_living:
                        embed.add_field(name="Energy Drain", value="No effect (nonliving/undead).", inline=False)
                    else:
                                                                                                               
                        _drain_res = await self._auto_apply_negative_levels(
                            ctx,
                            display_target or primary_target,
                            t_cfg, tgt_path,
                            n_levels=weapon_drains,
                            source=f"{canon_name} (draining weapon)",
                            embed=embed,
                        )
                                                                                                                          
                        try:
                            if isinstance(_drain_res, dict) and int(_drain_res.get("hp_after", new_hp if new_hp is not None else 0)) <= 0:
                                drain_kill = True
                                suppress_target_hp = True
                        except Exception:
                            pass

                                                                                      
                if not suppress_target_hp:
                    is_mon = _is_monster_file(tgt_path)
                    if is_mon:
                        mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                        bar_before = _life_bar(old_hp, mhp, width=10)
                        bar_after  = _life_bar(new_hp, mhp, width=10)
                        dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                        target_hp_field = f"{bar_before} → **{bar_after}**{dead_note}"
                    else:
                        dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                        target_hp_field = f"{old_hp} → **{new_hp}**{dead_note}"

            if target_hp_field is not None:
                embed.add_field(name="Target HP", value=target_hp_field, inline=False)

            if (hit is True) and pc_extra_eff:

                                                                                                                          
                if (hit is True) and tgt_path and pc_extra_eff.get("holdbite"):
                    try:
                        t_cfg = read_cfg(tgt_path)
                        cur_hp_after_hit = getint_compat(t_cfg, "cur", "hp", fallback=0)
                        if cur_hp_after_hit > 0:
                            bcfg_h = _load_battles(); chan_h = str(ctx.channel.id)
                            if bcfg_h and bcfg_h.has_section(chan_h) and (display_target or primary_target):
                                names_h, _ = _parse_combatants(bcfg_h, chan_h)

                                att_key = _find_ci_name(names_h, char_name) or char_name
                                def_key = _find_ci_name(names_h, (display_target or primary_target)) or (display_target or primary_target)

                                try: s_att = _slot(att_key)
                                except Exception: s_att = att_key.replace(" ","_")
                                try: s_def = _slot(def_key)
                                except Exception: s_def = def_key.replace(" ","_")

                                                                                    
                                prev = bcfg_h.get(chan_h, f"{s_att}.holds", fallback="")
                                if prev:
                                    try: s_prev = _slot(prev)
                                    except Exception: s_prev = prev.replace(" ", "_")
                                    if bcfg_h.has_option(chan_h, f"{s_prev}.heldby"):
                                        bcfg_h.remove_option(chan_h, f"{s_prev}.heldby")
                                    bcfg_h.remove_option(chan_h, f"{s_att}.holds")

                                               
                                bcfg_h.set(chan_h, f"{s_att}.holds", def_key)
                                bcfg_h.set(chan_h, f"{s_def}.heldby", att_key)

                                                                                                     
                                die = (pc_extra_eff.get("holdbite_dice") or "1d4").strip()
                                bcfg_h.set(chan_h, f"{s_def}.x_holdbite", "-1")                         
                                bcfg_h.set(chan_h, f"{s_def}.x_holdbite_label", "WORRY")
                                bcfg_h.set(chan_h, f"{s_def}.x_holdbite_code", "perm")
                                bcfg_h.set(chan_h, f"{s_def}.x_holdbite_dice", die)
                                bcfg_h.set(chan_h, f"{s_def}.x_holdbite_by", att_key)
                                _save_battles(bcfg_h)

                                                             
                                embed.add_field(
                                    name="Hold",
                                    value=(f"🐕 **HOLD ESTABLISHED** — {display_target or primary_target} is **HELD** by **{char_name}** "
                                           f"and will take **{die}** automatically each of their turns "
                                           f"until killed or `!escape` succeeds."),
                                    inline=False
                                )

                                                                              
                                try:
                                    msg_id = bcfg_h.getint(chan_h, "message_id", fallback=0)
                                    if msg_id:
                                        block = _format_tracker_block(bcfg_h, chan_h)
                                        msg = await ctx.channel.fetch_message(msg_id)
                                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                                except Exception:
                                    pass
                    except Exception:
                                                                                       
                        pass

                                                                  
                if pc_extra_eff.get("heal"):
                    heal_amt = max(0, (final_damage if 'final_damage' in locals() else applied_damage))
                    a_old = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                    a_max = getint_compat(atk_cfg, "max", "hp", fallback=a_old)
                    a_new = min(a_max, a_old + heal_amt)
                    if not atk_cfg.has_section("cur"): atk_cfg.add_section("cur")
                    atk_cfg["cur"]["hp"] = str(a_new); write_cfg(atk_path, atk_cfg)
                    embed.add_field(
                        name="Leech",
                        value=f"{atk_name} siphons **{heal_amt} HP**  •  HP: {a_old} → **{a_new}** / {a_max}",
                        inline=False
                    )

                                                          
                if pc_extra_eff.get("disease"):
                    try:
                        chance = int(pc_extra_eff.get("disease_chance", 100))
                    except Exception:
                        chance = 100
                    roll_pct = random.randint(1, 100)
                    if roll_pct <= max(0, min(100, chance)):
                        try:
                            bcfg = _load_battles()
                            if bcfg.has_section(chan_id) and (display_target or primary_target):
                                names, _ = _parse_combatants(bcfg, chan_id)
                                key = _find_ci_name(names, (display_target or primary_target)) or (display_target or primary_target)
                                try: slot_tgt = _slot(key)
                                except Exception: slot_tgt = key.replace(" ", "_")
                                if (pc_extra_eff.get("disease_kind") or "").lower() == "mummyrot":
                                    bcfg.set(chan_id, f"{slot_tgt}.mummyrot", "1")
                                    bcfg.set(chan_id, f"{slot_tgt}.noheal",   "1")
                                    _save_battles(bcfg)
                                    embed.add_field(name="Mummy Rot", value="Inflicted — **cannot benefit from healing** until cured.", inline=False)
                                else:
                                    bcfg.set(chan_id, f"{slot_tgt}.disease", "1"); _save_battles(bcfg)
                                    embed.add_field(name="Disease", value="Inflicted.", inline=False)
                        except Exception:
                            embed.add_field(name="Disease", value="Inflicted (state not saved due to error).", inline=False)
                    else:
                        embed.add_field(name="Disease", value=f"Chance roll **{roll_pct}%** > {chance}% — no infection.", inline=False)

                                                        
                drain_mix = int(pc_extra_eff.get("leveldrain", 0) or 0)
                if drain_mix > 0 and tgt_path:
                    try:
                        t_cfg = read_cfg(tgt_path)
                        _mix_res = await self._auto_apply_negative_levels(
                            ctx,
                            display_target or primary_target,
                            t_cfg, tgt_path,
                            n_levels=drain_mix,
                            source=f"{canon_name} (draining touch)",
                            embed=embed,
                        )
                                                                                     
                        try:
                            if isinstance(_mix_res, dict) and int(_mix_res.get("hp_after", new_hp if new_hp is not None else 0)) <= 0:
                                drain_kill = True
                                suppress_target_hp = True
                        except Exception:
                            pass
                    except Exception as e:
                        embed.add_field(
                            name="Energy Drain",
                            value=(f"{drain_mix} negative level(s) **not applied** due to an error; "
                                   f"GM may run `!drain {display_target or primary_target} {drain_mix}`. ({type(e).__name__})"),
                            inline=False
                        )

                                                                                
                if not _is_monster_file(tgt_path):
                              
                    con_loss = int(pc_extra_eff.get("conloss", 0) or 0)
                    if con_loss > 0:
                        tgt_con_now = getint_compat(t_cfg, "stats", "con", fallback=0) if 't_cfg' in locals() else getint_compat(read_cfg(tgt_path), "stats", "con", fallback=0)
                        if tgt_con_now <= 0:
                            embed.add_field(name="Constitution Drain", value="Target has no recorded CON; GM adjudicates.", inline=False)
                        else:
                            allow_save = False
                            try: allow_save = self._is_elf_or_dwarf(read_cfg(tgt_path))
                            except Exception: allow_save = False
                            if allow_save:
                                ok, roll, dc, _ = self._roll_save(read_cfg(tgt_path), vs="poi", penalty=0)
                                if ok:
                                    embed.add_field(name="Constitution Drain", value=f"Save vs Death: {roll} vs {dc} → **RESISTED**.", inline=False)
                                    con_loss = 0
                            if con_loss > 0:
                                hp_delta = self._apply_conloss_points(read_cfg(tgt_path), con_loss)
                                write_cfg(tgt_path, read_cfg(tgt_path))
                                embed.add_field(name="Constitution Drain", value=f"**-{con_loss} CON** (temp).", inline=False)

                              
                    str_loss = int(pc_extra_eff.get("strloss", 0) or 0)
                    if str_loss > 0:
                        applied, died, collapsed = self._apply_strloss_points(read_cfg(tgt_path), str_loss)
                        write_cfg(tgt_path, read_cfg(tgt_path))
                        parts = [f"**−{applied} STR**"]
                        if died: parts.append("☠️ **Death (STR 0)** — may rise as a shadow at next nightfall (GM).")
                        elif collapsed: parts.append("**Collapsed** (STR ≤ 2): can’t move until STR recovers (1/turn).")
                        embed.add_field(name="Strength Drain", value=" ".join(parts), inline=False)

                                                                                         
                if (hit is True) and tgt_path and pc_extra_eff.get("paralysis"):
                    t_cfg = read_cfg(tgt_path)

                                          
                    try:
                        if not self._is_living_cfg(t_cfg):
                            embed.add_field(name="Paralysis", value="No effect (nonliving/undead).", inline=False)
                        else:
                                                  
                            race = (get_compat(t_cfg, "info", "race", fallback="") or "").lower()
                            if "elf" in race:
                                embed.add_field(name="Paralysis", value="Elves are **immune** to ghoul paralysis.", inline=False)
                            else:
                                chance = int(pc_extra_eff.get("paralysis_chance", 100) or 100)
                                roll_pct = random.randint(1, 100)
                                if roll_pct > max(0, min(100, chance)):
                                    embed.add_field(
                                        name="Paralysis",
                                        value=f"Chance roll **{roll_pct}%** > {chance}% — no effect.",
                                        inline=False
                                    )
                                else:
                                    ok, sv_roll, sv_target, _ = self._roll_save(t_cfg, vs="para", penalty=0)
                                    if ok:
                                        embed.add_field(
                                            name="Paralysis",
                                            value=f"Save vs Paralyze: {sv_roll} vs {sv_target} → **RESISTED**.",
                                            inline=False
                                        )
                                    else:
                                        raw_rounds = str(pc_extra_eff.get("paralysis_rounds", "") or "").strip()
                                        raw_turns  = str(pc_extra_eff.get("paralysis_turns",  "") or "").strip()
                                        rolls_p = []

                                        def _parse_int_or_dice(s: str):
                                            if not s:
                                                return None, []
                                            try:
                                                return int(s), []                 
                                            except Exception:
                                                total, rolls, flat = roll_dice(s)               
                                                return total + flat, rolls

                                        rounds = turns = None

                                        val_rounds, r_rolls = _parse_int_or_dice(raw_rounds)
                                        val_turns,  t_rolls = _parse_int_or_dice(raw_turns)

                                        if val_rounds is not None:
                                            rounds = max(0, int(val_rounds))
                                            turns  = rounds // 60
                                            rolls_p = r_rolls
                                        elif val_turns is not None:
                                            turns  = max(0, int(val_turns))
                                            rounds = turns * 60
                                            rolls_p = t_rolls
                                        else:
                                            s, rolls_p, flat_p = roll_dice("2d8")
                                            turns  = s + flat_p
                                            rounds = turns * 60


                                        try:
                                            bcfg = _load_battles(); ch = str(ctx.channel.id)
                                            if bcfg and bcfg.has_section(ch):
                                                names, _ = _parse_combatants(bcfg, ch)
                                                key = _find_ci_name(names, (display_target or primary_target)) or (display_target or primary_target)
                                                s_tgt = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                                                cur_left = bcfg.getint(ch, f"{s_tgt}.paralyzed", fallback=0)
                                                bcfg.set(ch, f"{s_tgt}.paralyzed", str(max(cur_left, rounds)))
                                                                                  
                                                if bcfg.has_option(ch, f"{s_tgt}.para"):
                                                    bcfg.remove_option(ch, f"{s_tgt}.para")
                                                _save_battles(bcfg)
                                        except Exception:
                                            pass

                                        rolls_txt = f" [{', '.join(str(r) for r in rolls_p)}]" if rolls_p else ""
                                        embed.add_field(
                                            name="Paralysis",
                                            value=(f"Save vs Paralyze: {sv_roll} vs {sv_target} → **FAIL** — "
                                                   f"⛓️ **PARALYZED** for {turns} turns ({rounds} rounds){rolls_txt}."),
                                            inline=False
                                        )
                    except Exception:
                        pass

                                                  
                if pc_extra_eff.get("poison") == "saveordie" and tgt_path and (hit is True):
                    t_cfg = read_cfg(tgt_path)
                                                               
                    try:
                        if not self._is_living_cfg(t_cfg):
                            embed.add_field(name="Poison", value="No effect (nonliving/undead).", inline=False)
                        else:
                            ok, sv_roll, sv_target, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
                            if ok:
                                embed.add_field(name="Poison", value=f"Save vs Death/Poison: {sv_roll} vs {sv_target} → **RESISTED**.", inline=False)
                            else:
                                               
                                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                                t_cfg["cur"]["hp"] = "0"; write_cfg(tgt_path, t_cfg)
                                dead_field = (f"{_life_bar(old_hp, getint_compat(t_cfg, 'max', 'hp', fallback=old_hp), 10)}"
                                              f" → **{_life_bar(0, getint_compat(t_cfg, 'max', 'hp', fallback=old_hp), 10)}** ☠️ **DEAD!**"
                                              if _is_monster_file(tgt_path) else f"{old_hp} → **0** ☠️ **DEAD!**")
                                embed.add_field(name="Poison", value=f"Save vs Death/Poison: {sv_roll} vs {sv_target} → **FAIL**", inline=False)
                                embed.add_field(name="Target HP", value=dead_field, inline=False)
                                                                                             
                                await self._remove_from_battle_and_cleanup(ctx, display_target or primary_target, tgt_path)

                                await ctx.send(embed=embed)
                                return
                    except Exception:
                        pass

                                                                   
                if pc_extra_eff.get("constrict") and tgt_path and (hit is True):
                    dice = pc_extra_eff.get("constrict_dice") or "2d4"
                    pretty = display_target or primary_target or ""
                    bcfg = _load_battles(); ch = str(ctx.channel.id)
                    if bcfg and bcfg.has_section(ch) and pretty:
                        names, _ = _parse_combatants(bcfg, ch)
                        att_key = _find_ci_name(names, char_name) or char_name
                        def_key = _find_ci_name(names, pretty) or pretty
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ","_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ","_")

                                                                                            
                        prev = bcfg.get(ch, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ","_")
                            if bcfg.has_option(ch, f"{s_prev}.heldby"): bcfg.remove_option(ch, f"{s_prev}.heldby")
                            bcfg.remove_option(ch, f"{s_att}.holds")

                        bcfg.set(ch, f"{s_att}.holds", def_key)
                        bcfg.set(ch, f"{s_def}.heldby", att_key)
                        bcfg.set(ch, f"{s_def}.constrict_by", att_key)                      
                        bcfg.set(ch, f"{s_def}.constrict_dice", dice)                        
                        _save_battles(bcfg)

                                                      
                        t_cfg = read_cfg(tgt_path)
                        s, rolls, flat = roll_dice(dice)
                        raw = s + flat
                                                                                                           
                        final_c, note_c = _apply_mitigation(raw, weapon_name="Constrict", weapon_type="bludgeoning", t_cfg=t_cfg, is_magical=False)

                                                                
                        try:
                            dmg_after, absorbed, remain, discharged = self._ss_soak(bcfg, ch, s_def, final_c)
                            if absorbed > 0:
                                embed.add_field(name="Stoneskin", value=f"Stoneskin absorbs **{absorbed}**. "
                                                + ("**DISCHARGED!**" if discharged else f"Remaining buffer: **{remain}**."), inline=False)
                                final_c = dmg_after
                        except Exception:
                            pass

                        old = getint_compat(t_cfg, "cur", "hp", fallback=0)
                        new = max(0, old - final_c)
                        t_cfg["cur"]["hp"] = str(new); write_cfg(tgt_path, t_cfg)

                        line = f"Constrict: {dice} [{', '.join(map(str, rolls))}]"
                        line += (f" → **{final_c}** ({note_c})" if note_c else f" → **{final_c}**")
                        embed.add_field(name="Constriction", value=line, inline=False)

                                                         
                        if _is_monster_file(tgt_path):
                            mhp = getint_compat(t_cfg, "max", "hp", fallback=old)
                            embed.add_field(name="Target HP", value=f"{_life_bar(old, mhp, 10)} → **{_life_bar(new, mhp, 10)}**"
                                            + (" ☠️ **DEAD!**" if new <= 0 else ""), inline=False)
                        else:
                            embed.add_field(name="Target HP", value=f"{old} → **{new}**" + (" ☠️ **DEAD!**" if new <= 0 else ""), inline=False)

                                                                           
                        if new <= 0:
                            try:
                                await self._remove_from_battle_and_cleanup(ctx, pretty, tgt_path)
                            except Exception:
                                pass

                                              
            if 'healed' in locals() and healed > 0:
                a_now = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                a_max = getint_compat(atk_cfg, "max", "hp", fallback=a_now)
                embed.add_field(name="Attacker HP", value=f"{a_old} → **{a_now}** / {a_max}", inline=False)

                                                                                                     
            if want_charge and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                if char_name in names:
                    try:
                        slot_me = _slot(char_name)
                    except Exception:
                        slot_me = char_name.replace(" ", "_")
                    bcfg.set(chan_id, f"{slot_me}.acpen", "-2")
                    _save_battles(bcfg)

                                              
            if want_rage and is_barbarian and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                if char_name in names:
                    try:
                        slot_me = _slot(char_name)
                    except Exception:
                        slot_me = char_name.replace(" ", "_")
                                                                                                           
                    bcfg.set(chan_id, f"{slot_me}.acpen", "-2")
                    _save_battles(bcfg)

                                                                                
            try:
                if self._hr_enabled(ctx.channel, "quarterstaff_defense", default=True):
                    if bcfg.has_section(chan_id):
                        names, _ = _parse_combatants(bcfg, chan_id)
                        if char_name in names:
                            if normalize_name(canon_name) == "quarterstaff" and not want_twf:
                                try:
                                    slot_me = _slot(char_name)
                                except Exception:
                                    slot_me = char_name.replace(" ", "_")
                                bcfg.set(chan_id, f"{slot_me}.acbuf", "1")
                                _save_battles(bcfg)
                                embed.add_field(name="Defense", value="+1 AC until your next turn (quarterstaff stance)", inline=False)
            except Exception:
                pass


                                                                                  
            if (hit is True
                and tgt_path
                and weapon_slot_for_corrosion
                and _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle)
            ):
                try:
                    t_cfg_for_specials = read_cfg(tgt_path)
                    await self._maybe_corrode_weapon_on_hit(
                        ctx,
                        attacker_cfg=atk_cfg, attacker_path=atk_path, attacker_name=atk_name,
                        target_cfg=t_cfg_for_specials, target_name=(display_target or primary_target),
                        weapon_slot=weapon_slot_for_corrosion, weapon_name=canon_name,
                        embed=embed
                    )
                                                                              
                    try:
                                                             
                        still = normalize_name(get_compat(read_cfg(atk_path), "eq", weapon_slot_for_corrosion, fallback=""))\
                                == normalize_name(canon_name)
                    except Exception:
                        still = True
                    if repeat_times > 1 and not still:
                        embed.add_field(name="Repeat", value="🧪 Weapon dissolved — stopping further attacks.", inline=False)
                        repeat_times = 1                                       
                except Exception:
                    pass


            dead_mon = bool(tgt_path and (new_hp is not None) and new_hp <= 0 and _is_monster_file(tgt_path))
            if ko_applied:
                dead_mon = False                                                       

            if dead_mon and not drain_kill:                                                                               
                pretty_name = (display_target or "").strip()
                try:
                    bcfg = _load_battles()
                    if bcfg.has_section(chan_id):
                        names, scores = _parse_combatants(bcfg, chan_id)
                        name_key = _find_ci_name(names, pretty_name) or pretty_name
                        if name_key in names:
                            names = [n for n in names if n != name_key]
                            if bcfg.has_option(chan_id, name_key):
                                bcfg.remove_option(chan_id, name_key)
                            slot = _slot(name_key) if '_slot' in globals() else name_key.replace(" ", "_")
                            for suf in (".dex", ".join", ".disp"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names, scores)
                            if bcfg.get(chan_id, "turn", fallback="") == name_key:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                            try:
                                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                                if msg_id:
                                    bcfg = _load_battles() 
                                    block = _format_tracker_block(bcfg, chan_id)
                                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                                    msg = await ctx.channel.fetch_message(msg_id)
                                    await msg.edit(content=content)
                            except Exception:
                                pass
                except Exception as e:
                    await ctx.send(f"⚠️ couldn’t update initiative for **{pretty_name}**: `{e}`")
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception as e:
                    await ctx.send(f"⚠️ couldn’t delete `{os.path.basename(tgt_path)}`: `{e}`")

            if self._hr_enabled(ctx.channel, "heroic_called_shot", default=True):
                auto_called_applies = (
                    not want_called
                    and hit is True
                    and margin is not None and margin >= 4
                    and spec_applied
                    and class_lc in {"fighter", "fightermage"}
                    and not want_wrestle
                    and not is_oil and not is_holy
                    and tgt_path
                )
                if auto_called_applies:
                    t_cfg = read_cfg(tgt_path)
                    spec_pen = spec_dmg if (spec_applied and spec_dmg > 0) else 0
                    sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="para", penalty=spec_pen)
                    effect_success = (not sv_ok)
                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    save_line = f"Save vs Paralyze: {sv_roll}{pen_txt} vs {sv_target} → **{'CALLED SHOT GOES OFF' if effect_success else 'RESISTED'}**"
                    embed.add_field(name="Heroic called shot (auto)", value=save_line, inline=False)

       
                                                                                      
                                                                           
        if repeat_times > 1 and (hit is False):
            embed.add_field(name="\u200b", value="\u200b", inline=False)

        if repeat_times > 1 and tgt_path and display_target:
                                                    
            if 'new_hp' in locals() and new_hp is not None and new_hp <= 0:
                embed.add_field(name="Repeat", value="⛔ Target was slain by the first attack. Stopping repeats.", inline=False)
            else:
                for shot_idx in range(2, repeat_times + 1):
                    if not os.path.exists(tgt_path):
                        embed.add_field(name="Repeat", value=f"⛔ Target file missing before attack #{shot_idx}.", inline=False)
                        break

                                                                         
                    if needs_ammo and not _is_monster_file(atk_path):
                        carried_ok_b, carried_total_b = self._has_carried_item(cfg, needs_ammo)
                        if not carried_ok_b or carried_total_b < 1:
                            embed.add_field(
                                name=f"Ammunition #{shot_idx}",
                                value=f"⛔ Out of **{needs_ammo}** — stopping repeats.",
                                inline=False
                            )
                            break

                        if not self._consume_carried_item(cfg, needs_ammo, qty=1):
                            embed.add_field(
                                name=f"Ammunition #{shot_idx}",
                                value=f"⚠️ Carry stack desynced — could not consume **{needs_ammo}**.",
                                inline=False
                            )
                            break

                                                               
                        self._recompute_eq_weight(cfg)
                        self._recompute_move(cfg)
                        write_cfg(coe, cfg)

                                                                                                      
                        try:
                            _ok_b, remaining_rep = self._consume_inventory_item(cfg, coe, needs_ammo, qty=1)
                        except Exception:
                            remaining_rep = None

                        rtxt = remaining_rep if remaining_rep is not None else "—"
                        embed.add_field(
                            name=f"Ammunition #{shot_idx}",
                            value=f"({needs_ammo} –1; remaining: {rtxt})",
                            inline=True
                        )

                    t_cfg2 = read_cfg(tgt_path)
                                                                                                             
                    target_ac2 = target_ac if target_ac is not None else 11

                    d20b = random.randint(1, 20)
                    critb = (d20b == 20)
                    nat1b = (d20b == 1)
                    flank_bonus_b     = 0 if (want_sneak and is_thief) else (2 if want_flank else 0)
                    rage_hit_bonus_b  = 2 if (want_rage and is_barbarian) else 0
                                                                                                       
                    inv_b = 0                                                            
                    pain_att_pen_b = pain_att_pen                           

                                                      
                    inv_def_hit_penalty_b = 0
                    try:
                        bcfg_rep = _load_battles()
                        if bcfg_rep and bcfg_rep.has_section(chan_id) and display_target:
                            names_r, _ = _parse_combatants(bcfg_rep, chan_id)
                            key_r = _find_ci_name(names_r, display_target) or display_target
                            s_tgt_r = _slot(key_r) if '_slot' in globals() else key_r.replace(" ", "_")
                            if bcfg_rep.getint(chan_id, f"{s_tgt_r}.inv", fallback=0) > 0 or bcfg_rep.getint(chan_id, f"{s_tgt_r}.inv_perm", fallback=0) > 0:
                                                                      
                                sees_r = False
                                try:
                                    me_key_b = _find_ci_name(names_r, char_name) or char_name
                                    s_me_b = _slot(me_key_b) if '_slot' in globals() else me_key_b.replace(" ", "_")
                                    for opt in (
                                        f"{s_me_b}.seeinv", f"{s_me_b}.see_invisible", f"{s_me_b}.x_seeinvisible",
                                        f"{s_me_b}.truesee", f"{s_me_b}.truesight", f"{s_me_b}.x_trueseeing"
                                    ):
                                        if bcfg_rep.getint(chan_id, opt, fallback=0) > 0:
                                            sees_r = True; break
                                except Exception:
                                    pass
                                if not sees_r:
                                    inv_def_hit_penalty_b = -4
                    except Exception:
                        pass


                    total_to_hit_b = (d20b + ab + atk_mod + spec_hit
                                      + (4 if (want_sneak and is_thief) else 0)
                                      + (2 if want_charge else 0)
                                      + rage_hit_bonus_b
                                      + (1 if rng_short else 0) + (-2 if rng_long else 0)
                                      + halfling_missile_bonus
                                      + ranger_bow_hit_bonus
                                      + scout_bow_hit_bonus
                                      + extra_hit_bonus
                                      + flank_bonus_b
                                      + twf_penalty
                                      + blind_hit_penalty
                                      + inv_b
                                      + inv_def_hit_penalty_b
                                      + pain_att_pen_b
                                      + wpn_plus
                                      + p_atk_all
                                      + enh_wep_hit          
                                      + weak_wep_hit
                                      + bless_bane_hit)      


                    hit_b = False if nat1b else (critb or total_to_hit_b >= target_ac2)
                    margin_b = (total_to_hit_b - target_ac2) if target_ac2 is not None else None

                                 
                    d20_face_b = "**20** 🎉" if d20b == 20 else ("**1** 💀" if d20b == 1 else str(d20b))
                    ab_str_b   = f"+ {ab}" if ab >= 0 else f"{ab}"
                    mod_str_b  = f"+ {atk_mod}" if atk_mod >= 0 else f"{atk_mod}"
                    spec_str_b = f" + {spec_hit}" if spec_hit else ""
                    sneak_str_b = " + 4" if (want_sneak and is_thief) else ""
                    charge_str_b = " + 2" if want_charge else ""
                    rage_str_b   = " + 2" if rage_hit_bonus_b else ""                            
                    rng_str_b    = (" + 1" if rng_short else (" - 2" if rng_long else ""))
                    half_str_b   = " + 1" if halfling_missile_bonus else ""
                    ranger_bow_str_b = " + 2" if ranger_bow_hit_bonus else ""
                    user_str_b   = (f" + {extra_hit_bonus}" if extra_hit_bonus > 0 else
                                   (f" - {abs(extra_hit_bonus)}" if extra_hit_bonus < 0 else ""))
                    flank_str_b  = " + 2" if flank_bonus_b else ""
                    twf_str_b    = (f" - {abs(twf_penalty)}" if twf_penalty < 0 else "")
                    inv_str_b  = (f" + {inv_b}" if inv_b > 0 else (f" - {abs(inv_b)}" if inv_b < 0 else ""))
                    pain_str_b = (f" + {pain_att_pen_b}" if pain_att_pen_b > 0 else (f" - {abs(pain_att_pen_b)}" if pain_att_pen_b < 0 else ""))
                    wpn_plus_str_b = f" + {wpn_plus}" if wpn_plus else ""
                    p_str_b = f"+ {p_atk_all}" if p_atk_all else ""
                    enh_hit_str_b  = f" + {enh_wep_hit}" if enh_wep_hit else ""
                    weak_hit_str_b = f" - {abs(weak_wep_hit)}" if weak_wep_hit else ""
                    bless_bane_str_b = bb_str                
                    inv_def_str_b = " - 4" if inv_def_hit_penalty_b else ""
                    embed.add_field(
                        name=f"Attack #{shot_idx}",
                        value=(f"{d20_face_b} {ab_str_b} {mod_str_b}{spec_str_b}{sneak_str_b}"
                               f"{charge_str_b}{rage_str_b}{rng_str_b}{half_str_b}{ranger_bow_str_b}{user_str_b}"
                               f"{flank_str_b}{twf_str_b}{inv_str_b}{inv_def_str_b}{pain_str_b}{wpn_plus_str_b}{p_str_b}{enh_hit_str_b}{weak_hit_str_b}{bless_bane_str_b} = ``{total_to_hit_b}``"),
                        inline=True
                    )
                    embed.add_field(name=f"Result #{shot_idx}", value=("✅ **HIT!**" if hit_b else "❌ **MISS**"), inline=True)

                    if pnm_on and self._pc_attack_is_normal_missile(canon_name, item, False, False,
                                                                    weapon_type, short, med, longr, rng_long, is_magical_attack):
                        embed.add_field(name=f"Protection from Normal Missiles #{shot_idx}",
                                        value="Missile is **negated** — no effect.",
                                        inline=False)
                        continue

                    consumed_rep, left_rep = self._mi_consume_if_present(ctx, display_target)
                    if consumed_rep:
                        embed.add_field(
                            name=f"Mirror Image #{shot_idx}",
                            value=f"Figment destroyed. Images remaining: **{left_rep}**.",
                            inline=False
                        )
                        continue

                    try:
                        bcfg_note = _load_battles()
                        if bcfg_note and bcfg_note.has_section(chan_id):
                            names_note, _ = _parse_combatants(bcfg_note, chan_id)
                            cand_note = (prim_disp or primary_target or display_target or "").strip()
                            key_note = _find_ci_name(names_note, cand_note) or cand_note
                            s_tgt_note = _slot(key_note) if '_slot' in globals() else key_note.replace(" ", "_")
                            sh_left_b = bcfg_note.getint(chan_id, f"{s_tgt_note}.shield", fallback=0)
                            acbuf_b   = bcfg_note.getint(chan_id, f"{s_tgt_note}.acbuf",  fallback=0)
                            inw_left_b = bcfg_note.getint(chan_id, f"{s_tgt_note}.inw", fallback=0)
                            if inw_left_b > 0:
                                embed.add_field(
                                    name=f"Note #{shot_idx}",
                                    value="Target is under **Invulnerability** (immune to **nonmagical weapons**).",
                                    inline=False
                                )

                                                                            
                            is_missile_b = False
                            wtyp = (weapon_type or "").lower()
                            if wtyp in {"missile","ranged","bow","xbow","thrown"}:
                                is_missile_b = True
                            if not is_missile_b:
                                try:
                                    if self._is_halfling_missile_weapon(canon_name, item):
                                        is_missile_b = True
                                except Exception:
                                    pass
                            if not is_missile_b:
                                if any(bool(x) for x in (item.get("short"), item.get("med"), item.get("long"))) or rng_long:
                                    is_missile_b = True

                            if sh_left_b > 0:
                                shield_b = 6 if is_missile_b else 3
                                embed.add_field(name=f"Note #{shot_idx}", value=f"Target is under **Shield** (+{shield_b} AC).", inline=False)
                            if acbuf_b:
                                embed.add_field(name=f"Note #{shot_idx}", value=f"Target has a defensive stance (+{acbuf_b} AC).", inline=False)
                                                                                                  
                            wa_legacy_b = bcfg_note.getint(chan_id, f"{s_tgt_note}.weakarmor",    fallback=0)
                            wa_timer_b  = bcfg_note.getint(chan_id, f"{s_tgt_note}.x_weakenarmor", fallback=0)
                            wa_left_b   = max(wa_legacy_b, wa_timer_b)
                            if wa_left_b > 0:
                                embed.add_field(
                                    name=f"Note #{shot_idx}",
                                    value=f"Target’s armor is **WEAKENED** (−1 AC, {wa_left_b} rounds left).",
                                    inline=False
                                )
    
                    except Exception:
                        pass

                    if not hit_b:
                        continue

                    if self._hr_enabled(ctx.channel, "heroic_called_shot", default=True):
                        auto_called_applies_b = (
                            not want_called
                            and margin_b is not None and margin_b >= 4
                            and spec_applied
                            and class_lc in {"fighter", "fightermage"}
                            and not want_wrestle
                            and not is_oil and not is_holy
                            and tgt_path
                        )
                        
                    if pure_drain:
                        t_cfg2 = read_cfg(tgt_path)

                                                                                           
                        try:
                            bcfg = _load_battles(); ch = str(ctx.channel.id)
                            if bcfg and bcfg.has_section(ch):
                                names_ss, _ = _parse_combatants(bcfg, ch)
                                key_ss = _find_ci_name(names_ss, display_target) or display_target
                                try:    slot_tgt = _slot(key_ss)
                                except: slot_tgt = key_ss.replace(" ", "_")
                                _, absorbed_b, remain_b, discharged_b = self._ss_soak(bcfg, ch, slot_tgt, 1)
                                if absorbed_b > 0:
                                    embed.add_field(
                                        name=f"Stoneskin #{shot_idx}",
                                        value=("Stoneskin blocks the draining touch. "
                                               + ("**DISCHARGED!**" if discharged_b else f"Remaining buffer: **{remain_b}**.")),
                                        inline=False
                                    )
                                    continue
                        except Exception:
                            pass

                                          
                        try:
                            is_living_b = self._is_living_cfg(t_cfg2)
                        except Exception:
                            is_living_b = True

                        if not is_living_b:
                            embed.add_field(name=f"Energy Drain #{shot_idx}", value="No effect (nonliving/undead).", inline=False)
                            continue

                                                     
                        pre_drain_hp_pure = getint_compat(t_cfg2, "cur", "hp", fallback=0)
                        killed_by_drain_b = False
                        try:
                            drain_info_pure = await self._auto_apply_negative_levels(
                                ctx,
                                display_target or primary_target,
                                t_cfg2, tgt_path,
                                n_levels=drain_n,
                                source=f"{canon_name} (drain touch) #{shot_idx}",
                                embed=embed,
                            )
                        except Exception:
                            drain_info_pure = None

                        try:
                            post_drain_hp_pure = (drain_info_pure or {}).get("hp_after", pre_drain_hp_pure)
                        except Exception:
                            post_drain_hp_pure = pre_drain_hp_pure

                        if (pre_drain_hp_pure > 0 and post_drain_hp_pure <= 0) or (pre_drain_hp_pure > 0 and not os.path.exists(tgt_path)):
                            killed_by_drain_b = True

                        if killed_by_drain_b:
                                                    
                            if _is_monster_file(tgt_path):
                                try:
                                    bcfg2 = _load_battles()
                                    if bcfg2.has_section(str(ctx.channel.id)):
                                        names2, scores2 = _parse_combatants(bcfg2, str(ctx.channel.id))
                                        key2 = _find_ci_name(names2, display_target) or display_target
                                        if key2 in names2:
                                            names2 = [n for n in names2 if n != key2]
                                            if bcfg2.has_option(str(ctx.channel.id), key2):
                                                bcfg2.remove_option(str(ctx.channel.id), key2)
                                            slot2 = _slot(key2) if '_slot' in globals() else key2.replace(" ", "_")
                                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                                opt2 = f"{slot2}{suf}"
                                                if bcfg2.has_option(str(ctx.channel.id), opt2):
                                                    bcfg2.remove_option(str(ctx.channel.id), opt2)
                                            _write_combatants(bcfg2, str(ctx.channel.id), names2, scores2)
                                            if bcfg2.get(str(ctx.channel.id), "turn", fallback="") == key2:
                                                ents2 = _sorted_entries(bcfg2, str(ctx.channel.id))
                                                bcfg2.set(str(ctx.channel.id), "turn", ents2[0]["name"] if ents2 else "")
                                            _save_battles(bcfg2)
                                    try: os.remove(os.path.abspath(tgt_path))
                                    except Exception: pass
                                except Exception:
                                    pass
                            break                                        
                        else:
                            continue                                                                       

                    dice_sum_b, dmg_rolls_b, flat_mod_b = roll_dice(dmg_spec)
                    precrit_b = dice_sum_b + flat_mod_b
                    if used_stat == "str":
                        precrit_b += str_mod * (2 if barb_melee else 1)
                    if spec_applied and spec_dmg:
                        precrit_b += spec_dmg
                    if extra_dmg_value and not want_called:
                        precrit_b += extra_dmg_value
                    if (want_rage and is_barbarian) and not want_called:
                        precrit_b += 2
                    precrit_b += wpn_plus
                    precrit_b += enh_wep_dmg     
                    precrit_b += weak_wep_dmg    
                    if p_dmg_all:
                        precrit_b += p_dmg_all
                    base_damage_b = max(0, precrit_b)

                    mult_b = 1
                    if critb: mult_b *= 2
                    if (want_sneak and is_thief): mult_b *= 2
                    if want_charge: mult_b *= 2

                    applied_damage_b = base_damage_b * mult_b

                                                                    
                    head_b = None
                    if mult_b == 8: head_b = "🔥 **CRIT + SNEAK + CHARGE!**"
                    elif mult_b == 4 and critb: head_b = "🔥 **CRITICAL + (SNEAK/CHARGE)!**"
                    elif critb: head_b = "🔥 **CRITICAL HIT!**"
                    elif (want_sneak and is_thief) and want_charge: head_b = "🗡️ **SNEAK + CHARGE!**"
                    elif (want_sneak and is_thief): head_b = "🗡️ **SNEAK ATTACK!**"

                    fav_bonus_b = 3 if (want_fav and is_ranger and not want_called) else 0
                    raw_for_mitigation_b = applied_damage_b + fav_bonus_b

                    flame_plus_b = False
                    if is_flaming:
                        _, note_b = _apply_mitigation(1, weapon_name="probe", weapon_type="fire",
                                                      t_cfg=t_cfg2, is_magical=True, chan_id=str(ctx.channel.id), target_name=pretty_primary)
                        if (note_b or "").lower().find("weak to fire") != -1:
                            raw_for_mitigation_b += 1
                            flame_plus_b = True
                                         
                    mod_parts_b = []
                    if flat_mod_b:
                        mod_parts_b.append(f"{'+' if flat_mod_b > 0 else '-'} {abs(flat_mod_b)}")
                    if used_stat == "str" and str_mod:
                        val_b = str_mod * (2 if barb_melee else 1)
                        lbl_b = " (2×STR)" if barb_melee else ""
                        mod_parts_b.append(f"{'+' if val_b > 0 else '-'} {abs(val_b)}{lbl_b}")
                    if spec_applied and spec_dmg:
                        mod_parts_b.append(f"+ {spec_dmg}")
                    if (want_rage and is_barbarian) and not want_called:
                        mod_parts_b.append("+ 2 (Rage)")
                    if wpn_plus:
                        mod_parts_b.append(f"+ {wpn_plus}")
                    if extra_dmg_value and not want_called:
                        mod_parts_b.append(f"{'+ ' if extra_dmg_value > 0 else '- '}{abs(extra_dmg_value)}")
                    if flame_plus_b:
                        mod_parts_b.append("+ 1")
                    if p_dmg_all:
                        mod_parts_b.append(f"+ {p_dmg_all}")    
                    if enh_wep_dmg:
                        mod_parts_b.append(f"+ {enh_wep_dmg}")
                    if weak_wep_dmg:
                        mod_parts_b.append(f"- {abs(weak_wep_dmg)}")
                                                                                         
                    if pain_dmg_pen:
                        mod_parts_b.append(f"- {abs(pain_dmg_pen)} (Pain)")
                        raw_for_mitigation_b = max(0, raw_for_mitigation_b + pain_dmg_pen)

                    mod_text_b = (" " + " ".join(mod_parts_b)) if mod_parts_b else ""
                    display_base_total_b = applied_damage_b + (1 if flame_plus_b else 0)

                    rolls_str_b = "[" + ", ".join(str(r) for r in dmg_rolls_b) + "]"
                    base_line_b = f"{dmg_spec} {rolls_str_b}{mod_text_b}"
                    base_line_b += (f" × {mult_b} = ``{display_base_total_b}``" if mult_b != 1 else f" = ``{display_base_total_b}``")

                                                                             
                    final_damage_b, mitig_note_b = _apply_mitigation(
                        raw_for_mitigation_b, weapon_name=canon_name, weapon_type=weapon_type,
                        t_cfg=t_cfg2, is_magical=is_magical_attack
                    )

                                                                           
                    try:
                        bcfg_inw = _load_battles()
                        if bcfg_inw and bcfg_inw.has_section(chan_id) and hit_b:
                            names_inw, _ = _parse_combatants(bcfg_inw, chan_id)
                            key_inw = _find_ci_name(names_inw, display_target) or display_target
                            s_tgt_inw = _slot(key_inw) if '_slot' in globals() else key_inw.replace(" ", "_")
                            inw_left = bcfg_inw.getint(chan_id, f"{s_tgt_inw}.inw", fallback=0)
                            if inw_left > 0:
                                oil_or_holy = canon_name in {"Oil", "Holy Water"}
                                if (not is_magical_attack) and (not oil_or_holy):
                                    final_damage_b = 0
                                    inw_note_b = "immune (nonmagical)"
                                    mitig_note_b = (f"{mitig_note_b}; {inw_note_b}" if mitig_note_b else inw_note_b)
                    except Exception:
                        pass

                                 
                    dmg_line_b = base_line_b
                    if fav_bonus_b:
                        dmg_line_b += f"\n+ 3 (Favored Enemy) → ``{raw_for_mitigation_b}``"
                    if mitig_note_b:
                        dmg_line_b += f"\n→ **{mitig_note_b}** → ``{final_damage_b}``"

                                          
                    db_post_notes_b = []
                    db_applied_b = False

                    try:
                        bcfg_db = _load_battles()
                        ch_db = str(ctx.channel.id)
                        db_on = False
                        if bcfg_db and bcfg_db.has_section(ch_db):
                            try: slot_me = _slot(char_name)
                            except Exception: slot_me = char_name.replace(" ", "_")
                            db_on = (bcfg_db.getint(ch_db, f"{slot_me}.db", fallback=0) > 0)

                        is_melee_b    = _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle)
                        is_slashing_b = _is_slashing_weapon(canon_name, item)
                        if db_on and is_melee_b and is_slashing_b:
                            if self._is_living_cfg(t_cfg2):
                                final_damage_b += 1
                                db_applied_b = True
                                a_old_b = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                                a_max_b = getint_compat(atk_cfg, "max", "hp", fallback=a_old_b)
                                if a_old_b < a_max_b:
                                    atk_cfg["cur"]["hp"] = str(min(a_max_b, a_old_b + 1))
                                    write_cfg(atk_path, atk_cfg)
                                db_post_notes_b.append("🩸 Drainblade: +1")
                            else:
                                db_post_notes_b.append("Drainblade: no effect (nonliving)")
                    except Exception:
                        pass


                    if db_post_notes_b:
                        dmg_line_b += "\n" + " | ".join(db_post_notes_b)
                    if not mitig_note_b and not fav_bonus_b and db_applied_b:
                        dmg_line_b += f"\n→ ``{final_damage_b}``"

                    strike_added_b = 0
                    strike_lines_b = []

                    if hit_b and tgt_path and (not want_called) and (not want_wrestle) and (not is_oil) and (not is_holy):
                        try:
                            t_cfg_b2 = read_cfg(tgt_path)
                            bcfgS = _load_battles(); chS = str(ctx.channel.id)
                            namesS, _ = _parse_combatants(bcfgS, chS)
                            att_keyS = _find_ci_name(namesS, char_name) or char_name
                            try:
                                slot_meS = _slot(att_keyS)
                            except Exception:
                                slot_meS = att_keyS.replace(" ", "_")

                            is_melee_now = _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle)

                                                                                                                       
                            nd6 = bcfgS.getint(chS, f"{slot_meS}.strike_nd6", fallback=0)
                            if nd6 > 0 and is_melee_now:
                                s, rolls, flat = roll_dice(f"{nd6}d6")
                                raw = s + flat
                                s_final, s_note = _apply_mitigation(
                                    raw, weapon_name="Striking", weapon_type="magic",
                                    t_cfg=t_cfg_b2, is_magical=True
                                )
                                strike_added_b += s_final
                                msg = f"Striking: {nd6}d6 [{', '.join(map(str, rolls))}] → `{s_final}`"
                                if s_note: msg += f" ({s_note})"
                                strike_lines_b.append(msg)
                                for suf in ("strike_nd6","strike_expire_round"):
                                    opt = f"{slot_meS}.{suf}"
                                    if bcfgS.has_option(chS, opt):
                                        bcfgS.remove_option(chS, opt)
                                _save_battles(bcfgS)

                                                                                                   
                            until = bcfgS.getint(chS, f"{slot_meS}.strike_spell_until", fallback=0)
                            now_r = bcfgS.getint(chS, "round", fallback=0)
                            if until and now_r <= until:
                                spell_wpn = (bcfgS.get(chS, f"{slot_meS}.strike_weapon", fallback="") or "").strip()
                                if spell_wpn and normalize_name(spell_wpn) == normalize_name(canon_name):
                                    s, rolls, flat = roll_dice("1d6")
                                    raw = s + flat
                                    s_final, s_note = _apply_mitigation(
                                        raw, weapon_name="Striking (spell)", weapon_type="magic",
                                        t_cfg=t_cfg_b2, is_magical=True
                                    )
                                    strike_added_b += s_final
                                    msg = f"Striking (spell): 1d6 [{', '.join(map(str, rolls))}] → `{s_final}`"
                                    if s_note: msg += f" ({s_note})"
                                    strike_lines_b.append(msg)
                        except Exception:
                            pass

                                                         
                    if strike_added_b:
                        dmg_line_b += "\n" + " | ".join(strike_lines_b)
                        final_damage_b += strike_added_b
                        if not mitig_note_b and not fav_bonus_b and not db_applied_b:
                            dmg_line_b += f"\n→ ``{final_damage_b}``"

                    if pc_extra_eff.get("poison") == "saveordie" and hit_b:
                        if not tgt_path:
                            embed.add_field(name=f"Poison #{shot_idx}", value="No target file — cannot resolve save.", inline=False)
                            break

                        t_cfg_b = read_cfg(tgt_path)
                        try:
                            if not self._is_living_cfg(t_cfg_b):
                                embed.add_field(name=f"Poison #{shot_idx}", value="No effect (nonliving/undead).", inline=False)
                            else:
                                ok_b, sv_roll_b, sv_target_b, _ = self._roll_save(t_cfg_b, vs="poi", penalty=0)
                                if ok_b:
                                    embed.add_field(
                                        name=f"Poison #{shot_idx}",
                                        value=f"Save vs Death/Poison: {sv_roll_b} vs {sv_target_b} → **RESISTED**.",
                                        inline=False
                                    )
                                else:
                                                                                      
                                    old_b = getint_compat(t_cfg_b, "cur", "hp", fallback=0)
                                    t_cfg_b["cur"]["hp"] = "0"; write_cfg(tgt_path, t_cfg_b)

                                    if _is_monster_file(tgt_path):
                                        mhp_b = getint_compat(t_cfg_b, "max", "hp", fallback=old_b)
                                        bar_before = _life_bar(old_b, mhp_b, 10); bar_after = _life_bar(0, mhp_b, 10)
                                        embed.add_field(name=f"Poison #{shot_idx}", value=f"Save vs Death/Poison: {sv_roll_b} vs {sv_target_b} → **FAIL** — ☠️ **DEAD!**", inline=False)
                                        embed.add_field(name="Target HP", value=f"{bar_before} → **{bar_after}** ☠️ **DEAD!**", inline=False)
                                    else:
                                        embed.add_field(name=f"Poison #{shot_idx}", value=f"Save vs Death/Poison: {sv_roll_b} vs {sv_target_b} → **FAIL** — ☠️ **DEAD!**", inline=False)
                                        embed.add_field(name="Target HP", value=f"{old_b} → **0** ☠️ **DEAD!**", inline=False)

                                    try:
                                        await self._remove_from_battle_and_cleanup(ctx, display_target or primary_target, tgt_path)
                                    except Exception:
                                        pass

                                    await ctx.send(embed=embed)
                                    return                                    
                        except Exception:
                            pass

                                             
                    if hit_b and tgt_path and starlight_on:
                        try:
                            t_cfg_b = read_cfg(tgt_path)
                            if _is_undead_cfg(t_cfg_b, display_target or primary_target):
                                s, rolls, flat = roll_dice("1d6+1")
                                raw = s + flat
                                st_final_b, st_note_b = _apply_mitigation(
                                    raw, weapon_name="StarlightBlade", weapon_type="holy",
                                    t_cfg=t_cfg_b, is_magical=True
                                )
                                final_damage_b += st_final_b
                                add = f"StarlightBlade: 1d6+1 [{', '.join(map(str, rolls))}] → `{st_final_b}`"
                                if st_note_b: add += f" ({st_note_b})"
                                dmg_line_b += "\n+ " + add
                        except Exception:
                            pass

                                                                            
                    embed.add_field(name=f"Damage #{shot_idx}", value=dmg_line_b, inline=False)


                                               
                    try:
                        bcfg_ss = _load_battles()
                        ss_key  = _canon_init_key(bcfg_ss, chan_id, display_target or primary_target)
                        dmg_after_b, absorbed_b, remain_b, discharged_b = self._ss_absorb_by_name(bcfg_ss, chan_id, ss_key, final_damage_b)
                        if absorbed_b > 0:
                            line_b = f"Stoneskin absorbs **{absorbed_b}**. "
                            line_b += ("**DISCHARGED!**" if discharged_b else f"Remaining buffer: **{remain_b}**.")
                            embed.add_field(name=f"Stoneskin #{shot_idx}", value=line_b, inline=False)
                            final_damage_b = dmg_after_b
                    except Exception:
                        pass

                                  
                    old_hp_b = getint_compat(t_cfg2, "cur", "hp", fallback=0)
                    new_hp_b = max(0, old_hp_b - final_damage_b)
                    t_cfg2["cur"]["hp"] = str(new_hp_b)
                    write_cfg(tgt_path, t_cfg2)

                    killed_by_drain_b = False
                    if hit_b and tgt_path and weapon_drains > 0:
                        try:
                            t_cfg2_check = read_cfg(tgt_path)
                            is_living_b2 = True
                            try:
                                is_living_b2 = self._is_living_cfg(t_cfg2_check)
                            except Exception:
                                pass

                            if not is_living_b2:
                                embed.add_field(name=f"Energy Drain #{shot_idx}", value="No effect (nonliving/undead).", inline=False)
                            else:
                                pre_drain_hp_b = new_hp_b
                                drain_info_b = await self._auto_apply_negative_levels(
                                    ctx,
                                    display_target or primary_target,
                                    t_cfg2_check, tgt_path,
                                    n_levels=weapon_drains,
                                    source=f"{canon_name} (draining weapon) #{shot_idx}",
                                    embed=embed,
                                )
                                try:
                                    post_drain_hp_b = (drain_info_b or {}).get("hp_after", pre_drain_hp_b)
                                except Exception:
                                    post_drain_hp_b = pre_drain_hp_b

                                if (pre_drain_hp_b > 0 and post_drain_hp_b <= 0) or (pre_drain_hp_b > 0 and not os.path.exists(tgt_path)):
                                    killed_by_drain_b = True
                        except Exception:
                            pass

                                                                                   
                    if not killed_by_drain_b:
                        is_mon_b = _is_monster_file(tgt_path)
                        dead_note_b = " ☠️ **DEAD!**" if new_hp_b <= 0 else ""
                        if is_mon_b:
                            mhp_b = getint_compat(t_cfg2, "max", "hp", fallback=old_hp_b)
                            embed.add_field(
                                name=f"Target HP #{shot_idx}",
                                value=f"{_life_bar(old_hp_b, mhp_b, 10)} → **{_life_bar(new_hp_b, mhp_b, 10)}**{dead_note_b}",
                                inline=False
                            )
                        else:
                            embed.add_field(
                                name=f"Target HP #{shot_idx}",
                                value=f"{old_hp_b} → **{new_hp_b}**{dead_note_b}",
                                inline=False
                            )

                    if (hit_b is True) and (not killed_by_drain_b) and is_attacker_undead and pc_extra_eff:
                                         
                        if pc_extra_eff.get("heal"):
                            heal_amt_b = max(0, final_damage_b)
                            a_old_b = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                            a_max_b = getint_compat(atk_cfg, "max", "hp", fallback=a_old_b)
                            a_new_b = min(a_max_b, a_old_b + heal_amt_b)
                            if not atk_cfg.has_section("cur"): atk_cfg.add_section("cur")
                            atk_cfg["cur"]["hp"] = str(a_new_b); write_cfg(atk_path, atk_cfg)
                            embed.add_field(name=f"Leech #{shot_idx}", value=f"+**{heal_amt_b} HP**  •  {a_old_b} → **{a_new_b}** / {a_max_b}", inline=False)

                                                       
                        if pc_extra_eff.get("disease"):
                            try:
                                chance_b = int(pc_extra_eff.get("disease_chance", 100))
                            except Exception:
                                chance_b = 100
                            roll_pct_b = random.randint(1, 100)
                            if roll_pct_b <= max(0, min(100, chance_b)):
                                try:
                                    bcfg_b = _load_battles()
                                    if bcfg_b.has_section(chan_id):
                                        names_b, _ = _parse_combatants(bcfg_b, chan_id)
                                        key_b = _find_ci_name(names_b, display_target) or display_target
                                        try: slot_tgt_b = _slot(key_b)
                                        except Exception: slot_tgt_b = key_b.replace(" ", "_")
                                        if (pc_extra_eff.get("disease_kind") or "").lower() == "mummyrot":
                                            bcfg_b.set(chan_id, f"{slot_tgt_b}.mummyrot", "1")
                                            bcfg_b.set(chan_id, f"{slot_tgt_b}.noheal",   "1")
                                            _save_battles(bcfg_b)
                                            embed.add_field(name=f"Mummy Rot #{shot_idx}", value="Inflicted — **cannot benefit from healing** until cured.", inline=False)
                                        else:
                                            bcfg_b.set(chan_id, f"{slot_tgt_b}.disease", "1"); _save_battles(bcfg_b)
                                            embed.add_field(name=f"Disease #{shot_idx}", value="Inflicted.", inline=False)
                                except Exception:
                                    embed.add_field(name=f"Disease #{shot_idx}", value="Inflicted (state not saved due to error).", inline=False)
                            else:
                                embed.add_field(name=f"Disease #{shot_idx}", value=f"Chance roll **{roll_pct_b}%** > {chance_b}% — no infection.", inline=False)

                                                     
                        drain_mix_b = int(pc_extra_eff.get("leveldrain", 0) or 0)
                        if drain_mix_b > 0 and tgt_path:
                            try:
                                t_cfg_b = read_cfg(tgt_path)
                                await self._auto_apply_negative_levels(
                                    ctx,
                                    display_target or primary_target,
                                    t_cfg_b, tgt_path,
                                    n_levels=drain_mix_b,
                                    source=f"{canon_name} (draining touch) #{shot_idx}",
                                    embed=embed,
                                )
                            except Exception:
                                embed.add_field(name=f"Energy Drain #{shot_idx}", value="Couldn’t apply; GM may use `!drain ...`.", inline=False)

                                                    
                    if auto_called_applies_b and not killed_by_drain_b:
                        spec_pen_b = spec_dmg if (spec_applied and spec_dmg > 0) else 0
                        sv_ok_b, sv_roll_b, sv_target_b, sv_pen_b = self._roll_save(t_cfg2, vs="para", penalty=spec_pen_b)
                        pen_txt_b = f" - {sv_pen_b}" if sv_pen_b else ""
                        save_line_b = (f"Save vs Paralyze: {sv_roll_b}{pen_txt_b} vs {sv_target_b} → "
                                       f"**{'CALLED SHOT GOES OFF' if not sv_ok_b else 'RESISTED'}**")
                        embed.add_field(name=f"Heroic called shot (auto) #{shot_idx}", value=save_line_b, inline=False)

                                                                                      
                    if weapon_slot_for_corrosion and _is_melee_attack(is_rangedish, is_oil, is_holy, want_wrestle):
                        try:
                            t_cfg_for_specials_b = read_cfg(tgt_path)
                            await self._maybe_corrode_weapon_on_hit(
                                ctx,
                                attacker_cfg=atk_cfg, attacker_path=atk_path, attacker_name=atk_name,
                                target_cfg=t_cfg_for_specials_b, target_name=(display_target or primary_target),
                                weapon_slot=weapon_slot_for_corrosion, weapon_name=canon_name,
                                embed=embed,
                            )
                                                                   
                            try:
                                still = normalize_name(
                                    get_compat(read_cfg(atk_path), "eq", weapon_slot_for_corrosion, fallback="")
                                ) == normalize_name(canon_name)
                            except Exception:
                                still = True
                            if not still:
                                embed.add_field(name=f"Repeat #{shot_idx}", value="🧪 Weapon dissolved — stopping further attacks.", inline=False)
                                break
                        except Exception:
                            pass


                                                                         
                    if (_is_monster_file(tgt_path) and (new_hp_b <= 0 or killed_by_drain_b)):
                        try:
                            bcfg2 = _load_battles()
                            if bcfg2.has_section(str(ctx.channel.id)):
                                names2, scores2 = _parse_combatants(bcfg2, str(ctx.channel.id))
                                key2 = _find_ci_name(names2, display_target) or display_target
                                if key2 in names2:
                                    names2 = [n for n in names2 if n != key2]
                                    if bcfg2.has_option(str(ctx.channel.id), key2):
                                        bcfg2.remove_option(str(ctx.channel.id), key2)
                                    slot2 = _slot(key2) if '_slot' in globals() else key2.replace(" ", "_")
                                    for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                        opt2 = f"{slot2}{suf}"
                                        if bcfg2.has_option(str(ctx.channel.id), opt2):
                                            bcfg2.remove_option(str(ctx.channel.id), opt2)
                                    _write_combatants(bcfg2, str(ctx.channel.id), names2, scores2)
                                    if bcfg2.get(str(ctx.channel.id), "turn", fallback="") == key2:
                                        ents2 = _sorted_entries(bcfg2, str(ctx.channel.id))
                                        bcfg2.set(str(ctx.channel.id), "turn", ents2[0]["name"] if ents2 else "")
                                    _save_battles(bcfg2)
                            try: os.remove(os.path.abspath(tgt_path))
                            except Exception: pass
                        except Exception:
                            pass
                        break


                                                 
        try:
            bcfg = _load_battles()
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    bcfg = _load_battles() 
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        await ctx.send(embed=embed)





    def _infer_bps_from_attack_name(self, name: str | None) -> str | None:
        n = (name or "").strip().lower()
        if not n:                      
            return "bludgeoning"
        if n in _BLUDGEON_KWS:         return "bludgeoning"
        if n in _SLASH_KWS:            return "slashing"
        if n in _PIERCE_KWS:           return "piercing"
        if n.endswith("s") and n[:-1] in _SLASH_KWS:
            return "slashing"
        return None

    def _infer_monster_weapon_profile(self, attack_name: str | None) -> tuple[str | None, str | None]:
        """
        Returns (canon_weapon_name, bps_type) for monster 'attack_name'.
        Priority:
          1) If attack_name matches an item in item.lst -> use its type if it's B/P/S.
          2) Else use keyword sets above (unnamed/“slam” → bludgeoning, etc.)
        """
        canon: str | None = None
        bps: str | None = None

        n = (attack_name or "").strip()
        if n:
            try:
                canon_name, item = self._item_lookup(n)   
                
                if item:
                    typ = (item.get("type") or "").strip().lower()
                    if typ in {"bludgeoning","slashing","piercing"}:
                        bps = typ
                    canon = canon_name or n
            except Exception:
                pass

        if not bps:
            bps = self._infer_bps_from_attack_name(n)

        return canon, bps


    @commands.command(name="slam")
    async def slam(self, ctx, target: str, *, attack: str = ""):
        """Monster on its own turn attacks a target (charge/oil supported). Swarms auto-hit; unarmored double damage."""

        def _norm_attack(name: str) -> str:
            return re.sub(r"[^\w]+", "", (name or "").strip().lower())

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle running here. Use `!battle` first.")
            return

        turn_name = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
        if not turn_name:
            await ctx.send("❌ No one has the turn yet. Use `!n` to start the round.")
            return

                                                           
        atk_name, atk_path = _resolve_char_ci(turn_name)
        if not atk_path:
            await ctx.send(f"❌ Couldn’t find a character file for **{turn_name}**.")
            return
        if not _is_monster_file(atk_path):
            await ctx.send(f"❌ It is **{atk_name}**’s turn, but that is not a monster. Use `!a` for PCs.")
            return

        dm_id = (bcfg.get(chan_id, "DM", fallback="") or "").strip()
        is_gm = (str(ctx.author.id) == str(dm_id))

        controller_id = await _controller_id_for_monster(ctx, bcfg, chan_id, atk_name)
        is_controller = (controller_id and str(ctx.author.id) == str(controller_id))

        if not (is_gm or is_controller):
            owner_hint = f" <@{controller_id}>" if controller_id else ""
            await ctx.send(f"❌ Only the GM or the controller{owner_hint} can use `!slam` for **{atk_name}**.")
            return

                                          
        try:
            names_keyed, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names_keyed, atk_name) or atk_name
            slot_self = _slot(me_key)
        except Exception:
            slot_self = (atk_name or "").replace(" ", "_")

        opt_self_acpen = f"{slot_self}.acpen"
        if bcfg.has_option(chan_id, opt_self_acpen):
            bcfg.remove_option(chan_id, opt_self_acpen)
            _save_battles(bcfg)

                                      
        attacker_has_ts = False
        try:
            attacker_has_ts = self._true_seeing_active_for(bcfg, chan_id, atk_name)
        except Exception:
            pass

                               
        try:
            await self._apply_start_of_turn_oil(ctx, bcfg, chan_id, atk_name, atk_path)
            await self._apply_start_of_turn_web(ctx, bcfg, chan_id, atk_name, atk_path)
            await self._apply_start_of_turn_stoneskin(ctx, bcfg, chan_id, atk_name, atk_path)
        except Exception:
            pass

                                                          
        if attack is not None:
            toks = [t for t in re.split(r"\s+", f"{target} {attack}".strip()) if t]
        else:
            toks = [t for t in re.split(r"\s+", (target or "").strip()) if t]
        if len(toks) >= 2:
            first = toks[0]
            disp_first, path_first = _resolve_char_ci(first)
            if path_first and disp_first.lower() == atk_name.lower():
                target = toks[1]
                attack = " ".join(toks[2:]) if len(toks) > 2 else None

        names, _ = _parse_combatants(bcfg, chan_id)
        resolved, amb = _find_ci_or_partial_name(names, target)
        if not resolved:
            if amb:
                pretty = ", ".join(amb[:6]) + ("…" if len(amb) > 6 else "")
                await ctx.send(f"❌ Target '{target}' is ambiguous: {pretty}")
            else:
                await ctx.send(f"❌ Target '{target}' not found.")
            return
        target = resolved

                        
        tgt_name, tgt_path = _resolve_char_ci(target)
        if not tgt_path:
            await ctx.send(f"❌ Target '{target}' not found.")
            return

                                     
        try:
            self._conf_mark_if_targeted(chan_id, [tgt_name], by=atk_name)
        except Exception:
            pass

                          
        try:
            self._blur_clear_marks_for_attacker(bcfg, chan_id, slot_self)
        except Exception:
            pass

        want_charge = False
        want_oil = False
        want_flank = False
        splash_targets: list[str] = []
        try:
            names_to_wake = [tgt_name]
            if splash_targets:
                names_to_wake.extend(splash_targets)
            self._hyp_break_if_targeted(_section_id(ctx.channel), names_to_wake)
        except Exception:
            pass

        explicit_attack_name: str | None = None
        extra_hit_bonus = 0
        extra_dmg_spec = None
        extra_dmg_value = 0
        extra_dmg_rolls = []
        tokens = []
        if attack:
            tokens = [t for t in re.split(r"\s+", attack.strip()) if t]
            i = 0
            while i < len(tokens):
                tok = tokens[i].lower()
                if tok in _ADV_FLAGS:
                    want_flank = True
                    i += 1
                    continue
                if tok in ("-b", "-bonus") and i + 1 < len(tokens):
                    try:
                        extra_hit_bonus = int(tokens[i + 1].replace("+", "").strip())
                    except Exception:
                        extra_hit_bonus = 0
                    i += 2; continue
                if tok in ("-d", "-dmg", "-damage") and i + 1 < len(tokens):
                    raw = tokens[i + 1].strip()
                    extra_dmg_spec = raw
                    m = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+-]\s*\d+)?\s*", raw.lower())
                    if m:
                        try:
                            s, rolls, flat = roll_dice(raw)
                            extra_dmg_value = s + flat
                            extra_dmg_rolls = rolls
                        except Exception:
                            extra_dmg_value = 0; extra_dmg_rolls = []
                    else:
                        try:
                            extra_dmg_value = int(raw.replace("+", ""))
                        except Exception:
                            extra_dmg_value = 0
                    i += 2; continue
                if tok in ("charge", "-c", "-charge"):
                    want_charge = True; i += 1; continue
                if tok in ("oil", "flaskoil", "oilflask", "flaskofoil", "flask"):
                    want_oil = True; i += 1; continue
                if tok in ("-splash", "-sp", "splash"):
                    i += 1
                    while i < len(tokens):
                        splash_targets.append(tokens[i]); i += 1
                    break
                if explicit_attack_name and explicit_attack_name in _ADV_FLAGS:
                    explicit_attack_name = None
    
                if explicit_attack_name is None:
                    explicit_attack_name = tok
                i += 1
        
        flag_tokens = tokens if tokens else toks 
        want_flank = _has_adv_flag(flag_tokens)
        flank_hit_bonus = 2 if want_flank else 0
         
        def _bonuses_panel(include_charge: bool) -> str | None:
            lines = []
            if include_charge and want_charge:
                lines.append("Charge: +2 to hit; ×2 dmg on hit; attacker suffers –2 AC until next turn")
            if extra_hit_bonus:
                sign = "+" if extra_hit_bonus > 0 else "–"
                lines.append(f"Manual bonus: {sign}{abs(extra_hit_bonus)} to hit")
            if extra_dmg_spec:
                if extra_dmg_rolls:
                    rolls_txt = "[" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
                    lines.append(f"Extra damage: {extra_dmg_spec} {rolls_txt} → "
                                 f"{'+' if extra_dmg_value >= 0 else '–'}{abs(extra_dmg_value)}")
                else:
                    lines.append(f"Extra damage: {extra_dmg_spec} → "
                                 f"{'+' if extra_dmg_value >= 0 else '–'}{abs(extra_dmg_value)}")
            return "\n".join(lines) if lines else None

        atk_cfg = read_cfg(atk_path)
        tgt_cfg = read_cfg(tgt_path)
        bcfg = _load_battles()

                                 
        def _get_specials(cfg) -> str:
            out = []
            for sec in ("stats", "base", "info"):
                try:
                    v = (cfg.get(sec, "special", fallback="") or "")
                except Exception:
                    v = ""
                if v: out.append(v)
            return " ".join(out).lower()

        def _worn_armor_name(cfg) -> str:
            for sec in ("eq", "equipment", "items", "item", "base", "stats", "info"):
                try:
                    v = (cfg.get(sec, "armor1", fallback="") or cfg.get(sec, "armor", fallback="")).strip()
                except Exception:
                    v = ""
                if v and not v.isdigit():
                    return v
            return ""

        def _is_target_unarmored(effective_ac: int) -> (bool, str):
            name = _worn_armor_name(tgt_cfg)
            if name and name.strip().lower() not in {"", "none", "unarmored", "no armor"}:
                return (False, name)
            return (effective_ac < 15, "AC<15; no worn armor recorded")

                            
        # Monster attack bonus: use explicit stats.ab if present; otherwise HD-based table.
        hd = getint_compat(
            atk_cfg,
            "cur",
            "level",
            fallback=getint_compat(atk_cfg, "base", "hd", fallback=1),
        )
        hd = max(1, hd)

        try:
            raw_ab = get_compat(atk_cfg, "stats", "ab", fallback="")
            if str(raw_ab).strip():
                # Allow a hard-coded override on the monster entry.
                ab = int(raw_ab)
            else:
                # Default for monsters: use the HD → AB map from [monster] in class.lst.
                ab = self.monster_ab_for_hd(hd)
        except Exception:
            ab = self.monster_ab_for_hd(hd)


        blind_att_pen = 0

        try:
            if bcfg.getint(chan_id, f"{slot_self}.blind", fallback=0) > 0:
                blind_att_pen = -4
        except Exception:
            pass

                                                             
        try:
            inv_atk_bonus, inv_type_atk, inv_group_note = _attacker_invis_bonus_and_clear(
                bcfg, chan_id, atk_name, slot_self, atk_cfg
            )
        except Exception:
            inv_atk_bonus, inv_type_atk, inv_group_note = 0, "norm", None

        penalty = 0
        blur_or_disp_note = None
        primary_target = None
        try:
            attacker_has_ts = self._true_seeing_active_for(bcfg, chan_id, atk_name)
        except Exception:
            attacker_has_ts = False
        if attacker_has_ts:
            blur_or_disp_note = "True Seeing: ignores **Blur/Displacement** and sees through illusions."
        else:
            dp_pen, dp_note = self._displacement_penalty_for_attack(bcfg, chan_id, atk_name, slot_self, tgt_name or primary_target or "")
            if dp_pen:
                penalty += dp_pen; blur_or_disp_note = dp_note
            else:
                bl_pen, bl_note = self._blur_penalty_for_attack(bcfg, chan_id, atk_name, slot_self, tgt_name or primary_target or "")
                penalty += bl_pen; blur_or_disp_note = bl_note

        sick_att_pen = 0
        sick_note = None
        stn_left = 0
        stn_label = "Sickened"
        stn_emoji = ""
        try:
            sick_att_pen = bcfg.getint(chan_id, f"{slot_self}.stench_pen", fallback=0)
            stn_label = bcfg.get(chan_id, f"{slot_self}.stench_label", fallback=stn_label) or stn_label
            stn_emoji = bcfg.get(chan_id, f"{slot_self}.stench_emoji", fallback="") or ""
            stn_left = max(
                bcfg.getint(chan_id, f"{slot_self}.x_stenchn", fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.stn",    fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.stench", fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.sick",   fallback=0),
            )
        except Exception:
            pass
            
        if sick_att_pen == 0 and stn_left > 0:
            sick_att_pen = -2
        if sick_att_pen:
            sick_txt = f" {sick_att_pen:+} "
            sick_note = f"{(stn_emoji + ' ') if stn_emoji else ''}{stn_label}"
        else:
            sick_txt = ""
        nl_pen = 0
        try:
                                                                                        
            nl_candidates = [
                                        
                bcfg.getint(chan_id, f"{slot_self}.nl",              fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.neg_levels",      fallback=0),                                
                bcfg.getint(chan_id, f"{slot_self}.neglevels",       fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.neg_level",       fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.negative_levels", fallback=0),

                                                                  
                getint_compat(atk_cfg, "cur", "neg_levels",      fallback=0),
                getint_compat(atk_cfg, "cur", "negative_levels", fallback=0),
                getint_compat(atk_cfg, "cur", "neglevels",       fallback=0),
                getint_compat(atk_cfg, "cur", "nl",              fallback=0),
            ]
            nl_count = max(nl_candidates)
            if nl_count > 0:
                nl_pen = -int(nl_count)                                        
        except Exception:
            pass


        atk_type = ""

                                                                               
        target_ac, shield_bonus_applied, ac_defense_applied, blind_def_ac_pen, ma_bonus_applied, bs_bonus_applied =\
            self._defender_ac_with_buffs(bcfg, chan_id, tgt_name, want_oil=False, atk_type=atk_type or "")

        bless_bane_hit = 0
        bb_note = []
        bb_str = ""
        try:
            bcfg_bb = _load_battles()
            ch_bb = chan_id
            if bcfg_bb and bcfg_bb.has_section(ch_bb):
                names_bb, _ = _parse_combatants(bcfg_bb, ch_bb)
                me_key = _find_ci_name(names_bb, atk_name) or atk_name
                try: s_me = _slot(me_key)
                except Exception: s_me = me_key.replace(" ", "_")

                if bcfg_bb.getint(ch_bb, f"{s_me}.x_bless", fallback=0) > 0:
                    val = max(1, bcfg_bb.getint(ch_bb, f"{s_me}.bless_hit", fallback=1))
                    bless_bane_hit += val
                    bb_note.append(f"Bless: +{val} to hit")
                if bcfg_bb.getint(ch_bb, f"{s_me}.x_bane", fallback=0) > 0:
                    val = max(1, bcfg_bb.getint(ch_bb, f"{s_me}.bane_hit", fallback=1))
                    bless_bane_hit -= val
                    bb_note.append(f"Bane: −{val} to hit")

                if bless_bane_hit:
                    bb_str = (" + " if bless_bane_hit > 0 else " - ") + str(abs(bless_bane_hit))
        except Exception:
            pass


        if want_oil:
            d20 = random.randint(1, 20)



                                                                         
            total_to_hit = (
                d20 + ab
                + extra_hit_bonus
                + inv_atk_bonus                                                                     
                + blind_att_pen                                     
                + penalty                                   
                + sick_att_pen                            
                + nl_pen                                  
                + bless_bane_hit                                   
            )
            hit = (d20 == 20) or (d20 != 1 and total_to_hit >= target_ac)

            title = f"{atk_name} throws Oil! (vs {tgt_name})"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))


            d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
            hit_bonus_text = (f" + {extra_hit_bonus}" if extra_hit_bonus > 0 else
                              (f" - {abs(extra_hit_bonus)}" if extra_hit_bonus < 0 else ""))
            invis_txt = " + 4 (invis)" if inv_atk_bonus else ""
            blind_txt = " − 4" if blind_att_pen else ""
            nl_txt = (f" {nl_pen:+} (NL)" if nl_pen else "")
            sick_txt = (f" {sick_att_pen:+} " if sick_att_pen else "")

            embed.add_field(
                name="Attack roll",
                value=f"{d20_face} + {ab}{hit_bonus_text}{bb_str}{invis_txt}{blind_txt}{sick_txt}{nl_txt} = ``{total_to_hit}``",
                inline=True
            )
            embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                        
            if attacker_has_ts:
                embed.add_field(name="True Seeing", value="Ignores **Mirror Image** — strike lands on the real target.", inline=False)
            else:
                consumed, left = self._mi_consume_if_present(ctx, tgt_name)
                if consumed:
                    embed.add_field(name="Mirror Image", value=f"A figment is struck and shatters. Images remaining: **{left}**.", inline=False)
                    await ctx.send(embed=embed); return

                                                      
            if shield_bonus_applied:
                embed.add_field(name="Note", value=f"Target is under **Shield** (+{shield_bonus_applied} AC).", inline=False)
            if ac_defense_applied:
                embed.add_field(name="Note", value=f"Target has a defensive stance (+{ac_defense_applied} AC).", inline=False)
            if ma_bonus_applied:
                embed.add_field(name="Note", value=f"Target has **Mage Armor** (+{ma_bonus_applied} AC vs this attack).", inline=False)
            if bs_bonus_applied:
                embed.add_field(name="Note", value="Target has **Barkskin/Boneskin** (+4 AC).", inline=False)
            if blur_or_disp_note:
                embed.add_field(name="Displacement/Blur", value=blur_or_disp_note, inline=False)
            if sick_note:
                embed.add_field(name="Condition", value=sick_note, inline=False)

            if not hit:
                embed.add_field(name="Oil", value="Misses — no effect.", inline=False)
                await ctx.send(embed=embed); return

                                                                   
            s, rolls, flat = roll_dice("1d8")
            raw = s + flat + (extra_dmg_value or 0)
            final, note = _apply_mitigation(raw, weapon_name="Oil", weapon_type="fire", t_cfg=tgt_cfg, chan_id=str(ctx.channel.id), target_name=tgt_name)

            old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            max_hp_cap = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
            new_hp = old_hp - final
            new_hp = max(0, min(max_hp_cap, new_hp))
            tgt_cfg["cur"]["hp"] = str(new_hp); write_cfg(tgt_path, tgt_cfg)

            extra_txt = ""
            if extra_dmg_spec:
                if extra_dmg_rolls:
                    extra_txt = " + " + extra_dmg_spec + " [" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
                else:
                    extra_txt = f" {'+' if extra_dmg_value>=0 else '–'}{abs(extra_dmg_value)}"

            line = f"Primary {tgt_name}: 1d8 [{', '.join(str(r) for r in rolls)}]{extra_txt} = ``{raw}``"
            if note: line += f"\n→ **{note}** → ``{final}``"
            embed.add_field(name="🔥 Oil impact", value=line, inline=False)

            if new_hp > 0 and bcfg.has_section(chan_id):
                names_b, _ = _parse_combatants(bcfg, chan_id)
                if names_b:
                    name_key = _find_ci_name(names_b, tgt_name) or tgt_name
                    _add_oil_burn(bcfg, chan_id, name_key, 1)
                    embed.add_field(name="Ongoing", value=f"{tgt_name} will take **1d8 fire** at the start of their next turn.", inline=False)

            if _is_monster_file(tgt_path):
                mhp = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
            else:
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}**{dead_note}", inline=False)

                                         
            try:
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id); await msg.edit(content=content)
            except Exception:
                pass

            await ctx.send(embed=embed); return



        names_str = (self._gc(atk_cfg, "attacknames") or "")
        raw_names = [t.strip() for t in re.split(r"[,\s]+", names_str) if t.strip()]
        attack_list = [_norm_attack(t) for t in raw_names]
        disp_map = { _norm_attack(t): t for t in raw_names }

        chosen_attack = None
        dmg_spec = None

        def _read_attack_spec(name: str) -> str:
            name = (name or "").strip().lower()
            for key in (f"atk_{name}", f"dmg_{name}", f"{name}_dmg", f"{name}_atk", name, "damage", "dmg"):
                v = (self._gc(atk_cfg, key) or "").strip()
                if v:
                    return v
            return ""

        def _pick_from_list(want_norm: str) -> str | None:
            if want_norm in attack_list:
                return want_norm
            starts = [a for a in attack_list if a.startswith(want_norm)]
            if len(starts) == 1:
                return starts[0]
            subs = [a for a in attack_list if want_norm in a]
            if len(subs) == 1:
                return subs[0]
            best = difflib.get_close_matches(want_norm, attack_list, n=1, cutoff=0.8)
            return best[0] if best else None

        pretty_available = ", ".join(disp_map[a] for a in attack_list) if attack_list else None

        if explicit_attack_name:
            want = _norm_attack(explicit_attack_name)
            if attack_list:
                picked = _pick_from_list(want)
                if not picked:
                    if len([a for a in attack_list if want in a]) > 1:
                        amb = [disp_map[a] for a in attack_list if want in a][:6]
                        await ctx.send(f"❌ Attack '{explicit_attack_name}' is ambiguous for **{atk_name}**: {', '.join(amb)}")
                        return
                    await ctx.send(f"❌ **{atk_name}** doesn’t have an attack matching **{explicit_attack_name}**. Available: {pretty_available}.")
                    return
                chosen_attack = picked
                dmg_spec = _read_attack_spec(picked) or _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()
            else:
                dmg_spec = _read_attack_spec(want)
                if dmg_spec:
                    chosen_attack = want
                else:
                    chosen_attack = None
                    dmg_spec = _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()
        else:
            if attack_list:
                chosen_attack = attack_list[0]
                dmg_spec = _read_attack_spec(chosen_attack) or _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()
            else:
                chosen_attack = None
                dmg_spec = _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()

        fallback_note = None
        if not dmg_spec:
            dmg_spec = "1d6"
            fallback_note = (
                f"⚠️ No damage defined for '{(disp_map.get(chosen_attack) if chosen_attack else 'attack')}'. "
                f"Using 1d6 fallback."
            )

        atk_type = ""
        if chosen_attack:
            atk_type = (self._gc(atk_cfg, f"type_{chosen_attack}") or "").strip().lower()
        if not atk_type:
            atk_type = (self._gc(atk_cfg, "type") or "").strip().lower()
        try:
            TYPE_TOKENS = {"slashing","piercing","bludgeoning","fire","cold","electric","acid","force","holy","silver","magic","magical"}
            m = re.match(r"\s*\d+d\d+(?:\s*[+-]\s*\d+)?\s+([A-Za-z][\w-]*)\s*$", str(dmg_spec))
            if m and not atk_type:
                tok = m.group(1).lower()
                if tok in TYPE_TOKENS:
                    atk_type = tok
                    dmg_spec = re.sub(r"\s+[A-Za-z][\w-]*\s*$", "", str(dmg_spec)).strip()
        except Exception:
            pass


                  
        is_magical_attack = False
        try:
            typ = (atk_type or "").lower()
            if "mag" in typ or "magic" in typ:
                is_magical_attack = True
            if (chosen_attack or "") and "magic" in (chosen_attack or "").lower():
                is_magical_attack = True
        except Exception:
            pass


        is_swarm_attack = (str(chosen_attack or "").lower() == "swarm")

        enh_wep_hit = enh_wep_dmg = 0
        weak_wep_hit = weak_wep_dmg = 0
        try:
            bcfg_e = _load_battles()
            ch_e = str(ctx.channel.id)
            if bcfg_e and bcfg_e.has_section(ch_e):
                names_e, _ = _parse_combatants(bcfg_e, ch_e)
                me_key = _find_ci_name(names_e, atk_name) or atk_name
                try:
                    slot_me = _slot(me_key)
                except Exception:
                    slot_me = me_key.replace(" ", "_")

                enh_left = max(
                    bcfg_e.getint(ch_e, f"{slot_me}.enhwep",   fallback=0),
                    bcfg_e.getint(ch_e, f"{slot_me}.enh_wep",  fallback=0),
                )
                if enh_left > 0:
                    enh_bonus = max(
                        1,
                        bcfg_e.getint(ch_e, f"{slot_me}.enhwep_bonus", fallback=bcfg_e.getint(ch_e, f"{slot_me}.enh_wep_bonus", fallback=1))
                    )
                    enh_wep_hit = enh_bonus
                    enh_wep_dmg = enh_bonus

                weak_left = max(
                    bcfg_e.getint(ch_e, f"{slot_me}.weakwep",  fallback=0),
                    bcfg_e.getint(ch_e, f"{slot_me}.weak_wep", fallback=0),
                )
                if weak_left > 0:
                    weak_bonus = max(
                        1,
                        bcfg_e.getint(ch_e, f"{slot_me}.weakwep_bonus", fallback=bcfg_e.getint(ch_e, f"{slot_me}.weak_wep_bonus", fallback=1))
                    )
                    weak_wep_hit = -weak_bonus
                    weak_wep_dmg = -weak_bonus
        except Exception:
            pass


                                                       
        try:
            names_chk, _ = _parse_combatants(bcfg, chan_id)
            name_key_tgt = (_find_ci_name(names_chk, tgt_name) or tgt_name) if names_chk else tgt_name
            slot_tgt = _slot(name_key_tgt) if '_slot' in globals() else name_key_tgt.replace(" ", "_")
            opt_tgt_acpen = f"{slot_tgt}.acpen"
            turn_nm = bcfg.get(chan_id, "turn", fallback="")
            if name_key_tgt == turn_nm and bcfg.has_option(chan_id, opt_tgt_acpen):
                bcfg.remove_option(chan_id, opt_tgt_acpen); _save_battles(bcfg)
            elif bcfg.has_option(chan_id, opt_tgt_acpen):
                target_ac -= 2
        except Exception:
            pass

                                                        
        try:
            names_en, _ = _parse_combatants(bcfg, chan_id)
            key_en = _find_ci_name(names_en, tgt_name) or tgt_name
            try:
                slot_en = _slot(key_en)
            except Exception:
                slot_en = key_en.replace(" ", "_")

            enh_left = max(
                bcfg.getint(chan_id, f"{slot_en}.enharmor",   fallback=0),
                bcfg.getint(chan_id, f"{slot_en}.enh_armor",  fallback=0),          
            )
            weak_left = max(
                bcfg.getint(chan_id, f"{slot_en}.weakarmor",  fallback=0),
                bcfg.getint(chan_id, f"{slot_en}.weak_armor", fallback=0),          
            )
            if enh_left > 0:
                enh_mag = max(1, bcfg.getint(chan_id, f"{slot_en}.enharmor_bonus", fallback=1))
                target_ac += enh_mag
            if weak_left > 0:
                target_ac -= 1

        except Exception:
            pass


                                       
        gas_left = 0
        try:
            names_g, _ = _parse_combatants(bcfg, chan_id)
            key_g = _find_ci_name(names_g, tgt_name) or tgt_name
            s_tgt_g = _slot(key_g) if '_slot' in globals() else key_g.replace(" ", "_")
            gas_left = bcfg.getint(chan_id, f"{s_tgt_g}.gas", fallback=0)
            if gas_left > 0 and is_magical_attack:
                target_ac = 22
        except Exception:
            pass

                                                                  
        metalpierce_note = ""
        try:
            if (atk_type or "").lower() in {"metalpiercing", "metal-piercing", "piercemetal"}:
                armor_name = _worn_armor_name(tgt_cfg)
                n = armor_name.replace(" ", "").lower()
                metal_bonus = 7 if "plate" in n else 5 if "chain" in n else 0
                if metal_bonus > 0:
                    target_ac -= metal_bonus
                    metalpierce_note = f"Metal Piercing: ignores **{armor_name or 'metal armor'}** (−{metal_bonus} AC)."
        except Exception:
            pass

        flank_hit_bonus = 2 if want_flank else 0
        d20 = random.randint(1, 20)
        is_crit = (d20 == 20)
        d20_is1 = (d20 == 1)
        total_to_hit = d20 + ab + (2 if want_charge else 0) + extra_hit_bonus + inv_atk_bonus + blind_att_pen + penalty + sick_att_pen + nl_pen + enh_wep_hit + weak_wep_hit + flank_hit_bonus + bless_bane_hit
        hit = (d20 == 20) or (not d20_is1 and total_to_hit >= target_ac)

                                                      
        is_swarm_attack = (str(chosen_attack or "").lower() == "swarm")
        specials = _get_specials(atk_cfg)
        if is_swarm_attack:
            hit = True                        
            is_crit = False                   
            d20_is1 = False
            want_charge = False                                    
            penalty = 0                                              
            inv_atk_bonus = 0                               

        try:
            dmg_formula, extra_eff = self._parse_monster_attack_spec(dmg_spec) or (dmg_spec, {})
            if not isinstance(extra_eff, dict):
                extra_eff = {}
        except Exception:
            dmg_formula, extra_eff = dmg_spec, {}

        spec_lower = (dmg_spec or "").strip().lower()

                                         
        m_pure = re.fullmatch(r"(?:drain|energydrain|energy\s*drain|leveldrain)(?::?\s*(\d+))?", spec_lower)
        pure_drain = bool(m_pure)

                                                       
        m_transform = re.fullmatch(r"transform(?::\s*([\dd+\-\s]*d?[\d]+))?", spec_lower)
        is_transform = bool(m_transform)
        transform_override = (m_transform.group(1).replace(" ", "") if m_transform and m_transform.group(1) else None)

                                                                           
        no_damage = bool(extra_eff.get("nodmg"))

        if pure_drain:
            dmg_rolls = []
            base_damage = 0
            n = int(m_pure.group(1)) if (m_pure and m_pure.group(1)) else 1
            extra_eff = dict(extra_eff or {})
            extra_eff["leveldrain"] = max(1, n)

        elif no_damage:
            dmg_rolls = []
            base_damage = 0
            
        elif extra_eff.get("rotgrub"):
            base_damage = 0
            dmg_rolls = []                                                                        


        elif is_transform:
            dmg_rolls = []
            base_damage = 0
            extra_eff = dict(extra_eff or {})
            extra_eff["transform"] = transform_override or ""

        else:
            dice_sum, dmg_rolls, spec_flat = roll_dice(dmg_formula)
            precrit = dice_sum + spec_flat + (extra_dmg_value or 0)
            if not is_swarm_attack:
                precrit += enh_wep_dmg
                precrit += weak_wep_dmg
            base_damage = max(0, precrit)


        growth_mult = 1
        growth_note = None
        try:
            names_g, _ = _parse_combatants(bcfg, chan_id)
            me_key_g = _find_ci_name(names_g, atk_name) or atk_name
            try:
                slot_me_g = _slot(me_key_g)
            except Exception:
                slot_me_g = me_key_g.replace(" ", "_")

            growth_left = max(
                bcfg.getint(chan_id, f"{slot_me_g}.x_growanimal", fallback=0),
                bcfg.getint(chan_id, f"{slot_me_g}.growanimal",    fallback=0),                 
            )
            if growth_left > 0 and (not pure_drain):
                                                                                                     
                non_physical = {"fire","cold","electric","electricity","acid","force","holy","radiant","necrotic","poison","sonic","psychic"}
                if (not atk_type) or (atk_type not in non_physical):
                    growth_mult = 2
                    growth_note = "Growth of Animals: **×2 physical damage** (also grants **+2 natural AC** while active)."
        except Exception:
            pass


                                                            
        swarm_note = None
        if is_swarm_attack:
            unarm, why = _is_target_unarmored(target_ac)
                                                                                
            if unarm and ("noarmordouble" in specials or True):
                base_damage *= 2
                swarm_note = "Swarm vs **UNARMORED** (AC<15 & no armor): ×2 damage."

        mult = 1
        if is_crit: mult *= 2
        if want_charge and hit: mult *= 2                                                 
        applied_damage = base_damage * mult * growth_mult

               
        pretty_attack = disp_map.get(chosen_attack, chosen_attack) if 'disp_map' in locals() else chosen_attack
        title = (f"{atk_name} attacks {tgt_name} with {pretty_attack}!"
                 if chosen_attack else f"{atk_name} attacks {tgt_name} with slam!")
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        if is_swarm_attack:
            embed.add_field(name="Attack roll", value="— (auto-hit: **swarm**; no crit/charge; ignores Blur/Displacement)", inline=True)
        else:
            hit_bonus_text = (f" + {extra_hit_bonus}" if extra_hit_bonus > 0 else (f" - {abs(extra_hit_bonus)}" if extra_hit_bonus < 0 else ""))
            blind_txt = " − 4" if blind_att_pen else ""
            flank_str = " + 2" if want_flank else ""
            nl_txt = (f" {nl_pen:+} (NL)" if nl_pen else "")
            charge_note = " (+2 charge)" if want_charge else ""
            d20_face = "**20** 🎉" if is_crit else ("**1** 💀" if d20_is1 else str(d20))
            embed.add_field(
                name="Attack roll",
                value=f"{d20_face} + {ab}{charge_note}{hit_bonus_text}{bb_str}{(' + 4 (invis)' if inv_atk_bonus else '')}{blind_txt}{(f' {sick_att_pen:+} ' if sick_att_pen else '')}{nl_txt}{flank_str} = ``{total_to_hit}``",

                inline=True
            )
        embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                              
        pnm_on = self._pnm_active_for(bcfg, chan_id, tgt_name)
        if (not is_swarm_attack) and pnm_on and self._monster_attack_is_named_ranged(chosen_attack):
            embed.add_field(name="Protection from Normal Missiles", value="Normal missile is **negated** — no effect.", inline=False)
            await ctx.send(embed=embed)
            return

        if (not is_swarm_attack) and (not attacker_has_ts):
            consumed, left = self._mi_consume_if_present(ctx, tgt_name)
            if consumed:
                embed.add_field(name="Mirror Image", value=f"A figment is struck and shatters. Images remaining: **{left}**.", inline=False)
                await ctx.send(embed=embed)
                return
        elif (not is_swarm_attack) and attacker_has_ts:
            embed.add_field(name="True Seeing", value="Ignores **Mirror Image** — strike lands on the real target.", inline=False)

                                                                      
        if (not is_swarm_attack) and blur_or_disp_note:
            embed.add_field(name="Displacement/Blur", value=blur_or_disp_note, inline=False)
        if sick_note:
            embed.add_field(name="Condition", value=sick_note, inline=False)
        if ma_bonus_applied and (not is_swarm_attack):
            embed.add_field(name="Note", value=f"Target has **Mage Armor** (+{ma_bonus_applied} AC vs this attack).", inline=False)
      
        try:
            names_note, _ = _parse_combatants(bcfg, chan_id)
            def_key = _find_ci_name(names_note, tgt_name) or tgt_name
            try:
                slot_def = _slot(def_key)
            except Exception:
                slot_def = def_key.replace(" ", "_")
        except Exception:
            slot_def = tgt_name.replace(" ", "_")

                                             
        has_bark = max(
            bcfg.getint(chan_id, f"{slot_def}.barkskin",   fallback=0),
            bcfg.getint(chan_id, f"{slot_def}.x_barkskin", fallback=0),
        ) > 0
        has_bone = max(
            bcfg.getint(chan_id, f"{slot_def}.boneskin",   fallback=0),
            bcfg.getint(chan_id, f"{slot_def}.x_boneskin", fallback=0),
        ) > 0

        if bs_bonus_applied and (not is_swarm_attack):
            label = "Barkskin" if has_bark else "Boneskin"
            embed.add_field(name="Note", value=f"Target has **{label}** (+4 AC).", inline=False)

                                                               
        tree_left = max(
            bcfg.getint(chan_id, f"{slot_def}.tree",    fallback=0),
            bcfg.getint(chan_id, f"{slot_def}.x_tree",  fallback=0),
        )
        if tree_left > 0 and (not is_swarm_attack):
            embed.add_field(name="Note", value="Target is in **Tree Form** (+10 AC).", inline=False)

                                               
        try:
            names_en, _ = _parse_combatants(bcfg, chan_id)
            key_en = _find_ci_name(names_en, tgt_name) or tgt_name
            try:
                slot_en = _slot(key_en)
            except Exception:
                slot_en = key_en.replace(" ", "_")
            enh_left = bcfg.getint(chan_id, f"{slot_en}.enharmor", fallback=0)
            weak_left = bcfg.getint(chan_id, f"{slot_en}.weakarmor", fallback=0)
            if enh_left > 0 and (not is_swarm_attack):
                enh_mag = max(1, bcfg.getint(chan_id, f"{slot_en}.enharmor_bonus", fallback=1))
                embed.add_field(name="Note", value=f"Target has **Enhance Armor** (+{enh_mag} AC).", inline=False)
            if weak_left > 0 and (not is_swarm_attack):
                embed.add_field(name="Note", value="Target has **Weaken Armor** (−1 AC).", inline=False)

        except Exception:
            pass
                                                          
        try:
            if not is_swarm_attack:
                names_goa, _ = _parse_combatants(bcfg, chan_id)
                key_goa = _find_ci_name(names_goa, tgt_name) or tgt_name
                try:
                    s_tgt_goa = _slot(key_goa)
                except Exception:
                    s_tgt_goa = key_goa.replace(" ", "_")

                goa_left = max(
                    bcfg.getint(chan_id, f"{s_tgt_goa}.x_growanimal",      fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.growanimal",        fallback=0),          
                    bcfg.getint(chan_id, f"{s_tgt_goa}.x_growthanimals",   fallback=0),          
                    bcfg.getint(chan_id, f"{s_tgt_goa}.x_growthofanimals", fallback=0),          
                    bcfg.getint(chan_id, f"{s_tgt_goa}.growthanimals",     fallback=0),          
                    bcfg.getint(chan_id, f"{s_tgt_goa}.growthofanimals",   fallback=0),          
                    bcfg.getint(chan_id, f"{s_tgt_goa}.goa",               fallback=0),          
                )

                if goa_left > 0:
                    rounds_txt = f", {goa_left} rounds left" if goa_left else ""
                    embed.add_field(
                        name="Note",
                        value=f"Target is under **Growth of Animals** (+2 AC{rounds_txt}).",
                        inline=False
                    )
        except Exception:
            pass
            
        if ac_defense_applied and (not is_swarm_attack):
            embed.add_field(
                name="Defensive Stance",
                value=f"Target is in **Defensive Stance** ( +{ac_defense_applied} AC ).",
                inline=False
            )
            
        if gas_left > 0 and (not is_swarm_attack):
            embed.add_field(
                name="Gaseous Form",
                value="Defender is **Gaseous** — **AC 22 vs magical**; **immune to nonmagical weapons**.",
                inline=False
            )
        if metalpierce_note and (not is_swarm_attack):
            embed.add_field(name="Note", value=metalpierce_note, inline=False)
        if blind_def_ac_pen and (not is_swarm_attack):
            embed.add_field(name="Note", value="Defender is **BLINDED** (−4 AC).", inline=False)
        if blind_att_pen and (not is_swarm_attack):
            embed.add_field(name="Note", value="Attacker is **BLINDED** (−4 to hit).", inline=False)
        if is_swarm_attack:
            embed.add_field(name="Swarm", value="Area effect: **always hits**. Weapons can’t harm the swarm (defense-side), but this is outgoing swarm damage.", inline=False)
            if swarm_note:
                embed.add_field(name="Swarm Bonus", value=swarm_note, inline=False)
        if not is_swarm_attack:
            bp = _bonuses_panel(include_charge=True)
            if want_flank:
                bp = (bp + "\n" if bp else "") + "Flanking/Advantage: +2 to hit"
            if bb_note:
                bp = (bp + "\n" if bp else "") + "; ".join(bb_note)

            extra_lines = []
            if (enh_wep_hit or enh_wep_dmg):
                extra_lines.append(f"Enhanced Weapon: **+{enh_wep_hit or enh_wep_dmg}** to hit & damage")
            if (weak_wep_hit or weak_wep_dmg):
                extra_lines.append(f"Weakened Weapon: **−{abs(weak_wep_hit or weak_wep_dmg)}** to hit & damage")
            if extra_lines:
                bp = (bp + "\n" if bp else "") + "\n".join(extra_lines)

            if bp and not is_swarm_attack:
                embed.add_field(name="Bonuses", value=bp, inline=False)


        if growth_note:
            embed.add_field(name="Growth of Animals", value=growth_note, inline=False)


                     
        rolls_str = "[]" if pure_drain else "[" + ", ".join(str(r) for r in dmg_rolls) + "]"
        extra_txt = ""
        if extra_dmg_spec:
            if extra_dmg_rolls:
                extra_txt = " + " + extra_dmg_spec + " [" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
            else:
                extra_txt = f" {'+' if extra_dmg_value >= 0 else '–'}{abs(extra_dmg_value)}"

        head = None
        if mult == 4:
            head = "🔥 **CRIT + CHARGE!**"
        elif is_crit:
            head = "🔥 **CRITICAL HIT!**"
        elif want_charge and hit:
            head = "🏃 **CHARGE!**"

        formula = f"{dmg_spec} {rolls_str}{extra_txt}"
        if mult > 1:
            formula += f" × {mult}"
        if growth_mult > 1:
            formula += f" × {growth_mult} (Growth)"    
        base_line = (f"{head} {formula} = ``{applied_damage}``" if head else f"{formula} = ``{applied_damage}``")

        final_damage = applied_damage
        if hit and not pure_drain and not extra_eff.get("rotgrub"):
            canon_wep_name, bps_type = self._infer_monster_weapon_profile(chosen_attack)

            if (not atk_type) or (atk_type in {"bludgeoning","slashing","piercing"}):
                atk_type = bps_type or atk_type

        canon_wep_name, bps_type = self._infer_monster_weapon_profile(chosen_attack)
        if bps_type and bps_type in {"bludgeoning","slashing","piercing"}:
            atk_type = bps_type

        mitig, note = _apply_mitigation(
            applied_damage,
            weapon_name=(canon_wep_name or chosen_attack or None),
            weapon_type=("swarm" if is_swarm_attack else atk_type),
            t_cfg=tgt_cfg
        )
        final_damage = mitig
        if note:
            base_line += f"\n→ **{note}** → ``{final_damage}``"

        if hit and not is_transform and not pure_drain and not extra_eff.get("rotgrub"):
            embed.add_field(name="Damage", value=base_line, inline=False)


                                                                                         
        try:
            if hit and (not is_swarm_attack) and gas_left > 0 and not is_magical_attack:
                final_damage = 0
                base_line += f"\n→ **immune (Gaseous Form)** → ``{final_damage}``"
        except Exception:
            pass

                                                             
                                                                                                         

        if hit and chosen_attack and (not is_swarm_attack) and self._monster_has_ghoul_paralysis(atk_cfg, atk_name, chosen_attack):
                                                   
            if self._is_elf_pure(tgt_cfg):
                embed.add_field(
                    name="Paralysis",
                    value="❌ No effect — **Elves are immune** to ghoul/ghast paralysis.",
                    inline=False
                )
            else:
                                                                                                  
                ok, sv_roll, sv_dc, used_vs = self._roll_save(tgt_cfg, vs="para", penalty=0)
                if sv_dc is None:
                    ok, sv_roll, sv_dc, used_vs = self._roll_save(tgt_cfg, vs="pet", penalty=0)
                    used_vs = "pet"

                if ok:
                    embed.add_field(
                        name="Paralysis",
                        value=f"Save vs {self._sv_label(used_vs)}: {sv_roll} vs {sv_dc} → ✅ **RESISTED**.",
                        inline=False
                    )
                else:
                                                                       
                    total, rolls, flat = roll_dice("2d8")
                    turns = max(0, total + flat)
                    rounds = turns * 60
                    self._extend_paralyzed_timer(bcfg, chan_id, tgt_name, rounds)

                    embed.add_field(
                        name="Paralysis",
                        value=(f"Save vs {self._sv_label(used_vs)}: "
                               f"{sv_roll if sv_roll is not None else '—'} vs {sv_dc if sv_dc is not None else '—'} "
                               f"→ **FAIL**\n"
                               f"⛓️ **{tgt_name}** is **PARALYZED** for **{turns} turn(s)** "
                               f"({rounds} rounds) [{', '.join(str(r) for r in rolls)}]."),
                        inline=False
                    )

                                                                                                                                            

        if (
            hit and tgt_path
            and (extra_eff.get("paralysis") or extra_eff.get("paralyze"))
            and not self._monster_has_ghoul_paralysis(atk_cfg, atk_name, chosen_attack)
        ):
                                                                                                
            ok, sv_roll, sv_dc, used_tag = self._best_save_vs_paralysis(tgt_cfg)
                                                                                               
            if sv_dc is None:
                ok = False

                                                                                         
            dur_expr = (str(
                extra_eff.get("paralysis_turns")
                or extra_eff.get("paralysis_dur")
                or "1d4"
            )).strip()

            if ok:
                embed.add_field(
                    name="Paralysis",
                    value=f"Save vs {self._sv_label(used_tag)}: {sv_roll} vs {sv_dc} → ✅ **RESISTED**.",
                    inline=False
                )
            else:
                turns, t_rolls = self._roll_paralysis_turns(dur_expr, default_turns=1)
                rounds = turns * 60
                self._extend_paralyzed_timer(bcfg, chan_id, tgt_name, rounds)

                rolls_txt = f" [{', '.join(str(r) for r in t_rolls)}]" if t_rolls else ""
                embed.add_field(
                    name="Paralysis",
                    value=(f"Save vs {self._sv_label(used_tag)}: "
                           f"{sv_roll if sv_roll is not None else '—'} vs {sv_dc if sv_dc is not None else '—'} "
                           f"→ **FAIL**\n"
                           f"⛓️ **{tgt_name}** is **PARALYZED** for **{turns} turn(s)** ({rounds} rounds){rolls_txt}."),
                    inline=False
                )

                              
        new_hp = None
        if hit and not pure_drain and not extra_eff.get("rotgrub"):
            old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)

                                                                                                                                    
            try:
                names_keyed, _ = _parse_combatants(bcfg, chan_id)
                name_key = (_find_ci_name(names_keyed, tgt_name) or tgt_name) if names_keyed else tgt_name
                try:
                    slot_tgt = _slot(name_key)
                except Exception:
                    slot_tgt = name_key.replace(" ", "_")

                dmg_after, absorbed, remain, discharged = self._ss_absorb_by_name(
                    bcfg, chan_id, slot_tgt, final_damage
                )
                if absorbed > 0:
                    embed.add_field(
                        name="Stoneskin",
                        value=(f"Stoneskin absorbs **{absorbed}**. "
                               + ("**DISCHARGED!**" if discharged else f"Remaining buffer: **{remain}**.")),
                        inline=False,
                    )
                    final_damage = dmg_after
            except Exception as e:
                embed.add_field(name="Stoneskin (error)", value=f"{type(e).__name__}: {e}", inline=False)

            new_hp = max(0, old_hp - final_damage)
            tgt_cfg["cur"]["hp"] = str(new_hp); write_cfg(tgt_path, tgt_cfg)
                                                                                        
            try:
                await self._aaf_revert_if_slain(ctx, bcfg, chan_id, tgt_name, tgt_cfg, tgt_path, embed)
            except Exception:
                pass

            is_mon_target = _is_monster_file(tgt_path)
            dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
            if is_mon_target:
                mhp = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
            else:
                embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}**{dead_note}", inline=False)

        if hit and extra_eff.get("stun") and tgt_path:
            try:
                                                                       
                try:
                    if _is_undead_cfg(tgt_cfg, tgt_name):
                        embed.add_field(name="Stun", value="☠️ Undead — **no effect**.", inline=False)
                        raise RuntimeError("no_stun_effect")
                except Exception:
                    pass
                try:
                    if self._poison_immune(tgt_cfg):
                        embed.add_field(name="Stun", value="🧪 Poison-immune — **no effect**.", inline=False)
                        raise RuntimeError("no_stun_effect")
                except Exception:
                    pass

                                                                              
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                bonus = int(extra_eff.get("save_bonus", 0))
                total = (sv_roll or 0) + bonus
                sv_ok = (total >= sv_dc) if sv_dc is not None else False
                btxt = (f" {'+' if bonus>=0 else ''}{bonus}" if bonus else "")

                if sv_ok:
                    embed.add_field(
                        name="Stun",
                        value=f"Save vs Poison: {sv_roll}{btxt} vs {sv_dc} → ✅ **RESISTED**.",
                        inline=False
                    )
                else:
                    rounds = int(extra_eff.get("stun_rounds", 60))
                    self._extend_paralyzed_timer(bcfg, chan_id, tgt_name, rounds)
                    embed.add_field(
                        name="Stun",
                        value=(f"Save vs Poison: {sv_roll}{btxt} vs {sv_dc} → **FAIL**\n"
                               f"💫 **{tgt_name}** is **STUNNED** *(paralyzed)* for **{rounds}** rounds."),
                        inline=False
                    )
                    try:
                        if bcfg and bcfg.has_section(chan_id):
                            await self._update_tracker_message(ctx, bcfg, chan_id)
                    except Exception:
                        pass

            except RuntimeError as e:
                if str(e) != "no_stun_effect":
                    pass


        if hit and extra_eff.get("constrict") and tgt_path:
                                                                              
            cur_hp_after_bite = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_bite > 0:
                cons_die = (extra_eff.get("constrict_dice") or "2d4").strip()

                                       
                s_c, rolls_c, flat_c = roll_dice(cons_die)
                raw_c = s_c + flat_c

                                                 
                cons_final, cons_note = _apply_mitigation(raw_c, weapon_name="Constriction", weapon_type="bludgeoning", t_cfg=tgt_cfg)

                                 
                old_hp_c = cur_hp_after_bite
                new_hp_c = max(0, old_hp_c - cons_final)
                if not tgt_cfg.has_section("cur"):
                    tgt_cfg.add_section("cur")
                tgt_cfg["cur"]["hp"] = str(new_hp_c)
                write_cfg(tgt_path, tgt_cfg)

                                                                        
                if _is_monster_file(tgt_path):
                    mhp_c = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp_c)
                    before_c = _life_bar(old_hp_c, mhp_c, width=10)
                    after_c  = _life_bar(new_hp_c, mhp_c, width=10)
                    hp_line_c = f"{before_c} → **{after_c}**"
                else:
                    hp_line_c = f"{old_hp_c} → **{new_hp_c}**"

                            
                dmg_line_c = f"{cons_die} [{', '.join(str(r) for r in rolls_c)}]"
                if cons_note:
                    dmg_line_c += f" → **{cons_final}** ({cons_note})"
                else:
                    dmg_line_c += f" → **{cons_final}**"

                                                                           
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                                    
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                      
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                   
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                                             
                        bcfg.set(chan_id, f"{s_def}.x_constrict", "-1")                                           
                        bcfg.set(chan_id, f"{s_def}.x_constrict_label", "COIL")                                        
                        bcfg.set(chan_id, f"{s_def}.x_constrict_code", "perm")
                        bcfg.set(chan_id, f"{s_def}.x_constrict_dice", cons_die)
                        bcfg.set(chan_id, f"{s_def}.x_constrict_by", att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                    
                coil_note = (f"{dmg_line_c}\nHP {hp_line_c}\n"
                             f"🐍 **HOLD ESTABLISHED** — {tgt_name} is **HELD** by **{atk_name}** "
                             f"and will take **{cons_die}** each round thereafter (use `!escape` to break).")
                if new_hp_c <= 0:
                    coil_note += "  ☠️ **DEAD!**"
                embed.add_field(name="Constriction", value=coil_note, inline=False)

        if hit and extra_eff.get("holdbite") and tgt_path:
            cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_hit > 0:
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                 
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                   
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                                         
                        die = (extra_eff.get("holdbite_dice") or "1d4").strip()
                        bcfg.set(chan_id, f"{s_def}.x_holdbite", "-1")
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_label", "WORRY")
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_code", "perm")
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_dice", die)
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_by", att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                                                                       
                embed.add_field(
                    name="Hold",
                    value=(f"🐕 **HOLD ESTABLISHED** — {tgt_name} is **HELD** by **{atk_name}** and will take "
                           f"**{(extra_eff.get('holdbite_dice') or '1d4').strip()}** automatically each round "
                           f"until killed or `!escape` succeeds."),
                    inline=False
                )

        if hit and extra_eff.get("leech") and tgt_path:
            cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_hit > 0:
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                                                      
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                       
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                                                           
                        die = (extra_eff.get("leech_dice") or "1d6").strip()
                        bcfg.set(chan_id, f"{s_def}.x_leech", "-1")
                        bcfg.set(chan_id, f"{s_def}.x_leech_label", "LEECH")
                        bcfg.set(chan_id, f"{s_def}.x_leech_code",  "perm")
                        bcfg.set(chan_id, f"{s_def}.x_leech_dice",  die)
                        bcfg.set(chan_id, f"{s_def}.x_leech_by",    att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                    
                embed.add_field(
                    name="Attach",
                    value=(f"🩸 **ATTACHED** — {tgt_name} is latched onto by **{atk_name}** and will lose "
                           f"**{(extra_eff.get('leech_dice') or '1d6').strip()}** blood each round.\n"
                           f"`!escape` **does not work**; only killing the monster removes it."),
                    inline=False
                )


                                                                      
        if hit and extra_eff.get("entangle") and tgt_path:
            cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_hit > 0:
                vine_die = (extra_eff.get("entangle_dice") or "1d8").strip()

                                                                                  
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                      
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                   
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                   
                        bcfg.set(chan_id, f"{s_def}.x_entangle", "-1")                                       
                        bcfg.set(chan_id, f"{s_def}.x_entangle_label", "VINE")                                    
                        bcfg.set(chan_id, f"{s_def}.x_entangle_code", "perm")
                        bcfg.set(chan_id, f"{s_def}.x_entangle_dice", vine_die)
                        bcfg.set(chan_id, f"{s_def}.x_entangle_by", att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                    
                embed.add_field(
                    name="Entangle",
                    value=(f"🌿 **HOLD ESTABLISHED** — {tgt_name} is **ENTANGLED** by **{atk_name}** "
                           f"and will take **{vine_die}** each round thereafter (use `!escape` to break)."),
                    inline=False
                )

        if extra_eff.get("rotgrub"):
                                                                               
            disp_def, def_path = _resolve_char_ci(tgt_name) 
            if def_path:
                t_cfg = read_cfg(def_path)

                                                                                      
                try:
                    WIS = getint_compat(t_cfg, "stats", "wis", fallback=10)
                except Exception:
                    WIS = 10

                                                                                               
                try:
                                                                      
                    wis_mod = _osr_mod_from_score(WIS)
                except Exception:
                                              
                    wis_mod = (
                        -3 if WIS <= 3 else
                        -2 if WIS <= 5 else
                        -1 if WIS <= 8 else
                         0 if WIS <= 12 else
                         1 if WIS <= 15 else
                         2 if WIS <= 17 else
                         3
                    )

                ok0, roll, dc, pen = self._roll_save(t_cfg, vs="poi", penalty=0)
                total = roll + wis_mod
                noticed = (total >= dc)

                                                                                    
 
                death_in_rounds = random.randint(1, 3) * 60

                                                                                     
                try:
                    cur = int(bcfg.get(chan_id, f"{slot_def}.x_rotgrub", fallback="0"))
                except Exception:
                    cur = 0
                death_in_rounds = max(cur, death_in_rounds) if cur > 0 else death_in_rounds

                                                                                                                    
                burn_window = 2

                                                        
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                slot_def = _slot(tgt_name)

                bcfg.set(chan_id, f"{slot_def}.x_rotgrub", str(death_in_rounds))
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_burn", str(burn_window))
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_label", "Rot Grubs")
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_emoji", "🪱")
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_code", "DIS")                                 
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_by",   atk_name if atk_name else (atk_name or "Unknown"))
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_notice", "1" if noticed else "0")
                _save_battles(bcfg)

                                     
                title = f"🪱 Rot Grubs: {disp_def or tgt_name} is infested!"
                desc  = (f"Save vs Death/Poison — 1d20 **{roll}** "
                         f"{'+' + str(wis_mod) if wis_mod>=0 else str(wis_mod)} vs **{dc}** → ")
                desc += ("**NOTICED**." if noticed else "**not noticed**.")
                desc += (f"\n• Burn/Cut window: **{burn_window}** rounds"
                         f"\n• Death in: **{death_in_rounds}** rounds (1d3 turns)")
                await ctx.send(embed=nextcord.Embed(
                    title=title,
                    description=desc,
                    color=random.randint(0, 0xFFFFFF)
                ))


                                                                                          
        if hit and extra_eff.get("swallow") and tgt_path:
                                                                                 
            thresh = int(extra_eff.get("swallow_thresh", 19))
            roll_ok = (d20 >= thresh)                       

                                                                                    
            size_ok = (True if extra_eff.get("swallow_any") else _pc_is_small(tgt_cfg))

            if roll_ok and size_ok:
                cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
                if cur_hp_after_hit > 0:
                    try:
                        bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                        if bcfg and bcfg.has_section(chan_id):
                            names_b, _ = _parse_combatants(bcfg, chan_id)
                            att_key = _find_ci_name(names_b, atk_name) or atk_name
                            def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                            try: s_att = _slot(att_key)
                            except Exception: s_att = att_key.replace(" ", "_")
                            try: s_def = _slot(def_key)
                            except Exception: s_def = def_key.replace(" ", "_")

                                                                                               
                            prev = (bcfg.get(chan_id, f"{s_att}.holds", fallback="") or "").strip()
                            if prev:
                                try: s_prev = _slot(prev)
                                except Exception: s_prev = prev.replace(" ", "_")
                                prev_sw = (bcfg.get(chan_id, f"{s_prev}.x_swallow", fallback="") or "").strip()
                                if prev_sw:
                                    embed.add_field(
                                        name="Swallow Whole",
                                        value=f"Already **swallowing** {prev} — cannot swallow another.",
                                        inline=False
                                    )
                                else:
                                                                          
                                    if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                        bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                                    bcfg.remove_option(chan_id, f"{s_att}.holds")

                                                                 
                            if not prev or not (bcfg.get(chan_id, f"{_slot(prev)}.x_swallow", fallback="") or "").strip():
                                bcfg.set(chan_id, f"{s_att}.holds", def_key)
                                bcfg.set(chan_id, f"{s_def}.heldby", att_key)
                                die = (extra_eff.get("swallow_dice") or "1d8").strip()
                                bcfg.set(chan_id, f"{s_def}.x_swallow", "-1")                            
                                bcfg.set(chan_id, f"{s_def}.x_swallow_label", "GULLET")
                                bcfg.set(chan_id, f"{s_def}.x_swallow_code", "perm")
                                bcfg.set(chan_id, f"{s_def}.x_swallow_dice", die)
                                bcfg.set(chan_id, f"{s_def}.x_swallow_by", att_key)
                                _save_battles(bcfg)

                                embed.add_field(
                                    name="Swallow Whole",
                                    value=(f"🫗 **{tgt_name} is SWALLOWED** by **{atk_name}**\n"
                                           f"• Takes **{die}** at the **start** of their turns.\n"
                                           f"• `!escape` **does not work** while swallowed.\n"
                                           f"• May attack from inside only with a small cutting/stabbing weapon (e.g., dagger)."),
                                    inline=False
                                )
                    except Exception:
                        pass


                                                                                 
        if hit and extra_eff.get("poison"):
            try:
                                          
                try:
                    if _is_undead_cfg(tgt_cfg, tgt_name):
                        embed.add_field(name="Poison", value="☠️ Undead — **no effect**.", inline=False)
                        raise RuntimeError("no_poison_effect")
                except Exception:
                    pass
                try:
                    if self._poison_immune(tgt_cfg):
                        embed.add_field(name="Poison", value="🧪 Poison-immune — **no effect**.", inline=False)
                        raise RuntimeError("no_poison_effect")
                except Exception:
                    pass

                                                                                               
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                bonus = int(extra_eff.get("save_bonus", 0))
                total = (sv_roll or 0) + bonus
                if sv_dc is None:
                    sv_ok = False
                else:
                    sv_ok = (total >= sv_dc)

                             
                btxt  = (f" {'+' if bonus >= 0 else ''}{bonus}" if bonus != 0 else "")
                if sv_ok:
                    embed.add_field(
                        name="Poison",
                        value=f"Save vs Poison: {sv_roll}{btxt} vs {sv_dc} → ✅ **RESISTED**.",
                        inline=False
                    )
                else:
                                   
                    old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
                    mhp    = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
                    tgt_cfg.setdefault("cur", {})
                    tgt_cfg["cur"]["hp"] = "0"
                    write_cfg(tgt_path, tgt_cfg)
                    new_hp = 0                                               

                                                        
                    if _is_monster_file(tgt_path):
                        try:
                            before = _life_bar(old_hp, mhp, width=10)
                            after  = _life_bar(0,     mhp, width=10)
                            hp_line = f"{before} → **{after}**"
                        except Exception:
                            hp_line = f"{old_hp} → **0**"
                    else:
                        hp_line = f"{old_hp} → **0**"                

                    btxt  = (f" {'+' if bonus >= 0 else ''}{bonus}" if bonus != 0 else "")
                    sv_num = sv_roll if sv_roll is not None else "—"
                    sv_dc_txt = sv_dc if sv_dc is not None else "—"

                    embed.add_field(
                        name="Poison",
                        value=f"Save vs Poison: {sv_num}{btxt} vs {sv_dc_txt} → **FAIL**\n{hp_line}  ☠️ **DEAD!**",
                        inline=False
                    )

                    
            except RuntimeError as e:
                if str(e) != "no_poison_effect":
                                                                                
                    pass

        if hit and extra_eff.get("venom_kind") and tgt_path:
            try:
                            
                try:
                    if _is_undead_cfg(tgt_cfg, tgt_name):
                        embed.add_field(name="Venom", value="☠️ Undead — **no effect**.", inline=False)
                        raise RuntimeError("no_venom_effect")
                except Exception:
                    pass
                try:
                    if self._poison_immune(tgt_cfg):
                        embed.add_field(name="Venom", value="🧪 Poison-immune — **no effect**.", inline=False)
                        raise RuntimeError("no_venom_effect")
                except Exception:
                    pass

                                                                    
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                bonus = int(extra_eff.get("save_bonus", 2))
                total = (sv_roll or 0) + bonus
                if sv_dc is None:
                    sv_ok = False
                else:
                    sv_ok = (total >= sv_dc)

                kind = (extra_eff.get("venom_kind") or "").lower()                     
                die  = (extra_eff.get("venom_die")  or "1d6").strip()
                dur_expr = (extra_eff.get("venom_dur") or "2d4").strip()
                dur_n = _dice_sum(dur_expr)

                if sv_ok:
                    pace = "rounds" if kind == "fast" else "turns"
                    embed.add_field(
                        name="Venom",
                        value=f"Save vs Poison: {sv_roll} +{bonus} vs {sv_dc} → ✅ **RESISTED** (no {pace} damage).",
                        inline=False
                    )
                else:
                                 
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        s_def   = _slot(def_key)

                                                                                        
                        label = "FV" if kind == "fast" else "SV"
                        if kind == "fast":
                            bcfg.set(chan_id, f"{s_def}.x_fastvenom", str(max(1, dur_n)))                              
                            bcfg.set(chan_id, f"{s_def}.x_fastvenom_dice", die)
                            bcfg.set(chan_id, f"{s_def}.x_fastvenom_label", label)
                        else:
                                                                        
                            bcfg.set(chan_id, f"{s_def}.x_slowvenom", str(max(60, dur_n * 60)))
                            bcfg.set(chan_id, f"{s_def}.x_slowvenom_dice", die)
                            bcfg.set(chan_id, f"{s_def}.x_slowvenom_label", label)
                        _save_battles(bcfg)


                    pace = "each **round**" if kind == "fast" else "each **turn**"
                    embed.add_field(
                        name="Venom",
                        value=(f"Save vs Poison: {sv_roll} +{bonus} vs {sv_dc} → **FAIL**\n"
                               f"🧪 **{tgt_name}** will take **{die}** {pace} for **{dur_n}** "
                               f"{'rounds' if kind=='fast' else 'turns'}."),
                        inline=False
                    )
            except RuntimeError as e:
                if str(e) != "no_venom_effect":
                    pass

        if hit and extra_eff.get("burn"):
            pdie = (extra_eff.get("burn_die") or "3d10").strip()
            await self._apply_burn_on_hit(ctx, bcfg, chan_id, atk_name, tgt_name, tgt_cfg, embed, burn_die=pdie)

        try:
            if hit and (
                extra_eff.get("dance") or
                extra_eff.get("dancepoison") or
                (" dance" in f" {spec_lower} ")                                           
            ):
                await self._apply_dance_poison_on_hit(ctx, bcfg, chan_id, atk_name, tgt_name, tgt_cfg, embed, primary=True)
        except Exception:
            pass

        if hit and (is_transform or extra_eff.get("transform")) and tgt_path:
                                                                                       
            rounds = None
            override = (transform_override or extra_eff.get("transform") or "").strip()
            if override:
                                            
                try:
                    s_val, _rolls_val, flat_val = roll_dice(override)
                    rounds = max(1, s_val + flat_val)
                except Exception:
                    rounds = None
            if rounds is None:
                s4, rolls4, flat4 = roll_dice("1d4")
                rounds = 6 + s4 + flat4

                                                               
            try:
                bcfg2 = _load_battles(); ch2 = _section_id(ctx.channel)
                if bcfg2 and bcfg2.has_section(ch2):
                    names2, _ = _parse_combatants(bcfg2, ch2)
                    def_key2 = _find_ci_name(names2, tgt_name) or tgt_name
                    try: s_def2 = _slot(def_key2)
                    except Exception: s_def2 = def_key2.replace(" ", "_")

                                                                           
                    existing = bcfg2.getint(ch2, f"{s_def2}.x_transform", fallback=0)
                    new_left = max(existing, rounds)

                    bcfg2.set(ch2, f"{s_def2}.x_transform", str(new_left))
                    bcfg2.set(ch2, f"{s_def2}.x_transform_label", "JELLY")
                    bcfg2.set(ch2, f"{s_def2}.x_transform_code", "timer")                                     
                    bcfg2.set(ch2, f"{s_def2}.x_transform_by", atk_name)
                    bcfg2.set(ch2, f"{s_def2}.x_transform_type", "greenjelly")
                    bcfg2.set(ch2, f"{s_def2}.x_transform_grace", "1")                                
                    _save_battles(bcfg2)

                    rolls_txt = f" [{', '.join(str(r) for r in (rolls4 if rounds and not override else []))}]" if not override else ""
                    embed.add_field(
                        name="Green Jelly",
                        value=(f"🧪 **CLINGS!** {tgt_name} will **transform** in **{new_left}** rounds{rolls_txt} unless removed.\n"
                               f"• First round: can be scraped off (destroys tool). Thereafter: freeze/burn/cut away (same damage to both).\n"
                               f"• **Cure Disease** destroys a patch.\n"
                               f"• Use `!ds {tgt_name} transform` if removed (GM adjudicates)."),
                        inline=False
                    )
            except Exception:
                pass

        if hit and extra_eff.get("dissolvearmor") and tgt_path:
                                                                            
            try:
                bcfg2 = _load_battles(); ch2 = _section_id(ctx.channel)
                if bcfg2 and bcfg2.has_section(ch2):
                    names2, _ = _parse_combatants(bcfg2, ch2)
                    def_key = _find_ci_name(names2, tgt_name) or tgt_name
                    try: s_def2 = _slot(def_key)
                    except Exception: s_def2 = def_key.replace(" ", "_")
                    die = (extra_eff.get("dissolve_dice") or "2d8").strip()
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve", "-1")                                      
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_label", "ACID")                         
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_code", "perm")
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_dice", die)
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_by", atk_name)
                    _save_battles(bcfg2)
                    embed.add_field(name="Acid", value=f"🧪 **STUCK** — {tgt_name} will take **{die}** automatically each round.", inline=False)
            except Exception:
                pass

                                                                               
            try:
                await self._dissolve_body_armor(ctx, tgt_name, tgt_cfg, tgt_path, embed=embed, reason="Dissolve Armor")
                                                                                                           
                tgt_cfg = read_cfg(tgt_path)
            except Exception:
                embed.add_field(name="Dissolve Armor", value="⚠️ Error adjudicating armor melt (GM decides).", inline=False)


        if hit and extra_eff.get("petrify"):
                                           
            def _save_vs_petrify_best(t_cfg):
                                                                                     
                for tag in ("para", "pet", "parapet"):
                    ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                    if dc is not None:
                        return ok, roll, dc
                ok, roll, dc, pen = self._roll_save(t_cfg, vs="spell", penalty=0)
                return ok, roll, dc                           

            def _is_constructish_cfg(t_cfg, disp: str) -> bool:
                try:
                    blob = " ".join([
                        (get_compat(t_cfg, "base", "type", fallback="") or ""),
                        (get_compat(t_cfg, "info", "race", fallback="") or ""),
                        (disp or ""),
                    ]).lower()
                    for kw in ("construct", "golem", "animated object", "statue"):
                        if kw in blob:
                            return True
                except Exception:
                    pass
                return False

                                            
            try:
                if _is_undead_cfg(tgt_cfg, tgt_name):
                    embed.add_field(name="Petrification", value="☠️ Undead — **no effect**.", inline=False)
                               
                elif _is_constructish_cfg(tgt_cfg, tgt_name):
                    embed.add_field(name="Petrification", value="🛠️ Construct — **no effect**.", inline=False)
                else:
                                                             
                    try:
                        names_note, _ = _parse_combatants(bcfg, chan_id)
                        def_key = _find_ci_name(names_note, tgt_name) or tgt_name
                        try: slot_def_local = _slot(def_key)
                        except Exception: slot_def_local = def_key.replace(" ", "_")
                    except Exception:
                        slot_def_local = (locals().get("slot_def") or tgt_name.replace(" ", "_"))

                    already = (
                        bcfg.getint(chan_id, f"{slot_def_local}.pet_perm", fallback=0) > 0
                        or bcfg.getint(chan_id, f"{slot_def_local}.pet",      fallback=0) > 0
                    )
                    if already:
                        embed.add_field(name="Petrification", value="Already **Petrified** — no effect.", inline=False)
                    else:
                        ok, sv_roll, sv_dc = _save_vs_petrify_best(tgt_cfg)
                        if sv_dc is None:
                            ok = False                                                                       

                        if ok:
                            embed.add_field(
                                name="Petrification",
                                value=f"Save vs Petrification: {sv_roll} vs {sv_dc} → ✅ **RESISTED**.",
                                inline=False
                            )
                        else:
                                                        
                            bcfg.set(chan_id, f"{slot_def_local}.pet_perm", "1")
                            bcfg.set(chan_id, f"{slot_def_local}.pet_by", f"{atk_name} ({(chosen_attack or 'attack')})")
                            _save_battles(bcfg)
                            sv_txt = f"{sv_roll} vs {sv_dc}" if sv_dc is not None else "—"
                            embed.add_field(
                                name="Petrification",
                                value=f"Save vs Petrification: {sv_txt} → **FAIL** — **PETRIFIED** `[PET –]`.",
                                inline=False
                            )
            except Exception:
                pass

        
        if hit:
            if extra_eff.get("heal"):
                atk_old_hp = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                atk_max_hp = getint_compat(atk_cfg, "max", "hp", fallback=atk_old_hp)
                heal_amt = max(0, applied_damage)
                atk_new_hp = min(atk_max_hp, atk_old_hp + heal_amt)
                if not atk_cfg.has_section("cur"):
                    atk_cfg.add_section("cur")
                atk_cfg["cur"]["hp"] = str(atk_new_hp)
                write_cfg(atk_path, atk_cfg)
                before_bar = _life_bar(atk_old_hp, atk_max_hp, width=10)
                after_bar = _life_bar(atk_new_hp, atk_max_hp, width=10)
                embed.add_field(
                    name="Leech",
                    value=(f"{atk_name} regenerates **{heal_amt} HP**\n"
                           f"HP: {before_bar} → **{after_bar}**"),
                    inline=False
                )

            con_loss = int(extra_eff.get("conloss", 0))
            if con_loss > 0:
                tgt_con_now = getint_compat(tgt_cfg, "stats", "con", fallback=0)
                if tgt_con_now <= 0:
                    embed.add_field(name="Constitution Drain", value="Target has no recorded CON; GM adjudicates.", inline=False)
                else:
                    allow_save = False
                    try:
                        allow_save = self._is_elf_or_dwarf(tgt_cfg)
                    except Exception:
                        allow_save = False

                    resisted = False
                    if allow_save:
                        ok, roll, dc, _pen = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                        if ok:
                            resisted = True
                            embed.add_field(name="Constitution Drain", value=f"Save vs Death: {roll} vs {dc} → **RESISTED**.", inline=False)

                    if not resisted:
                        hp_delta = self._apply_conloss_points(tgt_cfg, con_loss)
                        write_cfg(tgt_path, tgt_cfg)
                        cur_con, temp, perm, peak, base = self._get_con_state(tgt_cfg)
                        v = (f"**-{con_loss} CON** (temp). Current CON: **{cur_con}**  •  Temp loss: {temp}  •  Permanent loss: {perm}")
                        if hp_delta != 0:
                            v += f"\nMax HP {'+' if hp_delta > 0 else ''}{hp_delta} due to CON mod change."
                            cur_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
                            max_hp = getint_compat(tgt_cfg, "max", "hp", fallback=cur_hp)
                            if cur_hp > max_hp:
                                v += f" Current HP clamped to {max_hp}."
                        v += "\nVictim appears aged."
                        embed.add_field(name="Constitution Drain", value=v, inline=False)

        str_loss = int(extra_eff.get("strloss", 0))
        if hit and str_loss > 0:
            applied, died, collapsed = self._apply_strloss_points(tgt_cfg, str_loss)
            write_cfg(tgt_path, tgt_cfg)
            eff_str = getint_compat(tgt_cfg, "stats", "str", fallback=None)
            parts = [f"**−{applied} STR**"]
            if eff_str is not None:
                parts.append(f"(now STR {eff_str})")
            if died:
                parts.append("☠️ **Death (STR 0)** — may rise as a shadow at next nightfall (GM).")
            elif collapsed:
                parts.append("**Collapsed** (STR ≤ 2): can’t move until STR recovers (1/turn).")
            embed.add_field(name="Strength Drain", value=" ".join(parts), inline=False)

                                                   

        if hit:
            drain_n = _extract_level_drain(dmg_spec, extra_eff)
            if drain_n > 0:
                try:
                    tgt_cfg = read_cfg(tgt_path)
                    await self._auto_apply_negative_levels(
                        ctx,
                        tgt_name, tgt_cfg, tgt_path,
                        n_levels=drain_n,
                        source=f"{atk_name} {(chosen_attack or 'attack')}",
                        embed=embed,
                    )
                except Exception as e:
                    embed.add_field(
                        name="Energy Drain",
                        value=(f"{drain_n} negative level(s) **not applied** due to an error; "
                               f"GM may run `!drain {tgt_name} {drain_n}`. ({type(e).__name__})"),
                        inline=False
                    )

                                                                         
        if want_charge and bcfg.has_section(chan_id):
            names_c, _ = _parse_combatants(bcfg, chan_id)
            if atk_name in names_c:
                bcfg.set(chan_id, f"{slot_self}.acpen", "-2"); _save_battles(bcfg)

 
                                    
        if tgt_path and hit and (new_hp is not None) and new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    name_key = _find_ci_name(names, tgt_name) or tgt_name
                    if name_key in names:
                        names = [n for n in names if n != name_key]
                        if bcfg.has_option(chan_id, name_key): bcfg.remove_option(chan_id, name_key)
                        slot = _slot(name_key)
                        for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == name_key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

                         
        try:
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    bcfg = _load_battles()
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        await ctx.send(embed=embed)


    @commands.command(name="aoo")
    async def attack_of_opportunity(self, ctx, attacker: str, target: str, *, opts: str = ""):
        """Monster AoO. Swarms auto-hit; unarmored double damage. Keeps PFNM, GAS, Stoneskin, drains, etc."""
        

        def _norm_attack(name: str) -> str:
            return re.sub(r"[^\w]+", "", (name or "").strip().lower())

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle running here. Use `!battle` first.")
            return

        atk_name, atk_path = _resolve_char_ci(attacker)
        if not atk_path:
            await ctx.send(f"❌ Attacker '{attacker}' not found.")
            return
        if not _is_monster_file(atk_path):
            await ctx.send(f"❌ **{atk_name}** is not a monster. Use `!a` for PCs.")
            return


        names, _ = _parse_combatants(bcfg, chan_id)
        resolved, amb = _find_ci_or_partial_name(names, target)
        if not resolved:
            if amb:
                pretty = ", ".join(amb[:6]) + ("…" if len(amb) > 6 else "")
                await ctx.send(f"❌ Target '{target}' is ambiguous: {pretty}")
            else:
                await ctx.send(f"❌ Target '{target}' not found.")
            return
        target = resolved
        
        tgt_name, tgt_path = _resolve_char_ci(target)
        if not tgt_path:
            await ctx.send(f"❌ Target '{target}' not found.")
            return

        dm_id = (bcfg.get(chan_id, "DM", fallback="") or "").strip()
        is_gm = (str(ctx.author.id) == str(dm_id))

        controller_id = await _controller_id_for_monster(ctx, bcfg, chan_id, atk_name)
        is_controller = (controller_id and str(ctx.author.id) == str(controller_id))

        if not (is_gm or is_controller):
            owner_hint = f" <@{controller_id}>" if controller_id else ""
            await ctx.send(f"❌ Only the GM or the controller{owner_hint} can use `!aoo` for **{atk_name}**.")
            return

        try:
            names_keyed, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names_keyed, atk_name) or atk_name
            slot_self = _slot(me_key)
        except Exception:
            me_key = atk_name
            slot_self = me_key.replace(" ", "_")

        try:
            self._conf_mark_if_targeted(chan_id, [tgt_name], by=atk_name)
        except Exception:
            pass

        try:
            self._blur_clear_marks_for_attacker(bcfg, chan_id, slot_self)
        except Exception:
            pass

        want_charge = False
        want_oil = False
        splash_targets: list[str] = []
        try:
            names_to_wake = [tgt_name]
            if splash_targets:
                names_to_wake.extend(splash_targets)
            self._hyp_break_if_targeted(chan_id, names_to_wake)
        except Exception:
            pass

        explicit_attack_name: str | None = None
        extra_hit_bonus = 0
        extra_dmg_spec = None
        extra_dmg_value = 0
        extra_dmg_rolls = []

        
        tokens = [t for t in re.split(r"\s+", (opts or "").strip()) if t]
        i = 0
        while i < len(tokens):
            tok = tokens[i].lower()
            if tok in _ADV_FLAGS:
                want_flank = True
                i += 1
                continue
            if tok in ("-b", "-bonus") and i + 1 < len(tokens):
                try:
                    extra_hit_bonus = int(tokens[i + 1].replace("+", "").strip())
                except Exception:
                    extra_hit_bonus = 0
                i += 2; continue
            if tok in ("-d", "-dmg", "-damage") and i + 1 < len(tokens):
                raw = tokens[i + 1].strip()
                extra_dmg_spec = raw
                m = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+-]\s*\d+)?\s*", raw.lower())
                if m:
                    try:
                        s, rolls, flat = roll_dice(raw)
                        extra_dmg_value = s + flat
                        extra_dmg_rolls = rolls
                    except Exception:
                        extra_dmg_value = 0; extra_dmg_rolls = []
                else:
                    try:
                        extra_dmg_value = int(raw.replace("+", ""))
                    except Exception:
                        extra_dmg_value = 0
                i += 2; continue
            if tok in ("charge", "-c", "-charge"):
                want_charge = True; i += 1; continue
            if tok in ("oil", "flaskoil", "oilflask", "flaskofoil", "flask"):
                want_oil = True; i += 1; continue
            if tok in ("-splash", "-sp", "splash"):
                i += 1
                while i < len(tokens):
                    splash_targets.append(tokens[i]); i += 1
                break
            if explicit_attack_name and explicit_attack_name in _ADV_FLAGS:
                explicit_attack_name = None    
            if explicit_attack_name is None:
                explicit_attack_name = tok
            i += 1

        want_flank = _has_adv_flag(tokens)
        flank_hit_bonus = 2 if want_flank else 0  

        def _bonuses_panel(include_charge: bool) -> str | None:
            lines = []
            if include_charge and want_charge:
                lines.append("Charge: +2 to hit; ×2 dmg on hit; attacker suffers –2 AC until next turn")
            if extra_hit_bonus:
                sign = "+" if extra_hit_bonus > 0 else "–"
                lines.append(f"Manual bonus: {sign}{abs(extra_hit_bonus)} to hit")
            if extra_dmg_spec:
                if extra_dmg_rolls:
                    rolls_txt = "[" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
                    lines.append(f"Extra damage: {extra_dmg_spec} {rolls_txt} → "
                                 f"{'+' if extra_dmg_value >= 0 else '–'}{abs(extra_dmg_value)}")
                else:
                    lines.append(f"Extra damage: {extra_dmg_spec} → "
                                 f"{'+' if extra_dmg_value >= 0 else '–'}{abs(extra_dmg_value)}")
            return "\n".join(lines) if lines else None

        atk_cfg = read_cfg(atk_path)
        tgt_cfg = read_cfg(tgt_path)

        def _get_specials(cfg) -> str:
            out = []
            for sec in ("stats", "base", "info"):
                try:
                    v = (cfg.get(sec, "special", fallback="") or "")
                except Exception:
                    v = ""
                if v: out.append(v)
            return " ".join(out).lower()

        def _worn_armor_name(cfg) -> str:
            for sec in ("eq", "equipment", "items", "item", "base", "stats", "info"):
                try:
                    v = (cfg.get(sec, "armor1", fallback="") or cfg.get(sec, "armor", fallback="")).strip()
                except Exception:
                    v = ""
                if v and not v.isdigit():
                    return v
            return ""

        def _is_target_unarmored(effective_ac: int) -> (bool, str):
            name = _worn_armor_name(tgt_cfg)
            if name and name.strip().lower() not in {"", "none", "unarmored", "no armor"}:
                return (False, name)
            return (effective_ac < 15, "AC<15; no worn armor recorded")

        # Monster attack bonus: use explicit stats.ab if present; otherwise HD-based table.
        hd = getint_compat(
            atk_cfg,
            "cur",
            "level",
            fallback=getint_compat(atk_cfg, "base", "hd", fallback=1),
        )
        hd = max(1, hd)

        try:
            raw_ab = get_compat(atk_cfg, "stats", "ab", fallback="")
            if str(raw_ab).strip():
                # Allow a hard-coded override on the monster entry.
                ab = int(raw_ab)
            else:
                # Default for monsters: use the HD → AB map from [monster] in class.lst.
                ab = self.monster_ab_for_hd(hd)
        except Exception:
            ab = self.monster_ab_for_hd(hd)

        attacker_has_ts = False
        try:
            attacker_has_ts = self._true_seeing_active_for(bcfg, chan_id, atk_name)
        except Exception:
            pass

        try:
            inv_atk_bonus, inv_type_atk, inv_group_note = _attacker_invis_bonus_and_clear(
                bcfg, chan_id, atk_name, slot_self, atk_cfg
            )
        except Exception:
            inv_atk_bonus, inv_type_atk, inv_group_note = 0, "norm", None

        blind_att_pen = 0
        try:
            if bcfg.getint(chan_id, f"{slot_self}.blind", fallback=0) > 0:
                blind_att_pen = -4
        except Exception:
            pass

        penalty = 0
        blur_or_disp_note = None
        if attacker_has_ts:
            blur_or_disp_note = "True Seeing: ignores **Blur/Displacement** and sees through illusions."
        else:
            dp_pen, dp_note = self._displacement_penalty_for_attack(bcfg, chan_id, atk_name, slot_self, tgt_name)
            if dp_pen:
                penalty += dp_pen; blur_or_disp_note = dp_note
            else:
                bl_pen, bl_note = self._blur_penalty_for_attack(bcfg, chan_id, atk_name, slot_self, tgt_name)
                penalty += bl_pen; blur_or_disp_note = bl_note

        sick_att_pen = 0
        sick_note = None
        stn_left = 0
        stn_label = "Sickened"
        stn_emoji = ""
        try:
            sick_att_pen = bcfg.getint(chan_id, f"{slot_self}.stench_pen", fallback=0)
            stn_label = bcfg.get(chan_id, f"{slot_self}.stench_label", fallback=stn_label) or stn_label
            stn_emoji = bcfg.get(chan_id, f"{slot_self}.stench_emoji", fallback="") or ""
            stn_left = max(
                bcfg.getint(chan_id, f"{slot_self}.x_stenchn", fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.stn",    fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.stench", fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.sick",   fallback=0),
            )
        except Exception:
            pass
        if sick_att_pen == 0 and stn_left > 0:
            sick_att_pen = -2
        if sick_att_pen:
            sick_txt = f" {sick_att_pen:+} "
            sick_note = f"{(stn_emoji + ' ') if stn_emoji else ''}{stn_label}"
        else:
            sick_txt = ""

        nl_pen = 0
        try:
            nl_candidates = [
                bcfg.getint(chan_id, f"{slot_self}.nl",              fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.neg_levels",      fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.neglevels",       fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.neg_level",       fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.negative_levels", fallback=0),
                getint_compat(atk_cfg, "cur", "neg_levels",      fallback=0),
                getint_compat(atk_cfg, "cur", "negative_levels", fallback=0),
                getint_compat(atk_cfg, "cur", "neglevels",       fallback=0),
                getint_compat(atk_cfg, "cur", "nl",              fallback=0),
            ]
            nl_count = max(nl_candidates)
            if nl_count > 0:
                nl_pen = -int(nl_count)
        except Exception:
            pass

        atk_type = ""

        target_ac, shield_bonus_applied, ac_defense_applied, blind_def_ac_pen, ma_bonus_applied, bs_bonus_applied =\
            self._defender_ac_with_buffs(bcfg, chan_id, tgt_name, want_oil=False, atk_type=atk_type or "")

        bless_bane_hit = 0
        bb_note = []
        bb_str = ""
        try:
            bcfg_bb = _load_battles()
            ch_bb = chan_id
            if bcfg_bb and bcfg_bb.has_section(ch_bb):
                names_bb, _ = _parse_combatants(bcfg_bb, ch_bb)
                me_key = _find_ci_name(names_bb, atk_name) or atk_name
                try: s_me = _slot(me_key)
                except Exception: s_me = me_key.replace(" ", "_")

                if bcfg_bb.getint(ch_bb, f"{s_me}.x_bless", fallback=0) > 0:
                    val = max(1, bcfg_bb.getint(ch_bb, f"{s_me}.bless_hit", fallback=1))
                    bless_bane_hit += val
                    bb_note.append(f"Bless: +{val} to hit")
                if bcfg_bb.getint(ch_bb, f"{s_me}.x_bane", fallback=0) > 0:
                    val = max(1, bcfg_bb.getint(ch_bb, f"{s_me}.bane_hit", fallback=1))
                    bless_bane_hit -= val
                    bb_note.append(f"Bane: −{val} to hit")

                if bless_bane_hit:
                    bb_str = (" + " if bless_bane_hit > 0 else " - ") + str(abs(bless_bane_hit))
        except Exception:
            pass

        if want_oil:
            d20 = random.randint(1, 20)
            total_to_hit = (
                d20 + ab
                + extra_hit_bonus
                + inv_atk_bonus
                + blind_att_pen
                + penalty
                + sick_att_pen
                + nl_pen
                + bless_bane_hit
            )
            hit = (d20 == 20) or (d20 != 1 and total_to_hit >= target_ac)

            title = f"{atk_name} throws Oil! (vs {tgt_name})"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

            bp = _bonuses_panel(include_charge=False)
            if bb_note:
                bp = (bp + "\n" if bp else "") + "; ".join(bb_note)
            if bp:
                embed.add_field(name="Bonuses", value=bp, inline=False)

            d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
            hit_bonus_text = (f" + {extra_hit_bonus}" if extra_hit_bonus > 0 else
                              (f" - {abs(extra_hit_bonus)}" if extra_hit_bonus < 0 else ""))
            invis_txt = " + 4 (invis)" if inv_atk_bonus else ""
            blind_txt = " − 4" if blind_att_pen else ""
            nl_txt = (f" {nl_pen:+} (NL)" if nl_pen else "")
            sick_txt = (f" {sick_att_pen:+} " if sick_att_pen else "")

            embed.add_field(
                name="Attack roll",
                value=f"{d20_face} + {ab}{hit_bonus_text}{bb_str}{invis_txt}{blind_txt}{sick_txt}{nl_txt} = ``{total_to_hit}``",
                inline=True
            )
            embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

            if attacker_has_ts:
                embed.add_field(name="True Seeing", value="Ignores **Mirror Image** — strike lands on the real target.", inline=False)
            else:
                consumed, left = self._mi_consume_if_present(ctx, tgt_name)
                if consumed:
                    embed.add_field(name="Mirror Image", value=f"A figment is struck and shatters. Images remaining: **{left}**.", inline=False)
                    await ctx.send(embed=embed); return

            if shield_bonus_applied:
                embed.add_field(name="Note", value=f"Target is under **Shield** (+{shield_bonus_applied} AC).", inline=False)
            if ac_defense_applied:
                embed.add_field(name="Note", value=f"Target has a defensive stance (+{ac_defense_applied} AC).", inline=False)
            if ma_bonus_applied:
                embed.add_field(name="Note", value=f"Target has **Mage Armor** (+{ma_bonus_applied} AC vs this attack).", inline=False)
            if bs_bonus_applied:
                embed.add_field(name="Note", value="Target has **Barkskin/Boneskin** (+4 AC).", inline=False)
            if blur_or_disp_note:
                embed.add_field(name="Displacement/Blur", value=blur_or_disp_note, inline=False)
            if sick_note:
                embed.add_field(name="Condition", value=sick_note, inline=False)

            if not hit:
                embed.add_field(name="Oil", value="Misses — no effect.", inline=False)
                await ctx.send(embed=embed); return

            s, rolls, flat = roll_dice("1d8")
            raw = s + flat + (extra_dmg_value or 0)
            final, note = _apply_mitigation(raw, weapon_name="Oil", weapon_type="fire", t_cfg=tgt_cfg, chan_id=str(ctx.channel.id), target_name=tgt_name)

            old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            max_hp_cap = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
            new_hp = old_hp - final
            new_hp = max(0, min(max_hp_cap, new_hp))
            tgt_cfg["cur"]["hp"] = str(new_hp); write_cfg(tgt_path, tgt_cfg)

            extra_txt = ""
            if extra_dmg_spec:
                if extra_dmg_rolls:
                    extra_txt = " + " + extra_dmg_spec + " [" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
                else:
                    extra_txt = f" {'+' if extra_dmg_value>=0 else '–'}{abs(extra_dmg_value)}"

            line = f"Primary {tgt_name}: 1d8 [{', '.join(str(r) for r in rolls)}]{extra_txt} = ``{raw}``"
            if note: line += f"\n→ **{note}** → ``{final}``"
            embed.add_field(name="🔥 Oil impact", value=line, inline=False)

            if new_hp > 0 and bcfg.has_section(chan_id):
                names_b, _ = _parse_combatants(bcfg, chan_id)
                if names_b:
                    name_key = _find_ci_name(names_b, tgt_name) or tgt_name
                    _add_oil_burn(bcfg, chan_id, name_key, 1)
                    embed.add_field(name="Ongoing", value=f"{tgt_name} will take **1d8 fire** at the start of their next turn.", inline=False)

            if _is_monster_file(tgt_path):
                mhp = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
            else:
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}**{dead_note}", inline=False)

            try:
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id); await msg.edit(content=content)
            except Exception:
                pass

            await ctx.send(embed=embed); return


        names_str = (self._gc(atk_cfg, "attacknames") or "")
        raw_names = [t.strip() for t in re.split(r"[,\s]+", names_str) if t.strip()]
        attack_list = [_norm_attack(t) for t in raw_names]
        disp_map = { _norm_attack(t): t for t in raw_names }

        chosen_attack = None
        dmg_spec = None

        def _read_attack_spec(name: str) -> str:
            name = (name or "").strip().lower()
            for key in (f"atk_{name}", f"dmg_{name}", f"{name}_dmg", f"{name}_atk", name, "damage", "dmg"):
                v = (self._gc(atk_cfg, key) or "").strip()
                if v:
                    return v
            return ""

        def _pick_from_list(want_norm: str) -> str | None:
            if want_norm in attack_list:
                return want_norm
            starts = [a for a in attack_list if a.startswith(want_norm)]
            if len(starts) == 1:
                return starts[0]
            subs = [a for a in attack_list if want_norm in a]
            if len(subs) == 1:
                return subs[0]
            best = difflib.get_close_matches(want_norm, attack_list, n=1, cutoff=0.8)
            return best[0] if best else None

        pretty_available = ", ".join(disp_map[a] for a in attack_list) if attack_list else None

        if explicit_attack_name:
            want = _norm_attack(explicit_attack_name)
            if attack_list:
                picked = _pick_from_list(want)
                if not picked:
                    if len([a for a in attack_list if want in a]) > 1:
                        amb = [disp_map[a] for a in attack_list if want in a][:6]
                        await ctx.send(f"❌ Attack '{explicit_attack_name}' is ambiguous for **{atk_name}**: {', '.join(amb)}")
                        return
                    await ctx.send(f"❌ **{atk_name}** doesn’t have an attack matching **{explicit_attack_name}**. Available: {pretty_available}.")
                    return
                chosen_attack = picked
                dmg_spec = _read_attack_spec(picked) or _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()
            else:
                dmg_spec = _read_attack_spec(want)
                if dmg_spec:
                    chosen_attack = want
                else:
                    chosen_attack = None
                    dmg_spec = _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()
        else:
            if attack_list:
                chosen_attack = attack_list[0]
                dmg_spec = _read_attack_spec(chosen_attack) or _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()
            else:
                chosen_attack = None
                dmg_spec = _read_attack_spec("") or (self._gc(atk_cfg, "damage") or "").strip()

        fallback_note = None
        if not dmg_spec:
            dmg_spec = "1d6"
            fallback_note = (
                f"⚠️ No damage defined for '{(disp_map.get(chosen_attack) if chosen_attack else 'attack')}'. "
                f"Using 1d6 fallback."
            )

        atk_type = ""
        if chosen_attack:
            atk_type = (self._gc(atk_cfg, f"type_{chosen_attack}") or "").strip().lower()
        if not atk_type:
            atk_type = (self._gc(atk_cfg, "type") or "").strip().lower()
        try:
            TYPE_TOKENS = {"slashing","piercing","bludgeoning","fire","cold","electric","acid","force","holy","silver","magic","magical"}
            m = re.match(r"\s*\d+d\d+(?:\s*[+-]\s*\d+)?\s+([A-Za-z][\w-]*)\s*$", str(dmg_spec))
            if m and not atk_type:
                tok = m.group(1).lower()
                if tok in TYPE_TOKENS:
                    atk_type = tok
                    dmg_spec = re.sub(r"\s+[A-Za-z][\w-]*\s*$", "", str(dmg_spec)).strip()
        except Exception:
            pass


        is_magical_attack = False
        try:
            typ = (atk_type or "").lower()
            if "mag" in typ or "magic" in typ:
                is_magical_attack = True
            if (chosen_attack or "") and "magic" in (chosen_attack or "").lower():
                is_magical_attack = True
        except Exception:
            pass

        try:
            names_chk, _ = _parse_combatants(bcfg, chan_id)
            name_key_tgt = (_find_ci_name(names_chk, tgt_name) or tgt_name) if names_chk else tgt_name
            slot_tgt = _slot(name_key_tgt) if '_slot' in globals() else name_key_tgt.replace(" ", "_")
            opt_tgt_acpen = f"{slot_tgt}.acpen"
            turn_nm = bcfg.get(chan_id, "turn", fallback="")
            if name_key_tgt == turn_nm and bcfg.has_option(chan_id, opt_tgt_acpen):
                bcfg.remove_option(chan_id, opt_tgt_acpen); _save_battles(bcfg)
            elif bcfg.has_option(chan_id, opt_tgt_acpen):
                target_ac -= 2
        except Exception:
            pass

        try:
            names_en, _ = _parse_combatants(bcfg, chan_id)
            key_en = _find_ci_name(names_en, tgt_name) or tgt_name
            try:
                slot_en = _slot(key_en)
            except Exception:
                slot_en = key_en.replace(" ", "_")

            enh_left = max(
                bcfg.getint(chan_id, f"{slot_en}.enharmor",   fallback=0),
                bcfg.getint(chan_id, f"{slot_en}.enh_armor",  fallback=0),
            )
            weak_left = max(
                bcfg.getint(chan_id, f"{slot_en}.weakarmor",  fallback=0),
                bcfg.getint(chan_id, f"{slot_en}.weak_armor", fallback=0),
            )
            if enh_left > 0:
                enh_mag = max(1, bcfg.getint(chan_id, f"{slot_en}.enharmor_bonus", fallback=1))
                target_ac += enh_mag
            if weak_left > 0:
                target_ac -= 1
        except Exception:
            pass

        gas_left = 0
        try:
            names_g, _ = _parse_combatants(bcfg, chan_id)
            key_g = _find_ci_name(names_g, tgt_name) or tgt_name
            s_tgt_g = _slot(key_g) if '_slot' in globals() else key_g.replace(" ", "_")
            gas_left = bcfg.getint(chan_id, f"{s_tgt_g}.gas", fallback=0)
            if gas_left > 0 and is_magical_attack:
                target_ac = 22
        except Exception:
            pass

        metalpierce_note = ""
        try:
            if (atk_type or "").lower() in {"metalpiercing", "metal-piercing", "piercemetal"}:
                armor_name = _worn_armor_name(tgt_cfg)
                n = armor_name.replace(" ", "").lower()
                metal_bonus = 7 if "plate" in n else 5 if "chain" in n else 0
                if metal_bonus > 0:
                    target_ac -= metal_bonus
                    metalpierce_note = f"Metal Piercing: ignores **{armor_name or 'metal armor'}** (−{metal_bonus} AC)."
        except Exception:
            pass

        enh_wep_hit = enh_wep_dmg = 0
        weak_wep_hit = weak_wep_dmg = 0
        try:
            enh_left = max(
                bcfg.getint(chan_id, f"{slot_self}.enhwep",  fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.enh_wep", fallback=0),
            )
            if enh_left > 0:
                wname = (bcfg.get(chan_id, f"{slot_self}.enhwep_name", fallback="") or
                         bcfg.get(chan_id, f"{slot_self}.enh_wep_name", fallback="") or "").strip()
                if (not wname) or (_norm_attack(wname) == _norm_attack(chosen_attack or "")):
                    enh_bonus = max(
                        1,
                        bcfg.getint(chan_id, f"{slot_self}.enhwep_bonus", fallback=bcfg.getint(chan_id, f"{slot_self}.enh_wep_bonus", fallback=1))
                    )
                    enh_wep_hit = enh_bonus
                    enh_wep_dmg = enh_bonus

            weak_left = max(
                bcfg.getint(chan_id, f"{slot_self}.weakwep",  fallback=0),
                bcfg.getint(chan_id, f"{slot_self}.weak_wep", fallback=0),
            )
            if weak_left > 0:
                wname = (bcfg.get(chan_id, f"{slot_self}.weakwep_name",  fallback="") or
                         bcfg.get(chan_id, f"{slot_self}.weak_wep_name", fallback="") or "").strip()
                if (not wname) or (_norm_attack(wname) == _norm_attack(chosen_attack or "")):
                    weak_bonus = max(
                        1,
                        bcfg.getint(chan_id, f"{slot_self}.weakwep_bonus", fallback=bcfg.getint(chan_id, f"{slot_self}.weak_wep_bonus", fallback=1))
                    )
                    weak_wep_hit = -weak_bonus
                    weak_wep_dmg = -weak_bonus
        except Exception:
            pass

        
        d20 = random.randint(1, 20)
        is_crit = (d20 == 20)
        d20_is1 = (d20 == 1)
        total_to_hit = (
            d20 + ab + (2 if want_charge else 0) + extra_hit_bonus + inv_atk_bonus + blind_att_pen +
            penalty + sick_att_pen + nl_pen + enh_wep_hit + weak_wep_hit + flank_hit_bonus + bless_bane_hit
        )
        invis_txt = " + 4 (invis)" if inv_atk_bonus else ""
        blind_txt = " − 4" if blind_att_pen else ""
        nl_txt = (f" {nl_pen:+} (NL)" if nl_pen else "")
        charge_note = " (+2 charge)" if want_charge else ""
        hit = (d20 == 20) or (not d20_is1 and total_to_hit >= target_ac)

        specials = _get_specials(atk_cfg)

        if is_swarm_attack:
            hit = True
            is_crit = False
            d20_is1 = False
            want_charge = False
            penalty = 0
            inv_atk_bonus = 0

        try:
            dmg_formula, extra_eff = self._parse_monster_attack_spec(dmg_spec) or (dmg_spec, {})
            if not isinstance(extra_eff, dict):
                extra_eff = {}
        except Exception:
            dmg_formula, extra_eff = dmg_spec, {}

        spec_lower = (dmg_spec or "").strip().lower()

        m_pure = re.fullmatch(r"(?:drain|energydrain|energy\s*drain|leveldrain)(?::?\s*(\d+))?", spec_lower)
        pure_drain = bool(m_pure)

        m_transform = re.fullmatch(r"transform(?::\s*([\dd+\-\s]*d?[\d]+))?", spec_lower)
        is_transform = bool(m_transform)
        transform_override = (m_transform.group(1).replace(" ", "") if m_transform and m_transform.group(1) else None)

        no_damage = bool(extra_eff.get("nodmg"))

        if pure_drain:
            dmg_rolls = []
            base_damage = 0
            n = int(m_pure.group(1)) if (m_pure and m_pure.group(1)) else 1
            extra_eff = dict(extra_eff or {})
            extra_eff["leveldrain"] = max(1, n)
        elif no_damage:
            dmg_rolls = []
            base_damage = 0
        elif extra_eff.get("rotgrub"):
            base_damage = 0
            dmg_rolls = []
        elif is_transform:
            dmg_rolls = []
            base_damage = 0
            extra_eff = dict(extra_eff or {})
            extra_eff["transform"] = transform_override or ""
        else:
            dice_sum, dmg_rolls, spec_flat = roll_dice(dmg_formula)
            precrit = dice_sum + spec_flat + (extra_dmg_value or 0)
            if not is_swarm_attack:
                precrit += enh_wep_dmg
                precrit += weak_wep_dmg
            base_damage = max(0, precrit)

        growth_mult = 1
        growth_note = None
        try:
            names_g, _ = _parse_combatants(bcfg, chan_id)
            me_key_g = _find_ci_name(names_g, atk_name) or atk_name
            try:
                slot_me_g = _slot(me_key_g)
            except Exception:
                slot_me_g = me_key_g.replace(" ", "_")

            growth_left = max(
                bcfg.getint(chan_id, f"{slot_me_g}.x_growanimal", fallback=0),
                bcfg.getint(chan_id, f"{slot_me_g}.growanimal",    fallback=0),
            )
            if growth_left > 0 and (not pure_drain):
                non_physical = {"fire","cold","electric","electricity","acid","force","holy","radiant","necrotic","poison","sonic","psychic"}
                if (not atk_type) or (atk_type not in non_physical):
                    growth_mult = 2
                    growth_note = "Growth of Animals: **×2 physical damage** (also grants **+2 natural AC** while active)."
        except Exception:
            pass

        swarm_note = None
        if is_swarm_attack:
            unarm, why = _is_target_unarmored(target_ac)
            if unarm and ("noarmordouble" in specials or True):
                base_damage *= 2
                swarm_note = "Swarm vs **UNARMORED** (AC<15 & no armor): ×2 damage."

        mult = 1
        if is_crit: mult *= 2
        if want_charge and hit: mult *= 2
        applied_damage = base_damage * mult * growth_mult

        pretty_attack = disp_map.get(chosen_attack, chosen_attack) if 'disp_map' in locals() else chosen_attack
        title = (f"{atk_name} (AoO) attacks {tgt_name} with {pretty_attack}!" if chosen_attack
                 else f"{atk_name} (AoO) slams {tgt_name}!")
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))


        if fallback_note: embed.add_field(name="Note", value=fallback_note, inline=False)

        if is_swarm_attack:
            embed.add_field(name="Attack roll", value="— (auto-hit: **swarm**; no crit/charge; ignores Blur/Displacement)", inline=True)
        else:
            d20_face = "**20** 🎉" if is_crit else ("**1** 💀" if d20_is1 else str(d20))
            flank_str = " + 2" if want_flank else ""
            embed.add_field(
                name="Attack roll",
                value=f"{d20_face} + {ab}{charge_note}{(f' + {extra_hit_bonus}' if extra_hit_bonus else '')}{bb_str}{invis_txt}{blind_txt}{(f' {sick_att_pen:+} ' if sick_att_pen else '')}{nl_txt}{flank_str} = ``{total_to_hit}``",
                inline=True
            )
        embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

        pnm_on = self._pnm_active_for(bcfg, chan_id, tgt_name)
        if (not is_swarm_attack) and pnm_on and self._monster_attack_is_named_ranged(chosen_attack):
            embed.add_field(name="Protection from Normal Missiles", value="Normal missile is **negated** — no effect.", inline=False)
            await ctx.send(embed=embed); return

        if (not is_swarm_attack) and (not attacker_has_ts):
            consumed, left = self._mi_consume_if_present(ctx, tgt_name)
            if consumed:
                embed.add_field(name="Mirror Image", value=f"A figment is struck and shatters. Images remaining: **{left}**.", inline=False)
                await ctx.send(embed=embed); return
        elif (not is_swarm_attack) and attacker_has_ts:
            embed.add_field(name="True Seeing", value="Ignores **Mirror Image** — strike lands on the real target.", inline=False)

        if (not is_swarm_attack) and blur_or_disp_note:
            embed.add_field(name="Displacement/Blur", value=blur_or_disp_note, inline=False)
        if sick_note:
            embed.add_field(name="Condition", value=sick_note, inline=False)
        if ma_bonus_applied and (not is_swarm_attack):
            embed.add_field(name="Note", value=f"Target has **Mage Armor** (+{ma_bonus_applied} AC vs this attack).", inline=False)

        
        extra_lines = []
        if (enh_wep_hit or enh_wep_dmg):
            extra_lines.append(f"Enhanced Weapon: **+{enh_wep_hit or enh_wep_dmg}** to hit & damage")
        if (weak_wep_hit or weak_wep_dmg):
            extra_lines.append(f"Weakened Weapon: **−{abs(weak_wep_hit or weak_wep_dmg)}** to hit & damage")

        bp = _bonuses_panel(include_charge=True)
        if want_flank:
            bp = (bp + "\n" if bp else "") + "Flanking/Advantage: +2 to hit"
        if bb_note:
            bp = (bp + "\n" if bp else "") + "; ".join(bb_note)
        if extra_lines:
            bp = (bp + "\n" if bp else "") + "\n".join(extra_lines)
        if bp:
            embed.add_field(name="Bonuses", value=bp, inline=False)

        try:
            names_note, _ = _parse_combatants(bcfg, chan_id)
            def_key = _find_ci_name(names_note, tgt_name) or tgt_name
            try:
                slot_def = _slot(def_key)
            except Exception:
                slot_def = def_key.replace(" ", "_")
        except Exception:
            slot_def = tgt_name.replace(" ", "_")

        has_bark = max(
            bcfg.getint(chan_id, f"{slot_def}.barkskin",   fallback=0),
            bcfg.getint(chan_id, f"{slot_def}.x_barkskin", fallback=0),
        ) > 0
        has_bone = max(
            bcfg.getint(chan_id, f"{slot_def}.boneskin",   fallback=0),
            bcfg.getint(chan_id, f"{slot_def}.x_boneskin", fallback=0),
        ) > 0

        if bs_bonus_applied and (not is_swarm_attack):
            label = "Barkskin" if has_bark else "Boneskin"
            embed.add_field(name="Note", value=f"Target has **{label}** (+4 AC).", inline=False)

        tree_left = max(
            bcfg.getint(chan_id, f"{slot_def}.tree",    fallback=0),
            bcfg.getint(chan_id, f"{slot_def}.x_tree",  fallback=0),
        )
        if tree_left > 0 and (not is_swarm_attack):
            embed.add_field(name="Note", value="Target is in **Tree Form** (+10 AC).", inline=False)

        try:
            names_en, _ = _parse_combatants(bcfg, chan_id)
            key_en = _find_ci_name(names_en, tgt_name) or tgt_name
            try:
                slot_en = _slot(key_en)
            except Exception:
                slot_en = key_en.replace(" ", "_")
            enh_left = bcfg.getint(chan_id, f"{slot_en}.enharmor", fallback=0)
            weak_left = bcfg.getint(chan_id, f"{slot_en}.weakarmor", fallback=0)
            if enh_left > 0 and (not is_swarm_attack):
                enh_mag = max(1, bcfg.getint(chan_id, f"{slot_en}.enharmor_bonus", fallback=1))
                embed.add_field(name="Note", value=f"Target has **Enhance Armor** (+{enh_mag} AC).", inline=False)
            if weak_left > 0 and (not is_swarm_attack):
                embed.add_field(name="Note", value="Target has **Weaken Armor** (−1 AC).", inline=False)
        except Exception:
            pass

        if growth_note:
            embed.add_field(name="Growth of Animals", value=growth_note, inline=False)

        try:
            if not is_swarm_attack:
                names_goa, _ = _parse_combatants(bcfg, chan_id)
                key_goa = _find_ci_name(names_goa, tgt_name) or tgt_name
                try:
                    s_tgt_goa = _slot(key_goa)
                except Exception:
                    s_tgt_goa = key_goa.replace(" ", "_")

                goa_left = max(
                    bcfg.getint(chan_id, f"{s_tgt_goa}.x_growanimal",      fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.growanimal",        fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.x_growthanimals",   fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.x_growthofanimals", fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.growthanimals",     fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.growthofanimals",   fallback=0),
                    bcfg.getint(chan_id, f"{s_tgt_goa}.goa",               fallback=0),
                )

                if goa_left > 0:
                    rounds_txt = f", {goa_left} rounds left" if goa_left else ""
                    embed.add_field(
                        name="Note",
                        value=f"Target is under **Growth of Animals** (+2 AC{rounds_txt}).",
                        inline=False
                    )
        except Exception:
            pass

        if ac_defense_applied and (not is_swarm_attack):
            embed.add_field(
                name="Defensive Stance",
                value=f"Target is in **Defensive Stance** ( +{ac_defense_applied} AC ).",
                inline=False
            )

        if gas_left > 0 and (not is_swarm_attack):
            embed.add_field(
                name="Gaseous Form",
                value="Defender is **Gaseous** — **AC 22 vs magical**; **immune to nonmagical weapons**.",
                inline=False
            )
        if metalpierce_note and (not is_swarm_attack):
            embed.add_field(name="Note", value=metalpierce_note, inline=False)
        if blind_def_ac_pen and (not is_swarm_attack):
            embed.add_field(name="Note", value="Defender is **BLINDED** (−4 AC).", inline=False)
        if blind_att_pen and (not is_swarm_attack):
            embed.add_field(name="Note", value="Attacker is **BLINDED** (−4 to hit).", inline=False)
        if is_swarm_attack:
            embed.add_field(name="Swarm", value="Area effect: **always hits**. Weapons can’t harm the swarm (defense-side), but this is outgoing swarm damage.", inline=False)
            if swarm_note:
                embed.add_field(name="Swarm Bonus", value=swarm_note, inline=False)

        rolls_str = "[]" if pure_drain else "[" + ", ".join(str(r) for r in dmg_rolls) + "]"
        extra_txt = ""
        if extra_dmg_spec:
            if extra_dmg_rolls:
                extra_txt = " + " + extra_dmg_spec + " [" + ", ".join(str(r) for r in extra_dmg_rolls) + "]"
            else:
                extra_txt = f" {'+' if extra_dmg_value >= 0 else '–'}{abs(extra_dmg_value)}"

        head = None
        if mult == 4:
            head = "🔥 **CRIT + CHARGE!**"
        elif is_crit:
            head = "🔥 **CRITICAL HIT!**"
        elif want_charge and hit:
            head = "🏃 **CHARGE!**"

        formula = f"{dmg_spec} {rolls_str}{extra_txt}"
        if mult > 1:
            formula += f" × {mult}"
        if growth_mult > 1:
            formula += f" × {growth_mult} (Growth)"
        base_line = (f"{head} {formula} = ``{applied_damage}``" if head else f"{formula} = ``{applied_damage}``")

        final_damage = applied_damage
        if hit and not pure_drain and not extra_eff.get("rotgrub"):
            canon_wep_name, bps_type = self._infer_monster_weapon_profile(chosen_attack)

            if (not atk_type) or (atk_type in {"bludgeoning","slashing","piercing"}):
                atk_type = bps_type or atk_type

            canon_wep_name, bps_type = self._infer_monster_weapon_profile(chosen_attack)
            if bps_type and bps_type in {"bludgeoning","slashing","piercing"}:
                atk_type = bps_type

            mitig, note = _apply_mitigation(
                applied_damage,
                weapon_name=(canon_wep_name or chosen_attack or None),
                weapon_type=("swarm" if is_swarm_attack else atk_type),
                t_cfg=tgt_cfg
            )
            final_damage = mitig
            if note:
                base_line += f"\n→ **{note}** → ``{final_damage}``"

        if hit and not is_transform and not pure_drain and not extra_eff.get("rotgrub"):
            embed.add_field(name="Damage", value=base_line, inline=False)

        try:
            if hit and (not is_swarm_attack) and gas_left > 0 and not is_magical_attack:
                final_damage = 0
                base_line += f"\n→ **immune (Gaseous Form)** → ``{final_damage}``"
        except Exception:
            pass

                                                             
                                                                                                         

        if hit and chosen_attack and (not is_swarm_attack) and self._monster_has_ghoul_paralysis(atk_cfg, atk_name, chosen_attack):
                                                   
            if self._is_elf_pure(tgt_cfg):
                embed.add_field(
                    name="Paralysis",
                    value="❌ No effect — **Elves are immune** to ghoul/ghast paralysis.",
                    inline=False
                )
            else:
                                                                                                  
                ok, sv_roll, sv_dc, used_vs = self._roll_save(tgt_cfg, vs="para", penalty=0)
                if sv_dc is None:
                    ok, sv_roll, sv_dc, used_vs = self._roll_save(tgt_cfg, vs="pet", penalty=0)
                    used_vs = "pet"

                if ok:
                    embed.add_field(
                        name="Paralysis",
                        value=f"Save vs {self._sv_label(used_vs)}: {sv_roll} vs {sv_dc} → ✅ **RESISTED**.",
                        inline=False
                    )
                else:
                                                                       
                    total, rolls, flat = roll_dice("2d8")
                    turns = max(0, total + flat)
                    rounds = turns * 60
                    self._extend_paralyzed_timer(bcfg, chan_id, tgt_name, rounds)

                    embed.add_field(
                        name="Paralysis",
                        value=(f"Save vs {self._sv_label(used_vs)}: "
                               f"{sv_roll if sv_roll is not None else '—'} vs {sv_dc if sv_dc is not None else '—'} "
                               f"→ **FAIL**\n"
                               f"⛓️ **{tgt_name}** is **PARALYZED** for **{turns} turn(s)** "
                               f"({rounds} rounds) [{', '.join(str(r) for r in rolls)}]."),
                        inline=False
                    )


                                                                                                                                            

        if (
            hit and tgt_path
            and (extra_eff.get("paralysis") or extra_eff.get("paralyze"))
            and not self._monster_has_ghoul_paralysis(atk_cfg, atk_name, chosen_attack)
        ):
                                                                                                
            ok, sv_roll, sv_dc, used_tag = self._best_save_vs_paralysis(tgt_cfg)
                                                                                               
            if sv_dc is None:
                ok = False

                                                                                         
            dur_expr = (str(
                extra_eff.get("paralysis_turns")
                or extra_eff.get("paralysis_dur")
                or "1d4"
            )).strip()

            if ok:
                embed.add_field(
                    name="Paralysis",
                    value=f"Save vs {self._sv_label(used_tag)}: {sv_roll} vs {sv_dc} → ✅ **RESISTED**.",
                    inline=False
                )
            else:
                turns, t_rolls = self._roll_paralysis_turns(dur_expr, default_turns=1)
                rounds = turns * 60
                self._extend_paralyzed_timer(bcfg, chan_id, tgt_name, rounds)

                rolls_txt = f" [{', '.join(str(r) for r in t_rolls)}]" if t_rolls else ""
                embed.add_field(
                    name="Paralysis",
                    value=(f"Save vs {self._sv_label(used_tag)}: "
                           f"{sv_roll if sv_roll is not None else '—'} vs {sv_dc if sv_dc is not None else '—'} "
                           f"→ **FAIL**\n"
                           f"⛓️ **{tgt_name}** is **PARALYZED** for **{turns} turn(s)** ({rounds} rounds){rolls_txt}."),
                    inline=False
                )

                  
        new_hp = None
        if hit and not pure_drain and not extra_eff.get("rotgrub"):
            old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            try:
                names_keyed, _ = _parse_combatants(bcfg, chan_id)
                name_key = (_find_ci_name(names_keyed, tgt_name) or tgt_name) if names_keyed else tgt_name
                try:
                    slot_tgt = _slot(name_key)
                except Exception:
                    slot_tgt = name_key.replace(" ", "_")

                dmg_after, absorbed, remain, discharged = self._ss_absorb_by_name(
                    bcfg, chan_id, slot_tgt, final_damage
                )
                if absorbed > 0:
                    embed.add_field(
                        name="Stoneskin",
                        value=(f"Stoneskin absorbs **{absorbed}**. "
                               + ("**DISCHARGED!**" if discharged else f"Remaining buffer: **{remain}**.")),
                        inline=False,
                    )
                    final_damage = dmg_after
            except Exception as e:
                embed.add_field(name="Stoneskin (error)", value=f"{type(e).__name__}: {e}", inline=False)

            new_hp = max(0, old_hp - final_damage)
            tgt_cfg["cur"]["hp"] = str(new_hp); write_cfg(tgt_path, tgt_cfg)
                                                                                        
            try:
                await self._aaf_revert_if_slain(ctx, bcfg, chan_id, tgt_name, tgt_cfg, tgt_path, embed)
            except Exception:
                pass

            is_mon_target = _is_monster_file(tgt_path)
            dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
            if is_mon_target:
                mhp = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
            else:
                embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}**{dead_note}", inline=False)

        if hit and extra_eff.get("stun") and tgt_path:
            try:
                                                                       
                try:
                    if _is_undead_cfg(tgt_cfg, tgt_name):
                        embed.add_field(name="Stun", value="☠️ Undead — **no effect**.", inline=False)
                        raise RuntimeError("no_stun_effect")
                except Exception:
                    pass
                try:
                    if self._poison_immune(tgt_cfg):
                        embed.add_field(name="Stun", value="🧪 Poison-immune — **no effect**.", inline=False)
                        raise RuntimeError("no_stun_effect")
                except Exception:
                    pass

                                                                              
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                bonus = int(extra_eff.get("save_bonus", 0))
                total = (sv_roll or 0) + bonus
                sv_ok = (total >= sv_dc) if sv_dc is not None else False
                btxt = (f" {'+' if bonus>=0 else ''}{bonus}" if bonus else "")

                if sv_ok:
                    embed.add_field(
                        name="Stun",
                        value=f"Save vs Poison: {sv_roll}{btxt} vs {sv_dc} → ✅ **RESISTED**.",
                        inline=False
                    )
                else:
                    rounds = int(extra_eff.get("stun_rounds", 60))
                    self._extend_paralyzed_timer(bcfg, chan_id, tgt_name, rounds)
                    embed.add_field(
                        name="Stun",
                        value=(f"Save vs Poison: {sv_roll}{btxt} vs {sv_dc} → **FAIL**\n"
                               f"💫 **{tgt_name}** is **STUNNED** *(paralyzed)* for **{rounds}** rounds."),
                        inline=False
                    )
                    try:
                        if bcfg and bcfg.has_section(chan_id):
                            await self._update_tracker_message(ctx, bcfg, chan_id)
                    except Exception:
                        pass

            except RuntimeError as e:
                if str(e) != "no_stun_effect":
                    pass

        if hit and extra_eff.get("constrict") and tgt_path:
                                                                              
            cur_hp_after_bite = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_bite > 0:
                cons_die = (extra_eff.get("constrict_dice") or "2d4").strip()

                                       
                s_c, rolls_c, flat_c = roll_dice(cons_die)
                raw_c = s_c + flat_c

                                                 
                cons_final, cons_note = _apply_mitigation(raw_c, weapon_name="Constriction", weapon_type="bludgeoning", t_cfg=tgt_cfg)

                                 
                old_hp_c = cur_hp_after_bite
                new_hp_c = max(0, old_hp_c - cons_final)
                if not tgt_cfg.has_section("cur"):
                    tgt_cfg.add_section("cur")
                tgt_cfg["cur"]["hp"] = str(new_hp_c)
                write_cfg(tgt_path, tgt_cfg)

                                                                        
                if _is_monster_file(tgt_path):
                    mhp_c = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp_c)
                    before_c = _life_bar(old_hp_c, mhp_c, width=10)
                    after_c  = _life_bar(new_hp_c, mhp_c, width=10)
                    hp_line_c = f"{before_c} → **{after_c}**"
                else:
                    hp_line_c = f"{old_hp_c} → **{new_hp_c}**"

                            
                dmg_line_c = f"{cons_die} [{', '.join(str(r) for r in rolls_c)}]"
                if cons_note:
                    dmg_line_c += f" → **{cons_final}** ({cons_note})"
                else:
                    dmg_line_c += f" → **{cons_final}**"

                                                                           
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                                    
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                      
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                   
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                                             
                        bcfg.set(chan_id, f"{s_def}.x_constrict", "-1")                                           
                        bcfg.set(chan_id, f"{s_def}.x_constrict_label", "COIL")                                        
                        bcfg.set(chan_id, f"{s_def}.x_constrict_code", "perm")
                        bcfg.set(chan_id, f"{s_def}.x_constrict_dice", cons_die)
                        bcfg.set(chan_id, f"{s_def}.x_constrict_by", att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                    
                coil_note = (f"{dmg_line_c}\nHP {hp_line_c}\n"
                             f"🐍 **HOLD ESTABLISHED** — {tgt_name} is **HELD** by **{atk_name}** "
                             f"and will take **{cons_die}** each round thereafter (use `!escape` to break).")
                if new_hp_c <= 0:
                    coil_note += "  ☠️ **DEAD!**"
                embed.add_field(name="Constriction", value=coil_note, inline=False)


        if hit and extra_eff.get("holdbite") and tgt_path:
            cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_hit > 0:
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                 
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                   
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                                         
                        die = (extra_eff.get("holdbite_dice") or "1d4").strip()
                        bcfg.set(chan_id, f"{s_def}.x_holdbite", "-1")
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_label", "WORRY")
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_code", "perm")
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_dice", die)
                        bcfg.set(chan_id, f"{s_def}.x_holdbite_by", att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                                                                       
                embed.add_field(
                    name="Hold",
                    value=(f"🐕 **HOLD ESTABLISHED** — {tgt_name} is **HELD** by **{atk_name}** and will take "
                           f"**{(extra_eff.get('holdbite_dice') or '1d4').strip()}** automatically each round "
                           f"until killed or `!escape` succeeds."),
                    inline=False
                )

        if hit and extra_eff.get("leech") and tgt_path:
            cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_hit > 0:
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                                                      
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                       
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                                                           
                        die = (extra_eff.get("leech_dice") or "1d6").strip()
                        bcfg.set(chan_id, f"{s_def}.x_leech", "-1")
                        bcfg.set(chan_id, f"{s_def}.x_leech_label", "LEECH")
                        bcfg.set(chan_id, f"{s_def}.x_leech_code",  "perm")
                        bcfg.set(chan_id, f"{s_def}.x_leech_dice",  die)
                        bcfg.set(chan_id, f"{s_def}.x_leech_by",    att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                    
                embed.add_field(
                    name="Attach",
                    value=(f"🩸 **ATTACHED** — {tgt_name} is latched onto by **{atk_name}** and will lose "
                           f"**{(extra_eff.get('leech_dice') or '1d6').strip()}** blood each round.\n"
                           f"`!escape` **does not work**; only killing the monster removes it."),
                    inline=False
                )
                
                                                                      
        if hit and extra_eff.get("entangle") and tgt_path:
            cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
            if cur_hp_after_hit > 0:
                vine_die = (extra_eff.get("entangle_dice") or "1d8").strip()

                                                                                  
                try:
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        try: s_att = _slot(att_key)
                        except Exception: s_att = att_key.replace(" ", "_")
                        try: s_def = _slot(def_key)
                        except Exception: s_def = def_key.replace(" ", "_")

                                                                                      
                        prev = bcfg.get(chan_id, f"{s_att}.holds", fallback="")
                        if prev:
                            try: s_prev = _slot(prev)
                            except Exception: s_prev = prev.replace(" ", "_")
                            if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                            bcfg.remove_option(chan_id, f"{s_att}.holds")

                                   
                        bcfg.set(chan_id, f"{s_att}.holds", def_key)
                        bcfg.set(chan_id, f"{s_def}.heldby", att_key)

                                                                   
                        bcfg.set(chan_id, f"{s_def}.x_entangle", "-1")                                       
                        bcfg.set(chan_id, f"{s_def}.x_entangle_label", "VINE")                                    
                        bcfg.set(chan_id, f"{s_def}.x_entangle_code", "perm")
                        bcfg.set(chan_id, f"{s_def}.x_entangle_dice", vine_die)
                        bcfg.set(chan_id, f"{s_def}.x_entangle_by", att_key)
                        _save_battles(bcfg)
                except Exception:
                    pass

                                    
                embed.add_field(
                    name="Entangle",
                    value=(f"🌿 **HOLD ESTABLISHED** — {tgt_name} is **ENTANGLED** by **{atk_name}** "
                           f"and will take **{vine_die}** each round thereafter (use `!escape` to break)."),
                    inline=False
                )

        if extra_eff.get("rotgrub"):
                                                                               
            disp_def, def_path = _resolve_char_ci(tgt_name)                                        
            if def_path:
                t_cfg = read_cfg(def_path)

                                                                                      
                try:
                    WIS = getint_compat(t_cfg, "stats", "wis", fallback=10)
                except Exception:
                    WIS = 10

                                                                                               
                try:
                                                                      
                    wis_mod = _osr_mod_from_score(WIS)
                except Exception:
                                              
                    wis_mod = (
                        -3 if WIS <= 3 else
                        -2 if WIS <= 5 else
                        -1 if WIS <= 8 else
                         0 if WIS <= 12 else
                         1 if WIS <= 15 else
                         2 if WIS <= 17 else
                         3
                    )

                ok0, roll, dc, pen = self._roll_save(t_cfg, vs="poi", penalty=0)
                total = roll + wis_mod
                noticed = (total >= dc)

                                
                death_in_rounds = random.randint(1, 3) * 60

                                                                                     
                try:
                    cur = int(bcfg.get(chan_id, f"{slot_def}.x_rotgrub", fallback="0"))
                except Exception:
                    cur = 0
                death_in_rounds = max(cur, death_in_rounds) if cur > 0 else death_in_rounds

                                                                                                                    
                burn_window = 2

                                                        
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                slot_def = _slot(tgt_name)

                bcfg.set(chan_id, f"{slot_def}.x_rotgrub", str(death_in_rounds))
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_burn", str(burn_window))
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_label", "Rot Grubs")
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_emoji", "🪱")
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_code", "DIS")                                 
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_by",   atk_name if atk_name else (attacker or "Unknown"))
                bcfg.set(chan_id, f"{slot_def}.x_rotgrub_notice", "1" if noticed else "0")
                _save_battles(bcfg)

                                     
                title = f"🪱 Rot Grubs: {disp_def or tgt_name} is infested!"
                desc  = (f"Save vs Death/Poison — 1d20 **{roll}** "
                         f"{'+' + str(wis_mod) if wis_mod>=0 else str(wis_mod)} vs **{dc}** → ")
                desc += ("**NOTICED**." if noticed else "**not noticed**.")
                desc += (f"\n• Burn/Cut window: **{burn_window}** rounds"
                         f"\n• Death in: **{death_in_rounds}** rounds (1d3 turns)")
                await ctx.send(embed=nextcord.Embed(
                    title=title,
                    description=desc,
                    color=random.randint(0, 0xFFFFFF)
                ))

                                                                                          
        if hit and extra_eff.get("swallow") and tgt_path:
                                                                                 
            thresh = int(extra_eff.get("swallow_thresh", 19))
            roll_ok = (d20 >= thresh)                       

                                                                                    
            size_ok = (True if extra_eff.get("swallow_any") else _pc_is_small(tgt_cfg))

            if roll_ok and size_ok:
                cur_hp_after_hit = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
                if cur_hp_after_hit > 0:
                    try:
                        bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                        if bcfg and bcfg.has_section(chan_id):
                            names_b, _ = _parse_combatants(bcfg, chan_id)
                            att_key = _find_ci_name(names_b, atk_name) or atk_name
                            def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                            try: s_att = _slot(att_key)
                            except Exception: s_att = att_key.replace(" ", "_")
                            try: s_def = _slot(def_key)
                            except Exception: s_def = def_key.replace(" ", "_")

                                                                                               
                            prev = (bcfg.get(chan_id, f"{s_att}.holds", fallback="") or "").strip()
                            if prev:
                                try: s_prev = _slot(prev)
                                except Exception: s_prev = prev.replace(" ", "_")
                                prev_sw = (bcfg.get(chan_id, f"{s_prev}.x_swallow", fallback="") or "").strip()
                                if prev_sw:
                                    embed.add_field(
                                        name="Swallow Whole",
                                        value=f"Already **swallowing** {prev} — cannot swallow another.",
                                        inline=False
                                    )
                                else:
                                                                          
                                    if bcfg.has_option(chan_id, f"{s_prev}.heldby"):
                                        bcfg.remove_option(chan_id, f"{s_prev}.heldby")
                                    bcfg.remove_option(chan_id, f"{s_att}.holds")

                                                                 
                            if not prev or not (bcfg.get(chan_id, f"{_slot(prev)}.x_swallow", fallback="") or "").strip():
                                bcfg.set(chan_id, f"{s_att}.holds", def_key)
                                bcfg.set(chan_id, f"{s_def}.heldby", att_key)
                                die = (extra_eff.get("swallow_dice") or "1d8").strip()
                                bcfg.set(chan_id, f"{s_def}.x_swallow", "-1")                            
                                bcfg.set(chan_id, f"{s_def}.x_swallow_label", "GULLET")
                                bcfg.set(chan_id, f"{s_def}.x_swallow_code", "perm")
                                bcfg.set(chan_id, f"{s_def}.x_swallow_dice", die)
                                bcfg.set(chan_id, f"{s_def}.x_swallow_by", att_key)
                                _save_battles(bcfg)

                                embed.add_field(
                                    name="Swallow Whole",
                                    value=(f"🫗 **{tgt_name} is SWALLOWED** by **{atk_name}**\n"
                                           f"• Takes **{die}** at the **start** of their turns.\n"
                                           f"• `!escape` **does not work** while swallowed.\n"
                                           f"• May attack from inside only with a small cutting/stabbing weapon (e.g., dagger)."),
                                    inline=False
                                )
                    except Exception:
                        pass


                                       
        
                                                                                 
        if hit and extra_eff.get("poison"):
            try:
                                          
                try:
                    if _is_undead_cfg(tgt_cfg, tgt_name):
                        embed.add_field(name="Poison", value="☠️ Undead — **no effect**.", inline=False)
                        raise RuntimeError("no_poison_effect")
                except Exception:
                    pass
                try:
                    if self._poison_immune(tgt_cfg):
                        embed.add_field(name="Poison", value="🧪 Poison-immune — **no effect**.", inline=False)
                        raise RuntimeError("no_poison_effect")
                except Exception:
                    pass

                                                                                               
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                bonus = int(extra_eff.get("save_bonus", 0))
                total = (sv_roll or 0) + bonus
                if sv_dc is None:
                    sv_ok = False
                else:
                    sv_ok = (total >= sv_dc)

                             
                btxt = f" +{bonus}" if bonus else ""
                if sv_ok:
                    embed.add_field(
                        name="Poison",
                        value=f"Save vs Poison: {sv_roll}{btxt} vs {sv_dc} → ✅ **RESISTED**.",
                        inline=False
                    )
                else:
                                   
                    old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
                    mhp    = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)
                    tgt_cfg.setdefault("cur", {})
                    tgt_cfg["cur"]["hp"] = "0"
                    write_cfg(tgt_path, tgt_cfg)
                    new_hp = 0                                               

                                                        
                    if _is_monster_file(tgt_path):
                        try:
                            before = _life_bar(old_hp, mhp, width=10)
                            after  = _life_bar(0,     mhp, width=10)
                            hp_line = f"{before} → **{after}**"
                        except Exception:
                            hp_line = f"{old_hp} → **0**"
                    else:
                        hp_line = f"{old_hp} → **0**"                

                    btxt  = (f" {'+' if bonus >= 0 else ''}{bonus}" if bonus != 0 else "")
                    sv_num = sv_roll if sv_roll is not None else "—"
                    sv_dc_txt = sv_dc if sv_dc is not None else "—"

                    embed.add_field(
                        name="Poison",
                        value=f"Save vs Poison: {sv_num}{btxt} vs {sv_dc_txt} → **FAIL**\n{hp_line}  ☠️ **DEAD!**",
                        inline=False
                    )


            except RuntimeError as e:
                if str(e) != "no_poison_effect":
                                                                                
                    pass

        if hit and extra_eff.get("venom_kind") and tgt_path:
            try:
                            
                try:
                    if _is_undead_cfg(tgt_cfg, tgt_name):
                        embed.add_field(name="Venom", value="☠️ Undead — **no effect**.", inline=False)
                        raise RuntimeError("no_venom_effect")
                except Exception:
                    pass
                try:
                    if self._poison_immune(tgt_cfg):
                        embed.add_field(name="Venom", value="🧪 Poison-immune — **no effect**.", inline=False)
                        raise RuntimeError("no_venom_effect")
                except Exception:
                    pass

                                                                    
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
                bonus = int(extra_eff.get("save_bonus", 2))
                total = (sv_roll or 0) + bonus
                if sv_dc is None:
                    sv_ok = False
                else:
                    sv_ok = (total >= sv_dc)

                kind = (extra_eff.get("venom_kind") or "").lower()                     
                die  = (extra_eff.get("venom_die")  or "1d6").strip()
                dur_expr = (extra_eff.get("venom_dur") or "2d4").strip()
                dur_n = _dice_sum(dur_expr)

                if sv_ok:
                    pace = "rounds" if kind == "fast" else "turns"
                    embed.add_field(
                        name="Venom",
                        value=f"Save vs Poison: {sv_roll} +{bonus} vs {sv_dc} → ✅ **RESISTED** (no {pace} damage).",
                        inline=False
                    )
                else:
                                 
                    bcfg = _load_battles(); chan_id = _section_id(ctx.channel)
                    if bcfg and bcfg.has_section(chan_id):
                        names_b, _ = _parse_combatants(bcfg, chan_id)
                        att_key = _find_ci_name(names_b, atk_name) or atk_name
                        def_key = _find_ci_name(names_b, tgt_name) or tgt_name
                        s_def   = _slot(def_key)

                                                                                        
                        label = "FV" if kind == "fast" else "SV"
                        if kind == "fast":
                            bcfg.set(chan_id, f"{s_def}.x_fastvenom", str(max(1, dur_n)))                              
                            bcfg.set(chan_id, f"{s_def}.x_fastvenom_dice", die)
                            bcfg.set(chan_id, f"{s_def}.x_fastvenom_label", label)
                        else:
                                                                        
                            bcfg.set(chan_id, f"{s_def}.x_slowvenom", str(max(60, dur_n * 60)))
                            bcfg.set(chan_id, f"{s_def}.x_slowvenom_dice", die)
                            bcfg.set(chan_id, f"{s_def}.x_slowvenom_label", label)
                        _save_battles(bcfg)


                    pace = "each **round**" if kind == "fast" else "each **turn**"
                    embed.add_field(
                        name="Venom",
                        value=(f"Save vs Poison: {sv_roll} +{bonus} vs {sv_dc} → **FAIL**\n"
                               f"🧪 **{tgt_name}** will take **{die}** {pace} for **{dur_n}** "
                               f"{'rounds' if kind=='fast' else 'turns'}."),
                        inline=False
                    )
            except RuntimeError as e:
                if str(e) != "no_venom_effect":
                    pass

        if hit and extra_eff.get("burn"):
            pdie = (extra_eff.get("burn_die") or "3d10").strip()
            await self._apply_burn_on_hit(ctx, bcfg, chan_id, atk_name, tgt_name, tgt_cfg, embed, burn_die=pdie)
                    
        try:
            if hit and (
                extra_eff.get("dance") or
                extra_eff.get("dancepoison") or
                (" dance" in f" {spec_lower} ")                                           
            ):
                await self._apply_dance_poison_on_hit(ctx, bcfg, chan_id, atk_name, tgt_name, tgt_cfg, embed, primary=True)
        except Exception:
            pass

                    
        if hit and (is_transform or extra_eff.get("transform")) and tgt_path:
                                                                                       
            rounds = None
            override = (transform_override or extra_eff.get("transform") or "").strip()
            if override:
                                            
                try:
                    s_val, _rolls_val, flat_val = roll_dice(override)
                    rounds = max(1, s_val + flat_val)
                except Exception:
                    rounds = None
            if rounds is None:
                s4, rolls4, flat4 = roll_dice("1d4")
                rounds = 6 + s4 + flat4

                                                               
            try:
                bcfg2 = _load_battles(); ch2 = _section_id(ctx.channel)
                if bcfg2 and bcfg2.has_section(ch2):
                    names2, _ = _parse_combatants(bcfg2, ch2)
                    def_key2 = _find_ci_name(names2, tgt_name) or tgt_name
                    try: s_def2 = _slot(def_key2)
                    except Exception: s_def2 = def_key2.replace(" ", "_")

                                                                           
                    existing = bcfg2.getint(ch2, f"{s_def2}.x_transform", fallback=0)
                    new_left = max(existing, rounds)

                    bcfg2.set(ch2, f"{s_def2}.x_transform", str(new_left))
                    bcfg2.set(ch2, f"{s_def2}.x_transform_label", "JELLY")
                    bcfg2.set(ch2, f"{s_def2}.x_transform_code", "timer")                                     
                    bcfg2.set(ch2, f"{s_def2}.x_transform_by", atk_name)
                    bcfg2.set(ch2, f"{s_def2}.x_transform_type", "greenjelly")
                    bcfg2.set(ch2, f"{s_def2}.x_transform_grace", "1")                                
                    _save_battles(bcfg2)

                    rolls_txt = f" [{', '.join(str(r) for r in (rolls4 if rounds and not override else []))}]" if not override else ""
                    embed.add_field(
                        name="Green Jelly",
                        value=(f"🧪 **CLINGS!** {tgt_name} will **transform** in **{new_left}** rounds{rolls_txt} unless removed.\n"
                               f"• First round: can be scraped off (destroys tool). Thereafter: freeze/burn/cut away (same damage to both).\n"
                               f"• **Cure Disease** destroys a patch.\n"
                               f"• Use `!ds {tgt_name} transform` if removed (GM adjudicates)."),
                        inline=False
                    )
            except Exception:
                pass

        if hit and extra_eff.get("dissolvearmor") and tgt_path:
                                                                            
            try:
                bcfg2 = _load_battles(); ch2 = _section_id(ctx.channel)
                if bcfg2 and bcfg2.has_section(ch2):
                    names2, _ = _parse_combatants(bcfg2, ch2)
                    def_key = _find_ci_name(names2, tgt_name) or tgt_name
                    try: s_def2 = _slot(def_key)
                    except Exception: s_def2 = def_key.replace(" ", "_")
                    die = (extra_eff.get("dissolve_dice") or "2d8").strip()
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve", "-1")                                      
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_label", "ACID")                         
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_code", "perm")
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_dice", die)
                    bcfg2.set(ch2, f"{s_def2}.x_dissolve_by", atk_name)
                    _save_battles(bcfg2)
                    embed.add_field(name="Acid", value=f"🧪 **STUCK** — {tgt_name} will take **{die}** automatically each round.", inline=False)
            except Exception:
                pass

                                                                               
            try:
                await self._dissolve_body_armor(ctx, tgt_name, tgt_cfg, tgt_path, embed=embed, reason="Dissolve Armor")
                                                                                                           
                tgt_cfg = read_cfg(tgt_path)
            except Exception:
                embed.add_field(name="Dissolve Armor", value="⚠️ Error adjudicating armor melt (GM decides).", inline=False)


        if hit and extra_eff.get("petrify"):
                                           
            def _save_vs_petrify_best(t_cfg):
                                                                                     
                for tag in ("para", "pet", "parapet"):
                    ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                    if dc is not None:
                        return ok, roll, dc
                ok, roll, dc, pen = self._roll_save(t_cfg, vs="spell", penalty=0)
                return ok, roll, dc                           

            def _is_constructish_cfg(t_cfg, disp: str) -> bool:
                try:
                    blob = " ".join([
                        (get_compat(t_cfg, "base", "type", fallback="") or ""),
                        (get_compat(t_cfg, "info", "race", fallback="") or ""),
                        (disp or ""),
                    ]).lower()
                    for kw in ("construct", "golem", "animated object", "statue"):
                        if kw in blob:
                            return True
                except Exception:
                    pass
                return False

                                            
            try:
                if _is_undead_cfg(tgt_cfg, tgt_name):
                    embed.add_field(name="Petrification", value="☠️ Undead — **no effect**.", inline=False)
                               
                elif _is_constructish_cfg(tgt_cfg, tgt_name):
                    embed.add_field(name="Petrification", value="🛠️ Construct — **no effect**.", inline=False)
                else:
                                                             
                    try:
                        names_note, _ = _parse_combatants(bcfg, chan_id)
                        def_key = _find_ci_name(names_note, tgt_name) or tgt_name
                        try: slot_def_local = _slot(def_key)
                        except Exception: slot_def_local = def_key.replace(" ", "_")
                    except Exception:
                        slot_def_local = (locals().get("slot_def") or tgt_name.replace(" ", "_"))

                    already = (
                        bcfg.getint(chan_id, f"{slot_def_local}.pet_perm", fallback=0) > 0
                        or bcfg.getint(chan_id, f"{slot_def_local}.pet",      fallback=0) > 0
                    )
                    if already:
                        embed.add_field(name="Petrification", value="Already **Petrified** — no effect.", inline=False)
                    else:
                        ok, sv_roll, sv_dc = _save_vs_petrify_best(tgt_cfg)
                        if sv_dc is None:
                            ok = False                                                                       

                        if ok:
                            embed.add_field(
                                name="Petrification",
                                value=f"Save vs Petrification: {sv_roll} vs {sv_dc} → ✅ **RESISTED**.",
                                inline=False
                            )
                        else:
                                                        
                            bcfg.set(chan_id, f"{slot_def_local}.pet_perm", "1")
                            bcfg.set(chan_id, f"{slot_def_local}.pet_by", f"{atk_name} ({(chosen_attack or 'attack')})")
                            _save_battles(bcfg)
                            sv_txt = f"{sv_roll} vs {sv_dc}" if sv_dc is not None else "—"
                            embed.add_field(
                                name="Petrification",
                                value=f"Save vs Petrification: {sv_txt} → **FAIL** — **PETRIFIED** `[PET –]`.",
                                inline=False
                            )
            except Exception:
                pass

        
        if hit:
            if extra_eff.get("heal"):
                atk_old_hp = getint_compat(atk_cfg, "cur", "hp", fallback=0)
                atk_max_hp = getint_compat(atk_cfg, "max", "hp", fallback=atk_old_hp)
                heal_amt = max(0, applied_damage)
                atk_new_hp = min(atk_max_hp, atk_old_hp + heal_amt)
                if not atk_cfg.has_section("cur"): atk_cfg.add_section("cur")
                atk_cfg["cur"]["hp"] = str(atk_new_hp); write_cfg(atk_path, atk_cfg)
                before_bar = _life_bar(atk_old_hp, atk_max_hp, width=10)
                after_bar = _life_bar(atk_new_hp, atk_max_hp, width=10)
                embed.add_field(name="Leech", value=f"{atk_name} regenerates **{heal_amt} HP**\nHP: {before_bar} → **{after_bar}**", inline=False)

                                  
        if hit:
            drain_n = _extract_level_drain(dmg_spec, extra_eff)
            if drain_n > 0:
                try:
                    tgt_cfg = read_cfg(tgt_path)
                    await self._auto_apply_negative_levels(
                        ctx, tgt_name, tgt_cfg, tgt_path, n_levels=drain_n, source=f"{atk_name} {(chosen_attack or 'attack')}", embed=embed
                    )
                except Exception as e:
                    embed.add_field(
                        name="Energy Drain",
                        value=(f"{drain_n} negative level(s) **not applied** due to an error; GM may run `!drain {tgt_name} {drain_n}`. ({type(e).__name__})"),
                        inline=False
                    )


                                                 
        if want_charge and bcfg.has_section(chan_id):
            names_c, _ = _parse_combatants(bcfg, chan_id)
            if atk_name in names_c:
                bcfg.set(chan_id, f"{slot_self}.acpen", "-2"); _save_battles(bcfg)

                                    
        if tgt_path and hit and (new_hp is not None) and new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    name_key = _find_ci_name(names, tgt_name) or tgt_name
                    if name_key in names:
                        names = [n for n in names if n != name_key]
                        if bcfg.has_option(chan_id, name_key): bcfg.remove_option(chan_id, name_key)
                        slot = _slot(name_key)
                        for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == name_key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

                         
        try:
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    bcfg = _load_battles()
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        await ctx.send(embed=embed)


    @commands.command(name="equip")
    async def equip_item(self, ctx, *, item_name: str):
        """
        Equip armor, shield, weapon, or special wearable onto your ACTIVE character.

        Weapons:
          - Appends to weapon list (weapon1..weaponN)
          - Blocks equipping a 2H weapon while a shield is equipped
          - Enforces race/class restrictions

        Armor & Shields:
          - Armor -> armor1 (replaces)
          - Shields -> armor2 (replaces)

        Specials (🔹 other):
          - Gauntlets/Girdles, Rings/Cloaks/Pendants of Protection, etc.
          - Go to slot: hands | belt | ring | cloak | neck | other1..other5
          - Recomputes AC and Move; Protection items grant +N to AC & saving throws

        Always recomputes AC / equipped weight / move and refreshes the tracker.
        """

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        race_lc, class_lc = self._get_char_race_class(cfg)
        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(cfg)
        old_ac_raw = get_compat(cfg, "stats", "ac", fallback="")
        try:
            old_ac = int(old_ac_raw) if str(old_ac_raw).strip() != "" else 10
        except Exception:
            old_ac = 10



        canon, item = self._item_lookup(item_name)
        if not item:
            await ctx.send(f"❌ Unknown item **{item_name}**.")
            return

        item_type = (self._item_type(item) or "").strip().lower()
        if item_type in {"gear", "food", "tool"}:
            pretty = re.sub(r"(?<!^)([A-Z])", r" \1", canon).strip()
            await ctx.send(
                f"⚠️ **{pretty}** is ordinary gear, not something you wear or wield.\n"
                f"Use `!carry {pretty}` if you want it in your carried items."
            )
            return


        
        has_it = False
        try:
            if cfg.has_section("item"):
                cnt = cfg.get("item", canon.lower(), fallback=None)
                if cnt is not None:
                    try:
                        has_it = int(str(cnt).strip()) > 0
                    except Exception:
                        has_it = True
                if not has_it:
                    storage = cfg.get("item", "storage", fallback="")
                    inv = {s.strip().lower() for s in storage.split() if s.strip()}
                    has_it = canon.lower() in inv
        except Exception:
            pass
        if not has_it:
            await ctx.send(f"⚠️ **{canon}** isn’t in your inventory.")
            return

        is_shield = self._item_is_shield(item)
        armor_ac  = self._item_ac(item)
        is_weapon = self._item_is_weapon(item)
        weight    = self._item_weight(item) or 0.0

        if not (is_weapon or is_shield or (armor_ac is not None)):
            slot = self._misc_slot_for_item(canon, cfg)
            if slot is None:
                nm = re.sub(r"[^a-z0-9]+", "", (canon or "").lower())
                if "ring" in nm:
                    await ctx.send("❌ Both ring slots are already used (`ring`, `ring2`). Unequip one first.")
                else:
                    await ctx.send("❌ No free slot available to equip this item.")
                return

            if not cfg.has_section("eq"):
                cfg.add_section("eq")

            prev = (get_compat(cfg, "eq", slot, fallback="") or "").strip()
            cfg.set("eq", slot, canon)

            
            self._dedupe_from_carry(cfg, canon.lower())

            nm_clean = re.sub(r"[^a-z0-9]+", "", canon.lower())
            if nm_clean in ("ringofregeneration", "pendantofregeneration"):
                try:
                    cur_hp = getint_compat(cfg, "cur", "hp", fallback=None)
                    if cur_hp is not None:
                        if not cfg.has_section("cur"):
                            cfg.add_section("cur")
                        cfg["cur"]["regen_cap_hp"] = str(cur_hp)
                except Exception:
                    pass

            
            seed_note = ""
            core = _pfed_norm(canon)
            if core in _PFED_SET:
                try:
                    cur, mx = _pfed_seed_if_missing(cfg, path, core)
                    seed_note = f"\n🔋 Protection vs Energy Drain charges: **{cur}/{mx}**"
                except Exception as e:
                    
                    seed_note = f"\n🔋 Protection vs Energy Drain charges: *(error: {type(e).__name__}: {e})*"


            
            new_weight = self._recompute_eq_weight(cfg)
            new_ac     = self._recompute_ac(cfg, channel=ctx.channel)
            new_move   = self._recompute_move(cfg)
            write_cfg(path, cfg)

            
            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    if char_name in names:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
            except Exception:
                pass

            
            repl = f" (replacing **{prev}** )" if prev else ""
            m = re.search(r"ofprotection\+(\d+)$", canon.lower())
            prot_txt = ""
            if m:
                try:
                    n = int(m.group(1))
                    prot_txt = f"\nProtection bonus active: **+{n} AC & saves**"
                except Exception:
                    prot_txt = ""

            await ctx.send(
                f"🔹 **{char_name}** equips **{canon}** → `{slot}`{repl}\n"
                f"AC: {old_ac} → **{new_ac}**   •   Equipped weight: **{self._fmt_w(new_weight)}**   •   Move: **{new_move}**"
                f"{prot_txt}"
                f"{seed_note}"
            )
            return


        if not is_weapon:
            ok, reason = self._class_can_wear_armor(class_lc, weight, is_shield, channel=ctx.channel)
            if not ok:
                await ctx.send(f"❌ Cannot equip **{canon}**: {reason}")
                return

            if is_shield:
                if class_lc in {"thief","scout","assassin"}:
                    await ctx.send(f"❌ {class_lc.title()}s cannot use shields.")
                    return
                
                names = self._eq_get_weapons(cfg)
                two_h_list = []
                for wn in names:
                    c2, it2 = self._item_lookup(wn)
                    if not it2:
                        continue
                    eff_h = self._effective_hands(it2, race_lc)
                    if eff_h >= 2:
                        two_h_list.append(c2 or wn)
                if two_h_list:
                    pretty = ", ".join(two_h_list)
                    await ctx.send(f"❌ Cannot equip **{canon}** while using 2-handed weapon(s): {pretty}.")
                    return
                cfg.set("eq", "armor2", canon)
            else:
                cfg.set("eq", "armor1", canon)

            
            a1 = cfg.get("eq", "armor1", fallback="").strip()
            a2 = cfg.get("eq", "armor2", fallback="").strip()
            armor_count = (1 if a1 else 0) + (1 if a2 else 0)
            cfg.set("eq", "armor", str(armor_count))

            new_weight = self._recompute_eq_weight(cfg)
            new_ac     = self._recompute_ac(cfg, channel=ctx.channel)
            new_move   = self._recompute_move(cfg)
            write_cfg(path, cfg)

            
            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    if char_name in names:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
            except Exception:
                pass

            slot_txt = "Shield (armor2)" if is_shield else "Armor (armor1)"
            await ctx.send(
                f"🛡️ **{char_name}** equips **{canon}** → {slot_txt}\n"
                f"AC: {old_ac} → **{new_ac}**   •   Equipped weight: **{self._fmt_w(new_weight)}**   •   Move: **{new_move}**"
            )
            return

        weap_type = self._item_type(item)
        rules_name = (str(item.get("base") or "").strip() or canon)

        ok, reason = self._class_can_use_weapon(class_lc, rules_name, weap_type, race_lc=race_lc)
        if not ok:
            await ctx.send(f"❌ Cannot equip **{canon}**: {reason}")
            return

        ok, reason, eff_h = self._race_can_use_weapon(race_lc, canon, item)
        if not ok:
            await ctx.send(f"❌ Cannot equip **{canon}**: {reason}")
            return

        if eff_h >= 2:
            sh = get_compat(cfg, "eq", "armor2", fallback="").strip()
            if sh:
                _csh, it_sh = self._item_lookup(sh)
                if it_sh and self._item_is_shield(it_sh):
                    size = self._item_size(item)
                    small_2h = (self._race_is_small(race_lc) and size == "m")
                    note = " (Small races must use Medium weapons two-handed)" if small_2h else ""
                    await ctx.send(f"❌ Cannot equip **{canon}** (two-handed) while a shield is equipped{note}.")
                    return

        slot_used = self._eq_add_weapon(cfg, canon)

        new_weight = self._recompute_eq_weight(cfg)
        new_ac     = self._recompute_ac(cfg, channel=ctx.channel)
        new_move   = self._recompute_move(cfg)
        write_cfg(path, cfg)

        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                if char_name in names:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
        except Exception:
            pass

        STR  = getint_compat(cfg, "stats", "str", fallback=10)
        race = get_compat(cfg, "info", "race", fallback="Human")
        light_lim, heavy_lim = self._weight_thresholds(race, STR)

        new_eq_w   = new_weight
        new_coin_w = old_coin_w
        new_total  = new_eq_w + new_coin_w

        await ctx.send(
            f"🗡️ **{char_name}** equips **{canon}** → `{slot_used}`\n"
            f"AC: {old_ac} → **{new_ac}**   •   Weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
            f"(coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  Move: **{new_move}**"
        )


    @commands.command(name="unequip")
    async def unequip(self, ctx, *, what: str):
        """
        Unequip a slot or a specific equipped item.
        Usage:
          !unequip armor
          !unequip shield
          !unequip weapon1
          !unequip hands
          !unequip belt
          !unequip ChainMail
        """

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        if not cfg.has_section("eq"):
            cfg.add_section("eq")

        arg = (what or "").strip().lower()
        cleared = None

                                                                            
        old_ac_raw = get_compat(cfg, "stats", "ac", fallback="")
        try:
            old_ac = int(old_ac_raw) if str(old_ac_raw).strip() != "" else 10
        except Exception:
            old_ac = 10
        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(cfg)
        old_str_mod = _effective_str_mod(cfg)

        def _clear(slot):
            nonlocal cleared
            if slot.startswith("weapon"):
                removed = self._eq_remove_weapon_by_slot(cfg, slot)            
                if removed:
                    cleared = (slot, removed)
                return
            if cfg.has_option("eq", slot):
                val = (cfg.get("eq", slot, fallback="") or "").strip()
                if val:
                    cfg.set("eq", slot, "")
                    cleared = (slot, val)

                 
        if arg in {"armor", "armour", "armor1", "armour1", "body"}:
            _clear("armor1")
        elif arg in {"shield", "armor2", "armour2"}:
            _clear("armor2")
        elif arg in {"hands", "gloves"}:
            _clear("hands")
        elif arg in {"belt", "girdle"}:
            _clear("belt")
        elif arg in {"ring", "ring1"}:
            _clear("ring")
        elif arg in {"ring2"}:
            _clear("ring2")
        elif arg in {"neck", "amulet", "pendant"}:
            _clear("neck"); _clear("pendant"); _clear("amulet")
        elif arg in {"cloak"}:
            _clear("cloak")
        elif arg in {"boots"}:
            _clear("boots")
        elif arg in {"helm", "helmet"}:
            _clear("helm")
        elif arg in {"other1","other2","other3","other4","other5"}:
            _clear(arg)
        elif re.fullmatch(r"weapon\d+", arg):
            _clear(arg)
        else:
                                                           
            canon, _it = self._item_lookup(what)
            target_name = (canon or what).strip().lower()

            slot_found = None
            for k, v in cfg.items("eq"):
                if re.fullmatch(r"weapon\d+", k, flags=re.I):
                    val = (v or "").strip()
                    if val and val.lower() == target_name:
                        slot_found = k
                        break

            if slot_found:
                removed = self._eq_remove_weapon_by_slot(cfg, slot_found)
                if removed:
                    cleared = ("weapon", removed)
            else:
                for slot in ("armor1","armor2","hands","belt","ring","ring2","neck","amulet","pendant","cloak","boots","helm","other1","other2","other3","other4","other5"):
                    val = (get_compat(cfg, "eq", slot, fallback="") or "").strip()
                    if val and val.lower() == target_name:
                        cfg.set("eq", slot, "")
                        cleared = (slot, val)
                        break

                            
        a1 = (get_compat(cfg, "eq", "armor1", fallback="") or "").strip()
        a2 = (get_compat(cfg, "eq", "armor2", fallback="") or "").strip()
        armor_count = (1 if a1 else 0) + (1 if a2 else 0)
        cfg.set("eq", "armor", str(armor_count))

                          
        new_weight = self._recompute_eq_weight(cfg)
        new_ac     = self._recompute_ac(cfg, channel=ctx.channel)
        new_move   = self._recompute_move(cfg)
        write_cfg(path, cfg)

                                          
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                if char_name in names:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
        except Exception:
            pass


        def _wearing_regen_now(cfg) -> bool:
            try:
                for k in ("ring", "ring2", "neck", "pendant", "amulet"):
                    v = (get_compat(cfg, "eq", k, fallback="") or "").strip().lower()
                    nm = re.sub(r"[^a-z0-9]+", "", v)
                    if "ringofregeneration" in nm or "pendantofregeneration" in nm:
                        return True
            except Exception:
                pass
            return False

        if not _wearing_regen_now(cfg):
            try:
                if cfg.has_option("cur", "regen_cap_hp"):
                    cfg.remove_option("cur", "regen_cap_hp")
            except Exception:
                pass

                                   
        new_eq_w   = self._eq_weight_cached(cfg)
        new_coin_w = self._coin_weight_from_cfg(cfg)
        new_total  = new_eq_w + new_coin_w

                                              
        new_str_mod = _effective_str_mod(cfg)
        fmt = lambda n: f"+{n}" if n >= 0 else str(n)
        str_note = f"\nSTR mod: {fmt(old_str_mod)} → **{fmt(new_str_mod)}**" if new_str_mod != old_str_mod else ""

        if cleared:
            slot, val = cleared
            await ctx.send(
                f"🧰 **{char_name}** unequips **{val}** from `{slot}`.\n"
                f"AC: {old_ac} → **{new_ac}**   •   "
                f"Weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
                f"(coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  "
                f"Move: **{new_move}**"
                f"{str_note}"
            )
        else:
            await ctx.send("ℹ️ Nothing to unequip (no matching slot/item found).")


    @commands.command(name="carry")
    async def carry_item(self, ctx, *, item_name: str):
        """
        Add a miscellaneous item to your carried gear list (with quantity-aware weight).
          • Accepts optional qty: "!carry IronSpikes x12" or "!carry IronSpikes 12"
          • If qty omitted, uses your inventory count if numeric; else 1
        """
        

                                  
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

                                           
                                    
                                                               
        m = re.match(r"^\s*(.*?)\s*(?:[x×]\s*(\d+)|\s+(\d+))?\s*$", item_name, flags=re.I)
        raw_name = (m.group(1) or "").strip()
        qty_group = m.group(2) or m.group(3)
        typed_qty = int(qty_group) if qty_group else None


                     
        canon, item = self._item_lookup(raw_name)
        if canon is None:
                                                                            
            canon, item = self.find_item(item_name.strip())
        if not item:
            await ctx.send(f"❌ Unknown item **{raw_name or item_name}**.")
            return

                                                         
        if self._item_is_shield(item) or (self._item_ac(item) is not None) or self._item_is_weapon(item):
            await ctx.send(f"⚠️ **{canon}** looks equip-able. Use `!equip {canon}` instead.")
            return

                                                         
        has_it = False
        inv_qty = 1
        try:
            if cfg.has_section("item"):
                key = canon.lower()
                raw_cnt = cfg.get("item", key, fallback=None)
                if raw_cnt is not None:
                    try:
                        inv_qty = max(1, int(str(raw_cnt).strip()))
                        has_it = inv_qty > 0
                    except Exception:
                                                                                       
                        has_it = True
                        inv_qty = 1
                if not has_it:
                    storage = cfg.get("item", "storage", fallback="")
                    inv = {s.strip().lower() for s in storage.split() if s.strip()}
                    has_it = key in inv
        except Exception:
            pass

        if not has_it:
            await ctx.send(f"⚠️ **{canon}** isn’t in your inventory.")
            return

        qty = typed_qty if (typed_qty is not None) else inv_qty
        qty = max(1, qty)

                                      
        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(cfg)

                                                                                      
        if not cfg.has_section("eq"):
            cfg.add_section("eq")
        slot_used = self._eq_add_carry(cfg, canon)                                    
        cfg.set("eq", f"{slot_used}_qty", str(qty))                                                     

                          
        new_weight = self._recompute_eq_weight(cfg)                                          
        new_move   = self._recompute_move(cfg)
        write_cfg(path, cfg)

                                           
        new_eq_w   = self._eq_weight_cached(cfg)
        new_coin_w = self._coin_weight_from_cfg(cfg)
        new_total  = new_eq_w + new_coin_w

                                                      
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                if char_name in names:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
        except Exception:
            pass

                                             
        STR  = getint_compat(cfg, "stats", "str", fallback=10)
        race = get_compat(cfg, "info", "race", fallback="Human")
        light_lim, heavy_lim = self._weight_thresholds(race, STR)

        if new_total <= light_lim:   load_txt = "light load"
        elif new_total <= heavy_lim: load_txt = "heavy load"
        else:                        load_txt = "encumbered"

        await ctx.send(
            f"🎒 **{char_name}** adds **{canon} x{qty}** → `{slot_used}`\n"
            f"Weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
            f"(coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  "
            f"Move: **{new_move}**"
        )


    @commands.command(name="uncarry", aliases=["unc"])
    async def uncarry(self, ctx, *, what: str):
        """
        Remove a carried item (by slot or name) and compact the list (qty-aware).
        Usage: !uncarry carry3   |   !uncarry GrapplingHook
        """
        

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(cfg)

                                                                      
        carried = []                                                    
        if cfg.has_section("eq"):
            for opt, val in cfg.items("eq"):
                if opt.startswith("carry") and not opt.endswith("_qty"):
                    name = (val or "").strip()
                    try:
                        idx = int(opt.replace("carry", ""))
                    except Exception:
                        continue
                    qty_key = f"{opt}_qty"
                    try:
                        qty = int(cfg.get("eq", qty_key, fallback="1"))
                    except Exception:
                        qty = 1
                    qty = max(1, qty)
                    carried.append((idx, opt, name, qty))
        carried.sort(key=lambda t: t[0])

        removed_name = None
        removed_qty  = None

        arg = (what or "").strip()

                                         
        target_index = None
        if re.fullmatch(r"carry\d+", arg.lower()):
                                     
            try:
                idx = int(arg.lower().replace("carry", ""))
                for i, (cidx, skey, nm, q) in enumerate(carried):
                    if cidx == idx:
                        target_index = i
                        break
            except Exception:
                target_index = None
        else:
                                              
            canon, _ = self._item_lookup(arg)
            if canon is None:
                                                                                
                canon, _ = self.find_item(arg.strip())
            target = (canon or arg).strip().lower()
            for i, (_cidx, _skey, nm, _q) in enumerate(carried):
                if nm.strip().lower() == target:
                    target_index = i
                    break

        if target_index is not None:
                                                         
            _, slot_key, removed_name, removed_qty = carried.pop(target_index)

                                                                         
            try:
                                 
                to_del = []
                for opt, _ in cfg.items("eq"):
                    if opt.startswith("carry"):
                        to_del.append(opt)
                for opt in to_del:
                    cfg.remove_option("eq", opt)

                                          
                for i, (_cidx, _skey, nm, q) in enumerate(carried, start=1):
                    cfg.set("eq", f"carry{i}", nm)
                    cfg.set("eq", f"carry{i}_qty", str(max(1, int(q))))
            except Exception:
                pass

                          
        new_weight = self._recompute_eq_weight(cfg)
        new_move   = self._recompute_move(cfg)
        write_cfg(path, cfg)

                                           
        new_eq_w   = self._eq_weight_cached(cfg)
        new_coin_w = self._coin_weight_from_cfg(cfg)
        new_total  = new_eq_w + new_coin_w
        
                                          
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                if char_name in names:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
        except Exception:
            pass

        new_eq_w   = self._eq_weight_cached(cfg)
        new_coin_w = self._coin_weight_from_cfg(cfg)
        new_total  = new_eq_w + new_coin_w

                                             
        STR  = getint_compat(cfg, "stats", "str", fallback=10)
        race = get_compat(cfg, "info", "race", fallback="Human")
        light_lim, heavy_lim = self._weight_thresholds(race, STR)

        if new_total <= light_lim:   load_txt = "light load"
        elif new_total <= heavy_lim: load_txt = "heavy load"
        else:                        load_txt = "encumbered"
        
        
        if removed_name:
            qty_note = f" x{removed_qty}" if (removed_qty and removed_qty > 1) else ""
            await ctx.send(
                f"🧳 **{char_name}** removes **{removed_name}{qty_note}** from carry.\n"
                f"Weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
                f"(coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  "
                f"Move: **{new_move}**"
            )
        else:
            await ctx.send("ℹ️ Nothing removed (no matching carried item or slot).")


    @commands.command(name="bag")
    async def bag(self, ctx, *, who: str | None = None):
        """
        Show inventory (storage) with markers:
          🗡️ equipped weapon, 🧥 armor, 🛡️ shield, 🎒 carried
        Quantities show as xN. Equipped items are bolded. Wands/Staves show charges.
        Usage:
          !bag
          !bag testman   (GM only)
        """
        

        def _resolve_char_ci(name: str):
            base = name.replace(" ", "_")
            target = f"{base}.coe".lower()
            for fn in os.listdir("."):
                if fn.lower() == target:
                    path = fn
                    try:
                        cfg2 = read_cfg(path)
                        real = get_compat(cfg2, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return None, None

        if who:
            char_name, path = _resolve_char_ci(who)
            if not path:
                await ctx.send(f"❌ Character '{who}' not found."); return
            cfg = read_cfg(path)
            owner_id = get_compat(cfg, "info", "owner_id", fallback="")
            if str(ctx.author.id) != str(owner_id) and not getattr(ctx.author.guild_permissions, "manage_guild", False):
                await ctx.send("❌ You must own this character or have Manage Server permission."); return
        else:
            char_name = get_active(ctx.author.id)
            if not char_name:
                await ctx.send("❌ No active character. Use `!char <name>` first."); return
            path = f"{char_name.replace(' ', '_')}.coe"
            if not os.path.exists(path):
                await ctx.send(f"❌ Character file not found for **{char_name}**."); return
            cfg = read_cfg(path)

        a1 = get_compat(cfg, "eq", "armor1", fallback="").strip()
        a2 = get_compat(cfg, "eq", "armor2", fallback="").strip()
        armor1_l = a1.lower() if a1 else ""
        armor2_l = a2.lower() if a2 else ""

        weap_list = self._eq_get_weapons(cfg)
        weap_set  = {w.lower() for w in weap_list}

        carry_list = self._eq_get_carry(cfg)
        carry_set  = {c.lower() for c in carry_list}


        
        other_slots = self._equipped_others(cfg)
        other_set = {v.lower() for v in other_slots.values()}
        hands_l = (get_compat(cfg, "eq", "hands", fallback="") or "").strip().lower()
        belt_l  = (get_compat(cfg, "eq", "belt",  fallback="") or "").strip().lower()

        storage_line = get_compat(cfg, "item", "storage", fallback="")
        storage_names = [s for s in storage_line.split() if s]
        storage_names.sort(key=lambda s: s.lower())

        def _qty(lower_key: str) -> int:
            try:
                return int(str(get_compat(cfg, "item", lower_key, fallback="1")).strip() or "1")
            except Exception:
                return 0

               
        pp = getint_compat(cfg, "cur", "pp", fallback=0)
        gp = getint_compat(cfg, "cur", "gp", fallback=0)
        ep = getint_compat(cfg, "cur", "ep", fallback=0)
        sp = getint_compat(cfg, "cur", "sp", fallback=0)
        cp = getint_compat(cfg, "cur", "cp", fallback=0)

                                      
        try:
            self._recompute_eq_weight(cfg)
            self._recompute_move(cfg)
        except Exception:
            pass

                         
        eq_weight   = self._eq_weight_cached(cfg)                                       
        coin_weight = self._coin_weight_from_cfg(cfg)
        total_w     = eq_weight + coin_weight
        move        = getint_compat(cfg, "stats", "move", fallback=20)


        def _fmt_line(name: str) -> str:
            lk = name.lower()
            qty = _qty(lk)
            tags = []
            is_equipped = False

            _c, it = self._item_lookup(name)
            is_potion   = bool(it and str(it.get("type","")).strip().lower() == "potion")
            has_charges = self._item_has_charges(name, it)

                                              
            if lk in weap_set:
                tags.append("🗡️"); is_equipped = True
            if lk == armor1_l:
                tags.append("🧥"); is_equipped = True
            if lk == armor2_l:
                _c2, it2 = self._item_lookup(name)
                tags.append("🛡️" if (it2 and self._item_is_shield(it2)) else "🧥")
                is_equipped = True
            if lk in other_set and not is_equipped:
                tags.append("🔹"); is_equipped = True
            if lk in carry_set and not is_equipped:
                tags.append("🎒")


            base = f"{name}" if qty == 1 else f"{name} x{qty}"
            if is_equipped:
                base = f"**{base}**"
            prefix = (" ".join(tags) + " ") if tags else ""
            line = prefix + base

            if is_potion:
                line += " *(potion)*"

            if has_charges:
                key = self._charges_key(name, it)
                cur, mx = self._get_item_charges(cfg, key, default_max=self._charges_max_for_item(name, it))
                if cur is not None and mx is not None:
                    line += f" — *{cur}/{mx}*"

            return line

        lines = [_fmt_line(n) for n in storage_names] or ["*(empty)*"]

                                 
        chunks, cur_chunk, cur_len = [], [], 0
        for line in lines:
            add = len(line) + 1
            if cur_len + add > 1000 and cur_chunk:
                chunks.append("\n".join(cur_chunk))
                cur_chunk, cur_len = [], 0
            cur_chunk.append(line)
            cur_len += add
        if cur_chunk:
            chunks.append("\n".join(cur_chunk))

        embed = nextcord.Embed(
            title=f"{char_name}'s Bag",
            description="**Legend:** 🗡️ equipped weapon · 🧥 armor · 🛡️ shield · 🔹 other · 🎒 carried",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(
            name="Weight / Move",
            value=f"{total_w:.1f} • {move}\n*(gear {eq_weight:.1f} • coins {coin_weight:.1f})*",
            inline=True
        )
        embed.add_field(name="Coins", value=f"pp:{pp} gp:{gp} ep:{ep} sp:{sp} cp:{cp}", inline=True)

        for i, block in enumerate(chunks, start=1):
            nm = "Inventory" if i == 1 else f"Inventory (cont. {i})"
            embed.add_field(name=nm, value=block, inline=False)

        await ctx.send(embed=embed)



    def _clean_name(self, s: str) -> str:
        return (s or "").strip()


    def _misc_slot_for_item(self, canon: str, cfg=None):
        nm = re.sub(r"[^a-z0-9]+", "", (canon or "").lower())

        if cfg is not None and not cfg.has_section("eq"):
            cfg.add_section("eq")

        def empty(slot):
            try:
                return not self._clean_name(get_compat(cfg, "eq", slot, fallback=""))
            except Exception:
                return True

        if "ring" in nm:
            if cfg is None:
                return "ring"
            if empty("ring"):
                return "ring"
            if empty("ring2"):
                return "ring2"
            return None 

        if "cloak" in nm:
            return "cloak"

        if "belt" in nm or "girdle" in nm:
            return "belt"

        if any(k in nm for k in ("pendant","amulet","necklace")):
            if cfg is None:
                return "neck"
            for k in ("neck","pendant","amulet"):
                if empty(k):
                    return k
            return self._eq_first_free_other(cfg)

        if "boots" in nm:
            return "boots"

        if any(k in nm for k in ("gauntlet","glove","hand")):
            return "hands"

        if any(k in nm for k in ("helm","helmet")):
            return "helm"

        return self._eq_first_free_other(cfg)




    def _eq_first_free_other(self, cfg):
        
        try:
            if cfg is not None and not cfg.has_section("eq"):
                cfg.add_section("eq")
        except Exception:
            pass
        keys = ("other1","other2","other3","other4","other5")
        for key in keys:
            try:
                val = get_compat(cfg, "eq", key, fallback="") if cfg else ""
            except Exception:
                val = ""
            if not self._clean_name(val):
                return key
        return "other1"  



    def _ensure_eq_section(self):
        
        char_name = get_active(self.ctx_author_id) if hasattr(self, 'ctx_author_id') else None

        return None



    def _protection_bonus_from_equipped(self, cfg) -> int:
        """Return the highest +N from any *ofProtection+N equipped item.
        Example item names: RingofProtection+2, CloakofProtection+1, BeltofProtection+3, PendantofProtection+1
        """
        others = self._equipped_others(cfg)
        best = 0
        for name in others.values():
            m = re.search(r"ofprotection\+(\d+)$", name.lower())
            if m:
                try:
                    best = max(best, int(m.group(1)))
                except Exception:
                    pass
        return best



    def _equipped_others(self, cfg) -> dict[str, str]:
        """
        Return a mapping of non-weapon/armor/shield equipment slots -> item names.
        Sources: [eq] section. Skips empty/placeholder values.
        """
        slots = (
            "ring", "ring2",
            "neck", "pendant", "amulet",
            "cloak", "belt", "hands", "boots", "helm",
            "other1", "other2", "other3", "other4", "other5",
        )
        out: dict[str, str] = {}
        for key in slots:
            val = (get_compat(cfg, "eq", key, fallback="") or "").strip()
            if val and val != "—":
                out[key] = val
        return out


    @commands.command(name="drop")
    async def drop_from_inventory(self, ctx, *, item_and_qty: str):
        """
        Drop items from your inventory (the [item] section only).
        Does NOT touch equipped or carried entries. Use !unequip / !uncarry for those.

        Usage:
          !drop Torch
          !drop Torch 5
          !drop "Holy Water" 3
          !drop StaffofPower all           # drops all copies/instances
          !drop StaffofPower@76f2b0        # drop a specific instance
        """
        

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        m = re.fullmatch(r'\s*(?:"([^"]+)"|\'([^\']+)\'|(.+?))(?:\s+(all|\*|\d+))?\s*', item_and_qty)
        if not m:
            await ctx.send("❌ Couldn’t parse. Try: `!drop Torch 3` or `!drop \"Holy Water\" 2`")
            return
        raw_name = (m.group(1) or m.group(2) or m.group(3) or "").strip()
        qty_tok  = (m.group(4) or "").strip().lower()

        storage_line = get_compat(cfg, "item", "storage", fallback="") or ""
        stor_names   = [s for s in storage_line.split() if s]
        stor_lc_map  = {s.lower(): s for s in stor_names}

        def _inst_list_for_base(base_canon_lc: str):
            out = []
            for t in stor_names:
                if "@" not in t: 
                    continue
                if t.split("@",1)[0].lower() == base_canon_lc:
                    out.append(t)
            return out

        a1 = (get_compat(cfg, "eq", "armor1", fallback="") or "").strip().lower()
        a2 = (get_compat(cfg, "eq", "armor2", fallback="") or "").strip().lower()
        weap_set  = { (w or "").strip().lower() for w in (self._eq_get_weapons(cfg) or [])}
        carry_set = { (c or "").strip().lower() for c in (self._eq_get_carry(cfg) or [])}

        if "@" in raw_name:
                                                                         
            token_lc = raw_name.lower()
            token = stor_lc_map.get(token_lc)
            if not token:
                                                         
                base_guess = raw_name.split("@",1)[0]
                candidates = [t for t in stor_names if t.split("@",1)[0].lower() == base_guess.lower()]
                if candidates:
                    await ctx.send("❌ Unknown item **{0}**.\nYou do have: {1}".format(
                        raw_name, ", ".join(candidates[:6]) + ("…" if len(candidates) > 6 else "")
                    ))
                else:
                    await ctx.send(f"❌ Unknown item **{raw_name}**.")
                return

                                                        
            if token_lc in weap_set or token_lc in carry_set or token_lc == a1 or token_lc == a2:
                await ctx.send(f"⚠️ **{token}** is equipped/carried. Use `!unequip` / `!uncarry` first.")
                return

            base = token.split("@",1)[0]
            canon, it = self._item_lookup(base)
            key_item = token.lower()                                                   

                                                              
            try:
                cur_count = int(str(cfg.get("item", key_item, fallback="1")).strip() or "1")
            except Exception:
                cur_count = 1

                                                             
            if qty_tok not in {"", "1", "all", "*"}:
                try:
                    if int(qty_tok) != 1:
                        await ctx.send("⚠️ Instance items are singular; dropping **1**.")
                except Exception:
                    pass

                                                                       
            if cfg.has_option("item", key_item):
                try:
                    cfg.remove_option("item", key_item)
                except Exception:
                    cfg.set("item", key_item, "0")
            cfg.set("item", "storage", " ".join([s for s in stor_names if s.lower() != key_item]))

                                        
            try:
                ch_key = self._charges_key(token, it)
                if cfg.has_section("charges") and cfg.has_option("charges", ch_key):
                    cfg.remove_option("charges", ch_key)
            except Exception:
                pass

            
            try:
                _pfed_cleanup_if_none_left(cfg, new_storage, base)  
            except Exception:
                pass


            write_cfg(path, cfg)
            await ctx.send(f"🗑️ **{char_name}** drops **{token} x1** (removed from bag)")
            return

        canon, it = self._item_lookup(raw_name)
        if not canon:
            await ctx.send(f"❌ Unknown item **{raw_name}**.")
            return
        base_lc = canon.lower()

                                          
        try:
            base_count = int(str(cfg.get("item", base_lc, fallback="0")).strip() or "0")
        except Exception:
            base_count = 0

                                       
        inst = _inst_list_for_base(base_lc)

        if base_count <= 0 and not inst:
            await ctx.send(f"⚠️ **{canon}** isn’t in your inventory.")
            return

                        
        if not qty_tok:
            want = 1
        elif qty_tok in {"all", "*"}:
            want = "ALL"
        else:
            try:
                want = max(1, int(qty_tok))
            except Exception:
                await ctx.send("❌ Quantity must be a positive integer (or 'all').")
                return

                                                                                                    
        equipped_instances = [t for t in inst if t.lower() in weap_set or t.lower() in carry_set or t.lower() in {a1,a2}]
        if equipped_instances:
            await ctx.send("⚠️ One or more **{0}** are equipped/carried: {1}\nUse `!unequip`/`!uncarry` first or drop a specific one like `!drop {2}`.".format(
                canon, ", ".join(equipped_instances[:6]) + ("…" if len(equipped_instances) > 6 else ""), equipped_instances[0]
            ))
            return

        dropped = 0
        new_storage = list(stor_names)

        def _remove_token(tok: str):
            nonlocal new_storage, dropped
            key_item = tok.lower()
            if cfg.has_option("item", key_item):
                try:
                    cfg.remove_option("item", key_item)
                except Exception:
                    cfg.set("item", key_item, "0")
            new_storage = [s for s in new_storage if s.lower() != key_item]
                                             
            try:
                ch_key = self._charges_key(tok, it)
                if cfg.has_section("charges") and cfg.has_option("charges", ch_key):
                    cfg.remove_option("charges", ch_key)
            except Exception:
                pass
            dropped += 1

                    
        if want == "ALL":
                                                     
                     
            if base_count > 0 and cfg.has_option("item", base_lc):
                try:
                    cfg.remove_option("item", base_lc)
                except Exception:
                    cfg.set("item", base_lc, "0")
                  
            new_storage = [s for s in new_storage if s.lower() != base_lc]

                       
            for tok in inst:
                _remove_token(tok)

        else:
                                                                                    
            take_from_stack = min(want, max(0, base_count))
            if take_from_stack > 0:
                new_val = base_count - take_from_stack
                if new_val <= 0:
                    if cfg.has_option("item", base_lc):
                        try:
                            cfg.remove_option("item", base_lc)
                        except Exception:
                            cfg.set("item", base_lc, "0")
                          
                    new_storage = [s for s in new_storage if s.lower() != base_lc]
                else:
                    cfg.set("item", base_lc, str(new_val))

                dropped += take_from_stack

            remaining = want - dropped
            if remaining > 0:
                                                        
                for tok in inst:
                    if remaining <= 0:
                        break
                    _remove_token(tok)
                    remaining -= 1


        
        try:
            _pfed_cleanup_if_none_left(cfg, new_storage, canon) 
        except Exception:
            pass
                       
        cfg.set("item", "storage", " ".join(new_storage))
        write_cfg(path, cfg)

                 
        tail = " (removed from bag)" if want == "ALL" else ""
        await ctx.send(f"🗑️ **{char_name}** drops **{canon} x{dropped}**{tail}")


    @commands.command(name="give")
    async def give(self, ctx, who: str, *, item_and_qty: str):
        """
        Give items from your ACTIVE character to another character.
          • Stacked items:  !give testman Oil 10      (moves 10 from your bag to theirs)
          • Instances:      !give holyman WandofCold@88bd1a  (moves that specific wand + its charges)
          • 'all' works for stacked + all instances: !give Alice Torch all
        Notes:
          • You must own the *source* (your active) character or have Manage Server.
          • You cannot give items that are equipped or carried; un-equip/uncarry first.
        """

        def _resolve_char_ci(name: str):
            base = name.replace(" ", "_")
            target = f"{base}.coe".lower()
            for fn in os.listdir("."):
                if fn.lower() == target and fn.lower().endswith(".coe"):
                    path = fn
                    try:
                        cfg2 = read_cfg(path)
                        real = get_compat(cfg2, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return None, None

        def _eq_weapon_slots(cfg_):
            slots = []
            if cfg_.has_section("eq"):
                for k, v in cfg_.items("eq"):
                    if re.fullmatch(r"weapon\d+", k, flags=re.I):
                        slots.append((k, (v or "").strip()))
            try:
                slots.sort(key=lambda kv: int(re.search(r"\d+", kv[0]).group()))
            except Exception:
                pass
            return slots

        def _is_equipped_or_carried(cfg_, cname: str) -> str | None:
            cn = (cname or "").strip().lower()
            a1 = get_compat(cfg_, "eq", "armor1", fallback="").strip().lower()
            a2 = get_compat(cfg_, "eq", "armor2", fallback="").strip().lower()
            if a1 == cn: return "equipped (armor1)"
            if a2 == cn: return "equipped (shield)"
            for slot, val in _eq_weapon_slots(cfg_):
                if (val or "").strip().lower() == cn:
                    return f"equipped ({slot})"
            if cfg_.has_section("eq"):
                for k, v in cfg_.items("eq"):
                    if re.fullmatch(r"carry\d+", k, flags=re.I):
                        if (v or "").strip().lower() == cn:
                            return f"carried ({k})"
            return None

        def _storage_names(cfg_):
            storage_line = get_compat(cfg_, "item", "storage", fallback="") or ""
            return [s for s in storage_line.split() if s]

        def _set_storage(cfg_, names: list[str]):
            if not cfg_.has_section("item"): cfg_.add_section("item")
            cfg_.set("item", "storage", " ".join([s for s in names if s]))

        def _inst_list_for_base(names_list: list[str], base_canon_lc: str):
            out = []
            for t in names_list:
                if "@" not in t:
                    continue
                if t.split("@", 1)[0].lower() == base_canon_lc:
                    out.append(t)
            return out

        def _charges_key_fallback(base_canon: str, token: str) -> str:
            core = "".join(ch for ch in base_canon.lower() if ch.isalnum())
            suf  = token.split("@", 1)[1].lower()
            return f"{core}_{suf}"

        src_name = get_active(ctx.author.id)
        if not src_name:
            await ctx.send("❌ No active character. Use `!char <name>` first."); return
        src_path = f"{src_name.replace(' ', '_')}.coe"
        if not os.path.exists(src_path):
            await ctx.send(f"❌ Character file not found for **{src_name}**."); return

        dst_name, dst_path = _resolve_char_ci(who)
        if not dst_path:
            await ctx.send(f"❌ Character '{who}' not found."); return

        src_cfg = read_cfg(src_path)
        dst_cfg = read_cfg(dst_path)

        owner_id = get_compat(src_cfg, "info", "owner_id", fallback="")
        if str(ctx.author.id) != str(owner_id) and not getattr(ctx.author.guild_permissions, "manage_guild", False):
            await ctx.send(f"❌ You must own **{src_name}** or have Manage Server to give items."); return

        if not src_cfg.has_section("item"):
            await ctx.send(f"❌ **{src_name}** has no inventory recorded."); return
        if not dst_cfg.has_section("item"):
            dst_cfg.add_section("item")

        m = re.fullmatch(r'\s*(?:"([^"]+)"|\'([^\']+)\'|(.+?))(?:\s+(all|\*|\d+))?\s*', item_and_qty)
        if not m:
            await ctx.send("❌ Couldn’t parse. Try: `!give testman Oil 3` or `!give holyman WandofCold@88bd1a`"); return
        raw_name = (m.group(1) or m.group(2) or m.group(3) or "").strip()
        qty_tok  = (m.group(4) or "").strip().lower()

        src_names = _storage_names(src_cfg)
        src_lc_map = {s.lower(): s for s in src_names}

        if "@" in raw_name:
            token_lc = raw_name.lower()
            token = src_lc_map.get(token_lc)
            if not token:
                                                
                base_guess = raw_name.split("@", 1)[0]
                candidates = [t for t in src_names if t.split("@",1)[0].lower() == base_guess.lower()]
                if candidates:
                    await ctx.send("❌ Unknown item **{0}**.\nYou do have: {1}".format(
                        raw_name, ", ".join(candidates[:6]) + ("…" if len(candidates) > 6 else "")
                    ))
                else:
                    await ctx.send(f"❌ **{src_name}** doesn’t have **{raw_name}**.")
                return

                                 
            where = _is_equipped_or_carried(src_cfg, token)
            if where:
                await ctx.send(f"❌ You can’t give **{token}** because it’s {where}. `!unequip` / `!uncarry` first."); return

            base = token.split("@", 1)[0]
            canon, it = self._item_lookup(base)
            ch_key = None
                                                
            try:
                ch_key = self._charges_key(token, it)
            except Exception:
                ch_key = _charges_key_fallback(canon or base, token)

                                      
            if src_cfg.has_option("item", token.lower()):
                try:
                    src_cfg.remove_option("item", token.lower())
                except Exception:
                    src_cfg.set("item", token.lower(), "0")
            src_names = [s for s in src_names if s.lower() != token.lower()]
            _set_storage(src_cfg, src_names)

                                         
            ch_val = None
            try:
                ch_val = src_cfg.get("charges", ch_key, fallback=None)
            except Exception:
                ch_val = None
            if ch_val is not None:
                if not dst_cfg.has_section("charges"): dst_cfg.add_section("charges")
                dst_cfg.set("charges", ch_key, ch_val)
                try:
                    if src_cfg.has_section("charges") and src_cfg.has_option("charges", ch_key):
                        src_cfg.remove_option("charges", ch_key)
                except Exception:
                    pass

                               
            dst_storage = _storage_names(dst_cfg)
            if token not in dst_storage:
                dst_storage.append(token)
                _set_storage(dst_cfg, dst_storage)
            dst_cfg.set("item", token.lower(), "1")
                                                                  
            try:
                if not dst_cfg.has_option("item", (canon or base).lower()):
                    dst_cfg.set("item", (canon or base).lower(), "0")
            except Exception:
                pass

            
            try:
                base = token.split("@", 1)[0]
                _pfed_cleanup_if_none_left(src_cfg, src_names, base)
            except Exception:
                pass

            write_cfg(src_path, src_cfg)
            write_cfg(dst_path, dst_cfg)

            await ctx.send(f"🎁 **{src_name}** gives **{token}** to **{dst_name}**.")
            return

        canon, it = self._item_lookup(raw_name)
        if not canon:
            await ctx.send(f"❌ Unknown item **{raw_name}**."); return
        base_lc = canon.lower()

                                      
        try:
            base_count = int(str(src_cfg.get("item", base_lc, fallback="0")).strip() or "0")
        except Exception:
            base_count = 0
        inst = _inst_list_for_base(src_names, base_lc)

        if base_count <= 0 and not inst:
            await ctx.send(f"❌ **{src_name}** has no **{canon}** to give."); return

                                                                                                    
        equipped_instances = [t for t in inst if _is_equipped_or_carried(src_cfg, t)]
        if equipped_instances:
            await ctx.send("❌ One or more **{0}** are equipped/carried: {1}\n"
                           "Use `!unequip`/`!uncarry` first or give a specific one like `!give {2} {3}`."
                           .format(canon, ", ".join(equipped_instances[:6]) + ("…" if len(equipped_instances) > 6 else ""),
                                   who, equipped_instances[0]))
            return

                        
        if not qty_tok:
            want = 1
        elif qty_tok in {"all", "*"}:
            want = "ALL"
        else:
            try:
                want = max(1, int(qty_tok))
            except Exception:
                await ctx.send("❌ Quantity must be a positive integer (or 'all')."); return

        moved_stack = 0
        moved_tokens = []

                         
        if want == "ALL":
                     
            if base_count > 0 and src_cfg.has_option("item", base_lc):
                try:
                    src_cfg.remove_option("item", base_lc)
                except Exception:
                    src_cfg.set("item", base_lc, "0")
                moved_stack = base_count
                                                             
                src_names = [s for s in src_names if s.lower() != base_lc]    
                       
            for tok in inst:
                                   
                if src_cfg.has_option("item", tok.lower()):
                    try:
                        src_cfg.remove_option("item", tok.lower())
                    except Exception:
                        src_cfg.set("item", tok.lower(), "0")
                src_names = [s for s in src_names if s.lower() != tok.lower()]
                moved_tokens.append(tok)
        else:
            total_have = base_count + len(inst)
            if want > total_have:
                await ctx.send(f"❌ Not enough **{canon}**. You have **{total_have}** total (stacked {base_count}, instances {len(inst)}).")
                return
                                             
            take_stack = min(want, max(0, base_count))
            if take_stack > 0:
                new_val = base_count - take_stack
                if new_val <= 0:
                    if src_cfg.has_option("item", base_lc):
                        try:
                            src_cfg.remove_option("item", base_lc)
                        except Exception:
                            src_cfg.set("item", base_lc, "0")
                                                                             
                    src_names = [s for s in src_names if s.lower() != base_lc]

                else:
                    src_cfg.set("item", base_lc, str(new_val))
                moved_stack = take_stack
            rem = want - moved_stack
            for tok in inst:
                if rem <= 0:
                    break
                if src_cfg.has_option("item", tok.lower()):
                    try:
                        src_cfg.remove_option("item", tok.lower())
                    except Exception:
                        src_cfg.set("item", tok.lower(), "0")
                src_names = [s for s in src_names if s.lower() != tok.lower()]
                moved_tokens.append(tok)
                rem -= 1

                                     
        _set_storage(src_cfg, src_names)

                       
        if moved_stack > 0:
            try:
                dst_cur = int(str(dst_cfg.get("item", base_lc, fallback="0")).strip() or "0")
            except Exception:
                dst_cur = 0
            dst_cfg.set("item", base_lc, str(dst_cur + moved_stack))
                                                                                
            dst_names = _storage_names(dst_cfg)
            if canon.lower() not in {t.lower() for t in dst_names}:
                dst_names.append(canon)
                _set_storage(dst_cfg, dst_names)

                                            
        for tok in moved_tokens:
            dst_names = _storage_names(dst_cfg)
            if tok not in dst_names:
                dst_names.append(tok)
                _set_storage(dst_cfg, dst_names)
            dst_cfg.set("item", tok.lower(), "1")
                                                                                
            if not dst_cfg.has_option("item", base_lc):
                dst_cfg.set("item", base_lc, "0")

                          
            base = tok.split("@", 1)[0]
            canon_tok, it_tok = self._item_lookup(base)
            try:
                ch_key = self._charges_key(tok, it_tok)
            except Exception:
                ch_key = _charges_key_fallback(canon_tok or base, tok)
            ch_val = None
            try:
                ch_val = src_cfg.get("charges", ch_key, fallback=None)
            except Exception:
                ch_val = None
            if ch_val is not None:
                if not dst_cfg.has_section("charges"): dst_cfg.add_section("charges")
                dst_cfg.set("charges", ch_key, ch_val)
                try:
                    if src_cfg.has_section("charges") and src_cfg.has_option("charges", ch_key):
                        src_cfg.remove_option("charges", ch_key)
                except Exception:
                    pass

        
        try:
            _pfed_cleanup_if_none_left(src_cfg, src_names, canon)
        except Exception:
            pass

                 
        write_cfg(src_path, src_cfg)
        write_cfg(dst_path, dst_cfg)

        bits = []
        if moved_stack:
            bits.append(f"{canon} x{moved_stack}")
        if moved_tokens:
            show = ", ".join(moved_tokens[:4]) + ("…" if len(moved_tokens) > 4 else "")
            bits.append(show)
        detail = " & ".join(bits) if bits else canon
        await ctx.send(f"🎁 **{src_name}** gives **{detail}** to **{dst_name}**.")


        
    def _format_accessories_from_cfg(self, cfg) -> str:
        """
        Build an 'Accessories' block from equipped non-weapon/armor items.
        Uses your existing _equipped_others(cfg) map plus direct eq.* lookups.
        """
        order = [
            ("ring",   "Ring"),
            ("ring2",  "Ring (2)"),
            ("neck",   "Neck"),
            ("pendant","Neck"),
            ("amulet", "Neck"),
            ("cloak",  "Cloak"),
            ("belt",   "Belt"),
            ("hands",  "Hands"),
            ("boots",  "Boots"),
            ("helm",   "Helm"),
            ("other1", "Other"),
            ("other2", "Other"),
            ("other3", "Other"),
            ("other4", "Other"),
            ("other5", "Other"),
        ]
        icons = {
            "ring": "🔹",
            "ring2": "🔹",
            "neck": "🔹",
            "pendant": "🔹",
            "amulet": "🔹",
            "cloak": "🔹",
            "belt": "🔹",
            "hands": "🔹",
            "boots": "🔹",
            "helm": "🔹",
            "other": "🔹",
        }
        try:
            slots = self._equipped_others(cfg) or {}
        except Exception:
            slots = {}
        lines = []
        for key, label in order:
            name = (slots.get(key) or get_compat(cfg, "eq", key, fallback="") or "").strip()
            if not name:
                continue
            base_key = "other" if key.startswith("other") else key
            icon = icons.get(base_key, "🔹")
            
            lines.append(f"{icon} {name}")
        return "\n".join(lines) if lines else "—"

    @commands.command(name="eq")
    async def show_equipment(self, ctx):
        """
        Show equipment for your ACTIVE character:
          • Equipped weapons (marks (2H) where applicable)
          • Armor & Shield
          • Equipped weight • Move • AC
        """
        

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        race_lc, class_lc = self._get_char_race_class(cfg)

                                    
        weap_list = self._eq_get_weapons(cfg) or []
        weap_lines = []
        for w in weap_list:
            c, it = self._item_lookup(w)
            label = c or w
            try:
                                                                           
                if it:
                    eff_h = self._effective_hands(it, race_lc)
                    if eff_h >= 2:
                        label += " (2H)"
            except Exception:
                pass
            weap_lines.append(f"🗡️ {label}")
        weapons_text = "\n".join(weap_lines) if weap_lines else "—"

                                                         
        a1 = (get_compat(cfg, "eq", "armor1", fallback="") or "").strip()
        a2 = (get_compat(cfg, "eq", "armor2", fallback="") or "").strip()

                                                                
        shield_name = ""
        if a2:
            c2, it2 = self._item_lookup(a2)
            if it2 and self._item_is_shield(it2):
                shield_name = c2 or a2

        armor_text = f"🧥 {a1}" if a1 else "🧥 —"
        shield_text = f"🛡️ {shield_name}" if shield_name else "🛡️ —"

        try:
            eq_weight = float(str(get_compat(cfg, "eq", "weight", fallback="0")).strip() or "0")
        except Exception:
            eq_weight = 0.0

                                                         
        try:
            eq_weight = self._recompute_eq_weight(cfg)
        except Exception:
            pass

        try:
            ac_raw = get_compat(cfg, "stats", "ac", fallback="")
            ac_now = int(ac_raw) if str(ac_raw).strip() != "" else 10
        except Exception:
            ac_now = 10
        try:
                                                                            
            move_now = self._recompute_move(cfg)
        except Exception:
            move_now = getint_compat(cfg, "stats", "move", fallback=20)

        embed = nextcord.Embed(
            title=f"{char_name}'s Equipment",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(name="Weapons (equipped)", value=weapons_text, inline=False)
        embed.add_field(name="Armor & Shield", value=f"{armor_text}\n{shield_text}", inline=False)
        embed.add_field(name="Accessories", value=self._format_accessories_from_cfg(cfg), inline=False)
        embed.add_field(
            name="Move / AC",
            value=f"**{move_now}**  •  **{ac_now}**",
            inline=False
        )
        embed.set_footer(text="Tip: use !bag to see full inventory")

        await ctx.send(embed=embed)


    @commands.command(name="shop")
    async def shop(self, ctx, *filters):
        """
        Show a shop catalog (optionally filtered).
          !shop                         # all categories
          !shop slashing                # just one category
          !shop weapon                  # melee + ranged (+ammo)
          !shop armor                   # armor + shields
          !shop item                    # everything after Shield (consumables & general)
          !shop armor potion            # multiple filters = union

        Categories: slashing, piercing, bludgeoning, ranged, missile, ammo,
                    armor, shield, potion, scroll, holy, fire, oil, holywater,
                    gear, tool, food, other
        """
        from collections import defaultdict

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return
        cfg = read_cfg(path)

                         
        pp = getint_compat(cfg, "cur", "pp", fallback=0)
        gp = getint_compat(cfg, "cur", "gp", fallback=0)
        ep = getint_compat(cfg, "cur", "ep", fallback=0)
        sp = getint_compat(cfg, "cur", "sp", fallback=0)
        cp = getint_compat(cfg, "cur", "cp", fallback=0)

        def _catalog_from_items_dict(items_dict: dict):
            out = []
            for name, data in items_dict.items():
                price_raw = data.get("price", None)
                if price_raw in (None, "", "-", 0, "0"):
                    continue
                try:
                    price = float(str(price_raw).strip())
                except Exception:
                    continue

                name_l = str(name).lower()
                typ = str(data.get("type", "other") or "other").strip().lower()

                shop_cat = typ
                if any(w in name_l for w in ("bow", "crossbow", "xbow", "sling")):
                    shop_cat = "ranged"

                size = str(data.get("size", "")).strip()
                dmg  = str(data.get("dmg",  "")).strip()
                wt   = str(data.get("weight","")).strip()

                out.append({
                    "name": name,
                    "price": price,
                    "type": typ,
                    "shop_cat": shop_cat,
                    "size": size,
                    "dmg": dmg,
                    "weight": wt
                })
            return out

        def _catalog_from_items_file(path="item.lst"):
            cp = configparser.ConfigParser()
            cp.optionxform = str
            try:
                cp.read(path, encoding="utf-8")
            except Exception:
                cp.read(path)
            out = []
            for sec in cp.sections():
                price_raw = cp.get(sec, "price", fallback="").strip()
                if price_raw in ("", "-", "0"):
                    continue
                try:
                    price = float(price_raw)
                except Exception:
                    continue

                name_l = sec.lower()
                typ = cp.get(sec, "type", fallback="other").strip().lower() or "other"

                shop_cat = typ
                if any(w in name_l for w in ("bow", "crossbow", "xbow", "sling")):
                    shop_cat = "ranged"

                size = cp.get(sec, "size",   fallback="").strip()
                dmg  = cp.get(sec, "dmg",    fallback="").strip()
                wt   = cp.get(sec, "weight", fallback="").strip()

                out.append({
                    "name": sec,
                    "price": price,
                    "type": typ,
                    "shop_cat": shop_cat,
                    "size": size,
                    "dmg": dmg,
                    "weight": wt
                })
            return out

        if hasattr(self, "items") and isinstance(self.items, dict) and self.items:
            catalog = _catalog_from_items_dict(self.items)
        else:
            catalog = _catalog_from_items_file("item.lst")

        if not catalog:
            await ctx.send("⚠️ No priced items found in the catalog.")
            return

        ICON = {
            "slashing": "⚔️", "piercing": "🗡️", "bludgeoning": "🔨",
            "missile": "🏹", "ranged": "🏹", "ammo": "🎯",
            "armor": "🧥", "shield": "🛡️",
            "potion": "🧪", "scroll": "📜",
            "fire": "🔥", "holy": "✨", "oil": "🔥", "holywater": "💧✨",
            "gear": "🎒", "tool": "🧰", "food": "🥖",
            "other": "📦",
        }
        ORDER = {
                           
            "slashing": 10, "piercing": 11, "bludgeoning": 12, "missile": 13, "ranged": 14, "ammo": 15,
                      
            "armor": 20, "shield": 21,
                                 
            "potion": 30, "scroll": 31, "holy": 32, "fire": 33, "oil": 34, "holywater": 35,
                     
            "gear": 40, "tool": 41, "food": 42,
                      
            "other": 99,
        }

        tokens = [str(f).strip().lower() for f in filters if str(f).strip()]
        WEAPON_CATS = {"slashing", "piercing", "bludgeoning", "missile", "ranged", "ammo"}
        ARMOR_CATS  = {"armor", "shield"}
        ITEM_CATS   = {k for k, n in ORDER.items() if n > ORDER["shield"]}                     

        wanted: set[str] = set()
        unknown: list[str] = []

        for t in tokens:
            if t in ("weapon", "weapons"):
                wanted |= WEAPON_CATS
            elif t == "armor":
                wanted |= ARMOR_CATS
            elif t in ("item", "items"):
                wanted |= ITEM_CATS
            elif t in ORDER:
                wanted.add(t)
            else:
                unknown.append(t)

        if tokens and not wanted:
            valid = ["weapon(s)", "armor", "item(s)"] + sorted(ORDER.keys())
            await ctx.send("❓ Unknown filter(s): " + ", ".join(f"`{u}`" for u in unknown) +
                           "\nTry one of: " + ", ".join(f"`{v}`" for v in valid))
            return

        groups = defaultdict(list)
        for it in catalog:
            typ = it.get("shop_cat", it.get("type", "other"))
            if typ not in ORDER:
                typ = "other"
                                     
            if wanted and typ not in wanted:
                continue
            groups[typ].append(it)

        if not groups:
            await ctx.send("ℹ️ No items match that filter.")
            return

                                      
        for typ in list(groups.keys()):
            groups[typ].sort(key=lambda d: (d["price"], d["name"].lower()))

        def _fmt_price(v: float) -> str:
            return f"{int(v)} gp" if abs(v - int(v)) < 1e-9 else f"{v:g} gp"

        def _fmt_line(it: dict) -> str:
            bits = []
            if it["dmg"]:
                bits.append(it["dmg"])
            if it["size"]:
                bits.append(it["size"].upper())
            if it["weight"]:
                bits.append(f"{it['weight']} wt")
            tail = f" ({', '.join(bits)})" if bits else ""
            return f"**{it['name']}** — {_fmt_price(it['price'])}{tail}"

        def _add_group_fields(embed, gtitle: str, lines: list[str]):
            if not lines:
                return
            block = []
            cur_len = 0
            for line in lines:
                add_len = len(line) + 1
                if block and cur_len + add_len > 1000:
                    embed.add_field(name=gtitle, value="\n".join(block), inline=False)
                    block, cur_len = [], 0
                    gtitle = gtitle + " (cont.)"
                block.append(line)
                cur_len += add_len
            if block:
                embed.add_field(name=gtitle, value="\n".join(block), inline=False)

        pretty_filter = " • ".join(tokens) if tokens else "All"
        embed = nextcord.Embed(
            title="🏪 Shop",
            description=f"Filter: **{pretty_filter}**\n(Use `!bag` to see what you’re carrying.)",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(name="Your Coins", value=f"pp:{pp} gp:{gp} ep:{ep} sp:{sp} cp:{cp}", inline=True)

                                
        for typ in sorted(groups.keys(), key=lambda t: (ORDER.get(t, 99), t)):
            icon = ICON.get(typ, ICON["other"])
            title = f"{icon} {typ.title()}"
            lines = [_fmt_line(it) for it in groups[typ]]
            _add_group_fields(embed, title, lines)

        await ctx.send(embed=embed)


    @commands.command(name="buy")
    async def buy(self, ctx, *, item_and_qty: str):
        """Buy an item using your active character's coins (keeps gear/coin weights separate)."""
        
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first."); return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**."); return

        m = re.fullmatch(r'\s*(?:"([^"]+)"|\'([^\']+)\'|(.+?))(?:\s+(\d+))?\s*', item_and_qty)
        if not m:
            await ctx.send("❌ Couldn’t parse item and quantity. Try: `!buy rations 2`"); return
        item_name = (m.group(1) or m.group(2) or m.group(3) or "").strip()
        qty = int(m.group(4) or "1")
        if qty <= 0:
            await ctx.send("❌ Quantity must be a positive integer."); return

        canon = self._canon(item_name)
        data = self.items.get(canon, {})
        price_raw = (data.get("price", "") or "").strip()
        if not price_raw:
            await ctx.send(f"❌ **{canon}** has no `price=` in item.lst."); return
        try:
            unit_gp = float(price_raw)
        except Exception:
            await ctx.send(f"❌ Couldn’t parse price for **{canon}**: `{price_raw}`"); return

        cost_gp = unit_gp * qty
        cost_cp = int(round(cost_gp * 100))

        cfg = read_cfg(path)

        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(cfg)

        pp = getint_compat(cfg, "cur", "pp", fallback=0)
        gp = getint_compat(cfg, "cur", "gp", fallback=0)
        ep = getint_compat(cfg, "cur", "ep", fallback=0)
        sp = getint_compat(cfg, "cur", "sp", fallback=0)
        cp = getint_compat(cfg, "cur", "cp", fallback=0)
        wallet_cp = pp*1000 + gp*100 + ep*50 + sp*10 + cp
        if wallet_cp < cost_cp:
            short_gp = (cost_cp - wallet_cp) / 100.0
            await ctx.send(f"❌ Not enough funds. Need **{cost_gp:.2f} gp**, short by **{short_gp:.2f} gp**.")
            return

        new_cp_total = wallet_cp - cost_cp
        new_pp = new_cp_total // 1000; rem = new_cp_total % 1000
        new_gp = rem // 100;          rem = rem % 100
        new_ep = rem // 50;           rem = rem % 50
        new_sp = rem // 10;           new_cp = rem % 10

        if not cfg.has_section("cur"): cfg.add_section("cur")
        cfg.set("cur", "pp", str(new_pp))
        cfg.set("cur", "gp", str(new_gp))
        cfg.set("cur", "ep", str(new_ep))
        cfg.set("cur", "sp", str(new_sp))
        cfg.set("cur", "cp", str(new_cp))

        if not cfg.has_section("item"): cfg.add_section("item")
        lower_key = canon.lower()
        try:
            cur_cnt = int(str(cfg.get("item", lower_key, fallback="0")).strip() or "0")
        except Exception:
            cur_cnt = 0
        cfg.set("item", lower_key, str(cur_cnt + qty))
        storage_line = cfg.get("item", "storage", fallback="")
        tokens = [t for t in storage_line.split() if t]
        if canon.lower() not in {t.lower() for t in tokens}:
            tokens.append(canon)
        cfg.set("item", "storage", " ".join(tokens))

        new_coin_w = (new_pp + new_gp + new_ep + new_sp + new_cp) * 0.02
        if not cfg.has_section("eq"): cfg.add_section("eq")
        cfg.set("eq", "coin_weight", f"{new_coin_w:.2f}")

                                                                                                      
        new_eq_w = self._recompute_eq_weight(cfg)

                                               
        new_move = self._recompute_move(cfg)

                                                       
        write_cfg(path, cfg)

        new_total = new_eq_w + new_coin_w
        await ctx.send(
            f"🛒 **{char_name}** buys **{qty}× {canon}** @ {unit_gp:g} gp each = **{cost_gp:.2f} gp**.\n"
            f"New coins → pp:{new_pp} gp:{new_gp} ep:{new_ep} sp:{new_sp} cp:{new_cp}\n"
            f"Total weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
            f"(gear {self._fmt_w(old_eq_w)} → {self._fmt_w(new_eq_w)}, coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  "
            f"Move: **{new_move}**"
        )


    @commands.command(name="sell")
    async def sell(self, ctx, *, item_and_qty: str):
        """Sell an item back to the shop for half price (keeps gear/coin weights separate)."""
        

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first."); return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**."); return

        m = re.fullmatch(r'\s*(?:"([^"]+)"|\'([^\']+)\'|(.+?))(?:\s+(\d+))?\s*', item_and_qty)
        if not m:
            await ctx.send("❌ Couldn’t parse item and quantity. Try: `!sell rations 2`"); return
        item_name = (m.group(1) or m.group(2) or m.group(3) or "").strip()
        qty = int(m.group(4) or "1")
        if qty <= 0:
            await ctx.send("❌ Quantity must be a positive integer."); return

        canon = self._canon(item_name)
        data = self.items.get(canon, {})
        price_raw = (data.get("price", "") or "").strip()
        if not price_raw:
            await ctx.send(f"❌ **{canon}** has no `price=` in item.lst, so it can’t be sold."); return
        try:
            unit_gp = float(price_raw)
        except Exception:
            await ctx.send(f"❌ Couldn’t parse price for **{canon}**: `{price_raw}`"); return

        cfg = read_cfg(path)

        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(cfg)

        if not cfg.has_section("item"):
            await ctx.send("❌ You don’t have any inventory recorded."); return
        lower_key = canon.lower()
        try:
            have = int(str(cfg.get("item", lower_key, fallback="0")).strip() or "0")
        except Exception:
            have = 0
        if have <= 0:
            await ctx.send(f"❌ You don’t have any **{canon}** to sell."); return
        if qty > have:
            await ctx.send(f"❌ You only have **{have}× {canon}**."); return

                                           
        def _eq_weapon_slots(cfg):
            slots = []
            if cfg.has_section("eq"):
                for k, v in cfg.items("eq"):
                    if re.fullmatch(r"weapon\d+", k, flags=re.I):
                        slots.append((k, (v or "").strip()))
            slots.sort(key=lambda kv: int(re.search(r"\d+", kv[0]).group()))
            return slots

        def _is_equipped_or_carried(cname: str) -> str | None:
            cn = (cname or "").strip().lower()
            a1 = get_compat(cfg, "eq", "armor1", fallback="").strip().lower()
            a2 = get_compat(cfg, "eq", "armor2", fallback="").strip().lower()
            if a1 == cn: return "equipped (armor1)"
            if a2 == cn: return "equipped (shield)"
            for slot, val in _eq_weapon_slots(cfg):
                if val.lower() == cn:
                    return f"equipped ({slot})"
            if cfg.has_section("eq"):
                for k, v in cfg.items("eq"):
                    if re.fullmatch(r"carry\d+", k, flags=re.I):
                        if (v or "").strip().lower() == cn:
                            return f"carried ({k})"
            return None

        where = _is_equipped_or_carried(canon)
        if where:
            await ctx.send(f"❌ You can’t sell **{canon}** because it’s {where}. Unequip/uncarry it first.")
            return

        proceeds_gp = unit_gp * qty * 0.5
        proceeds_cp = int(round(proceeds_gp * 100))

        pp = getint_compat(cfg, "cur", "pp", fallback=0)
        gp = getint_compat(cfg, "cur", "gp", fallback=0)
        ep = getint_compat(cfg, "cur", "ep", fallback=0)
        sp = getint_compat(cfg, "cur", "sp", fallback=0)
        cp = getint_compat(cfg, "cur", "cp", fallback=0)
        new_cp_total = pp*1000 + gp*100 + ep*50 + sp*10 + cp + proceeds_cp

        new_pp = new_cp_total // 1000; rem = new_cp_total % 1000
        new_gp = rem // 100;          rem = rem % 100
        new_ep = rem // 50;           rem = rem % 50
        new_sp = rem // 10;           new_cp = rem % 10

        if not cfg.has_section("cur"): cfg.add_section("cur")
        cfg.set("cur", "pp", str(new_pp))
        cfg.set("cur", "gp", str(new_gp))
        cfg.set("cur", "ep", str(new_ep))
        cfg.set("cur", "sp", str(new_sp))
        cfg.set("cur", "cp", str(new_cp))

        new_cnt = have - qty
        if new_cnt > 0:
            cfg.set("item", lower_key, str(new_cnt))
        else:
                                                           
            if cfg.has_option("item", lower_key):
                cfg.remove_option("item", lower_key)
            storage_line = cfg.get("item", "storage", fallback="")
            toks = [t for t in storage_line.split() if t]
            toks = [t for t in toks if t.lower() != canon.lower()]
            cfg.set("item", "storage", " ".join(toks))

        new_coin_w = (new_pp + new_gp + new_ep + new_sp + new_cp) * 0.02
        if not cfg.has_section("eq"): cfg.add_section("eq")
        cfg.set("eq", "coin_weight", f"{new_coin_w:.2f}")

                                                                                         
        new_eq_w = self._recompute_eq_weight(cfg)

                                               
        new_move = self._recompute_move(cfg)

                 
        write_cfg(path, cfg)

        total_get_gp = proceeds_cp / 100.0
        new_total = new_eq_w + new_coin_w
        await ctx.send(
            f"🏷️ **{char_name}** sells **{qty}× {canon}** for **{total_get_gp:.2f} gp** (½ of {unit_gp:g} gp each).\n"
            f"New coins → pp:{new_pp} gp:{new_gp} ep:{new_ep} sp:{new_sp} cp:{new_cp}\n"
            f"Total weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
            f"(gear {self._fmt_w(old_eq_w)} → {self._fmt_w(new_eq_w)}, coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  "
            f"Move: **{new_move}**"
        )


    @commands.command(name="damage")
    async def dm_damage(self, ctx, target: str, amount: str):
        """
        GM-only: Apply damage (or healing with negative) to a target by name.
        Examples:
          !damage testman 3d6+5
          !damage testman 3
          !damage BU1 -5        # heal 5
        """
        allowed = getattr(ctx.author.guild_permissions, "manage_guild", False)
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if bcfg.has_section(chan_id):
            dm_id = bcfg.get(chan_id, "DM", fallback="")
            if str(ctx.author.id) == str(dm_id):
                allowed = True
        else:
                                                                             
            for sec in bcfg.sections():
                if bcfg.get(sec, "DM", fallback="") == str(ctx.author.id):
                    allowed = True
                    break
                    
        if not allowed:
            await ctx.send("❌ Only the GM (this battle) or users with **Manage Server** may use `!damage`.")
            return

        tgt_name, tgt_path = _resolve_char_ci(target)
        if not tgt_path:
            await ctx.send(f"❌ Target '{target}' not found.")
            return

        tgt_cfg = read_cfg(tgt_path)
        old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(tgt_cfg, "max", "hp", fallback=old_hp)

        amount_raw = amount.strip()
        used_dice = False
        rolls = []
        flat = 0
        try:
                                         
            s, rolls, flat = roll_dice(amount_raw)
            val = s + flat
            used_dice = True
        except Exception:
                                                       
            try:
                val = int(amount_raw.replace("+", ""))
            except Exception:
                await ctx.send("❌ Invalid amount. Use a number (e.g. `3`) or dice (e.g. `3d6+5`).")
                return

                                                       
        delta_hp = -val
        new_hp = max(0, min(max_hp, old_hp + delta_hp))
        tgt_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, tgt_cfg)

        if used_dice:
            rolls_str = "[" + ", ".join(str(r) for r in rolls) + "]"
            mod_txt = (f" {'+' if flat > 0 else '-'} {abs(flat)}" if flat else "")
            detail = f"{amount_raw} {rolls_str}{mod_txt} → {val}"
        else:
            detail = f"{val}"

        is_mon = _is_monster_file(tgt_path)
        verb = "takes" if val >= 0 else "heals"
        title = f"💥 {tgt_name} {verb} {abs(val)}"

        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.add_field(name="Roll/Amount", value=detail, inline=True)

        if is_mon:
            mhp = getint_compat(tgt_cfg, "max", "hp", fallback=max_hp)
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
            embed.add_field(name="Target HP", value=f"{before} → **{after}**{dead_note}", inline=False)
        else:
            dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
            embed.add_field(name="Target HP", value=f"{old_hp} → **{new_hp}** / {max_hp}{dead_note}", inline=False)

        await ctx.send(embed=embed)

        if is_mon and new_hp <= 0:
            try:
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    name_key = _find_ci_name(names, tgt_name) or tgt_name
                    if name_key in names:
                        names = [n for n in names if n != name_key]
                        if bcfg.has_option(chan_id, name_key):
                            bcfg.remove_option(chan_id, name_key)
                        slot = _slot(name_key)
                        for suf in (".dex", ".join", ".disp"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == name_key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)

                                                                         
                        try:
                            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                            if msg_id:
                                block = _format_tracker_block(bcfg, chan_id)
                                content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                                msg = await ctx.channel.fetch_message(msg_id)
                                await msg.edit(content=content)
                        except Exception:
                            pass

                                                 
                try:
                    os.remove(tgt_path)
                except Exception:
                    pass

                await ctx.send(f"☠️ **{tgt_name}** is slain and removed.")
            except Exception:
                pass

        try:
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    try:
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass


    @commands.command(name="msave")
    async def monster_save(self, ctx, who: str, save_key: str, *opts):
        """
        GM: Roll a saving throw for a monster (or any .coe target).
        Usage:
          !msave BU1 poi
          !msave go2 para -p 2     (apply a -2 penalty to the save)
        Valid save keys: poi, wand, para, breath, spell
        """
        save_names = {
            "poi":    "Death Ray or Poison",
            "wand":   "Magic Wands",
            "para":   "Paralysis or Petrify",
            "breath": "Dragon Breath",
            "spell":  "Spells",
        }
        save_key = save_key.lower().strip()
        if save_key not in save_names:
            await ctx.send(f"❌ Unknown saving throw '{save_key}'. Valid: {', '.join(save_names.keys())}")
            return

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        allowed = getattr(ctx.author.guild_permissions, "manage_guild", False)
        if bcfg.has_section(chan_id):
            if bcfg.get(chan_id, "DM", fallback="") == str(ctx.author.id):
                allowed = True
        else:
                                                                     
            for sec in bcfg.sections():
                if bcfg.get(sec, "DM", fallback="") == str(ctx.author.id):
                    allowed = True
                    break
        if not allowed:
            await ctx.send("❌ Only the GM (or a user with Manage Server) can use `!msave`.")
            return

        targ_name, targ_path = _resolve_char_ci(who)
        if not targ_path:
            await ctx.send(f"❌ Target '{who}' not found.")
            return
        tcfg = read_cfg(targ_path)

        penalty = 0                                                                     
        i = 0
        while i < len(opts):
            tok = str(opts[i]).lower()
            if tok in ("-p", "-penalty", "-m", "-mod") and i + 1 < len(opts):
                try:
                    penalty = int(str(opts[i + 1]).replace("+", "").strip())
                except Exception:
                    penalty = 0
                i += 2
                continue
            i += 1

                                             
        primary_target = None

                                                                                                           
        if primary_target is None and targ_name:
            primary_target = targ_name


                                                                             
        prim_disp, prim_path = (None, None)
        target_ac = None
        if primary_target:
            prim_disp, prim_path = _resolve_char_ci(primary_target)
            if not prim_path:
                await ctx.send(f"⚠️ Target **{primary_target}** not found; rolling without AC check.")
                primary_target = None

        display_target = prim_disp or primary_target                              

        def _int_or_none(val):
            try:
                s = str(val).strip()
                return int(s) if s != "" else None
            except Exception:
                return None

        dc = _int_or_none(get_compat(tcfg, "saves", save_key, fallback=""))

        if dc is None:
            cls = (get_compat(tcfg, "info", "class", fallback="Fighter") or "Fighter")
            lvl = max(1, getint_compat(tcfg, "cur", "level", fallback=1))
            block = (self.class_saves.get(cls, {}) or self.class_saves.get(cls.title(), {}) or self.class_saves.get("Fighter", {}))
            arr = block.get(save_key, [])
            dc = int(arr[min(lvl - 1, len(arr) - 1)]) if arr else 15

        roll = random.randint(1,20)
        
        try:
            prot = max(0, int(_equipped_protection_bonus(cfg)))
        except Exception:
            prot = 0
        effective = roll + prot - max(0, penalty)
        success = (effective >= dc)

                                                                               
        face = "**20** 🎉" if roll == 20 else ("**1** 💀" if roll == 1 else str(roll))
        pen_txt = f" - {penalty}" if penalty else ""

        embed = nextcord.Embed(
            title=f"{targ_name} — Save vs {save_names[save_key]}",
            color=random.randint(0, 0xFFFFFF),
        )
        embed.add_field(name="Roll", value=face, inline=True)
        if penalty:
            embed.add_field(name="Modifier", value=f"Penalty {pen_txt}", inline=True)
        embed.add_field(name="Check", value=f"{effective} vs {dc}", inline=True)
        embed.add_field(name="Result", value=("✅ **SUCCESS**" if success else "❌ **FAIL**"), inline=False)

        await ctx.send(embed=embed)


    @commands.command(name="turn")
    async def turn_undead(self, ctx, *targets):
        """Cleric/Paladin: Turn Undead. Usage: !turn sk1 sk2 sk3"""
        if not targets:
            await ctx.send("Usage: `!turn <target1> [target2 ...]`")
            return

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ','_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return
        ccfg = read_cfg(path)
        owner_id = get_compat(ccfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        def _starlight_active_for(bcfg, chan_id, name):
            try:
                if not (bcfg and bcfg.has_section(chan_id)):
                    return False
                key  = _canon_init_key(bcfg, chan_id, name) if '_canon_init_key' in globals() else name
                slot = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                return (bcfg.getint(chan_id, f"{slot}.x_starlightblade", fallback=0)
                        or  bcfg.getint(chan_id, f"{slot}.x_starlight",      fallback=0)) > 0
            except Exception:
                return False

        klass = (get_compat(ccfg, "info", "class", fallback="") or "").strip().lower()
        level = getint_compat(ccfg, "cur", "level", fallback=1)
        chan_id = str(ctx.channel.id)
        starlight_active = _starlight_active_for(bcfg, chan_id, char_name)

        if klass == "cleric":
            eff_level = max(1, level)
        elif klass == "paladin":
            eff_level = max(1, level // 2)                                     
        elif starlight_active:
            eff_level = 5                               
        else:
            await ctx.send("❌ Only Clerics and Paladins can use `!turn`.")
            return

        resolved, not_found, non_undead = [], [], []
        for name in targets:
            disp, tpath = _resolve_char_ci(name)
            pretty = disp or name
            if not tpath or not os.path.exists(tpath):
                not_found.append(pretty); continue
            tcfg = read_cfg(tpath)
            col, label, is_und, hd = _pick_col_for_target(tcfg, pretty)
            if not is_und:
                non_undead.append(pretty); continue
            resolved.append({
                "pretty": pretty,
                "path": tpath,
                "cfg":  tcfg,
                "col":  col,
                "label": label,
                "hd":   max(1, hd),
            })

        if not resolved:
            msg = "No valid undead targets."
            if not_found:   msg += " Not found: " + ", ".join(f"**{n}**" for n in not_found) + "."
            if non_undead:  msg += " Not undead: " + ", ".join(f"**{n}**" for n in non_undead) + "."
            await ctx.send(msg)
            return

        resolved.sort(key=lambda r: (r["col"], r["hd"]))

        weakest = resolved[0]
        req0 = _turn_entry(eff_level, weakest["col"])
        d20 = random.randint(1, 20)
        auto_success = (req0 in ('T', 'D'))
        success = auto_success or (isinstance(req0, int) and d20 >= req0)

        if starlight_active and klass not in {"cleric", "paladin"}:
            title = f"✝️ {char_name} attempts to Turn Undead (effective {eff_level}; via **StarlightBlade**)"
        elif klass == "cleric":
            title = f"✝️ {char_name} attempts to Turn Undead (Lv {level})"
        else:           
            title = f"✝️ {char_name} attempts to Turn Undead (Lv {level} — effective {eff_level})"

        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        if auto_success:
            embed.add_field(name="Turning Roll", value="Auto (T/D)", inline=True)
        else:
            face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
            need = req0 if req0 is not None else "No"
            embed.add_field(name="Turning Roll", value=f"{face} vs {need}", inline=True)
        embed.add_field(name="Weakest Type", value=f"{weakest['label']}", inline=True)

        if (req0 is None) or (not success):
            lines = []
            if req0 is None:
                lines.append(f"Too powerful to affect **{weakest['label']}** at effective level {eff_level}.")
            else:
                lines.append("The undead resist the holy power.")
            if not_found:
                lines.append("Not found: " + ", ".join(not_found))
            if non_undead:
                lines.append("Not undead: " + ", ".join(non_undead))
            embed.add_field(name="Result", value="\n".join(lines), inline=False)
            await ctx.send(embed=embed)
            return

        d6a, d6b = random.randint(1,6), random.randint(1,6)
        pool = d6a + d6b
        embed.add_field(name="HD Pool", value=f"2d6 → [{d6a}, {d6b}] = **{pool}**", inline=True)

        needs_damage = any(_turn_entry(eff_level, r["col"]) == 'D' for r in resolved)
        dmg_rolls, dmg_total = [], 0
        if needs_damage:
            dice_n = max(1, eff_level)                                                        
            dmg_rolls = [random.randint(1,8) for _ in range(dice_n)]
            dmg_total = sum(dmg_rolls)
            embed.add_field(
                name="Radiant Damage",
                value=f"{dice_n}d8 → [{', '.join(map(str, dmg_rolls))}] = **{dmg_total}**",
                inline=True
            )

        hd_left = pool
        min_one_applied = False
        killed_any = []
        lines = []

        for r in resolved:
            entry = _turn_entry(eff_level, r["col"])
            pretty = r["pretty"]
            hd = r["hd"]

                                                
            elig = (entry in ('T', 'D')) or (isinstance(entry, int) and d20 >= entry)
            if not elig:
                lines.append(f"**{pretty}** ({r['label']}): Unaffected.")
                continue

                                                                   
            spend_ok = (hd_left >= hd) or (not min_one_applied)
            if not spend_ok:
                lines.append(f"**{pretty}** ({r['label']}): No HD left → unaffected.")
                continue

            min_one_applied = True
            if hd_left > 0:
                hd_left = max(0, hd_left - hd)

                          
            if entry == 'D' and dmg_total > 0:
                                                    
                old_hp = getint_compat(r["cfg"], "cur", "hp", fallback=0)
                new_hp = max(0, old_hp - dmg_total)
                if not r["cfg"].has_section("cur"):
                    r["cfg"].add_section("cur")
                r["cfg"]["cur"]["hp"] = str(new_hp)
                write_cfg(r["path"], r["cfg"])

                dead = (new_hp <= 0)
                if dead:
                    lines.append(f"**{pretty}** ({r['label']}): **DAMAGED {dmg_total} → DESTROYED ☠️**")
                                                          
                    try:
                        bcfg = _load_battles()
                        if bcfg.has_section(chan_id):
                            names, scores = _parse_combatants(bcfg, chan_id)
                            key = _find_ci_name(names, pretty) or pretty
                            if key in names:
                                names = [n for n in names if n != key]
                                if bcfg.has_option(chan_id, key):
                                    bcfg.remove_option(chan_id, key)
                                s = _slot(key)
                                for suf in (".dex",".join",".disp",".acpen",".oil"):
                                    opt = f"{s}{suf}"
                                    if bcfg.has_option(chan_id, opt):
                                        bcfg.remove_option(chan_id, opt)
                                _write_combatants(bcfg, chan_id, names, scores)
                                if bcfg.get(chan_id, "turn", fallback="") == key:
                                    ents = _sorted_entries(bcfg, chan_id)
                                    bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                                _save_battles(bcfg)
                        try:
                            os.remove(os.path.abspath(r["path"]))
                        except Exception:
                            pass
                        killed_any.append(pretty)
                    except Exception:
                        pass
                else:
                    lines.append(f"**{pretty}** ({r['label']}): **DAMAGED {dmg_total}**, then **TURNED!**")
            else:
                lines.append(f"**{pretty}** ({r['label']}): **TURNED!**")

                                      
        if not_found:
            lines.append("Not found: " + ", ".join(not_found))
        if non_undead:
            lines.append("Not undead: " + ", ".join(non_undead))

        embed.add_field(name="Effects", value="\n".join(lines) if lines else "No valid effects.", inline=False)

        if killed_any:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        await ctx.send(embed=embed)


    @commands.command(name="calm")
    async def druid_animal_affinity(self, ctx, *args):
        """Druid: Animal Affinity. Usage:
           !calm wolf1 wolf2 ...
           Flags (optional): -tame (all count as 1/2 HD), -monstrous (all count as +1 HD)
        """
        if not args:
            await ctx.send("Usage: `!calm <animal1> [animal2 ...] [-tame] [-monstrous]`")
            return

        tokens = [str(a).strip() for a in args]
        global_tame = any(t.lower() in ("-tame", "-tame", "tame") for t in tokens)
        global_monstrous = any(t.lower() in ("-monstrous", "-monstrous", "monstrous", "-monster") for t in tokens)
        target_names = [t for t in tokens if t.lower() not in {"-tame","-tame","tame","-monstrous","-monstrous","monstrous","-monster"}]

        if not target_names:
            await ctx.send("Usage: `!calm <animal1> [animal2 ...] [-tame] [-monstrous]`")
            return

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ','_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return
        ccfg = read_cfg(path)
        owner_id = get_compat(ccfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"❌ You do not own **{char_name}**.")
            return

        klass = (get_compat(ccfg, "info", "class", fallback="") or "").strip().lower()
        if klass != "druid":
            await ctx.send("❌ Only Druids can use `!calm`.")
            return
        level = getint_compat(ccfg, "cur", "level", fallback=1)

        cfg_b = _load_battles()
        chan_id = str(ctx.channel.id)
        in_battle = cfg_b.has_section(chan_id)
        if in_battle:
                                                                             
            try:
                slot_self = _slot(char_name)
            except Exception:
                slot_self = char_name.replace(" ","_")
            cur_round = cfg_b.getint(chan_id, "round", fallback=0)
            until = cfg_b.getint(chan_id, f"{slot_self}.aa_until", fallback=0)
                                                          
                                           
                                                                                                                           
                       
                                                    
                                             
                                                                       
                                                                          
                                         

            _save_battles(cfg_b)
            
                                                
                                                                                        
        AA_TABLE = [
                 
            [ 9, 13, 17, 19, None, None, None, None, None, None, None ],
                 
            [ 7, 11, 15, 18, 20,  None, None, None, None, None, None ],
                 
            [ 5,  9, 13, 17, 19,  None, None, None, None, None, None ],
                 
            [ 3,  7, 11, 15, 18, 20,   None, None, None, None, None ],
                 
            [ 2,  5,  9, 13, 17, 19,   None, None, None, None, None ],
                 
            [ 'C', 3,  7, 11, 15, 18, 20,   None, None, None, None ],
                 
            [ 'C', 2,  5,  9, 13, 17, 19,   None, None, None, None ],
                 
            [ 'C','C', 3,  7, 11, 15, 18, 20,   None, None, None ],
                 
            [ 'B','C', 2,  5,  9, 13, 17, 19,   None, None, None ],
                  
            [ 'B','C','C', 3,  7, 11, 15, 18, 20,   None, None ],
                  
            [ 'B','B','C', 2,  5,  9, 13, 17, 19,   None, None ],
                  
            [ 'B','B','C','C', 3,  7, 11, 15, 18, 20,   None ],
                  
            [ 'B','B','B','C', 2,  5,  9, 13, 17, 19,   None ],
                  
            [ 'B','B','B','C','C', 3,  7, 11, 15, 18, 20 ],
                  
            [ 'B','B','B','B','C', 2,  5,  9, 13, 17, 19 ],
                  
            [ 'B','B','B','B','C','C', 3,  7, 11, 15, 18 ],
                  
            [ 'B','B','B','B','B','C', 2,  5,  9, 13, 17 ],
                  
            [ 'B','B','B','B','B','C','C', 3,  7, 11, 15 ],
                  
            [ 'B','B','B','B','B','B','C', 2,  5,  9, 13 ],
                  
            [ 'B','B','B','B','B','B','C','C', 3,  7, 11 ],
        ]
        def _aa_entry(lv: int, col: int):
            lv = max(1, min(20, lv))
            col = max(0, min(10, col))
            return AA_TABLE[lv-1][col]

        def _hd_from_cfg(tcfg):
                                                                                                          
            raw = str(get_compat(tcfg, "base", "hd", fallback="1")).strip()
            m = re.match(r"\s*(\d+)", raw)
            return int(m.group(1)) if m else 1

        def _is_animal_cfg(tcfg):
            ty = (get_compat(tcfg, "base", "type", fallback="") or "").strip().lower()
            return ("animal" in ty)

        def _effective_col_and_notes(tcfg, tame_glob: bool, mon_glob: bool):
            base_hd = _hd_from_cfg(tcfg)
                                           
            tame_local = str(get_compat(tcfg, "base", "tame", fallback="0")).strip() in {"1","true","yes","y"}
            dom_local  = str(get_compat(tcfg, "base", "domesticated", fallback="0")).strip() in {"1","true","yes","y"}
            mon_local  = str(get_compat(tcfg, "base", "monstrous", fallback="0")).strip() in {"1","true","yes","y"}

            eff = float(base_hd)
            notes = []
            if tame_glob or tame_local or dom_local:
                eff = eff / 2.0
                notes.append("½ HD (tame)")
            if mon_glob or mon_local:
                eff = eff + 1.0
                notes.append("+1 HD (monstrous)")

                                 
            if eff < 1.0:
                col = 0
            else:
                col = int(min(10, math.floor(eff)))
            return col, base_hd, eff, notes

        resolved = []
        not_found = []
        non_animals = []
        for name in target_names:
            disp, tpath = _resolve_char_ci(name)
            pretty = disp or name
            if not tpath or not os.path.exists(tpath):
                not_found.append(pretty); continue
            tcfg = read_cfg(tpath)
            if not _is_animal_cfg(tcfg):
                non_animals.append(pretty); continue
            col, base_hd, eff_hd, notes = _effective_col_and_notes(tcfg, global_tame, global_monstrous)
            resolved.append({
                "pretty": pretty,
                "path": tpath,
                "cfg":  tcfg,
                "col":  col,                               
                "base_hd": base_hd,                           
                "eff_hd": eff_hd,                                              
                "notes": notes,                       
            })

        if not resolved:
            msg = "No valid animal targets."
            if not_found:   msg += " Not found: " + ", ".join(f"**{n}**" for n in not_found) + "."
            if non_animals: msg += " Not animals: " + ", ".join(f"**{n}**" for n in non_animals) + "."
            await ctx.send(msg)
            return

                                                                  
        resolved.sort(key=lambda r: (r["col"], r["eff_hd"]))

                                
        weakest = resolved[0]
        req0 = _aa_entry(level, weakest["col"])
        d20 = random.randint(1, 20)
        auto = (req0 in ('C','B'))
        success_weakest = auto or (isinstance(req0, int) and d20 >= req0)

                     
        title = f"🌿 {char_name} uses Animal Affinity (Lv {level})"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        if auto:
            auto_txt = "Auto " + ("Befriend" if req0 == 'B' else "Calm")
            embed.add_field(name="Affinity Roll", value=auto_txt, inline=True)
        else:
            face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
            need = req0 if req0 is not None else "No"
            embed.add_field(name="Affinity Roll", value=f"{face} vs {need}", inline=True)
        embed.add_field(
            name="Weakest (HD col)",
            value=f"{weakest['pretty']} (col {weakest['col']})",
            inline=True
        )

                                                               
        if (req0 is None) or (not success_weakest):
            lines = []
            if req0 is None:
                lines.append(f"Too powerful to affect **{weakest['pretty']}** at level {level}.")
            else:
                lines.append("The animals resist your presence.")
            if not_found:
                lines.append("Not found: " + ", ".join(not_found))
            if non_animals:
                lines.append("Not animals: " + ", ".join(non_animals))
            embed.add_field(name="Result", value="\n".join(lines), inline=False)

                                              
            if in_battle:
                try:
                    slot_self = _slot(char_name)
                except Exception:
                    slot_self = char_name.replace(" ","_")
                cur_round = cfg_b.getint(chan_id, "round", fallback=0)
                if cur_round:
                    cfg_b.set(chan_id, f"{slot_self}.aa_until", str(cur_round + 60))
                    _save_battles(cfg_b)

            await ctx.send(embed=embed)
            return

                                           
        d6a, d6b = random.randint(1,6), random.randint(1,6)
        pool = d6a + d6b
        embed.add_field(name="HD Pool", value=f"2d6 → [{d6a}, {d6b}] = **{pool}**", inline=True)

                                                                                
                                                                 
        lines = []
        any_fail_threshold = False                                                      
        hd_left = pool
        min_one_applied = False

        for r in resolved:
            entry = _aa_entry(level, r["col"])
            pretty = r["pretty"]
                                                           
            if entry is None:
                lines.append(f"**{pretty}**: No effect possible at this level.")
                any_fail_threshold = True
                continue
            if entry in ('C','B'):
                roll_ok = True
                mode = ("BEFRIENDED" if entry == 'B' else "CALMED")
            else:
                roll_ok = (d20 >= int(entry))
                mode = "CALMED"
                                                                                                                
            spend_hd = max(1, int(min(10, math.floor(r["eff_hd"])) if r["eff_hd"] >= 1 else 1))

            if not roll_ok:
                lines.append(f"**{pretty}**: Roll {d20} vs {entry} → **FAIL**")
                any_fail_threshold = True
                continue

                                                                            
            spend_ok = (hd_left >= spend_hd) or (not min_one_applied)
            if not spend_ok:
                lines.append(f"**{pretty}**: Eligible, but **no HD left** → unaffected (can try again next round).")
                continue

            min_one_applied = True
            if hd_left > 0:
                hd_left = max(0, hd_left - spend_hd)

                          
            note = ""
            if r["notes"]:
                note = " (" + "; ".join(r["notes"]) + ")"
            lines.append(f"**{pretty}**: **{mode}**{note}")

                                       
        if not_found:
            lines.append("Not found: " + ", ".join(not_found))
        if non_animals:
            lines.append("Not animals: " + ", ".join(non_animals))

        embed.add_field(name="Effects", value="\n".join(lines) if lines else "No valid effects.", inline=False)

                                                                                            
        if any_fail_threshold and in_battle:
            try:
                slot_self = _slot(char_name)
            except Exception:
                slot_self = char_name.replace(" ","_")
            cur_round = cfg_b.getint(chan_id, "round", fallback=0)
            if cur_round:
                cfg_b.set(chan_id, f"{slot_self}.aa_until", str(cur_round + 60))
                _save_battles(cfg_b)

        await ctx.send(embed=embed)


    @commands.command(name="surprise")
    async def surprise(self, ctx, *args):
        """
        Roll surprise for one or more creatures.
        Base: surprised on 1–2 on 1d6.
        Modifiers:
          • Elf or Alert => range –1 (harder to surprise)
          • Barbarian => base is 1–in–6 (harder to surprise)
          • Fireskull Familiar (FF) active on target => range –1
          • Global ±N at the end (e.g., +2 for ambush) => range ±N
        Examples:
          !surprise go1 go2 go3 +2
          !surprise testman -1
          !surprise elf_pc
        """
        
        if not args:
            await ctx.send("Usage: `!surprise <name> [name ...] [±N]`  (e.g., `!surprise go1 go2 +2`)")
            return

        tokens = list(args)
        ambush_mod = 0
        if tokens and re.fullmatch(r"[+-]\d+", tokens[-1]):
            try:
                ambush_mod = int(tokens[-1])
                tokens = tokens[:-1]
            except Exception:
                ambush_mod = 0
        names = tokens[:]
        if not names:
            await ctx.send("Give at least one name. Example: `!surprise go1 go2 +2`")
            return

        def _resolve_char_ci(name: str):
            base = name.replace(" ", "_")
            target = f"{base}.coe".lower()
            for fn in os.listdir("."):
                if fn.lower() == target:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return None, None

        def _has_alert(cfg) -> bool:
            """
            Returns True if the character has 'Alert' from their race (race.lst / self.races)
            OR from flags/strings in their .coe (skills/traits/abilities/etc.).
            """
            

            def _norm(s: str) -> str:
                return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

            try:
                try:
                    race_lc, _ = self._get_char_race_class(cfg)
                except Exception:
                    race_lc = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()
                race_norm = _norm(race_lc)

                try:
                    if hasattr(self, "races") and self.races:
                        rinfo = self.races.get(race_lc) or next(
                            (v for k, v in self.races.items() if _norm(k) == race_norm), None
                        )
                        if isinstance(rinfo, dict):
                            if "alert" in str(rinfo.get("skills", "")).lower():
                                return True
                            for k, v in rinfo.items():
                                kl = str(k).lower(); vl = str(v).lower()
                                if "alert" in kl:
                                    if vl in {"1","true","yes","on"} or "alert" in vl or vl == "":
                                        return True
                                if "alert" in vl:
                                    return True
                except Exception:
                    pass

                try:
                    cp = getattr(self, "_race_cp", None)
                    if cp is None:
                        cp = configparser.ConfigParser()
                        cp.optionxform = str
                        cp.read("race.lst")
                        self._race_cp = cp

                    sec = None
                    for s in cp.sections():
                        if s.lower() == race_lc or _norm(s) == race_norm:
                            sec = s
                            break

                    if sec:
                        skills_line = cp.get(sec, "skills", fallback="")
                        if "alert" in skills_line.lower():
                            return True
                        for opt in cp.options(sec):
                            if "alert" in opt.lower():
                                val = cp.get(sec, opt, fallback="").lower()
                                if val in {"1","true","yes","on"} or "alert" in val:
                                    return True
                except Exception:
                    pass

                for sec in ("skills", "skill", "traits", "abilities"):
                    if cfg.has_section(sec):
                                                                         
                        try:
                            lst = str(get_compat(cfg, sec, "list", fallback="")).lower()
                            if "alert" in lst:
                                return True
                        except Exception:
                            pass
                                                        
                        for opt in cfg.options(sec):
                            if "alert" in opt.lower():
                                val = str(get_compat(cfg, sec, opt, fallback="")).lower()
                                if val in {"1","true","yes","on"} or "alert" in val:
                                    return True


            except Exception:
                pass
            return False

        def _is_elf_or_alert(cfg) -> tuple[bool, str]:
            race_lc, _class_lc = (self._get_char_race_class(cfg) if hasattr(self, "_get_char_race_class") else ("",""))
            if race_lc == "elf":
                return True, "Elf"
            if _has_alert(cfg):
                return True, "Alert"
            return False, ""

        def _is_barbarian(cfg) -> bool:
            try:
                _race_lc, class_lc = self._get_char_race_class(cfg)
                return class_lc == "barbarian"
            except Exception:
                return False

        def _has_fireskull_bonus_on_target(tgt_display_name: str) -> bool:
            """
            Returns True if there is any active x_* effect on the target whose code is 'FF'
            or whose label is 'fireskullfamiliar'. Only checks if an initiative is running
            in this channel; otherwise returns False (keeps legacy behavior).
            """
            try:
                bcfg = _load_battles()
                chan = str(ctx.channel.id)
                if not bcfg or not bcfg.has_section(chan):
                    return False

                                                                        
                names, _scores = _parse_combatants(bcfg, chan)
                exact = _find_ci_name(names, tgt_display_name)
                if not exact:
                    return False

                try:
                    slot = _slot(exact)
                except Exception:
                    slot = exact.replace(" ", "_")

                prefix = f"{slot}.x_"
                for opt in bcfg.options(chan):
                    if not opt.startswith(prefix):
                        continue
                    if opt.endswith(("_code", "_label", "_emoji", "_by")):
                        continue
                    val = bcfg.getint(chan, opt, fallback=0)
                    if val <= 0:
                        continue
                    base = opt.split(".", 1)[1]                               
                    code  = bcfg.get(chan, f"{slot}.{base}_code",  fallback="")
                    label = bcfg.get(chan, f"{slot}.{base}_label", fallback="")
                    if (code or "").upper() == "FF":
                        return True
                    if (label or "").strip().lower().replace(" ", "") in {"fireskullfamiliar","fireskull","fire skull familiar"}:
                        return True
            except Exception:
                pass
            return False

        lines: list[str] = []
        surprised_any = False

        for raw in names:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw

            if not path:
                lines.append(f"• {pretty}: *(not found)*")
                continue

            cfg = read_cfg(path)

                                                          
            base_range = 1 if _is_barbarian(cfg) else 2

            less_likely, src = _is_elf_or_alert(cfg)
            ff_active = _has_fireskull_bonus_on_target(pretty)

                                         
            reduce_by = (1 if less_likely else 0) + (1 if ff_active else 0)

                                                 
            thr = base_range + ambush_mod - reduce_by
            if thr < 0: thr = 0
            if thr > 6: thr = 6

            d6 = random.randint(1, 6)
            hit = (d6 <= thr and thr > 0)
            surprised_any |= hit

                   
            adj_bits = []
            if ambush_mod:
                sign = "+" if ambush_mod > 0 else "–"
                adj_bits.append(f"{sign}{abs(ambush_mod)} ambush")
            if less_likely:
                adj_bits.append(f"–1 {src}")
            if ff_active:
                adj_bits.append("–1 Fireskull")

            notes = (" [" + "; ".join(adj_bits) + "]") if adj_bits else ""
            status = "😵 **SURPRISED!**" if hit else "🛡️ **Steady**"
            lines.append(f"• {pretty}: d6 = {d6} vs ≤{thr}{notes} → {status}")

        title = "🎲 Surprise Check"
        if ambush_mod:
            title += f" (ambush {ambush_mod:+d})"

        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.description = (
            "Base surprise on **1–2**; **Barbarians** are only surprised on **1**. "
            "Elves, **Alert**, or **Fireskull Familiar (FF)** reduce the range by **1**. "
        )

        block, cur_len = [], 0
        for line in lines:
            add = len(line) + 1
            if block and cur_len + add > 1000:
                embed.add_field(name="Result", value="\n".join(block), inline=False)
                block, cur_len = [], 0
            block.append(line); cur_len += add
        if block:
            embed.add_field(name="Result", value="\n".join(block), inline=False)

        await ctx.send(embed=embed)


    @commands.command(name="react")
    async def monster_reaction(self, ctx, *args):
        """
        Monster reaction roll for a group.
        One 2d6 roll, optional trailing ±N for CHA/situation.
        Examples:
          !react go1 go2 go3 +3
          !react brigand -1
        """
        

                     
                                                                                           
                   

        tokens = list(args)
        mod = 0
        if tokens and re.fullmatch(r"[+-]\d+", tokens[-1]):
            try:
                mod = int(tokens[-1])
                tokens = tokens[:-1]
            except Exception:
                mod = 0

        names = [t for t in tokens if t.strip()]
                      
                                                                                       
                   

                                                                    
        try:
            total, rolls, flat = roll_dice("2d6")
            d1, d2 = (rolls + [0, 0])[:2]
            base = total + flat                                                  
        except Exception:
            d1, d2 = random.randint(1, 6), random.randint(1, 6)
            base = d1 + d2
            rolls = [d1, d2]

        adj = base + mod

                       
        if adj <= 2:
            band = "⚔️ **Immediate Attack**"
            color = 0xCC3333
            note = "They lunge without hesitation."
        elif 3 <= adj <= 7:
            band = "😠 **Unfavorable**"
            color = 0xCC7A00
            note = "Hostile or standoffish; threats, demands, posturing."
        elif 8 <= adj <= 11:
            band = "🙂 **Favorable**"
            color = 0x2FA84F
            note = "Open to parley; will talk or hear offers."
        else:       
            band = "🤝 **Very Favorable**"
            color = 0x3B82F6
            note = "Friendly/helpful; may aid or offer information."

        group_list = ", ".join(names)
        mod_txt = f" {mod:+d}" if mod else ""

        embed = nextcord.Embed(
            title="🎲 Monster Reaction",
            description="Roll **2d6** (+ CHA / situational adj.) to see attitude.",
            color=color
        )
                                                                      
        embed.add_field(
            name="Roll",
            value=f"2d6 {rolls} = **{base}**{mod_txt} → **{adj}**",
            inline=True
        )
        embed.add_field(name="Outcome", value=f"{band}\n*{note}*", inline=False)

        await ctx.send(embed=embed)


    @commands.command(name="door")
    async def secret_door_check(self, ctx):
        """
        Secret door search (1 character).
        Rules:
          • Base success on 1 (on 1d6)
          • INT ≥ 15: success on 1–2
          • Elves add +1 to the range → Elf: 1–2; Elf with INT ≥ 15: 1–3
        Usage:
          !door
        """
        
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)

        INT = getint_compat(cfg, "stats", "int", fallback=10)
        try:
            race_lc, _class_lc = self._get_char_race_class(cfg)
        except Exception:
            race_lc = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()

                                                    
        door_bonus_races = {"elf", "half-elf", "goblin", "kobold", "hobgoblin"}
        has_secret_door_bonus = (race_lc in door_bonus_races)

                                                                    
        try:
            if hasattr(self, "races"):
                skills = str(self.races.get(race_lc, {}).get("skills", "")).lower()
                if "secretdoor" in skills:
                    has_secret_door_bonus = True
        except Exception:
            pass


                                                             
        success_max = 1
        reasons = ["base 1"]

        if INT >= 15:
            success_max += 1
            reasons.append("INT≥15: +1")

        if has_secret_door_bonus:
            success_max += 1
            reasons.append(f"{race_lc.title()}: +1 (keen senses)")


                           
        success_max = max(1, min(6, success_max))

        try:
            total, rolls, flat = roll_dice("1d6")
            d6 = total + flat
        except Exception:
            d6 = random.randint(1, 6)
            rolls = [d6]

        ok = (d6 <= success_max)

        title = "🕵️ Secret Door Search"
        color = 0x2ECC71 if ok else 0x95A5A6
        rng_text = f"1–{success_max}" if success_max > 1 else "1"
        reason_text = "; ".join(reasons)

        embed = nextcord.Embed(title=title, color=color)
        embed.add_field(name="Character", value=char_name, inline=True)
        embed.add_field(name="INT", value=str(INT), inline=True)
        embed.add_field(name="Race", value=race_lc.title() or "—", inline=True)

        embed.add_field(name="Roll", value=f"1d6 {rolls} → **{d6}**", inline=True)
        embed.add_field(name="Success on", value=rng_text, inline=True)
        embed.add_field(name="Modifiers", value=reason_text, inline=False)

        if ok:
            embed.add_field(
                name="Result",
                value="✅ **SUCCESS** — If a secret door is present in the searched section, you’d detect it.",
                inline=False
            )
        else:
            embed.add_field(
                name="Result",
                value="❌ No secret door found.",
                inline=False
            )

                                                                          
        embed.set_footer(text="Searching takes 1 turn per 10′ of wall per character.")

        await ctx.send(embed=embed)


    @commands.command(name="trap")
    async def find_trap(self, ctx):
        """
        Trap search (active character).
        Chooses the best available chance:
          • Base: 1 on 1d6 (≈16.7%)
          • Dwarf stonework: 1–2 on 1d6 (≈33.3%)
          • Thief Remove Traps % from class.lst (with racial mods from race.lst)
        Usage:
          !trap
        """
        

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return
        cfg = read_cfg(path)

        try:
            race_lc, class_lc = self._get_char_race_class(cfg)
        except Exception:
            race_lc = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()
            class_lc = (get_compat(cfg, "info", "class", fallback="") or "").strip().lower()
        level = getint_compat(cfg, "cur", "level", fallback=1)
        is_thief = ("thief" in (class_lc or ""))                                         
        is_scout = (class_lc == "scout")
                                                              
        stone_sense_races = {"dwarf", "goblin", "kobold"}
        has_stone_sense = (race_lc in stone_sense_races)

                                                                                     
        try:
            if hasattr(self, "races"):
                skills = str(self.races.get(race_lc, {}).get("skills", "")).lower()
                if ("stonecunn" in skills) or ("stonework" in skills):
                    has_stone_sense = True
        except Exception:
            pass


        def _get_class_row_list(cls_name_lc: str, key: str):
            d = {}
            try:
                d = self.classes.get(cls_name_lc, {}) if hasattr(self, "classes") else {}
                if not d and hasattr(self, "classes"):
                                                     
                    d = self.classes.get(cls_name_lc.title(), {})
            except Exception:
                d = {}
            v = d.get(key)
            if isinstance(v, list):
                return [int(x) for x in v]
            if isinstance(v, str):
                try:
                    return [int(x) for x in v.split()]
                except Exception:
                    return []
            return []

        def _race_mod(key: str) -> int:
            try:
                raw = self.races.get(race_lc, {}).get(key, 0) if hasattr(self, "races") else 0
                return int(str(raw))
            except Exception:
                return 0

        thief_pct = None
        thief_detail = ""
        if is_thief:
            tbl = _get_class_row_list("thief", "removetrap")
            if tbl:
                idx = min(max(1, level) - 1, len(tbl) - 1)
                base_pct = int(tbl[idx])
                mod_pct = _race_mod("removetrap")                
                final_pct = max(0, min(100, base_pct + mod_pct))
                thief_pct = final_pct
                sign = "+" if mod_pct >= 0 else "–"
                thief_detail = f"Thief L{level}: {base_pct}% {sign}{abs(mod_pct)} = **{final_pct}%**"
                                                       

        candidates = []                                          

                      
        candidates.append(("base", 1/6.0, {"range": "1 on 1d6", "max": 1}))

                                                   
        if has_stone_sense:
            candidates.append(("stone", 2/6.0, {"range": "1–2 on 1d6", "max": 2}))


        if is_scout:
            candidates.append(("scout", 2/6.0, {"range": "1-2 on 1d6", "max": 2}))

                 
        if thief_pct is not None and thief_pct > 0:
            candidates.append(("thief", thief_pct/100.0, {"percent": thief_pct, "detail": thief_detail}))

                                         
        best = max(candidates, key=lambda c: c[1]) if candidates else None
        if not best:
            await ctx.send("⚠️ Could not determine any valid trap detection method.")
            return

        method, prob, info = best

        title = "🪤 Trap Search"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.add_field(name="Character", value=char_name, inline=True)
        embed.add_field(name="Race / Class", value=f"{(race_lc or '—').title()} / {(class_lc or '—').title()}", inline=True)

        if method == "thief":
            method_line = info.get("detail") or f"Thief: d% ≤ {info['percent']}%"
        elif method == "stone":
            method_line = f"Stone-sense — {info['range']} (Dwarf/Goblin/Kobold)"
        elif method == "scout":
            method_line = f"Scout trap sense — {info['range']}"
        else:
            method_line = f"Base — {info['range']}"


        embed.add_field(name="Method", value=method_line, inline=False)

        if method == "thief":
                                  
            if info["percent"] >= 100:
                ok, d, rolls = True, 1, [1]
                roll_text = f"Auto-success (100%)."
            else:
                try:
                    total, rolls, flat = roll_dice("1d100")
                    d = total + flat
                except Exception:
                    d = random.randint(1, 100); rolls = [d]
                ok = (d <= info["percent"])
                roll_text = f"1d100 {rolls} → **{d}** (need ≤ {info['percent']})"
        else:
            try:
                total, rolls, flat = roll_dice("1d6")
                d = total + flat
            except Exception:
                d = random.randint(1, 6); rolls = [d]
            need_max = info["max"]
            rng_text = f"1–{need_max}" if need_max > 1 else "1"
            ok = (d <= need_max)
            roll_text = f"1d6 {rolls} → **{d}** (success on {rng_text})"

        embed.add_field(name="Roll", value=roll_text, inline=False)
        embed.add_field(
            name="Result",
            value=("✅ **TRAP DETECTED!** If a trap is present in the searched area, you find it."
                   if ok else "❌ No traps found."),
            inline=False
        )

                                                      
        def _fmt_cand(c):
            m, p, inf = c
            if m == "thief":
                return f"Thief: {inf['percent']}%"
            if m == "stone":
                return "Stone-sense: 1–2 on 1d6"
            if m == "scout":
                return "Scout: 1–2 on 1d6"
            return "Base: 1 on 1d6"

        embed.add_field(name="Considered Chances", value=" • ".join(_fmt_cand(c) for c in candidates), inline=False)

        embed.set_footer(text="Searching takes at least 1 turn per 10′ square.")

        await ctx.send(embed=embed)


    @commands.command(name="escape")
    async def escape_grab(self, ctx, *, who: str | None = None):
        """
        Try to escape a wrestling hold.
        Usage:
          !escape            -> your active character tries to escape
          !escape BU1        -> named creature tries to escape
        Mechanics:
          Save vs Death/Poison (1d20), add the better of STR or DEX modifiers.
          On success, the hold ends. On failure, you remain held.
        """
        

        if not who:
            who = get_active(ctx.author.id)
            if not who:
                await ctx.send("❌ No active character. Use `!char <name>` or specify a target like `!escape BU1`.")
                return

                                                            
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle running here.")
            return

                                                 
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, who) or who
        try:
            slot_def = _slot(key)
        except Exception:
            slot_def = key.replace(" ", "_")

                                             
        if (bcfg.get(chan_id, f"{slot_def}.x_swallow", fallback="") or "").strip():
            disp_who, _ = _resolve_char_ci(key)
            pretty = disp_who or key
            await ctx.send("⛔ **%s** is **SWALLOWED** and cannot use `!escape`. "
                           "You may attack from inside with a small cutting/stabbing weapon (e.g., dagger)." % pretty)
            return

                                                
        if (bcfg.get(chan_id, f"{slot_def}.x_leech", fallback="") or "").strip():
            disp_who, _ = _resolve_char_ci(key)
            pretty = disp_who or key
            await ctx.send("⛔ **%s** has a **LEECH ATTACHED** and cannot use `!escape`. "
                           "Kill the leech to remove it." % pretty)
            return
            
        if bcfg.has_option(chan_id, f"{slot_def}.web"):
                                    
            rounds = bcfg.getint(chan_id, f"{slot_def}.web", fallback=0)
            state  = (bcfg.get(chan_id, f"{slot_def}.web_state",  fallback="E") or "E").upper()
            canbrk =  bcfg.get(chan_id, f"{slot_def}.web_canbrk", fallback="0") == "1"

            disp_who, path_who = _resolve_char_ci(key)
            pretty = disp_who or key

                                                                                         
            if state == "T":
                if not canbrk:
                    await ctx.send(f"⛓️ **{pretty}** is **TRAPPED** in webs and not strong/HD enough to break free.")
                    return
                if not path_who:
                    await ctx.send(f"❌ Couldn’t find a character file for **{pretty}**.")
                    return

                t_cfg = read_cfg(path_who)
                ok, r, dc, pen = self._roll_save(t_cfg, vs="death", penalty=0)
                pen_txt = f" - {pen}" if pen else ""
                if ok:
                    bcfg.set(chan_id, f"{slot_def}.web_state", "E")
                    _save_battles(bcfg)
                    await ctx.send(f"💪 **{pretty}**: Save vs Death {r}{pen_txt} vs {dc} → **ENTANGLED** (½ move).")
                else:
                    await ctx.send(f"⛓️ **{pretty}**: Save vs Death {r}{pen_txt} vs {dc} → still **TRAPPED**.")

                                        
                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass
                return

                                                                              
            if state == "E":
                for suf in ("web","web_state","web_canbrk","webignite"):
                    opt = f"{slot_def}.{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)

                                        
                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

                await ctx.send(f"🏃 **{pretty}** forces a way out and leaves the webs (counts as movement).")
                return

                        
        holder = bcfg.get(chan_id, f"{slot_def}.heldby", fallback="").strip()
        if not holder:
            await ctx.send(f"ℹ️ **{key}** is not currently held.")
            return

                                       
        def_disp, def_path = _resolve_char_ci(key)
        if not def_path:
            await ctx.send(f"❌ Couldn’t find a character file for **{key}**.")
            return
        def_cfg = read_cfg(def_path)

                              
        try:
            STR = getint_compat(def_cfg, "stats", "str", fallback=10)
            DEX = getint_compat(def_cfg, "stats", "dex", fallback=10)
            str_mod, dex_mod = _osr_str_dex_mods(cfg)
        except Exception:
            str_mod = dex_mod = 0
        best_mod = max(str_mod, dex_mod)

                                                                                
        ok0, roll, dc, pen = self._roll_save(def_cfg, vs="poi", penalty=0)
        total = roll + best_mod
        success = (total >= dc)

                      
        title = f"🪢 Escape Attempt: {def_disp or key}"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.add_field(name="Held By", value=holder, inline=True)
        bm = f"+{best_mod}" if best_mod >= 0 else f"{best_mod}"
        embed.add_field(name="Save", value=f"Death/Poison — 1d20 **{roll}** {bm} vs **{dc}**", inline=True)

        if success:
                                   
                              
            try:
                slot_h = _slot(holder)
            except Exception:
                slot_h = holder.replace(" ", "_")
            if bcfg.get(chan_id, f"{slot_h}.holds", fallback="").strip() == key:
                bcfg.remove_option(chan_id, f"{slot_h}.holds")
            if bcfg.has_option(chan_id, f"{slot_def}.heldby"):
                bcfg.remove_option(chan_id, f"{slot_def}.heldby")
                                                                       
            for suf in ("x_constrict","x_constrict_label","x_constrict_emoji","x_constrict_code","x_constrict_by","x_constrict_dice"):
                opt = f"{slot_def}.{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)  
                                                                       
            for suf in ("x_entangle","x_entangle_label","x_entangle_emoji","x_entangle_code","x_entangle_by","x_entangle_dice"):
                opt = f"{slot_def}.{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
                                                                              
            for suf in ("x_holdbite","x_holdbite_label","x_holdbite_emoji","x_holdbite_code","x_holdbite_by","x_holdbite_dice"):
                opt = f"{slot_def}.{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
                      
            _save_battles(bcfg)
            embed.add_field(name="Result", value="✅ **ESCAPED!** The hold is broken.", inline=False)
        else:
            embed.add_field(name="Result", value="❌ Still held.", inline=False)


                                                                     
        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content=content)
        except Exception:
            pass

        await ctx.send(embed=embed)


    @commands.command(name="defend")
    async def defend(self, ctx):
        """
        Take the Defend action: +4 AC until the start of your next turn.
        Must be your turn in an active initiative.
        """
                                  
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return

        coe = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(coe):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        cfg_b = _load_battles()
        chan_id = str(ctx.channel.id)
        if not cfg_b.has_section(chan_id):
            await ctx.send("❌ No active initiative in this channel.")
            return

        names, _scores = _parse_combatants(cfg_b, chan_id)
        turn_name = cfg_b.get(chan_id, "turn", fallback="")
        if char_name not in names:
            await ctx.send(f"❌ **{char_name}** is not in the current initiative.")
            return
        if char_name != turn_name:
            await ctx.send(f"⏳ It's not **{char_name}**'s turn. (Current: **{turn_name or '—'}**)")
            return

                            
        try:
            slot_me = _slot(char_name)
        except Exception:
            slot_me = char_name.replace(" ", "_")

        cfg_b.set(chan_id, f"{slot_me}.acbuf", "4")
        _save_battles(cfg_b)

                                          
        try:
            msg_id = cfg_b.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(cfg_b, chan_id)
                content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content=content)
        except Exception:
            pass

        embed = nextcord.Embed(
            title=f"{char_name} defends!",
            description="+4 AC until the **start** of your next turn.",
            color=random.randint(0x000000, 0xFFFFFF)
        )
        await ctx.send(embed=embed)


    @commands.command(name="conloss")
    async def conloss(self, ctx, *args):
        """
        Apply or clear Constitution loss.

        Apply loss (owner or GM):
          !conloss <name> <points>            # temp CON loss
          !conloss <name> <points> -perm     # permanent CON loss
          (If <name> omitted, uses your active character.)

        GM CLEAR (GM only in this channel):
          !conloss clear <name?> [-temp|-perm|-all]
            - Default clears ALL (temp+perm)
            - If <name> omitted, uses your active character
        """
        

        def _is_dm_here() -> bool:
            try:
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                if not (bcfg and bcfg.has_section(chan_id)):                                     
                    return False
                dm_id = bcfg.get(chan_id, "DM", fallback="")
                return str(ctx.author.id) == str(dm_id)
            except Exception:
                return False

        def _resolve_target(name: str | None):
            if not name:
                who = get_active(ctx.author.id)
                if not who:
                    return None, None
                return _resolve_char_ci(who)
            return _resolve_char_ci(name)

        def _safe_apply_con_delta(cfg, delta_con: int):
            """
            Add (positive) or subtract (negative) raw CON points, adjusting Max HP with your helper if present.
            """
                                       
            cur_con = getint_compat(cfg, "stats", "con", fallback=10)
            new_con = max(1, cur_con + int(delta_con))
            if not cfg.has_section("stats"):
                cfg.add_section("stats")
            cfg["stats"]["con"] = str(new_con)

                                                                   
            try:
                                                                                     
                self._apply_con_change_adjust_hp(cfg, int(delta_con))
            except Exception:
                                                                                         
                pass

        if not args:
            await ctx.send("Usage:\n"
                           "• `!conloss <name> <points> [-perm]`\n"
                           "• `!conloss clear <name?> [-temp|-perm|-all]`  *(GM only)*")
            return

        if str(args[0]).strip().lower() in {"clear", "reset", "remove"}:
            if not _is_dm_here():
                await ctx.send("❌ Only the **DM** can use `!conloss clear` in this channel.")
                return

                                                        
            name = None
            mode = "all"
            tail = [a for a in args[1:]]
            for t in tail:
                tl = str(t).strip().lower()
                if tl in {"-temp", "-t"}:
                    mode = "temp"
                elif tl in {"-perm", "-p"}:
                    mode = "perm"
                elif tl in {"-all", "-a"}:
                    mode = "all"
                elif not name and not tl.startswith("-"):
                    name = t

            disp_name, file_path = _resolve_target(name)
            if not file_path:
                who_txt = name or "(your active character)"
                await ctx.send(f"❌ Character {who_txt} not found.")
                return

            cfg = read_cfg(file_path)

                             
            old_hp   = getint_compat(cfg, "cur", "hp",  fallback=0)
            old_max  = getint_compat(cfg, "max", "hp",  fallback=old_hp)
            con_before = getint_compat(cfg, "stats", "con", fallback=10)
            temp     = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
            perm     = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)

            if temp <= 0 and perm <= 0:
                await ctx.send(f"ℹ️ **{disp_name}** has no recorded CON loss.")
                return

                                                       
            restore_temp = temp if mode in {"temp", "all"} else 0
            restore_perm = perm if mode in {"perm", "all"} else 0
            delta_con    = restore_temp + restore_perm
            if delta_con <= 0:
                await ctx.send(f"ℹ️ Nothing to clear for **{disp_name}** with mode `{mode}`.")
                return

                                             
            if not cfg.has_section("cur"):
                cfg.add_section("cur")
            if restore_temp:
                cfg["cur"]["con_loss_temp"] = "0"
            if restore_perm:
                cfg["cur"]["con_loss_perm"] = "0"
                                                        
            cfg["cur"]["con_loss_peak"] = "0"

                                    
            if not cfg.has_section("stats"):
                cfg.add_section("stats")
            cfg["stats"]["con"] = str(max(1, con_before + delta_con))

                                                                           
            def _con_mod(v: int) -> int:
                if v <= 3:  return -3
                if v <= 5:  return -2
                if v <= 8:  return -1
                if v <= 12: return 0
                if v <= 15: return +1
                if v <= 17: return +2
                return +3

            level = max(1, getint_compat(cfg, "cur", "level", fallback=1))
            prev_max = old_max
            hp_delta_applied = 0

                                            
            try:
                self._apply_con_change_adjust_hp(cfg, int(delta_con))
                test_max = getint_compat(cfg, "max", "hp", fallback=prev_max)
                hp_delta_applied = (test_max - prev_max)
            except Exception:
                hp_delta_applied = 0

                                                                                  
            if hp_delta_applied == 0:
                con_after  = getint_compat(cfg, "stats", "con", fallback=con_before)
                d_mod      = _con_mod(con_after) - _con_mod(con_before)
                manual_bump = d_mod * level
                if manual_bump != 0:
                    if not cfg.has_section("max"):
                        cfg.add_section("max")
                    cfg["max"]["hp"] = str(max(0, prev_max + manual_bump))

                                              
            write_cfg(file_path, cfg)
            cfg = read_cfg(file_path)

            new_con = getint_compat(cfg, "stats", "con", fallback=10)
            new_hp  = getint_compat(cfg, "cur", "hp",  fallback=0)
            new_max = getint_compat(cfg, "max", "hp",  fallback=new_hp)

                                                                         
            clamped = False
            try:
                neg_pool = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
                eff_cap  = max(0, new_max - max(0, neg_pool))
                if new_hp > eff_cap:
                    cfg["cur"]["hp"] = str(eff_cap)
                    write_cfg(file_path, cfg)
                    new_hp = eff_cap
                    clamped = True
            except Exception:
                pass

                             
            title = f"🧪 Constitution Loss Cleared for {disp_name}"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

            cleared_label = {"temp":"temporary", "perm":"permanent", "all":"ALL (temp + perm)"}[mode]
            embed.add_field(name="Action", value=f"Cleared {cleared_label} CON loss.", inline=False)

            temp_now = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
            perm_now = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)
            embed.add_field(
                name="Constitution",
                value=f"**{con_before} → {new_con}** • temp **-{temp_now}**, perm **-{perm_now}**",
                inline=False
            )

            if old_max != new_max:
                delta = new_max - old_max
                sign  = "+" if delta > 0 else ""
                embed.add_field(name="Max HP", value=f"{old_max} → **{new_max}**  ({sign}{delta} from CON)", inline=False)

            if clamped or old_hp != new_hp:
                tail = " *(clamped to effective cap)*" if clamped else ""
                embed.add_field(name="HP", value=f"{old_hp} → **{new_hp}** / {new_max}{tail}", inline=False)

            await ctx.send(embed=embed)
            return


                                           
                                                                      
        who = None
        points_tok = None
        want_perm = False

                                                     
        toks = [a for a in args if str(a).strip()]
        if not toks:
            await ctx.send("Usage:\n"
                           "• `!conloss <name> <points> [-perm]`\n"
                           "• `!conloss clear <name?> [-temp|-perm|-all]`  *(GM only)*")
            return

                      
        tail_flags = []
        if toks and str(toks[-1]).strip().lower().startswith("-"):
            tail_flags = [toks.pop(-1)]
        if toks and toks[-1] in ("-perm","-p","perm"):
            tail_flags.append(toks.pop(-1))
        want_perm = any(t in ("-perm","-p","perm") for t in [f.lower() for f in tail_flags])

                                                                                 
        if not toks:
            await ctx.send("❌ Provide a positive number of CON points to lose, e.g. `!conloss holyman2 2`.")
            return
        if re.fullmatch(r"[+-]?\d+", str(toks[-1])):
            points_tok = int(toks[-1])
            name = " ".join(toks[:-1]) if len(toks) > 1 else None
        else:
            await ctx.send("❌ Provide a positive number of CON points to lose, e.g. `!conloss holyman2 2`.")
            return

        if points_tok is None or int(points_tok) <= 0:
            await ctx.send("❌ Provide a positive number of CON points to lose, e.g. `!conloss holyman2 2`.")
            return
        points = int(points_tok)

                                                
        disp_name, file_path = _resolve_target(name)
        if not file_path:
            who_txt = name or "(your active character)"
            await ctx.send(f"❌ Character {who_txt} not found.")
            return

        cfg = read_cfg(file_path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        allowed = (not owner_id) or (owner_id == str(ctx.author.id))
        if not allowed:
            try:
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                if bcfg.has_section(chan_id):
                    dm_id = bcfg.get(chan_id, "DM", fallback="")
                    allowed = (str(ctx.author.id) == str(dm_id))
            except Exception:
                pass
        if not allowed:
            await ctx.send(f"❌ You do not own **{disp_name}**.")
            return

        old_hp   = getint_compat(cfg, "cur", "hp",  fallback=0)
        old_max  = getint_compat(cfg, "max", "hp",  fallback=old_hp)
        cur_con  = getint_compat(cfg, "stats", "con", fallback=10)
        temp     = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
        perm     = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)
        base_con = max(1, cur_con + temp + perm)                    

        if want_perm:
            hp_delta = self._apply_conloss_points(cfg, points, permanent=True)
        else:
            hp_delta = self._apply_conloss_points(cfg, points, permanent=False)

                           
        write_cfg(file_path, cfg)
        cfg = read_cfg(file_path)

        new_hp  = getint_compat(cfg, "cur", "hp",  fallback=0)
        new_max = getint_compat(cfg, "max", "hp",  fallback=new_hp)
        cur_con = getint_compat(cfg, "stats", "con", fallback=0)
        temp    = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
        perm    = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)

                                    
        clamped = False
        if new_hp > new_max:
            cfg["cur"]["hp"] = str(new_max)
            write_cfg(file_path, cfg)
            new_hp = new_max
            clamped = True

        title = f"🩸 Constitution Loss afflicts {disp_name}"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        loss_kind = "permanent" if want_perm else "temp"
        embed.add_field(name="Loss Applied", value=f"**−{points} CON** ({loss_kind})", inline=False)

        con_line = f"**{base_con} → {cur_con}** • temp **-{temp}**, perm **-{perm}**"
        embed.add_field(name="Constitution", value=con_line, inline=False)

        if old_max != new_max:
            delta = new_max - old_max
            sign  = "+" if delta > 0 else ""
            embed.add_field(name="Max HP", value=f"{old_max} → **{new_max}**  ({sign}{delta} from CON)", inline=False)

        if clamped or old_hp != new_hp:
            tail = " *(clamped to new max)*" if clamped else ""
            embed.add_field(name="HP", value=f"{old_hp} → **{new_hp}** / {new_max}{tail}", inline=False)

        embed.add_field(
            name="Effect",
            value=("Victim appears aged. Long rest (`!lr`) restores 1 CON per day; "
                   "if total loss exceeded 1, the final point requires a Save vs Death."),
            inline=False
        )

        await ctx.send(embed=embed)


    @commands.command(name="strloss")
    async def strloss(self, ctx, *args):
        """
        Apply or clear Strength loss (Shadow-style drain).

        Apply loss (owner or GM):
          !strloss <name> <points>          # temporary STR loss (recovers 1/turn automatically)
          (If <name> omitted, uses your active character.)

        GM CLEAR (GM only in this channel):
          !strloss clear <name?> [-temp|-perm|-all]
            - Default clears ALL (temp+perm)
            - If <name> omitted, uses your active character

        Notes:
          • STR loss auto-recovers at 1 point per *turn* (≈60 rounds). This command exists to apply manual drain
            (e.g., house-rule effects) or to fix edge cases via GM clear.
          • Permanent STR loss is uncommon; supported here only for items of Weakness.
        """
        

        def _is_dm_here() -> bool:
            try:
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                if not (bcfg and bcfg.has_section(chan_id)):
                    return False
                dm_id = bcfg.get(chan_id, "DM", fallback="")
                return str(ctx.author.id) == str(dm_id)
            except Exception:
                return False

        def _resolve_target(name: str | None):
            if not name:
                who = get_active(ctx.author.id)
                if not who:
                    return None, None
                return _resolve_char_ci(who)
            return _resolve_char_ci(name)

                                                                                  
        def _get_str_loss_buckets(cfg):
            cur = "cur"
            def gi(key, fallback=0):
                return getint_compat(cfg, cur, key, fallback=fallback)

                          
            temp = gi("str_loss_temp", fallback=None)
            perm = gi("str_loss_perm", fallback=None)
                                                        
            if temp is None:
                temp = gi("str_loss", fallback=0)
            if perm is None:
                perm = gi("str_perm_loss", fallback=0)

            return max(0, int(temp or 0)), max(0, int(perm or 0))

        def _set_str_loss_buckets(cfg, temp: int | None = None, perm: int | None = None, reset_peak: bool = False):
            if not cfg.has_section("cur"):
                cfg.add_section("cur")
            if temp is not None:
                cfg["cur"]["str_loss_temp"] = str(max(0, int(temp)))
                                             
                cfg["cur"]["str_loss"] = cfg["cur"]["str_loss_temp"]
            if perm is not None:
                cfg["cur"]["str_loss_perm"] = str(max(0, int(perm)))
            if reset_peak:
                                                                       
                cfg["cur"]["str_loss_peak"] = "0"

        if not args:
            await ctx.send("Usage:\n"
                           "• `!strloss <name> <points>`\n"
                           "• `!strloss clear <name?> [-temp|-perm|-all]`  *(GM only)*")
            return

        if str(args[0]).strip().lower() in {"clear", "reset", "remove"}:
            if not _is_dm_here():
                await ctx.send("❌ Only the **DM** can use `!strloss clear` in this channel.")
                return

                                                        
            name = None
            mode = "all"
            for t in [a for a in args[1:]]:
                tl = str(t).strip().lower()
                if tl in {"-temp", "-t"}:
                    mode = "temp"
                elif tl in {"-perm", "-p"}:
                    mode = "perm"
                elif tl in {"-all", "-a"}:
                    mode = "all"
                elif not name and not tl.startswith("-"):
                    name = t

            disp_name, file_path = _resolve_target(name)
            if not file_path:
                who_txt = name or "(your active character)"
                await ctx.send(f"❌ Character {who_txt} not found.")
                return

            cfg = read_cfg(file_path)

                      
            str_before = getint_compat(cfg, "stats", "str", fallback=10)
            temp_loss, perm_loss = _get_str_loss_buckets(cfg)

            if temp_loss <= 0 and perm_loss <= 0:
                await ctx.send(f"ℹ️ **{disp_name}** has no recorded STR loss.")
                return

            restore_temp = temp_loss if mode in {"temp", "all"} else 0
            restore_perm = perm_loss if mode in {"perm", "all"} else 0
            delta = restore_temp + restore_perm
            if delta <= 0:
                await ctx.send(f"ℹ️ Nothing to clear for **{disp_name}** with mode `{mode}`.")
                return

                                                                    
            if mode in {"temp", "all"}:
                _set_str_loss_buckets(cfg, temp=0, reset_peak=True)
            if mode in {"perm", "all"}:
                _set_str_loss_buckets(cfg, perm=0, reset_peak=True)

                                    
            if not cfg.has_section("stats"):
                cfg.add_section("stats")
            cfg["stats"]["str"] = str(max(1, str_before + delta))

                                                                                 
            try:
                if cfg.has_option("cur", "str_recover_rounds"):
                    cfg["cur"]["str_recover_rounds"] = "0"
            except Exception:
                pass

                              
            write_cfg(file_path, cfg)
            cfg = read_cfg(file_path)

            str_after = getint_compat(cfg, "stats", "str", fallback=str_before)
            temp_now, perm_now = _get_str_loss_buckets(cfg)

            title = f"💪 Strength Loss Cleared for {disp_name}"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

            cleared_label = {"temp":"temporary", "perm":"permanent", "all":"ALL (temp + perm)"}[mode]
            embed.add_field(name="Action", value=f"Cleared {cleared_label} STR loss.", inline=False)
            embed.add_field(
                name="Strength",
                value=f"**{str_before} → {str_after}** • temp **-{temp_now}**, perm **-{perm_now}**",
                inline=False
            )

                                                             
            if str_before <= 2 and str_after > 2:
                embed.add_field(name="Condition", value="No longer **Collapsed** (STR > 2).", inline=False)

            await ctx.send(embed=embed)
            return

                                  
        toks = [str(a).strip() for a in args if str(a).strip()]
        if not toks:
            await ctx.send("Usage:\n"
                           "• `!strloss <name?> <points> [-perm]`\n"
                           "• `!strloss clear <name?> [-temp|-perm|-all]`  *(GM only)*")
            return

        mode = "temp" 
        name_parts, points = [], None
        for t in toks:
            tl = t.lower()
            if re.fullmatch(r"[+-]?\d+", tl):
                points = int(t)
            elif tl in {"-perm", "-perm", "perm", "permanent", "-p"}:
                mode = "perm"
            elif tl in {"-temp", "-temp", "temp", "-t"}:
                mode = "temp"
            else:
                name_parts.append(t)

        name = " ".join(name_parts) if name_parts else None

        if points is None or int(points) <= 0:
            await ctx.send("❌ Provide a positive number of STR points to lose, e.g. "
                           "`!strloss testman 2` (add `-perm` for permanent).")
            return
        points = int(points)

        disp_name, file_path = _resolve_target(name)
        if not file_path:
            who_txt = name or "(your active character)"
            await ctx.send(f"❌ Character {who_txt} not found.")
            return

        cfg = read_cfg(file_path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        allowed = (not owner_id) or (owner_id == str(ctx.author.id))
        if not allowed:
            try:
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                if bcfg.has_section(chan_id):
                    dm_id = bcfg.get(chan_id, "DM", fallback="")
                    allowed = (str(ctx.author.id) == str(dm_id))
            except Exception:
                pass
        if not allowed:
            await ctx.send(f"❌ You do not own **{disp_name}**.")
            return

        str_now   = getint_compat(cfg, "stats", "str", fallback=10)
        temp_loss, perm_loss = _get_str_loss_buckets(cfg)
        base_str = max(1, str_now + temp_loss + perm_loss) 

        if mode == "perm":
            new_perm = max(0, int(perm_loss) + points)
            new_str  = max(0, base_str - int(temp_loss) - new_perm)

            _set_str_loss_buckets(cfg, perm=new_perm)
            if not cfg.has_section("stats"):
                cfg.add_section("stats")
            cfg["stats"]["str"] = str(new_str)
            write_cfg(file_path, cfg)
            cfg = read_cfg(file_path)

            str_after = getint_compat(cfg, "stats", "str", fallback=str_now)
            temp_now, perm_now = _get_str_loss_buckets(cfg)

            died = (str_after <= 0)
            collapsed = (not died and str_after <= 2)

            title = f"🦇 Permanent Strength Drain afflicts {disp_name}"
            embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
            embed.add_field(name="Loss Applied", value=f"**−{points} STR (permanent)**", inline=False)
            embed.add_field(
                name="Strength",
                value=f"**{base_str} → {str_after}** • temp **-{temp_now}**, perm **-{perm_now}**",
                inline=False
            )

            cond_lines = []
            if died:
                cond_lines.append("☠️ **Death (STR 0)** — may rise as a **Shadow** at next nightfall (GM adjudication).")
            elif collapsed:
                cond_lines.append("**Collapsed** (STR ≤ 2): can’t move until STR recovers.")
            if cond_lines:
                embed.add_field(name="Condition", value="\n".join(cond_lines), inline=False)

            embed.add_field(
                name="Recovery",
                value="**Permanent** loss does not auto-recover. Use `!strloss clear -perm` (GM) to fix edge cases, "
                      "or resolve via magic (e.g., Remove Curse on items of Weakness, then restoration by GM rules).",
                inline=False
            )
            await ctx.send(embed=embed)
            return

        applied, died, collapsed = self._apply_strloss_points(cfg, points)
        write_cfg(file_path, cfg)
        cfg = read_cfg(file_path)

        str_after = getint_compat(cfg, "stats", "str", fallback=str_now)
        temp_now, perm_now = _get_str_loss_buckets(cfg)

        title = f"🦇 Strength Drain afflicts {disp_name}"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.add_field(name="Loss Applied", value=f"**−{applied} STR**", inline=False)
        embed.add_field(
            name="Strength",
            value=f"**{base_str} → {str_after}** • temp **-{temp_now}**" + (f", perm **-{perm_now}**" if perm_now else ""),
            inline=False
        )

        cond_lines = []
        if died:
            cond_lines.append("☠️ **Death (STR 0)** — may rise as a **Shadow** at next nightfall (GM adjudication).")
        elif collapsed:
            cond_lines.append("**Collapsed** (STR ≤ 2): can’t move until STR recovers. Recovery is **1/turn (≈60 rounds)**.")
        if cond_lines:
            embed.add_field(name="Condition", value="\n".join(cond_lines), inline=False)

        embed.add_field(
            name="Recovery",
            value="Temporary STR recovers automatically at **1 point per turn**. Use `!strloss clear` (GM) only to fix edge cases.",
            inline=False
        )
        await ctx.send(embed=embed)


    @commands.command(name="rouse")
    async def rouse(self, ctx, target: str):
        """Rouse a sleeping or KO’d (subdued) target to 1 HP. Requires adjacency per-table.
           • Sleep: wake in 1d4 rounds (no damage).
           • Subdual KO: may be roused only after 2d10 rounds; otherwise natural wake in 1d4 turns."""
        
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        tgt_disp, tgt_path = _resolve_char_ci(target)
        if not tgt_path or not bcfg.has_section(chan_id):
            await ctx.send(f"❌ Target '{target}' not found or no battle running.")
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_disp) or tgt_disp
        try: slot = _slot(key)
        except Exception: slot = key.replace(" ", "_")

        now_r = bcfg.getint(chan_id, "round", fallback=0)

                              
        ko_left = bcfg.getint(chan_id, f"{slot}.ko", fallback=0)
        if ko_left > 0:
            ready_r = bcfg.getint(chan_id, f"{slot}.ko_ready", fallback=10**9)
            if now_r < ready_r:
                await ctx.send(f"• **{tgt_disp}** is KO’d from subdual. Too soon to rouse — **{ready_r - now_r}** more rounds.")
                return

                                                                           
            bcfg.set(chan_id, f"{slot}.ko", "0")
            for suf in ("sleep","paralyzed"):
                if bcfg.has_option(chan_id, f"{slot}.{suf}"):
                    bcfg.remove_option(chan_id, f"{slot}.{suf}")
            _save_battles(bcfg)

            tcfg = read_cfg(tgt_path)
            old = getint_compat(tcfg, "cur", "hp", fallback=0)
            tcfg["cur"]["hp"] = "1"; write_cfg(tgt_path, tcfg)
            await ctx.send(f"• **{tgt_disp}** is roused from subdual! HP: {old} → **1**.")
            return

                                                                 
        cur_sleep = bcfg.getint(chan_id, f"{slot}.sleep", fallback=0)
        if cur_sleep <= 0:
            await ctx.send(f"• **{tgt_disp}** is not asleep or KO’d.")
            return

        d4 = random.randint(1, 4)
        new = min(cur_sleep, d4)
        bcfg.set(chan_id, f"{slot}.sleep", str(new))
        bcfg.set(chan_id, f"{slot}.paralyzed", str(new))
        _save_battles(bcfg)
        await ctx.send(f"• **{tgt_disp}** is being roused. They will awaken in **{new} rounds** (1d4 → {d4}).")


    @commands.command(name="unpoly")
    async def unpoly(self, ctx, *who):
        """
        GM-only: remove Polymorph overlay from a creature.
        Usage:
          !unpoly <name>        # clear polymorph on that creature
          !unpoly self          # clear on the command issuer's active PC
        """

                                  
        target = (who[0] if who else "").strip()
        if not target:
            await ctx.send("Usage: `!unpoly <name>` (or `!unpoly self`)")
            return

                                                       
        if target.lower() == "self":
            active = get_active(ctx.author.id)
            if not active:
                await ctx.send("❌ You have no active character.")
                return
            target = active

                                    
        try:
            disp, path = self._resolve_char_ci(target)
        except Exception:
            disp, path = target, None

        if not path:
                                        
            base = target.replace(" ", "_") + ".coe"
            try:
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        path = fn; disp = target; break
            except Exception:
                pass

        if not path:
            await ctx.send(f"❌ Target **{target}** not found.")
            return

        cfg = read_cfg(path)
        if not _poly_active(cfg):
            await ctx.send(f"ℹ️ **{disp}** is not polymorphed.")
            return

                                                 
        _poly_clear_overlay(cfg)
        write_cfg(path, cfg)

                                              
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                _clear_battle_poly_flags(bcfg, chan_id, disp)

                                                   
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        await ctx.send(f"✅ **{disp}** is restored to their original form.")


    @commands.command(name="spin")
    async def spin(self, ctx, spinner: str, *targets):
        """
        Air elemental 'spin': each target of 2 HD/levels or less must save vs Death or fall prone.
        (We just display PRONE; no tracker status.)
        Usage: !spin AI1 go1 go2 go3
        """
        
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first."); return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!spin`."); return

        spin_name, spin_path = _resolve_char_ci(spinner)
        if not spin_path: 
            await ctx.send(f"❌ Spinner '{spinner}' not found."); return
        if not targets:
            await ctx.send("Usage: `!spin <spinner> <target1> [target2 ...]`"); return

        
        title = f"{spin_name} spins!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        lines = []
        for t in targets:
            t_disp, t_path = _resolve_char_ci(t)
            pretty = t_disp or t
            if not t_path:
                lines.append(f"{pretty}: *(not found)*"); continue
            t_cfg = read_cfg(t_path)

                                                                                      
            hd_or_lvl = getint_compat(t_cfg, "cur", "level", fallback=1)
            if hd_or_lvl >= 3:
                lines.append(f"{pretty}: Unaffected (HD/Level {hd_or_lvl} ≥ 3)")
                continue

            ok, roll, dc, pen = self._roll_save(t_cfg, vs="poi", penalty=0)             
            result = "RESISTED" if ok else "**PRONE**"
            lines.append(f"{pretty}: Save vs Death {roll} vs {dc} → {result}")

        embed.add_field(
            name="Effect",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        embed.set_footer(text="Air Elemental Spin: affects only targets of 2 HD/levels or less.")
        await ctx.send(embed=embed)
        
            
    @commands.command(name="thunderclap")
    async def thunderclap(self, ctx, striker: str, *targets):
        """
        Lightning elemental 'thunderclap': each target saves vs Paralysis or is DEAFENED for 1d8 turns.
        Now sets a tracker timer: [DEAF N] with 🔇, expiring automatically.
        Usage: !thunderclap LI1 wizard testman holyman
        """
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first."); return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!thunderclap`."); return

        try:
            att_name, att_path = self._resolve_char_ci(striker)
        except Exception:
            att_name, att_path = _resolve_char_ci(striker)
        if not att_path:
            await ctx.send(f"❌ Striker '{striker}' not found."); return
        if not targets:
            await ctx.send("Usage: `!thunderclap <striker> <target1> [target2 ...]`"); return

        title = f"{att_name} unleashes a Thunderclap!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        lines, any_tagged = [], False

        for t in targets:
            try:
                t_disp, t_path = self._resolve_char_ci(t)
            except Exception:
                t_disp, t_path = _resolve_char_ci(t)
            pretty = t_disp or t
            if not t_path:
                lines.append(f"{pretty}: *(not found)*"); continue

            t_cfg = read_cfg(t_path)
            ok, roll, dc, pen = self._roll_save(t_cfg, vs="para", penalty=0)
            if dc is None:
                ok, roll, dc, pen = self._roll_save(t_cfg, vs="para", penalty=0)

            if ok:
                lines.append(f"{pretty}: Save {roll} vs {dc} → RESISTED")
                continue

            total, rolls, flat = roll_dice("1d8")
            turns = total + flat
            rounds = turns * 60  

            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, t_disp) or pretty
                try:
                    s_tgt = _slot(key)
                except Exception:
                    s_tgt = key.replace(" ", "_")
                base, label = "x_deaf", "Deafened"
                bcfg.set(chan_id, f"{s_tgt}.{base}",       str(rounds))
                bcfg.set(chan_id, f"{s_tgt}.{base}_label", label)
                bcfg.set(chan_id, f"{s_tgt}.{base}_code",  "DEAF")
                bcfg.set(chan_id, f"{s_tgt}.{base}_emoji", "🔇")
                bcfg.set(chan_id, f"{s_tgt}.{base}_by",    att_name)
                _save_battles(bcfg)
                any_tagged = True
            except Exception:
                pass

            rolls_txt = ", ".join(str(r) for r in rolls)
            lines.append(f"{pretty}: Save {roll} vs {dc} → **DEAFENED** for **{turns} turns** [{rolls_txt}]")

        embed.add_field(
            name="Effect (30′ radius; you pick targets)",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        embed.set_footer(text="Deafened applies normally; tracker tag will expire automatically." if any_tagged
                         else "No targets deafened.")
        await ctx.send(embed=embed)

        if any_tagged:
            try:
                await self._refresh_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


    @commands.command(name="gaze")
    async def petrifying_gaze(self, ctx, striker: str, *targets):
        """
        Basilisk/Medusa petrifying gaze: each target saves vs Petrification or is PETRIFIED permanently.
        Usage: !gaze BA1 wizard holyman
        Notes:
          • GM-only. Requires an active battle.
          • Undead / obvious constructs are unaffected.
          • Already-petrified targets are unaffected.
          • On fail: sets <slot>.pet_perm = 1 and <slot>.pet_by = <striker name> (tracker shows [PET –]).
        """
        

                                    
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!gaze`.")
            return

                         
        att_name, att_path = _resolve_char_ci(str(striker))
        if not att_path:
            await ctx.send(f"❌ Striker '{striker}' not found.")
            return

        try:
            acfg = read_cfg(att_path)
            if not _monster_has_gaze(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list a 'gaze' special — proceeding anyway.")
        except Exception:
            pass


        if not targets:
            await ctx.send("Usage: `!gaze <striker> <target1> [target2 ...]`")
            return

                                                                             
        def _save_vs_para(t_cfg):
            """Best-effort save lookup for 'petrification/paralysis'."""
            for tag in ("para", "parapet", "petrify", "petrification", "pet"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen, tag
            ok, roll, dc, pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            return ok, roll, dc, pen, "para?"

        def _is_constructish_cfg(t_cfg, disp: str) -> bool:
            try:
                blob = " ".join([
                    (get_compat(t_cfg, "base", "type", fallback="") or ""),
                    (get_compat(t_cfg, "info", "race", fallback="") or ""),
                    (disp or ""),
                ]).lower()
                for kw in ("construct", "golem", "animated object", "statue"):
                    if kw in blob:
                        return True
            except Exception:
                pass
            return False

                                                                             
        title = f"{att_name}'s Petrifying Gaze!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        lines = []
        for raw in targets:
            t_disp, t_path = _resolve_char_ci(raw)
            pretty = t_disp or raw
            if not t_path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(t_path)

                        
            try:
                if _is_undead_cfg(t_cfg, pretty):
                    lines.append(f"• **{pretty}**: ☠️ Undead — **unaffected**.")
                    continue
            except Exception:
                pass
            if _is_constructish_cfg(t_cfg, pretty):
                lines.append(f"• **{pretty}**: 🛠️ Construct — **unaffected**.")
                continue

                                                       
            slot = None
            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty) or pretty
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")
            except Exception:
                slot = None

            if slot:
                already = (
                    bcfg.getint(chan_id, f"{slot}.pet_perm", fallback=0) > 0
                    or bcfg.getint(chan_id, f"{slot}.pet", fallback=0) > 0
                )
                if already:
                    lines.append(f"• **{pretty}**: already **Petrified** — **no effect**.")
                    continue

            try:
                if slot and bcfg.getint(chan_id, f"{slot}.x_gazereflection", fallback=0) > 0:
                                                                                            
                    a_cfg = read_cfg(att_path)
                    ok_a, roll_a, dc_a, _pen_a, _tag_a = _save_vs_para(a_cfg)
                    if dc_a is None:
                        save_txt_a = f"(rolled **{roll_a}** vs **PARA**; table missing)"
                        fail_a = True
                    else:
                        save_txt_a = f"(d20 **{roll_a}** vs **{dc_a}**)"
                        fail_a = (not ok_a)

                    if fail_a:
                                                      
                        try:
                            names_a, _ = _parse_combatants(bcfg, chan_id)
                            key_a = _find_ci_name(names_a, att_name) or att_name
                            try:
                                s_att = _slot(key_a)
                            except Exception:
                                s_att = key_a.replace(" ", "_")
                            bcfg.set(chan_id, f"{s_att}.pet_perm", "1")
                            bcfg.set(chan_id, f"{s_att}.pet_by", f"{pretty} (Gaze Reflection)")
                            _save_battles(bcfg)
                        except Exception:
                            pass

                        lines.append(f"• **{pretty}**: 🪞 **Gaze Reflection!** Attacker saves {save_txt_a} → **FAIL** — "
                                     f"**{att_name} PETRIFIED** `[PET –]`. **{pretty}** is unaffected.")
                    else:
                        lines.append(f"• **{pretty}**: 🪞 **Gaze Reflection!** Attacker saves {save_txt_a} → **RESISTED**; "
                                     f"**{pretty}** is unaffected.")
                    continue                                    
            except Exception:
                pass


                          
            sv_ok, sv_roll, sv_dc, _pen, tag_used = _save_vs_para(t_cfg)
            if sv_dc is None:
                save_txt = f"(rolled **{sv_roll}** vs **PARA**; table missing)"
                failed = True                             
            else:
                save_txt = f"(d20 **{sv_roll}** vs **{sv_dc}**)"
                failed = (not sv_ok)

            if not failed:
                lines.append(f"• **{pretty}**: Save vs Petrification {save_txt} → **RESISTED**")
                continue

                                             
            if slot:
                try:
                    bcfg.set(chan_id, f"{slot}.pet_perm", "1")
                    bcfg.set(chan_id, f"{slot}.pet_by", att_name)
                    _save_battles(bcfg)
                except Exception:
                    pass
                lines.append(f"• **{pretty}**: Save vs Petrification {save_txt} → **FAIL** — **PETRIFIED** `[PET –]`.")
            else:
                lines.append(f"• **{pretty}**: Save vs Petrification {save_txt} → **FAIL** — would be **Petrified** (no active slot).")

        embed.add_field(
            name="Effect (you choose targets in line of sight)",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        embed.set_footer(text="Restoration: Stone to Flesh or similar magic.")

        await ctx.send(embed=embed)

                                                                
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


    @commands.command(name="spit")
    async def spit_venom(self, ctx, spitter: str, *targets):
        """
        Spitting Cobra 'spit': each target must Save vs Poison or be **BLINDED permanently**.
        Usage: !spit SC1 wizard holyman BU1
        Notes:
          • GM-only. Requires an active battle.
          • Undead / obvious constructs are unaffected.
          • If already permanently blind, no effect.
          • On fail: sets <slot>.blind_perm = 1, <slot>.blind big sentinel, and metadata; tracker shows [BL –].
        """
        

        PERM_ROUNDS = 10_000_000                                           

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!spit`.")
            return

        att_name, att_path = _resolve_char_ci(str(spitter))
        if not att_path:
            await ctx.send(f"❌ Spitter '{spitter}' not found.")
            return

        try:
            acfg = read_cfg(att_path)
            if not _monster_has_spit(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list a 'gaze' special — proceeding anyway.")
        except Exception:
            pass

        if not targets:
            await ctx.send("Usage: `!spit <spitter> <target1> [target2 ...]`")
            return

                                                                             
        def _is_constructish_cfg(t_cfg, disp: str) -> bool:
            try:
                blob = " ".join([
                    (get_compat(t_cfg, "base", "type", fallback="") or ""),
                    (get_compat(t_cfg, "info", "race", fallback="") or ""),
                    (disp or ""),
                ]).lower()
                for kw in ("construct", "golem", "animated object", "statue"):
                    if kw in blob:
                        return True
            except Exception:
                pass
            return False

                                                                             
        title = f"{att_name} spits venom!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        lines = []
        wake_list = []                                  

        for raw in targets:
            t_disp, t_path = _resolve_char_ci(raw)
            pretty = t_disp or raw
            if not t_path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(t_path)

                                        
            try:
                if _is_undead_cfg(t_cfg, pretty):
                    lines.append(f"• **{pretty}**: ☠️ Undead — **unaffected**.")
                    continue
            except Exception:
                pass
            if _is_constructish_cfg(t_cfg, pretty):
                lines.append(f"• **{pretty}**: 🛠️ Construct — **unaffected**.")
                continue

                                                               
            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty) or pretty
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")
            except Exception:
                slot = None

                                        
            if slot:
                bl_perm = bcfg.getint(chan_id, f"{slot}.blind_perm", fallback=0)
                if bl_perm > 0:
                    lines.append(f"• **{pretty}**: already **BLINDED** (permanent) — **no effect**.")
                    continue

                                      
            ok, roll, dc, pen = self._roll_save(t_cfg, vs="poi", penalty=0)
            if dc is None:
                                                                               
                ok = False
            save_txt = f"(d20 **{roll}** vs **{dc if dc is not None else 'POI'}**)"

            if ok:
                lines.append(f"• **{pretty}**: Save vs Poison {save_txt} → **RESISTED**")
                continue

                                                            
            if slot:
                try:
                                                        
                    for opt in (f"{slot}.blind", f"{slot}.blind_level"):
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)

                    bcfg.set(chan_id, f"{slot}.blind",       str(PERM_ROUNDS))
                    bcfg.set(chan_id, f"{slot}.blind_perm",  "1")
                    bcfg.set(chan_id, f"{slot}.blind_src",   "spit")
                    bcfg.set(chan_id, f"{slot}.blind_by",    att_name)
                    bcfg.set(chan_id, f"{slot}.blind_level", "0")                             
                    _save_battles(bcfg)
                except Exception:
                    pass
                lines.append(f"• **{pretty}**: Save vs Poison {save_txt} → **FAIL** — **BLINDED (permanent)** `[BL –]`.")
                wake_list.append(pretty)
            else:
                lines.append(f"• **{pretty}**: Save vs Poison {save_txt} → **FAIL** — would be **BLINDED (permanent)** (no active slot).")

                                                           
        try:
            if wake_list:
                self._hyp_break_if_targeted(chan_id, wake_list)
        except Exception:
            pass

        embed.add_field(
            name="Effect (you choose targets in line of sight)",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        embed.set_footer(text="Blind: surprised on 1–4; attack −4; AC −4; initiative −2. Cure with Cure Blindness or similar.")
        await ctx.send(embed=embed)

                                                               
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


    @commands.command(name="goo")
    async def cave_locust_goo(self, ctx, spitter: str, *targets):
        """
        Giant Cave Locust 'goo':
          • Make an attack vs **Unarmored AC** (11 + Dex mod only)
          • On hit: target saves vs Poison (poi); on fail → 🤢 NAUSEATED for **3d6 rounds**
          • Each locust can do this **once per encounter**
        Usage:
          !goo L1 hero
          !goo L3 wizard  (only the FIRST valid target is used per rules)
          !goo L2 -reset  (GM tool: clear the once/encounter flag for L2)
        Notes:
          • GM-only; requires an active battle
          • Undead & poison-immune creatures are unaffected (like Stinking Cloud)
          • Mirror Image works; True Seeing ignores Blur/Displacement
        """
        

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!goo`.")
            return

        att_name, att_path = _resolve_char_ci(str(spitter))
        if not att_path:
            await ctx.send(f"❌ Spitter '{spitter}' not found.")
            return
        if not _is_monster_file(att_path):
            await ctx.send(f"❌ **{att_name}** is not a monster.")
            return

        acfg = read_cfg(att_path)
        try:
            if not _monster_has_goo(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list 'goo' in special — proceeding anyway.")
        except Exception:
            pass

                                     
        try:
            names_b, _ = _parse_combatants(bcfg, chan_id)
            k_att = _find_ci_name(names_b, att_name) or att_name
            try:
                s_att = _slot(k_att)
            except Exception:
                s_att = k_att.replace(" ", "_")
        except Exception:
            s_att = att_name.replace(" ", "_")

                     
        if targets and len(targets) == 1 and str(targets[0]).lower() in {"-reset", "reset", "-off", "clear"}:
            if bcfg.has_option(chan_id, f"{s_att}.goo_used"):
                bcfg.remove_option(chan_id, f"{s_att}.goo_used"); _save_battles(bcfg)
            await ctx.send(f"🔄 **{att_name}**: Goo use reset.")
            return

                                  
        if bcfg.getint(chan_id, f"{s_att}.goo_used", fallback=0) > 0:
            await ctx.send(f"⛔ **{att_name}** has already used its goo this encounter. (`!goo {att_name} -reset` to clear)")
            return

                       
        if not targets:
            await ctx.send("Usage: `!goo <spitter> <target>`")
            return

                                                     
        raw = targets[0]
        tgt_disp, tgt_path = _resolve_char_ci(raw)
        pretty = tgt_disp or raw
        if not tgt_path:
            await ctx.send(f"❌ Target '{pretty}' not found.")
            return
        t_cfg = read_cfg(tgt_path)

                                          
        try:
            self._hyp_break_if_targeted(chan_id, [pretty])
        except Exception:
            pass

        try:
            if _is_undead_cfg(t_cfg, pretty):
                await ctx.send(f"• **{pretty}**: ☠️ Undead — **no effect**.")
                return
        except Exception:
            pass
        try:
            if self._poison_immune(t_cfg):
                await ctx.send(f"• **{pretty}**: 🧪 Poison-immune — **no effect**.")
                return
        except Exception:
            pass

                             
        hd = getint_compat(acfg, "cur", "level", fallback=getint_compat(acfg, "base", "hd", fallback=1))
        ab = self.monster_ab_for_hd(max(1, hd))

                                                       
        inv_bonus = blind_att_pen = sick_att_pen = nl_pen = 0
        bb_hit = 0; bb_note = []
        blur_or_disp_note = None
        attacker_has_ts = False

                    
        try:
            attacker_has_ts = self._true_seeing_active_for(bcfg, chan_id, att_name)
        except Exception:
            attacker_has_ts = False

                                                         
        try:
            inv_bonus, _inv_type, _note = _attacker_invis_bonus_and_clear(bcfg, chan_id, att_name, s_att, acfg)
        except Exception:
            inv_bonus = 0

                           
        try:
            if bcfg.getint(chan_id, f"{s_att}.blind", fallback=0) > 0:
                blind_att_pen = -4
        except Exception:
            pass

                                                                             
        if not attacker_has_ts:
            try:
                dp_pen, dp_note = self._displacement_penalty_for_attack(bcfg, chan_id, att_name, s_att, pretty)
                if dp_pen:
                    blur_or_disp_note = dp_note
                    ab += dp_pen                              
                else:
                    bl_pen, bl_note = self._blur_penalty_for_attack(bcfg, chan_id, att_name, s_att, pretty)
                    if bl_pen:
                        blur_or_disp_note = bl_note
                        ab += bl_pen
            except Exception:
                pass

                                      
        try:
            sick_att_pen = bcfg.getint(chan_id, f"{s_att}.stench_pen", fallback=0)
            if not sick_att_pen:
                for key in (".x_stenchn", ".stn", ".stench", ".sick"):
                    if bcfg.getint(chan_id, f"{s_att}{key}", fallback=0) > 0:
                        sick_att_pen = -2; break
        except Exception:
            pass

                                     
        try:
            nl_candidates = [
                bcfg.getint(chan_id, f"{s_att}.nl", fallback=0),
                bcfg.getint(chan_id, f"{s_att}.neg_levels", fallback=0),
                bcfg.getint(chan_id, f"{s_att}.neglevels", fallback=0),
                bcfg.getint(chan_id, f"{s_att}.neg_level", fallback=0),
                getint_compat(acfg, "cur", "neg_levels", fallback=0),
            ]
            nl_n = max(nl_candidates)
            if nl_n > 0: nl_pen = -int(nl_n)
        except Exception:
            pass

                    
        try:
            names_bb, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names_bb, att_name) or att_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            if bcfg.getint(chan_id, f"{s_me}.x_bless", fallback=0) > 0:
                val = max(1, bcfg.getint(chan_id, f"{s_me}.bless_hit", fallback=1))
                bb_hit += val; bb_note.append(f"Bless +{val}")
            if bcfg.getint(chan_id, f"{s_me}.x_bane", fallback=0) > 0:
                val = max(1, bcfg.getint(chan_id, f"{s_me}.bane_hit", fallback=1))
                bb_hit -= val; bb_note.append(f"Bane −{val}")
        except Exception:
            pass

                                                   
        try:
            names_t, _ = _parse_combatants(bcfg, chan_id)
            k_t = _find_ci_name(names_t, pretty) or pretty
            try:
                s_t = _slot(k_t)
            except Exception:
                s_t = k_t.replace(" ", "_")
        except Exception:
            s_t = pretty.replace(" ", "_")

        dex_mod = getint_compat(t_cfg, "stats", "dex_modifier", fallback=0)
        target_ac = 11 + dex_mod                                                                     

                     
        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + inv_bonus + blind_att_pen + sick_att_pen + nl_pen + bb_hit
        hit = (d20 == 20) or (d20 != 1 and total_to_hit >= target_ac)

                     
        title = f"{att_name} spits **goo** at {pretty}!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        mods_line = []
        if inv_bonus: mods_line.append("+4 invis")
        if blind_att_pen: mods_line.append("−4 blinded")
        if sick_att_pen: mods_line.append(f"{sick_att_pen:+} sickened")
        if nl_pen: mods_line.append(f"{nl_pen:+} NL")
        if bb_hit: mods_line.append(("+" if bb_hit>0 else "")+str(bb_hit)+" Bless/Bane")

        embed.add_field(
            name="Attack (vs Unarmored AC)",
            value=f"**{d20}** + {ab}"
                  + ((" " + " ".join(mods_line)) if mods_line else ""),
            inline=False
        )
        if attacker_has_ts:
            embed.add_field(name="True Seeing", value="Ignores **Blur/Displacement**.", inline=False)
        elif blur_or_disp_note:
            embed.add_field(name="Displacement/Blur", value=blur_or_disp_note, inline=False)

                                                         
        try:
            bcfg.set(chan_id, f"{s_att}.goo_used", "1"); _save_battles(bcfg)
        except Exception:
            pass

        if not hit:
            embed.add_field(name="Result", value="❌ **MISS**", inline=True)
            await ctx.send(embed=embed)
            return

                           
        if not attacker_has_ts:
            consumed, left = self._mi_consume_if_present(ctx, pretty)
            if consumed:
                embed.add_field(name="Mirror Image", value=f"A figment is struck and shatters. Images remaining: **{left}**.", inline=False)
                embed.add_field(name="Result", value="Hit a figment — no effect.", inline=True)
                await ctx.send(embed=embed)
                return
        else:
            embed.add_field(name="Mirror Image", value="**True Seeing**: goo hits the real target.", inline=False)

                        
        ok, sv_roll, sv_dc, _pen = self._roll_save(t_cfg, vs="poi", penalty=0)
        if sv_dc is None:
            ok = False                                                                 
        save_text = f"Save vs Poison: d20 **{sv_roll}** vs **{sv_dc if sv_dc is not None else 'POI'}**"

        if ok:
            embed.add_field(name="Result", value=f"✅ **HIT**\n{save_text} → **RESISTED**", inline=False)
            await ctx.send(embed=embed)
            return

                                                                                
        dur_total, dur_rolls, _flat = roll_dice("3d6")
        try:
            base = f"{s_t}.x_nausea"
            curv = bcfg.getint(chan_id, base, fallback=0)
            newv = max(curv, dur_total)
            bcfg.set(chan_id, base, str(newv))
            bcfg.set(chan_id, f"{base}_label", "NA")
            bcfg.set(chan_id, f"{base}_code",  "NA")
            bcfg.set(chan_id, f"{base}_by",    att_name)
            _save_battles(bcfg)
        except Exception:
            newv = dur_total

        embed.add_field(
            name="Result",
            value=(f"✅ **HIT**\n{save_text} → **FAIL**\n"
                   f"🤢 **NAUSEATED** for **{dur_total}** rounds "
                   f"[3d6: {', '.join(map(str, dur_rolls))}]" + (f" *(now {newv})*" if newv != dur_total else "")),
            inline=False
        )
        embed.set_footer(text="Nauseated: may only move (no attacks, spells, or concentration).")

        await ctx.send(embed=embed)

                                                            
        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


    @commands.command(name="spray")
    async def beetle_spray(self, ctx, sprayer: str, *targets):
        """
        Giant Bombardier Beetle 'spray': 2d6 damage in a cone; Save vs Death/Poison for half.
        Usage: !spray GI1 testman wizard green

        Mechanics:
          • One damage roll for all targets (2d6).
          • Save vs Poison ("poi"); half on success.
          • 5/day limit per beetle.
          • Cooldown: no more than once per three rounds (shows as an x_* timer in tracker).
          • This command does NOT place the cone template; GM chooses targets.
        """
        
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!spray`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(sprayer))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Sprayer '{sprayer}' not found.")
            return

                                              
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, att_name or sprayer) or (att_name or sprayer)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
        except Exception:
            slot = (att_name or sprayer).replace(" ", "_")

        uses_key = f"{slot}.spray_uses"
        used = bcfg.getint(chan_id, uses_key, fallback=0)
        if used >= 5:
            await ctx.send(f"⛔ **{att_name}** has expended all five sprays for today.")
            return

        cd_key = f"{slot}.x_spraycd"
        cd_left = bcfg.getint(chan_id, cd_key, fallback=0)
        if cd_left > 0:
            await ctx.send(f"⛔ **{att_name}** is recharging its spray (**{cd_left}** rounds left).")
            return

        if not targets:
            await ctx.send("Usage: `!spray <sprayer> <target1> [target2 ...]`")
            return

        total, rolls, flat = roll_dice("2d6")
        base_dmg = max(0, total + flat)

        title = f"{att_name} unleashes a toxic blast!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.add_field(name="Attack", value=f"💨 **2d6** → **{base_dmg}** damage (Save vs Death Ray for half)", inline=False)

        lines = []
        dead_monsters, any_hp_changes = [], False

                                             
        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                                                                                  
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

                                     
        for raw in targets:
            disp, path = _resolve_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

                                  
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="poi", penalty=0)
            if sv_dc is None:
                ok = False                                                                 
            save_txt = f"(d20 **{sv_roll}** vs **{sv_dc if sv_dc is not None else 'POI'}**" + (f"; {sv_pen}" if sv_pen else "") + ")"

            dmg = base_dmg // 2 if ok else base_dmg

            final, note = _apply_mitigation(dmg, weapon_name="Toxic Spray", weapon_type="acid", t_cfg=t_cfg)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

                             
            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} → {after}{dead_note}"
            else:
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} → **{new_hp}**{dead_note}"

            res_txt = "**RESIST**" if ok else "**FAIL**"
            line = f"• **{pretty}**: Save vs Death Ray {save_txt} → {res_txt} → **{final}**\n{hp_txt}"
            if note: line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))

                                                      
        try:
            bcfg.set(chan_id, uses_key, str(used + 1))
                                                                      
            bcfg.set(chan_id, f"{slot}.x_spraycd",         "3")
            bcfg.set(chan_id, f"{slot}.x_spraycd_code",    "BS")                                     
            bcfg.set(chan_id, f"{slot}.x_spraycd_label",   "Bombardier Spray (CD)")                
            bcfg.set(chan_id, f"{slot}.x_spraycd_emoji",   "⏱️")
            bcfg.set(chan_id, f"{slot}.x_spraycd_by",      att_name)
            _save_battles(bcfg)
        except Exception:
            pass

                      
        embed.add_field(
            name="Effect",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        embed.add_field(
            name="Limit",
            value=f"Uses today: **{used+1} / 5**  •  Cooldown started: **3 rounds** `[BS 3]`",
            inline=False
        )
        embed.set_footer(text="Very hot, noxious gases: Save vs Death/Poison for half.")

        await ctx.send(embed=embed)

                                                                   
        if dead_monsters:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                            slot_rm = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot_rm}{suf}"
                                if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass

                                                            
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


    @commands.command(name="enslave")
    async def aboleth_enslave(self, ctx, enslaver: str, *targets):
        """
        Aboleth Enslave (special): Up to three times per day, an aboleth can attempt to enslave
        one living creature within 30 feet (not undead or non-living). The target must Save vs
        Spells or be utterly dominated, obeying the aboleth's telepathic commands.

        Usage:
          !enslave AB1 testman
          !enslave AB1 testman wizard   # each valid living target consumes one of the 3/day attempts

        Notes:
          • Max 3 successful/attempted en-slave tries per aboleth per day.
          • Affected creatures may attempt a new save vs Spells every 24 hours to break free.
          • Remove Curse, the aboleth’s death, or separation by more than 1 mile also ends control.
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return

        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!enslave`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(enslaver))
        except Exception:
            att_name, att_path = (None, None)

        if not att_path:
            await ctx.send(f"❌ Enslaver '{enslaver}' not found.")
            return
        if not _is_monster_file(att_path):
            await ctx.send(f"❌ **{att_name}** is not a monster.")
            return

        acfg = read_cfg(att_path)
        try:
            if not _monster_has_enslave(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list an 'enslave' special — proceeding anyway.")
        except Exception:
            pass

        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, att_name or enslaver) or (att_name or enslaver)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
        except Exception:
            slot = (att_name or enslaver).replace(" ", "_")

        uses_key = f"{slot}.enslave_uses"
        used = bcfg.getint(chan_id, uses_key, fallback=0)

        if not targets:
            await ctx.send("Usage: `!enslave <aboleth> <target1> [target2 ...]`  _(Range 30 ft; max 3/day)_")
            return

        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        candidates = [] 
        lines = []

        for raw in targets:
            disp, path = _resolve_ci(str(raw))
            pretty = disp or str(raw)
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            if not _is_living_creature(t_cfg):
                lines.append(f"• **{pretty}**: unaffected (not a living creature).")
                continue

            candidates.append((pretty, path, t_cfg))

        attempts = len(candidates)
        remaining = max(0, 3 - used)

        if attempts > remaining and attempts > 0:
            await ctx.send(
                f"⛔ **{att_name}** can only attempt Enslave **3/day**.\n"
                f"Already used: **{used}**  •  Remaining: **{remaining}**.\n"
                f"You targeted **{attempts}** valid creature(s). Reduce your target list or wait for a new day."
            )
            return

        embed = nextcord.Embed(
            title=f"{att_name} reaches into mortal minds…",
            color=random.randint(0, 0xFFFFFF),
        )
        embed.add_field(
            name="Effect",
            value=(
                "🧠 **Enslave** — One living creature within **30 ft** must Save vs **Spells** or be **enslaved**.\n"
                "• On a **success**: resists this attempt (the aboleth may try again later, up to 3/day).\n"
                "• On a **failure**: becomes a dominated thrall, obeying telepathic commands.\n"
                "• A *remove curse* spell, the aboleth's death, or moving more than **1 mile** away also ends the effect."
            ),
            inline=False,
        )
        embed.add_field(name="Range", value="30 ft", inline=True)
        embed.add_field(name="Limit", value="3 enslave attempts per day per aboleth.", inline=True)

        # Second pass: actually roll saves for valid candidates
        attempt_count = 0
        for pretty, path, t_cfg in candidates:
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                ok = False  # fall back to 'treat as fail' if we can't find a DC

            pen_txt = f" - {sv_pen}" if sv_pen else ""
            save_vs = sv_dc if sv_dc is not None else "SPELL"
            save_txt = f"(d20 **{sv_roll}** vs **{save_vs}**{pen_txt})"

            if ok:
                lines.append(
                    f"• **{pretty}**: Save vs Spells {save_txt} → ✅ **RESISTS**"
                )
            else:
                lines.append(
                    f"• **{pretty}**: Save vs Spells {save_txt} → 💀 **ENSLAVED** — now a dominated thrall of **{att_name}**"
                )

            attempt_count += 1

        embed.add_field(
            name="Targets",
            value=("\n".join(lines) if lines else "*(no valid targets)*"),
            inline=False,
        )

        new_used = used + attempt_count
        try:
            bcfg.set(chan_id, uses_key, str(new_used))
            _save_battles(bcfg)
        except Exception:
            pass

        embed.add_field(
            name="Daily Uses",
            value=f"Attempts today: **{new_used} / 3**",
            inline=False,
        )
        embed.set_footer(text="Enslaved creatures get a new save every 24 hours; GM tracks ongoing control and distance.")
        await ctx.send(embed=embed)


    @commands.command(name="breath")
    async def monster_breath(self, ctx, breather: str, *targets):
        """
        Monster Breath attack (Chimera, Dragons, etc.)
        Usage: !breath CH1 testman wizard orc1

        Rules:
          • If [base] breath = poison → each target saves vs DRAGON BREATH or dies (poison-immune & undead unaffected)
          • Else [base] breath = <XdY[+Z]> <type> (fire/cold/electric/acid)
              – One roll for all targets
              – Save vs DRAGON BREATH for half
              – Mitigation via weapon_type=<type> (resists/vulns applied)
          • AoE: clears Mirror Image on all affected targets
          • GM-only; requires an active battle
        """
        

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!breath`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(breather))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Breather '{breather}' not found.")
            return
        if not _is_monster_file(att_path):
            await ctx.send(f"❌ **{att_name}** is not a monster.")
            return

                                                                    
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            breather_key = _find_ci_name(names, att_name or breather) or (att_name or breather)
            try:
                breather_slot = _slot(breather_key)
            except Exception:
                breather_slot = breather_key.replace(" ", "_")
        except Exception:
            breather_key = (att_name or breather)
            breather_slot = breather_key.replace(" ", "_")

        acfg = read_cfg(att_path)
                                                 
        try:
            if not _monster_has_breath(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list a 'breath' special — proceeding anyway.")
        except Exception:
            pass

        raw_spec, src = _read_monster_breath_spec(acfg, att_path)
        if not raw_spec:
            await ctx.send(f"❌ {att_name}: no `breath` defined on the instance or its template.")
            return

        spec = re.sub(r"\s+", " ", raw_spec.lower())

                       
                    
                                                                 
                                               
                                     
                                                                 
        dice_spec, dtype = None, None

        def _norm_type(t: str | None):
            if not t: return None
            t = t.lower()
            if t in {"elec", "electric", "electricity", "lightning"}: return "electric"
            if t in {"cold", "ice", "frost"}:                         return "cold"
            if t in {"fire", "flame"}:                                 return "fire"
            if t in {"acid", "corrosive"}:                             return "acid"
            if t in {"holy"}:                                          return "holy"
            if t in {"poison", "toxic"}:                               return "poison"
            if t in {"petrify", "petrification", "stone"}:             return "petrify"         
            return t

        if "poison" in spec:
            dtype = "poison"
        elif any(tok in spec for tok in ("petrify", "petrification", "stone")):         
            dtype = "petrify"
        else:
                                   
            m_dice = re.search(r"(\d+d\d+(?:\s*\+\s*\d+)?)", spec)
            if m_dice:
                dice_spec = m_dice.group(1).replace(" ", "")
                                           
            for cand in ("fire", "cold", "electric", "electricity", "lightning", "acid", "holy"):
                if cand in spec:
                    dtype = _norm_type(cand)
                    break


                
        if dtype not in {"poison", "petrify"} and not dice_spec:

            where = f" (`{src}`)" if src else ""
            await ctx.send(f"❌ {att_name}: breath spec unclear from `{raw_spec}`{where}. Expected e.g. `3d4 fire` or `poison`.")
            return
        if not targets:
            await ctx.send("Usage: `!breath <monster> <target1> [target2 ...]`")
            return

                      
        title = f"🐲 {att_name} uses its breath attack!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

                                                           
        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []                        

        if dtype == "petrify":
                                                                              
            hd_limit = getint_compat(acfg, "base", "hd", fallback=0) or 0
            uses_key = f"{breather_slot}.gorgon_uses"
            cd_key   = f"{breather_slot}.x_gorgoncd"

            used = bcfg.getint(chan_id, uses_key, fallback=0)
            if hd_limit > 0 and used >= hd_limit:
                await ctx.send(f"⛔ **{att_name}** has expended all petrifying breaths for today (**{used}/{hd_limit}**).")
                return

            cd_left = bcfg.getint(chan_id, cd_key, fallback=0)
            if cd_left > 0:
                await ctx.send(f"⛔ **{att_name}** cannot use its breath yet (**{cd_left}** round{'s' if cd_left!=1 else ''} left).")
                return

                          
            embed.add_field(
                name="Attack",
                value=("🗿 **Petrifying Breath** — Save vs **Petrify** or **turned to stone**.\n"
                       "_Area: 60′ long × 10′ wide (GM adjudicates targets). Living creatures only._"),
                inline=False
            )

            def _resolve_ci(name: str):
                try:
                    return _resolve_char_ci(name)
                except Exception:
                    base = name.replace(" ", "_").lower() + ".coe"
                    for fn in os.listdir("."):
                        if fn.lower() == base:
                            path = fn
                            try:
                                cfg = read_cfg(path)
                                real = get_compat(cfg, "info", "name", fallback=None)
                                return (real or fn[:-4].replace("_", " ")), path
                            except Exception:
                                return fn[:-4].replace("_", " "), path
                    return None, None

                                                                
            def _is_construct_cfg(cfg):
                t = ((get_compat(cfg, "info", "type",  fallback="") or get_compat(cfg, "base", "type",  fallback="")) or "").strip().lower()
                return ("construct" in t) or ("golem" in t)

            lines = []
            any_changes = False

            for raw in targets:
                disp, path = _resolve_ci(raw)
                pretty = disp or raw
                if not path:
                    lines.append(f"• **{pretty}**: *(not found)*")
                    continue

                t_cfg = read_cfg(path)

                                         
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"• **{pretty}**: Mirror Image **({cleared})** destroyed by area effect.")

                                    
                try:
                    if _is_undead_cfg(t_cfg, pretty) or _is_construct_cfg(t_cfg):
                        lines.append(f"• **{pretty}**: **unaffected** (not living).")
                        continue
                except Exception:
                    pass

                                                                
                ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="pp", penalty=0)                     
                if sv_dc is None:
                    ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="petrify", penalty=0)

                if sv_dc is None:
                    ok = False                                           

                if ok:
                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    lines.append(f"• **{pretty}**: Save vs Petrify {sv_roll}{pen_txt} vs {sv_dc} → ✅ **RESISTED**")
                    continue

                                                                                  
                if bcfg and bcfg.has_section(chan_id):
                    t_slot = self._effect_slot_for(bcfg, chan_id, pretty)
                    bcfg.set(chan_id, f"{t_slot}.x_pet",        "999")                                         
                    bcfg.set(chan_id, f"{t_slot}.x_pet_label",  "Petrified")
                    bcfg.set(chan_id, f"{t_slot}.pet_perm", "1")
                    bcfg.set(chan_id, f"{t_slot}.x_pet_code",   "PET")
                    bcfg.set(chan_id, f"{t_slot}.x_pet_emoji",  "🗿")
                    bcfg.set(chan_id, f"{t_slot}.x_pet_by",     att_name)
                    _save_battles(bcfg)
                    any_changes = True
                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    lines.append(f"• **{pretty}**: Save vs Petrify {sv_roll}{pen_txt} vs {sv_dc} → **FAIL** → 🗿 **PETRIFIED** (stone).")
                else:
                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    lines.append(f"• **{pretty}**: Save vs Petrify {sv_roll}{pen_txt} vs {sv_dc} → **FAIL** → **PETRIFIED** (manual; no active battle).")

                                      
            embed.add_field(name="Effect", value=("\n".join(lines) if lines else "*(no valid targets)*"), inline=False)

                                                   
            try:
                if hd_limit > 0:
                    bcfg.set(chan_id, uses_key, str(used + 1))
                bcfg.set(chan_id, f"{cd_key}",           "2")                                    
                bcfg.set(chan_id, f"{cd_key}_code",      "GB")
                bcfg.set(chan_id, f"{cd_key}_label",     "Gorgon Breath (CD)")
                bcfg.set(chan_id, f"{cd_key}_emoji",     "⏱️")
                bcfg.set(chan_id, f"{cd_key}_by",        att_name)
                _save_battles(bcfg)
                any_changes = True
            except Exception:
                pass

                                                                        
            if hd_limit > 0:
                embed.add_field(
                    name="Limit",
                    value=f"Uses today: **{min(used+1, hd_limit)} / {hd_limit}**  •  Cooldown started: **2 rounds** `[GB 2]`  •  Area: **60′×10′** (living only)",
                    inline=False
                )
            else:
                embed.add_field(
                    name="Limit",
                    value="Cooldown started: **2 rounds** `[GB 2]`  •  Area: **60′×10′** (living only)",
                    inline=False
                )

            await ctx.send(embed=embed)

                                                           
            if any_changes:
                try:
                    await self._update_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass
            return

        if dtype == "poison":
            embed.add_field(
                name="Attack",
                value="☣️ **Poison Breath** — Save vs **Dragon Breath** or **die**.",
                inline=False
            )

            for raw in targets:
                disp, path = _resolve_ci(raw)
                pretty = disp or raw
                if not path:
                    lines.append(f"• **{pretty}**: *(not found)*")
                    continue

                t_cfg = read_cfg(path)
                absorbs_electric = ("electric" in _collect_absorb_types(t_cfg)) if (dtype == "electric") else False
                               
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"• **{pretty}**: Mirror Image **({cleared})** destroyed by area effect.")

                            
                try:
                    if _is_undead_cfg(t_cfg, pretty):
                        lines.append(f"• **{pretty}**: ☠️ Undead — **unaffected**.")
                        continue
                except Exception:
                    pass
                try:
                    if self._poison_immune(t_cfg):
                        lines.append(f"• **{pretty}**: 🧪 Poison-immune — **unaffected**.")
                        continue
                except Exception:
                    pass

                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
                max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                if old_hp is None:
                    lines.append(f"• **{pretty}**: ⚠️ No HP field — cannot resolve.")
                    continue
                if old_hp <= 0:
                    lines.append(f"• **{pretty}**: already ☠️ **dead**.")
                    continue

                ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="breath", penalty=0)
                if sv_dc is None:
                    ok = False                                                                   

                if ok:
                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    lines.append(f"• **{pretty}**: Save vs Dragon Breath {sv_roll}{pen_txt} vs {sv_dc} → ✅ **RESISTED**")
                    continue

                               
                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(path, t_cfg)
                any_hp_changes = True

                                   
                try:
                    if _is_monster_file(path):
                        mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                        before = _life_bar(old_hp, mhp, width=10)
                        after  = _life_bar(0, mhp, width=10)
                        lines.append(f"• **{pretty}**: Save vs Dragon Breath {sv_roll} vs {sv_dc} → **FAIL**\n{before} → **{after}** ☠️ **DEAD!**")
                    else:
                        lines.append(f"• **{pretty}**: Save vs Dragon Breath {sv_roll} vs {sv_dc} → **FAIL**\nHP {old_hp} → **0** ☠️ **DEAD!**")
                except Exception:
                    lines.append(f"• **{pretty}**: Save vs Dragon Breath {sv_roll} vs {sv_dc} → **FAIL** — ☠️ **DEAD!**")

                if _is_monster_file(path):
                    dead_monsters.append((pretty, path))

        else:
                               
            total, rolls, flat = roll_dice(dice_spec)
            base_dmg = max(0, total + flat)

            dtype_label = {"fire":"Fire","cold":"Cold","electric":"Lightning","acid":"Acid"}.get(dtype or "", (dtype or "?").title())
            embed.add_field(
                name="Attack",
                value=f"{dtype_label} Breath: **{dice_spec}** [{', '.join(map(str, rolls))}]"
                      + (f" +{flat}" if flat and isinstance(flat, int) and flat > 0 else "")
                      + f" = **{base_dmg}**  •  Save vs **Dragon Breath** for **half**",
                inline=False
            )

            for raw in targets:
                disp, path = _resolve_ci(raw)
                pretty = disp or raw
                if not path:
                    lines.append(f"• **{pretty}**: *(not found)*")
                    continue

                t_cfg = read_cfg(path)

                               
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"• **{pretty}**: Mirror Image **({cleared})** destroyed by area effect.")

                                                                                                           
                absorbs_electric = (dtype == "electric") and ("electric" in _collect_absorb_types(t_cfg))
                absorbs_fire     = (dtype == "fire")     and ("fire"     in _collect_absorb_types(t_cfg))

                                                                               
                ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="breath", penalty=0)
                if sv_dc is None:
                    ok = False
                if absorbs_electric or absorbs_fire:
                    ok = False

                dmg = base_dmg // 2 if ok else base_dmg

                                                                                                            
                final, note = _apply_mitigation(
                    dmg,
                    weapon_name=f"{dtype_label} Breath",
                    weapon_type=(dtype or "fire"),
                    t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty
                                                                                                                      
                )

                                                                            
                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
                if not t_cfg.has_section("cur"):
                    t_cfg.add_section("cur")
                t_cfg["cur"]["hp"] = str(new_hp)
                write_cfg(path, t_cfg)
                any_hp_changes = True

                               
                if _is_monster_file(path):
                    mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                    before = _life_bar(old_hp, mhp2, width=10)
                    after  = _life_bar(new_hp, mhp2, width=10)
                    dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                    hp_txt = f"{before} → {after}{dead_note}"
                else:
                    dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                    hp_txt = f"{old_hp} → **{new_hp}**{dead_note}"

                pen_txt  = f" - {sv_pen}" if sv_pen else ""
                res_txt  = "**RESIST**" if ok else "**FAIL**"
                auto_bits = []
                if absorbs_electric: auto_bits.append("absorbs electric")
                if absorbs_fire:     auto_bits.append("absorbs fire")
                auto_txt = f" (auto-fail: {', '.join(auto_bits)})" if auto_bits else ""

                amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"
                dup_heal = (final < 0) and note and ("heals" in note.lower())
                amt_part = "" if dup_heal else f" → {amt_txt}"

                line = f"• **{pretty}**: Save vs Dragon Breath {sv_roll}{pen_txt} vs {sv_dc} → {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
                if note:
                    line += f" ({note})"
                lines.append(line)

                if new_hp <= 0 and _is_monster_file(path):
                    dead_monsters.append((pretty, path))


                                   
        embed.add_field(
            name="Effect",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        await ctx.send(embed=embed)

        if dead_monsters:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot_rm = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot_rm}{suf}"
                                if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass

        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2 and bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


    @commands.command(name="gibber")
    async def gibbering_mouther_gibber(self, ctx, mouther: str, *targets):
        """
        Gibbering Mouther: maddening gibbering aura.
        Usage: !gibber MOUTHER target1 target2 ...

        Rules:
          • All living creatures (other than mouthers) within ~60 ft
            must Save vs Paralysis or become Confused for 1d2 rounds.
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!gibber`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(mouther))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Mouther '{mouther}' not found.")
            return
        if not _is_monster_file(att_path):
            await ctx.send(f"❌ **{att_name}** is not a monster.")
            return

        try:
            acfg = read_cfg(att_path)
            if not _monster_has_gibbering(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list a 'gibbering' special — proceeding anyway.")
        except Exception:
            pass

        if not targets:
            await ctx.send("Usage: `!gibber <mouther> <target1> [target2 ...]`  _(Affects ~60 ft)_")
            return

        embed = nextcord.Embed(
            title=f"{att_name} unleashes a maddening chorus of gibbering!",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(
            name="Effect",
            value=(
                "😵‍💫 **Gibbering** — Each **living** creature within ~60 ft must Save vs **Paralysis** "
                "or become **Confused** for **1d2 rounds**.\n"
                "Creatures of the same kind (other mouthers) are unaffected."
            ),
            inline=False
        )

        lines = []
        any_changes = False

        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        k_sum, k_rolls, k_flat = roll_dice("1d2")
        dur_rounds = max(1, k_sum + k_flat)

        for raw in targets:
            disp, path = _resolve_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            try:
                ty_txt = " ".join(filter(None, [
                    str(get_compat(t_cfg, "info", "monster_type", fallback="")),
                    str(get_compat(t_cfg, "base", "type",         fallback="")),
                    str(get_compat(t_cfg, "stats", "type",        fallback="")),
                    str(pretty)
                ])).lower()
            except Exception:
                ty_txt = str(pretty or "").lower()

            if "mouther" in ty_txt and "gibber" in ty_txt:
                lines.append(f"• **{pretty}**: unaffected (another gibbering mouther).")
                continue

            try:
                if _is_undead_cfg(t_cfg, pretty):
                    lines.append(f"• **{pretty}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass
            ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
                  str(get_compat(t_cfg, "info", "type",  fallback=""))).lower()
            if any(k in ty for k in ("construct", "golem", "ooze", "slime", "jelly", "mindless")):
                lines.append(f"• **{pretty}**: construct/mindless — **no effect**.")
                continue

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="para", penalty=0)
            if sv_dc is None:
                ok = False

            d20_face = "**20** 🎉" if sv_roll == 20 else ("**1** 💀" if sv_roll == 1 else str(sv_roll))
            pen_txt  = f" - {sv_pen}" if sv_pen else ""

            if ok:
                lines.append(
                    f"• **{pretty}** — Save vs Paralysis {d20_face}{pen_txt} vs {sv_dc} → ✅ **RESISTED**"
                )
                continue

            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    s   = self._effect_slot_for(bcfg, chan_id, key)
                except Exception:
                    try:
                        s = _slot(pretty)
                    except Exception:
                        s = str(pretty).replace(" ", "_")

                try:
                    prev = bcfg.getint(chan_id, f"{s}.cn", fallback=0)
                except Exception:
                    prev = 0
                bcfg.set(chan_id, f"{s}.cn", str(max(prev, dur_rounds)))
                bcfg.set(chan_id, f"{s}.cn_by", att_name)
                _save_battles(bcfg)
                any_changes = True

            lines.append(
                f"• **{pretty}** — Save vs Paralysis {d20_face}{pen_txt} vs {sv_dc} → 😵‍💫 **CONFUSED** "
                f"for **{dur_rounds}** round{'s' if dur_rounds != 1 else ''}."
            )

        if not lines:
            lines.append("*(no valid targets)*")

        embed.add_field(name="Targets", value="\n".join(lines), inline=False)
        embed.set_footer(text="Applies the same Confusion status [CN N] as the *confusion* spell for 1d2 rounds.")
        await ctx.send(embed=embed)

        if any_changes:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


    @commands.command(name="spore")
    async def yellow_mold_spore(self, ctx, sporer: str, *targets):
        """
        Yellow Mold: toxic spore cloud.
        Usage: !spore MOLD target1 target2 ...

        Rules:
          • All within ~10 ft save vs Death Ray or take 1d8 dmg/round for 6 rounds.
          • Each patch can emit spores once per day (we enforce 'once per battle' via a used flag).
          • GM adjudicates exact areas/ranges.
        """

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!spore`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(sporer))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Sporer '{sporer}' not found.")
            return

                                                                         
        try:
            acfg = read_cfg(att_path)
            if not _monster_has_spore(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list 'spore' in its specials — proceeding anyway.")
        except Exception:
            pass

                                                                               
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, att_name or sporer) or (att_name or sporer)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
        except Exception:
            slot = (att_name or sporer).replace(" ", "_")

                                                                         
        used_key = f"{slot}.x_spore_used"
        if bcfg.getint(chan_id, used_key, fallback=0) > 0:
            await ctx.send(f"⛔ **{att_name}** has already emitted spores today (used).")
            return

        if not targets:
            await ctx.send("Usage: `!spore <mold> <target1> [target2 ...]`  _(Affects ~10 ft)_")
            return

                     
        embed = nextcord.Embed(
            title=f"{att_name} erupts in a cloud of yellow spores!",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(
            name="Effect",
            value="☣️ **Toxic Spores** — Save vs **Death**; on fail take **1d8** damage each round for **6** rounds.",
            inline=False
        )
        embed.add_field(
            name="Notes",
            value="GM chooses who’s within ~10 ft. Each patch can emit once per day.",
            inline=False
        )

        lines = []
        any_changes = False

                                            
        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in targets:
            disp, path = _resolve_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

                                                
            try:
                is_undead = "undead" in (get_compat(t_cfg, "info", "type", fallback="").lower())
            except Exception:
                is_undead = False
            if is_undead or (self._poison_immune(t_cfg) if hasattr(self, "_poison_immune") else False):
                lines.append(f"• **{pretty}**: 🚫 **No effect** (poison immune/undead).")
                continue

                                                          
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="poi", penalty=0)
            if sv_dc is None:
                ok = False                                               

            if ok:
                pen_txt = f" - {sv_pen}" if sv_pen else ""
                lines.append(f"• **{pretty}**: Save vs Death {sv_roll}{pen_txt} vs {sv_dc} → ✅ **RESISTED**")
                continue

                                                                             
            try:
                t_slot = self._effect_slot_for(bcfg, chan_id, pretty)
            except Exception:
                                        
                t_slot = _slot(pretty)

                                                             
            cur = bcfg.getint(chan_id, f"{t_slot}.x_spore", fallback=0)
            newv = max(cur, 6)
            bcfg.set(chan_id, f"{t_slot}.x_spore",       str(newv))
            bcfg.set(chan_id, f"{t_slot}.x_spore_dice",  "1d8")
            bcfg.set(chan_id, f"{t_slot}.x_spore_label", "Toxic Spores")
            bcfg.set(chan_id, f"{t_slot}.x_spore_code",  "YS")
            bcfg.set(chan_id, f"{t_slot}.x_spore_emoji", "☣️")
            bcfg.set(chan_id, f"{t_slot}.x_spore_by",    att_name)
            _save_battles(bcfg)
            any_changes = True

            pen_txt = f" - {sv_pen}" if sv_pen else ""
            lines.append(
                f"• **{pretty}**: Save vs Death {sv_roll}{pen_txt} vs {sv_dc} → **FAIL** → ☣️ **SPORES** for **{newv}** rounds "
                "(1d8 at start of each turn)."
            )

        embed.add_field(name="Targets", value=("\n".join(lines) if lines else "*(no valid targets)*"), inline=False)
        embed.set_footer(text="Yellow mold is dormant after brief sunlight; prolonged sunlight kills it (GM adjudicates).")
        await ctx.send(embed=embed)

                                                              
        try:
            bcfg.set(chan_id, f"{slot}.x_spore_used", "1")
            bcfg.set(chan_id, f"{slot}.x_spore_used_label", "Spores (used)")
            bcfg.set(chan_id, f"{slot}.x_spore_used_code",  "SP")
            _save_battles(bcfg)
        except Exception:
            pass

                                            
        if any_changes:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


    @commands.command(name="charm")
    async def harpy_song(self, ctx, singer: str, *targets):
        """
        Harpy Song (special): all living creatures within 300' of one or more singing harpies
        must Save vs **Spells** or become **Charmed**.

        Usage:
          !charm HA1 testman wizard green
          !charm HA2 -D knight  # also roll the immediate 'led into danger' save for any who fail

        Flags:
          -D / -danger   → After initial checks, any FAILED targets immediately take a second Save vs Spells
                            as if they were being led toward a hazard (ravine, fire, etc.).

        Notes:
          • On a SUCCESS: The same harpy’s song cannot affect that creature again for 24 hours (messaged only).
          • On a FAIL: The victim approaches without fear; once in reach they surrender completely.
          • If led into danger, roll an immediate second save (this command can do that for you with -danger).
          • The charm lasts one full round after all harpies have ceased singing (GM adjudicates 'singing' state).
          • Range 300 feet (GM adjudicates distance; this command does not measure).
        """
        
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!charm`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(singer))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Singer '{singer}' not found.")
            return
        if not _is_monster_file(att_path):
            await ctx.send(f"❌ **{att_name}** is not a monster.")
            return

        acfg = read_cfg(att_path)
                                                                               
        try:
            if not _monster_has_harpysong(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list a 'harpy song' special — proceeding anyway.")
        except Exception:
            pass

        do_danger = False
        names = []
        for t in (targets or ()):
            tl = str(t).strip().lower()
            if tl in ("-d","-danger"):
                do_danger = True
            else:
                names.append(str(t))

        if not names:
            await ctx.send("Usage: `!charm <harpy> <target1> [target2 ...]`  _(Range 300 ft)_")
            return

                     
        embed = nextcord.Embed(
            title=f"{att_name} sings a haunting, irresistible melody…",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(
            name="Effect",
            value=("💗 **Harpy Song** — Each **living** target must Save vs **Spells** or become **Charmed**.\n"
                   "• Success: immune to **this harpy’s** song for **24 hours** (GM note).\n"
                   "• Failure: approaches the harpy without fear, and surrenders upon reaching it.\n"
                   "• If led toward danger, an immediate second save is allowed (use `-D/-danger` to roll it now)."),
            inline=False
        )
        embed.add_field(name="Range", value="300 feet (GM adjudicates)", inline=True)
        embed.add_field(name="Duration", value="While harpies sing, plus **1 round** after they stop.", inline=True)

                                           
        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        lines = []

        for raw in names:
            disp, path = _resolve_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

                                                                    
            if not _is_living_creature(t_cfg):
                lines.append(f"• **{pretty}**: unaffected (not a living creature).")
                continue

                            
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                                                                                             
                ok = False

            pen_txt = f" - {sv_pen}" if sv_pen else ""

            if ok:
                                                                                   
                lines.append(
                    f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → ✅ **RESISTS** — "
                    f"immune to **{att_name}**’s song for **24 hours**."
                )
                continue

                                           
            fail_line = (
                f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → 💗 **CHARMED** — "
                f"approaches **{att_name}** without fear; surrenders upon reaching."
            )

                                                                 
            if do_danger:
                ok2, sv2_roll, sv2_dc, sv2_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
                if sv2_dc is None:
                    ok2 = False
                pen2_txt = f" - {sv2_pen}" if sv2_pen else ""
                if ok2:
                    fail_line += (
                        f"\n  ↳ **Hazard Save**: {sv2_roll}{pen2_txt} vs {sv2_dc} → ✅ **RESISTS** near the hazard "
                        f"(does not proceed into danger)."
                    )
                else:
                    fail_line += (
                        f"\n  ↳ **Hazard Save**: {sv2_roll}{pen2_txt} vs {sv2_dc} → 💀 **FAILS** — "
                        f"proceeds directly into danger."
                    )

            lines.append(fail_line)

        embed.add_field(name="Targets", value=("\n".join(lines) if lines else "*(no valid targets)*"), inline=False)
        embed.set_footer(text="A charmed victim remains affected for 1 round after all harpies stop singing.")

        await ctx.send(embed=embed)



    @commands.command(name="slow")
    async def stone_golem_slow(self, ctx, slower: str, *targets):
        """
        Stone Golem Slow (special): once every other round, as reverse Haste.
        Usage: !slow ST1 target1 target2 ...

        Mechanics (per BFRPG-style note):
          • Save vs Spells per target.
          • On FAIL:
              – If target is Hasted, remove Haste instead of applying Slow.
              – Else apply Slow as a manual timer/tag.
          • Duration: 2d6 rounds (one roll shared for all affected targets).
          • Range: 10 feet (GM adjudicates; this command does not measure distance).
          • Cooldown: cannot be used two rounds in a row (2-round CD tag on the golem).
        """
        

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!slow`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(slower))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Slower '{slower}' not found.")
            return

                                                                
        try:
            acfg = read_cfg(att_path)
            if not _monster_has_golemslow(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list 'golemslow' in its specials — proceeding anyway.")
        except Exception:
            pass

                                                       
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, att_name or slower) or (att_name or slower)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
        except Exception:
            slot = (att_name or slower).replace(" ", "_")

        cd_key = f"{slot}.x_gslwcd"
        cd_left = bcfg.getint(chan_id, cd_key, fallback=0)
        if cd_left > 0:
            await ctx.send(f"⛔ **{att_name}** is recovering its slow (**{cd_left}** round{'s' if cd_left!=1 else ''} left).")
            return

        if not targets:
            await ctx.send("Usage: `!slow <golem> <target1> [target2 ...]`  _(Range 10 ft)_")
            return

                                           
        dur_sum, dur_rolls, dur_flat = roll_dice("2d6")
        slow_rounds = max(1, dur_sum + dur_flat)

                            
        embed = nextcord.Embed(
            title=f"{att_name} exudes a crushing lethargy!",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(
            name="Effect",
            value=f"🐢 **Slow** — Save vs **Spells**; on fail apply **Slow** for **{slow_rounds}** rounds.\n",
            inline=False
        )
        embed.add_field(
            name="Duration Roll",
            value=f"2d6 → [{', '.join(map(str, dur_rolls))}] = **{slow_rounds}**",
            inline=False
        )

        lines = []
        any_changes = False

                                                                                                
        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in targets:
            disp, path = _resolve_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

                            
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                ok = False                                                            

            if ok:
                pen_txt = f" - {sv_pen}" if sv_pen else ""
                lines.append(f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → ✅ **RESISTED**")
                continue

                                                               
            dispelled_haste = False
            if bcfg and bcfg.has_section(chan_id):
                t_slot = self._effect_slot_for(bcfg, chan_id, pretty)

                                           
                cleared = False
                for key in ("x_hst", "x_haste", "haste"):
                    opt = f"{t_slot}.{key}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                        cleared = True
                for key in ("x_hst_label", "x_hst_code", "x_hst_by", "haste_by", "haste_src"):
                    opt = f"{t_slot}.{key}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                        cleared = True

                if cleared:
                    _save_battles(bcfg)
                    dispelled_haste = True
                    any_changes = True

                if dispelled_haste:
                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    lines.append(
                        f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → **FAIL** → ✨ **Haste dispelled** (no Slow)."
                    )
                else:
                                                           
                    bcfg.set(chan_id, f"{t_slot}.x_slw",       str(slow_rounds))
                    bcfg.set(chan_id, f"{t_slot}.x_slw_label", "Slow")
                    bcfg.set(chan_id, f"{t_slot}.x_slw_code",  "SLO")
                    bcfg.set(chan_id, f"{t_slot}.x_slw_by",    att_name)
                    _save_battles(bcfg)
                    any_changes = True

                    pen_txt = f" - {sv_pen}" if sv_pen else ""
                    lines.append(
                        f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → **FAIL** → 🐢 **SLOWED** for **{slow_rounds}** rounds "
                        f"_(half move; half attacks—generally act every other round)_"
                    )
            else:
                pen_txt = f" - {sv_pen}" if sv_pen else ""
                lines.append(
                    f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → **FAIL** → **SLOWED {slow_rounds} rounds** "
                    f"(no active battle; won’t auto-tick)."
                )

        embed.add_field(
            name="Targets",
            value=("\n".join(lines) if lines else "*(no valid targets)*"),
            inline=False
        )
        embed.set_footer(text="Haste and Slow don’t stack; they counter/dispel each other. Range 10 ft.")

        await ctx.send(embed=embed)

                                                                                         
        try:
            bcfg.set(chan_id, f"{slot}.x_gslwcd",       "2")
            bcfg.set(chan_id, f"{slot}.x_gslwcd_code",  "SG")
            bcfg.set(chan_id, f"{slot}.x_gslwcd_label", "Golem Slow (CD)")
            bcfg.set(chan_id, f"{slot}.x_gslwcd_emoji", "⏱️")
            bcfg.set(chan_id, f"{slot}.x_gslwcd_by",    att_name)
            _save_battles(bcfg)
            any_changes = True
        except Exception:
            pass

                                                         
        if any_changes:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


    @commands.command(name="dance")
    async def cmd_dance_secondary(self, ctx, *who_list: str):
        """
        Force onlookers to dance (secondary victims):
          • Each target makes a Save vs Spells.
          • On fail: DANCE for 2d4 rounds (no ongoing poison damage).
          • Manual penalties: attacks −4; saves −4; Thief abilities disabled while dancing.
        Usage: !dance testman holyman wizard
        GM-only; requires a running battle.
        """
        

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle running here. Use `!battle` first.")
            return

        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!dance`.")
            return

        names = [w for w in (who_list or []) if str(w).strip()]
        if not names:
            await ctx.send("❌ Usage: `!dance <name1> <name2> ...`")
            return

        
        emb = nextcord.Embed(
            title="🕷️ Giant Tarantula — Secondary Dance",
            description="Each listed creature makes a **Save vs Spells**.",
            color=random.randint(0, 0xFFFFFF)
        )

        any_applied = False
        for raw in names:
            disp, path = _resolve_char_ci(raw)
            if not path or not os.path.exists(path):
                emb.add_field(name=raw, value="Not found.", inline=False)
                continue

            tcfg = read_cfg(path)

                                                                                      
            try:
                if _is_undead_cfg(tcfg, disp):
                    emb.add_field(name=disp, value="☠️ Undead — **no effect**.", inline=False)
                    continue
            except Exception:
                pass

            ok, roll, dc, _ = self._roll_save(tcfg, vs="spell", penalty=0)
            if dc is None:
                ok = True                                          
            if ok:
                emb.add_field(name=disp, value=f"Save vs Spells: {roll} vs {dc} → ✅ **RESISTED**.", inline=False)
            else:
                emb.add_field(name=disp, value=f"Save vs Spells: {roll} vs {dc} → ❌ **FAIL**", inline=False)                                                        
                await self._apply_dance_poison_on_hit(ctx, bcfg, chan_id, "Tarantula", disp, tcfg, emb, primary=False)
                any_applied = True

                                             
        if any_applied:
            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
            except Exception:
                pass

        await ctx.send(embed=emb)


    @commands.command(name="lightning")
    async def monster_lightning_throw(self, ctx, thrower: str, *targets):
        """
        Storm Giant 'Lightning Throw' (and similar monsters with special=lightning).
        Usage: !lightning ST1 testman wizard holyman

        Mechanics:
          • Works like Lightning Bolt, but always **15d6** (not HD-based).
          • One damage roll shared by all targets.
          • Save vs **Spells** for half.
          • Mitigation as electric/lightning (weapon_type="electric").
          • Clears Mirror Image on hit (line/AoE handling like your LB helpers).
          • Cooldown: **5 rounds** between uses (x_* timer in tracker).
          • GM-only; requires an active battle.
        """
        

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!lightning`.")
            return

        try:
            att_name, att_path = _resolve_char_ci(str(thrower))
        except Exception:
            att_name, att_path = (None, None)
        if not att_path:
            await ctx.send(f"❌ Thrower '{thrower}' not found.")
            return
        if not _is_monster_file(att_path):
            await ctx.send(f"❌ **{att_name}** is not a monster.")
            return

        acfg = read_cfg(att_path)
                                                                           
        try:
            if not _monster_has_lightning_throw(acfg, att_path):
                await ctx.send(f"⚠️ **{att_name}** doesn’t list a 'lightning' special — proceeding anyway.")
        except Exception:
            pass

                                                                       
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, att_name or thrower) or (att_name or thrower)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
        except Exception:
            slot = (att_name or thrower).replace(" ", "_")

        cd_key = f"{slot}.x_lightcd"
        cd_left = bcfg.getint(chan_id, cd_key, fallback=0)
        if cd_left > 0:
            await ctx.send(f"⛔ **{att_name}** is recharging its lightning (**{cd_left}** rounds left).")
            return

        if not targets:
            await ctx.send("Usage: `!lightning <monster> <target1> [target2 ...]`")
            return

        dice_spec = "15d6"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        title = f"{att_name} hurls a bolt of lightning!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        embed.add_field(
            name="Attack",
            value=f"⚡ **{dice_spec}** [{', '.join(map(str, rolls))}]"
                  + (f" +{flat}" if flat and isinstance(flat, int) and flat > 0 else "")
                  + f" = **{base_dmg}**  •  Save vs **Spells** for **half**",
            inline=False
        )

        def _resolve_ci(name: str):
            try:
                return _resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        lines = []
        dead_monsters, any_hp_changes = [], False

        for raw in targets:
            disp, path = _resolve_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"• **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)

                                              
            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"• **{pretty}**: Mirror Image **({cleared})** destroyed by area effect.")
            except Exception:
                pass

                                                                        
            absorbs_electric = ("electric" in _collect_absorb_types(t_cfg))

                                                                                    
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                ok = False
            if absorbs_electric:
                ok = False

            dmg = base_dmg // 2 if ok else base_dmg

                                                                                           
            final, note = _apply_mitigation(dmg, weapon_name="Lightning Throw", weapon_type="electric", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty, is_magical=True)

                                         
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))

            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

                                     
            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} → {after}{dead_note}"
            else:
                dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} → **{new_hp}**{dead_note}"

                                                                                       
            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            res_txt  = "**RESIST**" if ok else "**FAIL**"
            auto_txt = " (auto-fail: absorbs electric)" if absorbs_electric else ""
            amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"

            dup_heal = (final < 0) and note and ("heals" in note.lower())
            amt_part = "" if dup_heal else f" → {amt_txt}"

            line = f"• **{pretty}**: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} → {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


                        
        embed.add_field(name="Effect", value="\n".join(lines) if lines else "*(no valid targets)*", inline=False)

                                                                    
        try:
            bcfg.set(chan_id, f"{slot}.x_lightcd",       "5")
            bcfg.set(chan_id, f"{slot}.x_lightcd_code",  "LT")                                           
            bcfg.set(chan_id, f"{slot}.x_lightcd_label", "Lightning Throw (CD)")             
            bcfg.set(chan_id, f"{slot}.x_lightcd_emoji", "⏱️")
            bcfg.set(chan_id, f"{slot}.x_lightcd_by",    att_name)
            _save_battles(bcfg)
            embed.add_field(name="Cooldown", value="Started: **5 rounds** `[LT 5]`", inline=False)
        except Exception:
            pass

        await ctx.send(embed=embed)

        if dead_monsters:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key2 = _find_ci_name(names, pretty) or pretty
                        if key2 in names:
                            names = [n for n in names if n != key2]
                            if bcfg.has_option(chan_id, key2):
                                bcfg.remove_option(chan_id, key2)
                            slot_rm = _slot(key2)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot_rm}{suf}"
                                if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass

        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


    @commands.command(name="invis")
    async def monster_invis(self, ctx, who: str, *opts):
        """
        Make a monster invisible (GM only; requires active battle).

        Usage:
          !invis <monster>                 # normal Invisibility (24h; breaks on attack)
          !invis <monster> -imp           # Improved-style (does NOT break on attack)
          !invis <monster> -rounds 120    # custom duration in rounds
          !invis <monster> -off           # end invisibility

        Notes:
          • Pixies default to Improved (sticky) invis and can attack without breaking it.
          • For pixie ambushes, use: !surprise <foes> +3  (to get 1–5 on 1d6).
          • Keys used: <slot>.inv (rounds), <slot>.inv_by (who set it), <slot>.inv_type ("imp" if improved).
        """
        

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!invis`.")
            return

        disp, path = _resolve_char_ci(str(who))
        pretty = disp or who
        if not path:
            await ctx.send(f"❌ Monster '{who}' not found.")
            return
        if not _is_monster_file(path):
            await ctx.send(f"❌ **{pretty}** is not a monster file. (Use the Invisibility spell for PCs.)")
            return
        cfg = read_cfg(path)

                         
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, pretty) or pretty
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
        except Exception:
            slot = pretty.replace(" ", "_")

        tokens = [t for t in opts if str(t).strip()]
        want_off   = any(t.lower() in {"-off","off","clear","-clear","end"} for t in tokens)
        want_imp   = any(t.lower() in {"-imp","-i","improved"} for t in tokens)
        rounds     = None
        for i, t in enumerate(tokens):
            if t.lower() in {"-rounds","-r"} and i+1 < len(tokens):
                try: rounds = max(1, int(str(tokens[i+1])))
                except Exception: pass

                                                  
        is_pixie = False
        try:
            hay = " ".join([
                (get_compat(cfg, "base", "type",   fallback="") or ""),
                (get_compat(cfg, "info", "race",   fallback="") or ""),
                (get_compat(cfg, "stats","special",fallback="") or ""),
                pretty or ""
            ]).lower()
            is_pixie = ("pixie" in hay)
        except Exception:
            pass

        if want_off:
            removed = False
            for opt in (f"{slot}.inv", f"{slot}.inv_by", f"{slot}.inv_type"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt); removed = True
            if removed: _save_battles(bcfg)

            embed = nextcord.Embed(
                title=f"🫥 Invisibility ends for {pretty}",
                description="**Visible.** Attack/Dodge vs them is no longer affected by invisibility.",
                color=nextcord.Color.dark_gray()
            )
            await ctx.send(embed=embed)

                             
            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
            return

                           
        PERM_ROUNDS = 10_000_000                         
        if rounds is None:
            if want_imp or is_pixie:
                rounds = PERM_ROUNDS
            else:
                rounds = 8640                                           

                  
        bcfg.set(chan_id, f"{slot}.inv",    str(rounds))
        bcfg.set(chan_id, f"{slot}.inv_by", pretty)
        if want_imp or is_pixie:
            bcfg.set(chan_id, f"{slot}.inv_type", "imp")
        else:
                                                                        
            if bcfg.has_option(chan_id, f"{slot}.inv_type"):
                bcfg.remove_option(chan_id, f"{slot}.inv_type")
        _save_battles(bcfg)

                 
        flavor = "becomes invisible" if not (want_imp or is_pixie) else "fades into **Improved Invisibility**"
        desc_lines = [
            f"🫥 **{pretty}** {flavor}.",
            f"• Duration: **{rounds} rounds**" + (" (does **not** end on attack)" if (want_imp or is_pixie) else " (ends on attack)"),
            "• Attackers suffer **−4 to hit** unless they can detect invisibility (GM adjudication).",
            "• True Seeing / See Invisible negates the penalty."
        ]
        if is_pixie:
            desc_lines.append("• Pixie ambush: use `!surprise <foes> +3` (surprise on **1–5** on 1d6).")

        embed = nextcord.Embed(
            title="🫥 Invisibility",
            description="\n".join(desc_lines),
            color=random.randint(0, 0xFFFFFF)
        )
        await ctx.send(embed=embed)

                                                                
        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


    @commands.command(name="brush")
    async def brush(self, ctx):
        """Spend your round brushing off maggots (you still take this round's damage)."""
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ','_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**.")
            return

        bcfg = _load_battles(); chan_id = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("⚠️ Not in an initiative tracker here.")
            return

        slotT, disp = _resolve_effect_slot(bcfg, chan_id, char_name)
        left = bcfg.getint(chan_id, f"{slotT}.x_maggots", fallback=0)
        if left <= 0:
            await ctx.send(f"🪱 **{disp}** has no maggots to brush off.")
            return

                                                                      
        await self._tick_maggots_start_of_turn(ctx, bcfg, chan_id, char_name, path)
        bcfg.set(chan_id, f"{slotT}.x_maggots", "0")
        _save_battles(bcfg)
        await ctx.send(f"🧹 **{disp}** spends the round brushing off the maggots. Ongoing damage **ended**. (Sickened, if any, remains.)")


    @commands.command(name="stench")
    async def stench(self, ctx, stinker: str, *targets):
        raw = ctx.message.content.lower().strip()
                                                                              
        if isinstance(ctx.prefix, str) and ctx.prefix.lower().startswith(("!cast", "/cast")):
            return
                                                                               
        if raw.startswith(("!cast stench", "/cast stench")):
            return

        """
        Ghast (or similar) Stench aura:
          • Each target saves vs Poison; on fail they suffer STENCH for 1d6 rounds.
          • We track this as [ST N] in the initiative panel.
        Usage: !stench GH1 go1 go2 testman
        """
        

        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle here. Use `!init` first."); return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!stench`."); return

        stink_name, stink_path = _resolve_char_ci(stinker)
        if not stink_path:
            await ctx.send(f"❌ Source '{stinker}' not found."); return
        if not targets:
            await ctx.send("Usage: `!stench <source> <target1> [target2 ...]`"); return

        title = f"{stink_name} exudes a nauseating stench!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        lines = []

        for t in targets:
            t_disp, t_path = _resolve_char_ci(t)
            pretty = t_disp or t
            if not t_path:
                lines.append(f"{pretty}: *(not found)*"); continue

            t_cfg = read_cfg(t_path)

                                                                                              
            try:
                resist, reduce1, immune = _defense_sets(t_cfg)
            except Exception:
                resist, reduce1, immune = set(), set(), set()
            if "poison" in immune:
                lines.append(f"{pretty}: **Immune (poison)** → no effect.")
                continue

                                    
            ok, roll, dc, pen = self._roll_save(t_cfg, vs="poi", penalty=0)
            if ok:
                lines.append(f"{pretty}: Save {roll} vs {dc} → **RESISTED**")
                continue

                                                      
            s, _rolls, _flat = roll_dice("1d6")
            dur = max(1, s)

                                       
            try:
                slot = _choose_slot_for_effects(bcfg, chan_id, pretty)
            except Exception:
                try:
                    slot = _slot(pretty)
                except Exception:
                    slot = pretty.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.stench", str(dur))
            bcfg.set(chan_id, f"{slot}.stench_by", stink_name)
            _save_battles(bcfg)

            lines.append(f"{pretty}: Save {roll} vs {dc} → **STENCH** for **{dur} rounds** [STN {dur}]")

                                        
        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        embed.add_field(
            name="Effect (≈10′ aura; you choose targets)",
            value="\n".join(lines) if lines else "*(no valid targets)*",
            inline=False
        )
        embed.set_footer(text="STENCH: track as [STN N]. Apply attack/roleplay penalties manually if any.")
        await ctx.send(embed=embed)


    @commands.command(name="cure")
    async def cure(self, ctx, target: str, what: str = "disease"):
        """
        GM tool: remove statuses from a character.
        Usage:
          !cure <target> disease
          !cure <target> mummyrot
          !cure <target> all
        Aliases:
          disease: disease, dis, sick, sickened
          mummyrot: mummyrot, mrot
          all: all, everything
        """
        

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        try:
            chan_id = _section_id(ctx.channel)
        except Exception:
            chan_id = str(ctx.channel.id)

                                                 
        if bcfg and bcfg.has_section(chan_id):
            dm_id = bcfg.get(chan_id, "DM", fallback="")
            if str(ctx.author.id) != str(dm_id):
                await ctx.send("❌ Only the GM can use `!cure` in this battle channel.")
                return

        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target)
        except Exception:
            try:
                tgt_disp, tgt_path = _resolve_char_ci(target)
            except Exception:
                tgt_disp, tgt_path = target, None

        if not tgt_path or not os.path.exists(tgt_path):
            await ctx.send(f"❌ Target `{target}` not found.")
            return

                                       
        slot_tgt = None
        if bcfg and bcfg.has_section(chan_id):
            try:
                names_keyed, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names_keyed, tgt_disp) or tgt_disp
                slot_tgt = _slot(key)
            except Exception:
                slot_tgt = (tgt_disp or "").replace(" ", "_")
        else:
            slot_tgt = (tgt_disp or "").replace(" ", "_")

        w = re.sub(r"[^\w]+", "", (what or "").lower())
        kinds = set()
        if w in {"all", "everything"}:
            kinds.update(("disease", "mummyrot"))
        elif w in {"disease", "dis", "sick", "sickened"}:
            kinds.add("disease")
        elif w in {"mummyrot", "mrot"}:
            kinds.add("mummyrot")
        else:
            await ctx.send(f"❌ Unknown cure kind `{what}`. Try `disease`, `mummyrot`, or `all`.")
            return

        from configparser import NoSectionError
        cfg = read_cfg(tgt_path)
        if not cfg.has_section("cur"):
            cfg.add_section("cur")

        did_anything = False
        notes = []

                             
        if w in {"disease", "dis", "sick", "sickened", "all", "everything"}:
            try:
                cfg["cur"]["disease"] = "0"
                for k in ("sick_days","sick_turns","sick_exert","sick_block_heal","sick_block_prep","sick_block_run"):
                    if cfg.has_option("cur", k): cfg.remove_option("cur", k)
                write_cfg(tgt_path, cfg)
                did_anything = True
                notes.append("disease cleared")
            except NoSectionError:
                pass
                                                      
            try:
                if bcfg and bcfg.has_section(chan_id):
                    for suf in (".sick",".sick_pen",
                                ".x_sick",".x_sick_code",".x_sick_label",".x_sick_emoji",".x_sick_by",
                                ".maggots",".maggots_die",
                                ".x_maggots",".x_maggots_dmg",".x_maggots_label",".x_maggots_emoji",".x_maggots_code",".x_maggots_by"):
                        opt = f"{slot_tgt}{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                    try: self._tracker_remove_tag(bcfg, chan_id, slot_tgt, "DIS")
                    except Exception: pass
                    _save_battles(bcfg)
            except Exception:
                pass

                                                                     
        if w in {"mummyrot", "mrot", "disease", "dis", "sick", "sickened", "all", "everything"}:
                                    
            if not cfg.has_section("cur"):
                cfg.add_section("cur")
            cfg["cur"]["mummyrot"] = "0"
            for k in ("mrot_block_heal", "mrot_days"):
                if cfg.has_option("cur", k):
                    cfg.remove_option("cur", k)
            write_cfg(tgt_path, cfg)
            did_anything = True
            if "mummy rot cleared" not in notes:
                notes.append("mummy rot cleared")

                                         
            try:
                if bcfg and bcfg.has_section(chan_id):
                    for suf in (".mrot",".mrot_block_heal",
                                ".x_mrot",".x_mrot_n",".x_mrot_code",".x_mrot_label",".x_mrot_emoji",".x_mrot_by"):
                        opt = f"{slot_tgt}{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                    try: self._tracker_remove_tag(bcfg, chan_id, slot_tgt, "MROT")
                    except Exception: pass
                    _save_battles(bcfg)
            except Exception:
                pass

                                                                


        if bcfg and bcfg.has_section(chan_id):
            try:
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        if did_anything:
            await ctx.send(f"✨ **Cure**\n**{tgt_disp}**: " + ", ".join(notes) + ".")
        else:
            await ctx.send(f"ℹ️ **Cure**\nNo matching statuses found on **{tgt_disp}**.")


    @commands.command(name="ward")
    async def ward(self, ctx, pc: str, swarm: str = None, *, opts: str = ""):
        """
        Ward off an insect swarm with a torch.
        Usage:
          !ward <PC> <SWARM>
          !ward <PC> all         (apply to all swarms on this battlefield)
          !ward <PC>             (auto-apply to all swarms if ambiguous)
          !ward off <SWARM|all>  (remove torch ward flag)
        If the PC has no torch, posts a reminder that swarm damage is reduced to 1 (GM adjudicates).
        """
        

                                                                             
        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel)
        if not bcfg.has_section(chan_id):
            await ctx.send("❌ No battle running here. Use `!battle` first.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("❌ Only the GM can use `!ward`.")
            return

                  
        if pc.lower() == "off":
            target = (swarm or "").strip()
            victims = []
            names, _ = _parse_combatants(bcfg, chan_id)
            if not target or target.lower() == "all":
                victims = names[:]
            else:
                n, _p = _resolve_char_ci(target)
                if n: victims = [n]
            cleared = []
            for v in victims:
                s = _slot(v)
                if bcfg.has_option(chan_id, f"{s}.x_swarm_torch"):
                    bcfg.remove_option(chan_id, f"{s}.x_swarm_torch")
                    for suf in ("_label","_emoji","_code","_by"):
                        opt = f"{s}.x_swarm_torch{suf}"
                        if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    cleared.append(v)
            _save_battles(bcfg)
            if cleared:
                await ctx.send(f"🕯️ Torch ward **cleared** from: {', '.join(cleared)}.")
            else:
                await ctx.send("🕯️ No torch wards were set.")
            return

                                  
        pc_name, pc_path = _resolve_char_ci(pc)
        if not pc_path:
            await ctx.send(f"❌ PC '{pc}' not found.")
            return
        pc_cfg = read_cfg(pc_path)

        def _pc_has_torch(c):
                                                         
            for sec in ("items","item","eq","equipment","inventory","gear","pack","bag"):
                try:
                    if not c.has_section(sec): continue
                    for k, v in c.items(sec):
                        s = f"{k} {v}".lower()
                        if "torch" in s:
                            return True
                except Exception:
                    pass
                                                      
            try:
                notes = (get_compat(c, "info", "notes", fallback="") or "").lower()
                if "torch" in notes: return True
            except Exception:
                pass
            return False

        has_torch = _pc_has_torch(pc_cfg)

                              
        names, _ = _parse_combatants(bcfg, chan_id)
        swarm_names = []
        for n in names:
            fn = f"{n}.coe"
            if not os.path.exists(fn): continue
            c = read_cfg(fn)
            if str(get_compat(c, "info", "class", fallback="")).strip().lower() != "monster":
                continue
            if str(get_compat(c, "info", "monster_type", fallback="")).strip().lower() == "insectswarm":
                swarm_names.append(n)

        targets = []
        if not swarm or swarm.strip().lower() == "all":
            targets = swarm_names[:]
        else:
            nm, _p = _resolve_char_ci(swarm)
            if nm:
                targets = [nm]
            else:
                                                            
                cand = [s for s in swarm_names if s.lower().startswith(swarm.lower())]
                targets = cand or swarm_names[:]

        if not targets:
            await ctx.send("❌ No insect swarms found in this battle.")
            return

        if not has_torch:
                                                    
            await ctx.send(f"🕯️ **{pc_name}** wards at {', '.join(targets)}.\n"
                           f"Damage to warding creature is **reduced to 1** per round *(GM adjudicates)*.")
            return

                                        
        for t in targets:
            s = _slot(t)
            bcfg.set(chan_id, f"{s}.x_swarm_torch", "1")
            bcfg.set(chan_id, f"{s}.x_swarm_torch_code", "WARD")
            bcfg.set(chan_id, f"{s}.x_swarm_torch_label", f"Warded by Torch ({pc_name})")
            bcfg.set(chan_id, f"{s}.x_swarm_torch_emoji", "🕯️")
            bcfg.set(chan_id, f"{s}.x_swarm_torch_by", pc_name)
        _save_battles(bcfg)

        await ctx.send(f"🕯️ **{pc_name}** wards {'all swarms' if len(targets)>1 else targets[0]} with a torch. "
                       f"Each warded swarm takes **1d4 damage** at the start of its turn.")


    @commands.command(name="charges")
    async def charges(self, ctx, *, arg: str | None = None):
        """
        Show or edit item charges for wands/staves.

        Examples:
          !charges
          !charges set StaffofPower 18/30
          !charges set WandofFireballs 12
          !charges set WandofFireballs@ab12 12/20   # target a specific instance
          !charges spend StaffofPower 2
          !charges spend WandofFireballs@ab12 3     # spend on a specific instance
        """
        
                        
        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("❌ No active character. Use `!char <name>` first."); return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"❌ Character file not found for **{char_name}**."); return
        cfg = read_cfg(path)

                                                                                  
        def _resolve_item_token(item_text: str):
            """
            Returns (token_for_key, base_name, it_dict, error_msg_or_None, choices_if_ambiguous)
            - token_for_key: either 'Name@id' (preferred) OR the base 'Name' (legacy/pooled)
            - if user didn't include @id and multiple instances are present, returns error with choices
            """
            storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
            token = (item_text or "").strip()
            base  = token.split("@", 1)[0] if token else ""
            canon, it = self._item_lookup(base)

            if not self._item_has_charges(base, it):
                return None, base, it, f"❌ **{base}** doesn’t look like a wand/staff.", None

                                                                      
            if "@" in token:
                if token not in storage:
                                                         
                    inst = [t for t in storage if t.split("@", 1)[0].lower() == base.lower() and "@" in t]
                    choices = ", ".join(inst[:6]) + ("…" if len(inst) > 6 else "")
                    msg = f"❌ **{token}** isn’t in your bag."
                    if inst:
                        msg += f"\nYou do have: {choices}"
                    return None, base, it, msg, inst
                return token, base, it, None, None

                                                            
            inst = [t for t in storage if t.split("@", 1)[0].lower() == base.lower() and "@" in t]
            if len(inst) > 1:
                                            
                choices = ", ".join(inst[:6]) + ("…" if len(inst) > 6 else "")
                return None, base, it, (
                    f"⚠️ You own multiple **{base}**. Specify one (e.g., `!charges set {inst[0]} 12/20`).\n{choices}"
                ), inst
            if len(inst) == 1:
                                               
                return inst[0], base, it, None, None

                                                                                          
            return base, base, it, None, None

        if arg:
            parts = arg.strip().split()

            if parts and parts[0].lower() == "set":
                                                           
                if len(parts) < 3:
                    await ctx.send("Usage: `!charges set <ItemName> <cur>[/<max>]`"); return

                                                                                     
                val_tok = parts[-1]
                item_text = " ".join(parts[1:-1]).strip()

                m = re.match(r"^\s*(\d+)(?:\s*/\s*(\d+))?\s*$", val_tok)
                if not m:
                    await ctx.send("Usage: `!charges set <ItemName> <cur>[/<max>]`"); return
                cur = int(m.group(1))
                mx  = int(m.group(2)) if m.group(2) else None

                token, base, it, err, _choices = _resolve_item_token(item_text)
                if err:
                    await ctx.send(err); return
                    
                self._migrate_legacy_charge_key(cfg, path, token, it)

                key = self._charges_key(token, it)
                                                                                            
                key = self._charges_key(token, it)
                if mx is None:
                    mx = self._charges_max_for_item(base, it)
                self._set_item_charges(cfg, path, key, cur, mx)
                await ctx.send(f"✅ **{token}** charges set to **{cur}/{mx}**.")
                return

            if parts and parts[0].lower() == "spend":
                                                      
                if len(parts) < 3:
                    await ctx.send("Usage: `!charges spend <ItemName> <cost>`"); return

                cost_tok = parts[-1]
                item_text = " ".join(parts[1:-1]).strip()
                try:
                    cost = int(cost_tok)
                except Exception:
                    await ctx.send("Usage: `!charges spend <ItemName> <cost>`"); return

                token, base, it, err, _choices = _resolve_item_token(item_text)
                if err:
                    await ctx.send(err); return
                self._migrate_legacy_charge_key(cfg, path, token, it)

                key = self._charges_key(token, it)
                key = self._charges_key(token, it)                                   
                default_max = self._charges_max_for_item(base, it)

                ok, left, msg = self._spend_item_charges(cfg, path, key, cost, default_max)
                if not ok:
                    await ctx.send(msg); return

                mx = self._get_item_charges(cfg, key, default_max)[1] or default_max
                await ctx.send(f"🔋 **{token}**: spent **{cost}** → **{left}/{mx}** left.")
                return

        names = [s for s in get_compat(cfg, "item", "storage", fallback="").split() if s]
        lines = []
        for nm in sorted(names, key=str.lower):
            base = nm.split("@", 1)[0]                             
            _c, it = self._item_lookup(base)
            if not self._item_has_charges(base, it):
                continue
            key = self._charges_key(nm, it)                                        
            cur, mx = self._get_item_charges(cfg, key, default_max=self._charges_max_for_item(base, it))
            if cur is None or mx is None:
                lines.append(f"• {nm}: *(unseeded; try `!charges set {nm} <cur>/<max>`)*")
            else:
                lines.append(f"• {nm}: **{cur}/{mx}**")
        await ctx.send("\n".join(lines) if lines else "(No charge-bearing items in your bag.)")


    @commands.command(name="drain")
    async def energy_drain(self, ctx, target: str = None, levels: str = "1"):
        if not target:
            await ctx.send("Usage: `!drain <name> [count]`"); return

        disp, path = _resolve_char_ci(target)
        pretty = disp or target
        if not path or not os.path.exists(path):
            await ctx.send(f"❌ Target **{pretty}** not found."); return

        try:
            n_levels = max(1, int(str(levels)))
        except Exception:
            n_levels = 1

        cfg = read_cfg(path)

        
        embed = nextcord.Embed(
            title=f"☠️ Energy Drain afflicts {pretty}",
            color=random.randint(0, 0xFFFFFF)
        )

        state = await self._auto_apply_negative_levels(
            ctx,
            pretty, cfg, path,
            n_levels=n_levels,
            source="Energy Drain (manual)",
            embed=embed
        )

        await ctx.send(embed=embed)


    @commands.group(name="hr", invoke_without_command=True)
    async def hr(self, ctx: commands.Context):
        await self.hr_list(ctx)


    @hr.command(name="list")
    async def hr_list(self, ctx: commands.Context):
        self._hr_migrate_once(ctx.channel)
        rows = []
        for k, info in self._hr_known().items():
            val = self._hr_enabled(ctx.channel, k, default=info["default"])
            rows.append(f"• **{k}**: {'ON ✅' if val else 'OFF ❌'} — {info['desc']}")
        footer = "\n\nUsage: `!hr on <rule>`, `!hr off <rule>`, `!hr preset <classic|house>`"
        await ctx.send("**House Rules (this channel)**\n" + "\n".join(rows) + footer)


    @hr.command(name="on")
    async def hr_on(self, ctx: commands.Context, key: str):
        key = key.strip().lower()
        if key not in self._hr_known():
            await ctx.send(f"Unknown rule `{key}`. Try `!hr list`.")
            return
        self._hr_set(ctx.channel, key, True)
        await ctx.send(f"✅ **{key}** enabled for this channel.")


    @hr.command(name="off")
    async def hr_off(self, ctx: commands.Context, key: str):
        key = key.strip().lower()
        if key not in self._hr_known():
            await ctx.send(f"Unknown rule `{key}`. Try `!hr list`.")
            return
        self._hr_set(ctx.channel, key, False)
        await ctx.send(f"✅ **{key}** disabled for this channel.")


    @hr.command(name="preset")
    async def hr_preset(self, ctx: commands.Context, name: str):
        """
        Presets:
          classic -> all OFF except vancian prep
          house   -> all ON  except vancian prep
        """
        name = (name or "").strip().lower()
        if name not in _PRESET_MAP:
            await ctx.send("Presets: `classic`, `house`")
            return

                                                                                        
        cfg = _load_battles()
        base = _section_id(ctx.channel)
        sec  = f"{base}:hr"
        if not cfg.has_section(sec):
            cfg.add_section(sec)

                                                  
        preset = _PRESET_MAP[name]
        base_val = "1" if preset["base"] else "0"
        for k in self._hr_known().keys():
            cfg.set(sec, k, base_val)

                            
        for k, v in (preset.get("overrides") or {}).items():
            if k in self._hr_known():
                cfg.set(sec, k, "1" if v else "0")

        _save_battles(cfg)
        await ctx.send(f"✅ Preset **{name}** applied. (`!hr list` to verify)")

                      

    @staticmethod
    def _is_living_cfg(t_cfg) -> bool:
        
        txt = " ".join(filter(None, [
            str(get_compat(t_cfg, "info","monster_type", fallback="")),
            str(get_compat(t_cfg, "stats","type",        fallback="")),
            str(get_compat(t_cfg, "base","type",         fallback="")),
            str(get_compat(t_cfg, "traits","tags",       fallback="")),
        ])).lower()
        toks = {t for t in re.split(r"[^a-z0-9]+", txt) if t}
        return not bool(toks & {
            "undead","golem","golems","construct","constructs",
            "ooze","oozes","elemental","elementals","plant","plants"
        })
        
        
    def monster_ab_for_hd(self, hd: int) -> int:
        if hd >= 33:
            return 16
        if hd in self.mon_ab:
            return self.mon_ab[hd]
                                                  
        lower = [k for k in self.mon_ab.keys() if k <= hd]
        if lower:
            return self.mon_ab[max(lower)]
        if self.mon_ab:
            return self.mon_ab[min(self.mon_ab.keys())]
        return 0


    def find_item(self, query: str):
        key = normalize_name(query)
        canon = self.item_index.get(key)
        if canon:
            return canon, self.items[canon]

                               
        close_norm = difflib.get_close_matches(key, self.item_index.keys(), n=5, cutoff=0.6)
        suggestions = []
        seen = set()
        for n in close_norm:
            c = self.item_index[n]
            if c not in seen:
                seen.add(c)
                suggestions.append(c)
        return None, suggestions


    def _item_lookup(self, name: str):
        """Return (canon_name, item_dict) or (None, None) from item.lst, case-insensitive."""
        key = normalize_name(name)
        canon = self.item_index.get(key)
        if not canon:
            return None, None
        return canon, self.items.get(canon, {})


    def _item_ac(self, item: dict) -> int | None:
        v = item.get("AC") if "AC" in item else item.get("ac")
        if v is None or str(v).strip() == "":
            return None
        try:
            return int(str(v).strip())
        except Exception:
            return None


    def _item_weight(self, item: dict) -> float:
        v = item.get("weight", 0)
        try:
            return float(str(v).strip())
        except Exception:
            return 0.0


    def _item_is_shield(self, item: dict) -> bool:
        flag = item.get("armor2") or item.get("ARMOR2")
        return str(flag).strip().lower() in {"$true", "true", "yes", "y", "1"}


    def _item_hands(self, item: dict) -> int:
        h = item.get("hands") or item.get("HANDS") or "1"
        try:
            return int(str(h).strip())
        except Exception:
            return 1


    def _get_char_race_class(self, cfg):
        race = (get_compat(cfg, "info", "race", fallback="Human") or "").strip().lower()
        cls  = (get_compat(cfg, "info", "class", fallback="Fighter") or "").strip().lower()
        return race, cls


    def _item_size(self, item: dict) -> str:
        return (item.get("size") or "").strip().lower()
        
        
    def _item_type(self, item: dict) -> str:
        return (item.get("type") or "").strip().lower()


    def _item_is_weapon(self, item: dict) -> bool:
                                                                 
        if self._item_is_shield(item):
            return False
        return "dmg" in {k.lower() for k in item.keys()}


    def _race_is_small(self, race: str) -> bool:
        """
        True if the race should use 'small' equipment/encumbrance rules.
        Halfling is always small. Otherwise, we check race.lst / self.races for 'Small' in skills.
        """
        

        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

        race_lc = (race or "").strip().lower()
        if not race_lc:
            return False

                                    
        if race_lc == "halfling":
            return True

                                                  
        try:
            if hasattr(self, "races") and self.races:
                rinfo = self.races.get(race_lc) or next(
                    (v for k, v in self.races.items() if _norm(k) == _norm(race_lc)), None
                )
                if isinstance(rinfo, dict):
                    if "small" in str(rinfo.get("skills", "")).lower():
                        return True
                                                             
                    for k, v in rinfo.items():
                        if "small" in str(k).lower() or "small" in str(v).lower():
                            return True
        except Exception:
            pass

                                         
        try:
            cp = getattr(self, "_race_cp", None)
            if cp is None:
                cp = configparser.ConfigParser()
                cp.optionxform = str
                cp.read("race.lst")
                self._race_cp = cp

                                   
            sec = None
            for s in cp.sections():
                if s.lower() == race_lc or _norm(s) == _norm(race_lc):
                    sec = s
                    break
            if sec:
                skills_line = cp.get(sec, "skills", fallback="")
                if "small" in skills_line.lower():
                    return True
                                                                 
                for opt in cp.options(sec):
                    if "small" in opt.lower():
                        val = cp.get(sec, opt, fallback="")
                        if "small" in val.lower() or val.lower() in {"1","true","yes","on",""}:
                            return True
        except Exception:
            pass

        return False


    def _effective_hands(self, item: dict, race_lc: str) -> int:
        """Small races: medium weapons count as two-handed; large forbidden."""
        base = self._item_hands(item)
        size = self._item_size(item)
        is_small = self._race_is_small(race_lc)

        if is_small:
            if size == "l":
                return 999                      
            if size == "m":
                return max(2, base)
        return base

        
    def _eq_get_weapons(self, cfg) -> list[str]:
        """Return equipped weapons in order (weapon1..weaponN), compacted."""
        names: list[str] = []
        try:
            cnt = getint_compat(cfg, "eq", "weapon", fallback=None)
        except Exception:
            cnt = None

        if cnt and cnt > 0:
            for i in range(1, cnt + 1):
                w = get_compat(cfg, "eq", f"weapon{i}", fallback="").strip()
                if w:
                    names.append(w)
        else:
                                 
            if cfg.has_section("eq"):
                pairs = []
                for k, v in cfg.items("eq"):
                    m = re.fullmatch(r"weapon(\d+)", k, flags=re.I)
                    if m and v.strip():
                        pairs.append((int(m.group(1)), v.strip()))
                names = [v for _, v in sorted(pairs)]

        return names


    def _eq_set_weapons(self, cfg, names: list[str]) -> None:
        """Write weapons back contiguously as weapon1..weaponN and set eq.weapon."""
        if not cfg.has_section("eq"):
            cfg.add_section("eq")

                                            
        max_idx = 0
        for k, _ in cfg.items("eq"):
            m = re.fullmatch(r"weapon(\d+)", k, flags=re.I)
            if m:
                max_idx = max(max_idx, int(m.group(1)))

                        
        for i, w in enumerate(names, start=1):
            cfg.set("eq", f"weapon{i}", w)

                         
        for j in range(len(names) + 1, max_idx + 1):
            if cfg.has_option("eq", f"weapon{j}"):
                cfg.remove_option("eq", f"weapon{j}")

        cfg.set("eq", "weapon", str(len(names)))


    def _eq_add_weapon(self, cfg, name: str) -> str:
        """Append weapon name to the next slot and return the slot used."""
        names = self._eq_get_weapons(cfg)
        names.append(name)
        self._eq_set_weapons(cfg, names)
        return f"weapon{len(names)}"


    def _eq_remove_weapon_by_slot(self, cfg, slot: str) -> str | None:
        """Remove e.g. 'weapon3' and compact; return removed name or None."""
        m = re.fullmatch(r"weapon(\d+)", slot.strip().lower())
        if not m:
            return None
        idx = int(m.group(1))
        names = self._eq_get_weapons(cfg)
        if 1 <= idx <= len(names):
            removed = names.pop(idx - 1)
            self._eq_set_weapons(cfg, names)
            return removed
        return None


    def _eq_remove_weapon_by_name(self, cfg, needle: str) -> str | None:
        """Remove first case-insensitive match by name and compact; return removed name or None."""
        names = self._eq_get_weapons(cfg)
        ln = needle.strip().lower()
        for i, w in enumerate(names):
            if w.strip().lower() == ln:
                removed = names.pop(i)
                self._eq_set_weapons(cfg, names)
                return removed
        return None

        
    def _eq_weapon_names_from_cfg(self, cfg) -> list[str]:
        return self._eq_get_weapons(cfg)
        
        
    def _dec_timer(cfg_b, chan_id: str, slot: str, key: str, remove_fields: tuple[str, ...] = ()):
        """Decrement <slot>.<key> by 1; if it hits 0, remove it and any extra fields given."""
        try:
            left = cfg_b.getint(chan_id, f"{slot}.{key}", fallback=0)
        except Exception:
            left = 0
        if left > 0:
            left -= 1
            if left <= 0:
                                           
                if cfg_b.has_option(chan_id, f"{slot}.{key}"):
                    cfg_b.remove_option(chan_id, f"{slot}.{key}")
                                          
                for k in remove_fields:
                    if cfg_b.has_option(chan_id, f"{slot}.{k}"):
                        cfg_b.remove_option(chan_id, f"{slot}.{k}")
            else:
                cfg_b.set(chan_id, f"{slot}.{key}", str(left))

        
    def _class_can_wear_armor(self, class_lc: str, armor_weight: float, is_shield: bool, channel=None) -> tuple[bool,str|None]:
        if class_lc == "magic-user":
            return False, "Magic-Users cannot wear armor or use shields."
        if class_lc == "thief":
            if is_shield:
                return False, "Thieves cannot use shields."
            if armor_weight is not None and armor_weight > 20:
                return False, "Thieves may only wear armor with weight ≤ 20."
        if class_lc == "scout":
            if is_shield:
                return False, "Scouts cannot use shields."
            if armor_weight is not None and armor_weight > 20:
                return False, "Scouts may only wear armor with weight ≤ 20."
        if class_lc == "assassin":
            if is_shield:
                return False, "Assassins cannot use shields."
            if armor_weight is not None and armor_weight > 20:
                return False, "Assassins may only wear armor with weight ≤ 20."                                
        if class_lc == "barbarian":
                                                                        
            hr_on = True
            try:
                if channel is not None:
                    hr_on = self._hr_enabled(channel, "barbarian_leather_only", default=True)
            except Exception:
                pass
            if hr_on and armor_weight is not None and armor_weight > 20:
                return False, "Barbarians may only wear armor with weight ≤ 20."    
        if class_lc == "ranger":
            if armor_weight is not None and armor_weight > 20:
                return False, "Rangers may only wear armor with weight ≤ 20."     
        if class_lc == "druid":
            if armor_weight is not None and armor_weight > 20:
                return False, "Druids may only wear armor with weight ≤ 20."                                  
                                          
        return True, None


    def _class_can_use_weapon(
        self,
        class_lc: str,
        canon_name: str,
        weap_type: str,
        *,
        race_lc: str | None = None
    ) -> tuple[bool, str | None]:
        nm = (canon_name or "").strip().lower()
        race_lc = (race_lc or "").strip().lower()

                                          
        if class_lc == "magic-user":
            if nm not in {"dagger", "club"}:
                return False, "Magic-Users may only wield Dagger or Club."
        if class_lc == "illusionist":
            if nm not in {"dagger", "club"}:
                return False, "Illusionists may only wield Dagger or Club."
        if class_lc == "necromancer":
            if nm not in {"dagger", "club"}:
                return False, "Necromancers may only wield Dagger or Club."
        if class_lc == "spellcrafter":
            if nm not in {"dagger", "club"}:
                return False, "Spellcrafters may only wield Dagger or Club."

                                       
        if class_lc == "druid":
            if nm in {"greatsword", "greataxe", "longbow", "heavyxbow", "lightxbow", "polearm", "maul"}:
                return False, "Banned weapon for Druid."

                                           
        if class_lc == "cleric":
            hob_extra = {"spear", "2hspear", "battleaxe", "longsword"}
            if race_lc == "hobgoblin" and nm in hob_extra:
                return True, None                              
            if weap_type != "bludgeoning":
                if race_lc == "hobgoblin":
                    return False, ("Clerics may only use bludgeoning weapons "
                                   "(Hobgoblin exception: Spear, 2HSpear, BattleAxe, Longsword).")
                return False, "Clerics may only use bludgeoning weapons."

                                
        return True, None


    def _race_can_use_weapon(self, race_lc: str, canon_name: str, item: dict) -> tuple[bool, str | None, int]:
        size = self._item_size(item)
        eff_h = self._effective_hands(item, race_lc)
        nm = canon_name.strip().lower()

                                                             
        if self._race_is_small(race_lc):
            if size == "l":
                return False, "Small races cannot wield Large weapons.", eff_h
                                                                          

        if race_lc == "dwarf":
            if nm in {"greatsword", "polearm", "longbow"}:
                return False, "Dwarves cannot wield Greatsword, Polearm, or Longbow.", eff_h

        return True, None, eff_h


    def _defender_ac_with_buffs(self, bcfg, chan_id: str, tgt_name: str, *, want_oil: bool, atk_type: str):
        """
        Return (ac, shield_bonus, ac_defense_applied, blind_def_pen, magearmor_bonus, boneskin_bonus)
        - Shield: treat OIL as missile (+6) per your rule; otherwise +6 vs missiles, +3 vs melee/thrown.
        - Mage Armor: +4 vs projectiles; +2 vs melee/thrown. Treat OIL as thrown here (so +2).
        - Boneskin: +4 always.
        - Blind on defender: −4 AC.
        - Defend/Parry: add both.
        """
                 
        t_cfg = read_cfg(_resolve_char_ci(tgt_name)[1])
        try:
            ac = int(self._gc(t_cfg, "ac") or 11)
        except Exception:
            ac = 11

                      
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")

                      
        acbuf = bcfg.getint(chan_id, f"{slot}.acbuf", fallback=0)
        parry = bcfg.getint(chan_id, f"{slot}.parry", fallback=0)
        ac_def = acbuf + parry
        ac += ac_def

                           
        blind_def_pen = 0
        if bcfg.getint(chan_id, f"{slot}.blind", fallback=0) > 0:
            ac -= 4
            blind_def_pen = 4

                                                          
        try:
            if bcfg.getint(chan_id, f"{slot}.sick", fallback=0) > 0:
                ac -= 2
        except Exception:
            pass

                
        shield_bonus = 0
        sh_left = bcfg.getint(chan_id, f"{slot}.shield", fallback=0)
        if sh_left > 0:
            is_missileish = (atk_type in {"missile","ranged","bow","xbow","projectile","sling","thrown"})
            if want_oil:                                                   
                shield_bonus = 6
            else:
                shield_bonus = 6 if is_missileish and atk_type not in {"melee"} else 3
            ac += shield_bonus

                                          
        ma_bonus = 0
        bs_bonus = 0

        ma_left = bcfg.getint(chan_id, f"{slot}.magearmor", fallback=0)

                                                                    
        bones_left = max(
            bcfg.getint(chan_id, f"{slot}.boneskin",   fallback=0),
            bcfg.getint(chan_id, f"{slot}.x_boneskin", fallback=0),                         
        )
        bark_left = max(
            bcfg.getint(chan_id, f"{slot}.barkskin",   fallback=0),
            bcfg.getint(chan_id, f"{slot}.x_barkskin", fallback=0),
        )

                                                                                             
        bs_source = None
        if bark_left > 0:
            bs_bonus = 4
            bs_source = "Barkskin"
        elif bones_left > 0:
            bs_bonus = 4
            bs_source = "Boneskin"

        if ma_left > 0:
            is_projectile = atk_type in {"missile","ranged","bow","xbow","projectile","sling"}
            is_thrown     = want_oil or atk_type in {"thrown"}
            ma_bonus = 4 if is_projectile else 2 if (is_thrown or atk_type in {"melee",""}) else 2
            ac += ma_bonus

        if bs_bonus:
            ac += bs_bonus

                                                        
                           
        try:
            tree_left = max(
                bcfg.getint(chan_id, f"{slot}.tree",    fallback=0),
                bcfg.getint(chan_id, f"{slot}.x_tree",  fallback=0),
            )
            if tree_left > 0:
                ac += 10
                try:
                    notes.append("Tree Form: +10 AC")
                except NameError:
                    pass
        except Exception:
            pass

                                                               
        try:
            enh_left = max(
                bcfg.getint(chan_id, f"{slot}.enharmor",       fallback=0),
                bcfg.getint(chan_id, f"{slot}.x_enhancearmor", fallback=0),
            )
            weak_left = max(
                bcfg.getint(chan_id, f"{slot}.weakarmor",      fallback=0),
                bcfg.getint(chan_id, f"{slot}.x_weakenarmor",  fallback=0),
            )
            if enh_left > 0:
                enh_mag = max(1, bcfg.getint(chan_id, f"{slot}.enharmor_bonus", fallback=1))
                ac += enh_mag
            if weak_left > 0:
                ac -= 1
        except Exception:
            pass


                                                                   
        try:
            goa_left = max(
                bcfg.getint(chan_id, f"{slot}.x_growanimal",      fallback=0),
                bcfg.getint(chan_id, f"{slot}.growanimal",        fallback=0),          
                bcfg.getint(chan_id, f"{slot}.x_growthanimals",   fallback=0),          
                bcfg.getint(chan_id, f"{slot}.x_growthofanimals", fallback=0),          
                bcfg.getint(chan_id, f"{slot}.growthanimals",     fallback=0),          
                bcfg.getint(chan_id, f"{slot}.growthofanimals",   fallback=0),          
                bcfg.getint(chan_id, f"{slot}.goa",               fallback=0),          
            )
            if goa_left > 0:
                bump = max(1, bcfg.getint(chan_id, f"{slot}.growanimal_ac_bonus", fallback=2))
                ac += bump
                try:
                    notes.append(f"Growth of Animals: +{bump} AC")
                except NameError:
                    pass
        except Exception:
            pass


        return ac, shield_bonus, ac_def, blind_def_pen, ma_bonus, bs_bonus

    
    def _eq_get_carry(self, cfg) -> list[str]:
        """Return carried items in order (carry1..carryN)."""
        names: list[str] = []
        try:
            cnt = getint_compat(cfg, "eq", "carry", fallback=None)
        except Exception:
            cnt = None

        if cnt and cnt > 0:
            for i in range(1, cnt + 1):
                v = get_compat(cfg, "eq", f"carry{i}", fallback="").strip()
                if v:
                    names.append(v)
        else:
            if cfg.has_section("eq"):
                pairs = []
                for k, v in cfg.items("eq"):
                    m = re.fullmatch(r"carry(\d+)", k, flags=re.I)
                    if m and v.strip():
                        pairs.append((int(m.group(1)), v.strip()))
                names = [v for _, v in sorted(pairs)]
        return names


    def _eq_set_carry(self, cfg, names: list[str]) -> None:
        """Write carried items contiguously as carry1..carryN and set eq.carry."""
        if not cfg.has_section("eq"):
            cfg.add_section("eq")

        max_idx = 0
        for k, _ in cfg.items("eq"):
            m = re.fullmatch(r"carry(\d+)", k, flags=re.I)
            if m:
                max_idx = max(max_idx, int(m.group(1)))

        for i, name in enumerate(names, start=1):
            cfg.set("eq", f"carry{i}", name)

        for j in range(len(names) + 1, max_idx + 1):
            if cfg.has_option("eq", f"carry{j}"):
                cfg.remove_option("eq", f"carry{j}")

        cfg.set("eq", "carry", str(len(names)))


    def _eq_add_carry(self, cfg, name: str) -> str:
        names = self._eq_get_carry(cfg)
        names.append(name)
        self._eq_set_carry(cfg, names)
        return f"carry{len(names)}"


    def _eq_remove_carry_by_slot(self, cfg, slot: str) -> str | None:
        m = re.fullmatch(r"carry(\d+)", slot.strip().lower())
        if not m:
            return None
        idx = int(m.group(1))
        names = self._eq_get_carry(cfg)
        if 1 <= idx <= len(names):
            removed = names.pop(idx - 1)
            self._eq_set_carry(cfg, names)
            return removed
        return None


    def _dedupe_from_carry(self, cfg, name_lc: str):
        """Remove any carry entries that match name_lc (case-insensitive) and compact."""
        if not cfg.has_section("eq"):
            return
        carried = []
        for opt, val in cfg.items("eq"):
            if opt.startswith("carry") and not opt.endswith("_qty"):
                nm = (val or "").strip()
                try:
                    idx = int(opt.replace("carry", ""))
                except Exception:
                    continue
                qkey = f"{opt}_qty"
                try:
                    qty = int(cfg.get("eq", qkey, fallback="1"))
                except Exception:
                    qty = 1
                carried.append((idx, nm, qty))
                            
        kept = [(i, nm, q) for (i, nm, q) in carried if nm.strip().lower() != name_lc]
                             
        to_del = [opt for opt, _ in cfg.items("eq") if opt.startswith("carry")]
        for opt in to_del:
            cfg.remove_option("eq", opt)
                                    
        for i, (_old_i, nm, q) in enumerate(kept, start=1):
            cfg.set("eq", f"carry{i}", nm)
            cfg.set("eq", f"carry{i}_qty", str(max(1, int(q))))


    def _eq_remove_carry_by_name(self, cfg, needle: str) -> str | None:
        names = self._eq_get_carry(cfg)
        ln = needle.strip().lower()
        for i, v in enumerate(names):
            if v.strip().lower() == ln:
                removed = names.pop(i)
                self._eq_set_carry(cfg, names)
                return removed
        return None
    

    def _has_weaponspec(self, cfg) -> bool:
        """Fighters always qualify; otherwise require 'weaponspec' in [skills] list."""
        cls = (get_compat(cfg, "info", "class", fallback="") or "").strip().lower()
        if cls == "fighter":
            return True
        skills_line = (get_compat(cfg, "skills", "list", fallback="") or "").lower()
        tokens = {t for t in re.split(r"[,\s]+", skills_line) if t}
        return any(t in {"weaponspec", "weapon_spec", "weapon-specialization", "weaponspecialization"} for t in tokens)


    def _get_spec_weapon(self, cfg) -> str:
        """Canonical name stored in [feat].weaponspec (if any)."""
        return (get_compat(cfg, "feat", "weaponspec", fallback="") or "").strip()


    def _set_spec_weapon(self, cfg, canon_name: str) -> None:
        if not cfg.has_section("feat"):
            cfg.add_section("feat")
        cfg.set("feat", "weaponspec", canon_name)


    def _spec_mods_for_level(self, level: int) -> tuple[int, int, int]:
        """
        Return (to_hit_bonus, damage_bonus, attacks_allowed) for levels 1..20.
          L1-3:  +1/+0   (1 attack)
          L4-6:  +1/+1   (1 attack)
          L7-9:  +2/+1   (1 attack)
          L10-12:+2/+2   (2 attacks)
          L13-15:+3/+2   (2 attacks)
          L16-18:+3/+3   (2 attacks)
          L19-20:+4/+3   (3 attacks)
        """
        L = max(1, min(int(level or 1), 20))
        hit_tab = [0, 1,1,1, 1,1,1, 2,2,2, 2,2,2, 3,3,3, 3,3,3, 4,4]                
        dmg_tab = [0, 0,0,0, 1,1,1, 1,1,1, 2,2,2, 2,2,2, 3,3,3, 3,3]
        atk_tab = [0, 1,1,1, 1,1,1, 1,1,1, 2,2,2, 2,2,2, 2,2,2, 3,3]
        return hit_tab[L], dmg_tab[L], atk_tab[L]


    def _consume_inventory_item(self, cfg, path, canon_name: str, qty: int = 1) -> tuple[bool, int | None]:
        """
        Try to consume `qty` of canon_name from [item] inventory counts.
        Returns (ok, remaining_count or None if unknown).
        - If a numeric count exists (item.<lowername>=N), decrement it (floor at 0).
        - If no numeric count but present in storage list, treat as 1→0 and keep storage as-is.
        """
        if not cfg.has_section("item"):
            return False, None

        key = canon_name.lower()
                        
        raw = cfg.get("item", key, fallback=None)
        if raw is not None:
            try:
                cur = int(str(raw).strip())
            except Exception:
                cur = 1
            if cur <= 0:
                return False, max(0, cur)
            newv = max(0, cur - qty)
            cfg.set("item", key, str(newv))
                                                                                          
            if newv == 0:
                try:
                    removed = self._eq_remove_carry_by_name(cfg, canon_name)
                    if removed:
                                                      
                        pass
                except Exception:
                    pass
            write_cfg(path, cfg)
            return True, newv

                                                                              
        storage = cfg.get("item", "storage", fallback="")
        names = {s.strip().lower() for s in storage.split() if s.strip()}
        if key in names:
                                    
            cfg.set("item", key, "0")
            try:
                removed = self._eq_remove_carry_by_name(cfg, canon_name)
                if removed:
                    pass
            except Exception:
                pass
            write_cfg(path, cfg)
            return True, 0

        return False, None


    def _recompute_eq_weight(self, cfg) -> float:
        names = []
        try:
            if cfg.has_option("eq", "armor1"):
                names.append(cfg.get("eq", "armor1").strip())
        except Exception:
            pass
        try:
            if cfg.has_option("eq", "armor2"):
                names.append(cfg.get("eq", "armor2").strip())
        except Exception:
            pass

        names += self._eq_weapon_names_from_cfg(cfg)

        total = 0.0

                  
        for n in names:
            canon, item = self._item_lookup(n)                    
            if item:
                total += float(self._item_weight(item) or 0.0)    

                                       
        try:
            if cfg.has_section("eq"):
                carry_slots = []
                for opt, val in cfg.items("eq"):
                    if opt.startswith("carry") and not opt.endswith("_qty"):
                        try:
                            idx = int(opt.replace("carry", ""))
                            carry_slots.append((idx, opt, (val or "").strip()))
                        except Exception:
                            pass
                carry_slots.sort(key=lambda t: t[0])

                for _idx, slot_key, canon in carry_slots:
                    if not canon:
                        continue
                    _, it = self._item_lookup(canon)              
                    if not it:
                        continue

                    each = float(self._item_weight(it) or 0.0)    
                                                        
                    try:
                        qty = int(cfg.get("eq", f"{slot_key}_qty", fallback="1"))
                    except Exception:
                        qty = 1
                    qty = max(1, qty)

                    total += each * qty
        except Exception:
            pass

        total += self._misc_slots_weight(cfg)
        
        if not cfg.has_section("stats"):
            cfg.add_section("stats")
        cfg.set("stats", "eq_weight", str(round(total, 2)))

        if not cfg.has_section("eq"):
            cfg.add_section("eq")
        cfg.set("eq", "weight", str(total))                             


        return total
        
    
    def _item_lookup(self, name: str):
        """Return (canon_name, item_dict) or (None, None) from item.lst, case-insensitive."""
        key = normalize_name(name)
        canon = self.item_index.get(key)
        if not canon:
            return None, None
        return canon, self.items.get(canon, {})


    def _item_ac(self, item: dict) -> int | None:
        v = item.get("AC") if "AC" in item else item.get("ac")
        if v is None or str(v).strip() == "":
            return None
        try:
            return int(str(v).strip())
        except Exception:
            return None


    def _item_weight(self, item: dict) -> float:
        """Return the item weight as a float. Accepts 'weight', 'wt', or 'w'."""
        for k in ("weight", "wt", "w"):
            if k in item:
                try:
                    return float(str(item[k]).strip())
                except Exception:
                    pass
        return 0.0    


    def _barbarian_unarmored_ac(self, level: int) -> int:
                                                          
        if level <= 1: return 12
        if level == 2: return 13
        if level == 3: return 14
        if level == 4: return 16
        if level == 5: return 17
        if level == 6: return 18
        return 20


    def _recompute_ac(self, cfg, channel=None) -> int:
        a1 = get_compat(cfg, "eq", "armor1", fallback="").strip()
        a2 = get_compat(cfg, "eq", "armor2", fallback="").strip()

        armor1_ac = None
        if a1:
            _c1, it1 = self._item_lookup(a1)
            try:
                armor1_ac = int((it1.get("AC") or it1.get("ac") or "").strip())
            except Exception:
                armor1_ac = None

        shield_bonus = 0
        if a2:
            _c2, it2 = self._item_lookup(a2)
            if it2 and self._item_is_shield(it2):
                try:
                    shield_bonus = int((it2.get("AC") or it2.get("ac") or "").strip() or "0")
                except Exception:
                    shield_bonus = 0

        _race_lc, class_lc = self._get_char_race_class(cfg)
        level = getint_compat(cfg, "cur", "level", fallback=1)

        use_uar = True
        try:
            if channel is not None:
                use_uar = self._hr_enabled(channel, "barbarian_unarmored_defense", default=True)
        except Exception:
            pass

        if class_lc == "barbarian" and not a1 and use_uar:
            base_ac = self._barbarian_unarmored_ac(level)                          
        else:
            base_ac = armor1_ac if armor1_ac is not None else 10

        new_ac = base_ac + shield_bonus
        try:
            new_ac += max(0, int(_equipped_protection_bonus(cfg)))
        except Exception:
            pass
        if not cfg.has_section("stats"):
            cfg.add_section("stats")
        cfg.set("stats", "ac", str(new_ac))
        return new_ac


    def _safe_float(self, v, default=0.0):
        try:
            return float(v)
        except Exception:
            return default


    def _eq_weight_cached(self, cfg) -> float:
                                                                               
        w = get_compat(cfg, "eq", "weight", fallback="0")
        return self._safe_float(w, 0.0)


    def _coin_weight_from_cfg(self, cfg) -> float:
        """Each coin weighs 0.02 lb."""
        pp = getint_compat(cfg, "cur", "pp", fallback=0)
        gp = getint_compat(cfg, "cur", "gp", fallback=0)
        ep = getint_compat(cfg, "cur", "ep", fallback=0)
        sp = getint_compat(cfg, "cur", "sp", fallback=0)
        cp = getint_compat(cfg, "cur", "cp", fallback=0)
        return (pp + gp + ep + sp + cp) * 0.02


    def _weights_snapshot(self, cfg):
        """
        Returns (eq_weight, coin_weight, total_weight),
        where total = equipped + coins.
        """
        eq_w   = self._eq_weight_cached(cfg)
        coin_w = self._coin_weight_from_cfg(cfg)
        return (eq_w, coin_w, eq_w + coin_w)


    def _fmt_num(self, value, places=1):
                                                                  
        from decimal import Decimal, ROUND_HALF_UP
        q = Decimal('1').scaleb(-places)
        d = Decimal(str(value)).quantize(q, rounding=ROUND_HALF_UP)
        s = format(d, 'f')
        if '.' in s:
            s = s.rstrip('0').rstrip('.')
        return s


    def _fmt_w(self, v) -> str:
        return self._fmt_num(v, 1)


    def _fmt_coin_w(self, v) -> str:
        return self._fmt_num(v, 1)


    def _gc(self, cfg, key: str) -> str:
        """Read a monster value from either [stats] or [base]."""
        return (
            (get_compat(cfg, "stats", key, fallback="") or "") or
            (get_compat(cfg, "base",  key, fallback="") or "")
        )


    def _is_elf_pure(self, cfg) -> bool:
        """True only for race exactly 'Elf' (half-elves are NOT immune)."""
        r = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()
        return r == "elf"


    def _monster_has_ghoul_paralysis(self, atk_cfg, atk_name: str | None, chosen_attack: str | None) -> bool:
        """
        True only for ghoul/ghast-style paralysis (the one with elf immunity and 2d8 turns):
          • Monster looks like a ghoul/ghast AND attack is claw/bite, OR
          • The per-attack effect mentions paralysis AND the creature is undead AND the attack is claw/bite, OR
          • An explicit flag requests ghoul-style handling: ghoulparalysis / ghastparalysis / elfimmuneparalysis.
        NOTE: Plain 'paralysis' in the *damage string* is NOT used here (that’s the generic rider).
        """
        
        ca = re.sub(r"[^\w]+", "", (chosen_attack or "")).strip().lower()
        if not ca:
            return False

                                                                        
        blob = " ".join([
            (self._gc(atk_cfg, "monster_type") or ""),
            (self._gc(atk_cfg, "type") or ""),
            (self._gc(atk_cfg, "race") or ""),
            (self._gc(atk_cfg, "name") or ""),
            (atk_name or ""),
        ]).lower()

        is_ghoulish = ("ghoul" in blob) or ("ghast" in blob)
        is_undead  = ("undead" in blob)

                                                              
        eff_txt = " ".join(filter(None, [
            self._gc(atk_cfg, f"effect_{ca}"),
            self._gc(atk_cfg, f"{ca}_effect"),
            self._gc(atk_cfg, f"special_{ca}"),
            self._gc(atk_cfg, "special"),
            self._gc(atk_cfg, "effect"),
        ])).strip().lower()

        explicit_flag = any(tok in eff_txt for tok in ("ghoulparalysis", "ghastparalysis", "elfimmuneparalysis"))
        has_paraly_effect = ("paraly" in eff_txt)                                           

        natural_ok = ca in {"claw", "bite"}

                                                                                                
        if explicit_flag:
            return True
        if is_ghoulish and natural_ok:
            return True
        if is_undead and natural_ok and has_paraly_effect:
            return True
        return False


    def _sv_label(self, tag: str) -> str:
        return "Paralyze" if tag == "para" else ("Petrify" if tag == "pet" else "Spells")


    def _best_save_vs_paralysis(self, t_cfg):
        """
        Prefer Save vs Paralyze; fall back to Petrify; last resort Spells.
        Returns: (ok, roll, dc, tag)
        If all DCs are missing, returns (False, None, None, 'para') for consistent 'auto-fail' behavior
        when callers want that.
        """
        for tag in ("para", "pet"):
            ok, roll, dc, _ = self._roll_save(t_cfg, vs=tag, penalty=0)
            if dc is not None:
                return ok, roll, dc, tag
        ok, roll, dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
        if dc is not None:
            return ok, roll, dc, "spell"
        return False, None, None, "para"


    def _roll_paralysis_turns(self, expr: str, default_turns: int = 1) -> tuple[int, list[int]]:
        """
        Accepts plain integer ("3") or dice ("1d4", "2d6+1"). Returns (turns, roll_list).
        """
        
        expr = (str(expr or "")).strip().lower()
        if re.search(r"\d+d\d+", expr):
            s, rolls, flat = roll_dice(expr)
            return max(0, s + flat), rolls
        try:
            return max(0, int(expr)), []
        except Exception:
            return max(0, default_turns), []


    def _extend_paralyzed_timer(self, bcfg, chan_id: str, tgt_name: str, rounds: int) -> None:
        """
        Writes/extends the battle timer for 'paralyzed' on target.
        """
        try:
            names_tmp, _ = _parse_combatants(bcfg, chan_id)
            key_disp = _find_ci_name(names_tmp, tgt_name) or tgt_name
            try:
                slot_tgt = _slot(key_disp)
            except Exception:
                slot_tgt = key_disp.replace(" ", "_")
            cur_left = bcfg.getint(chan_id, f"{slot_tgt}.paralyzed", fallback=0)
            bcfg.set(chan_id, f"{slot_tgt}.paralyzed", str(max(cur_left, max(0, rounds))))
            _save_battles(bcfg)
        except Exception:
                                                                                           
            pass


    async def _apply_start_of_turn_paralysis(self, ctx, bcfg, chan_id, who_name: str, who_path: str) -> bool:
        """Tick down paralysis (stored as rounds) and skip turn if still paralyzed."""
        try:
            slot = _slot(who_name)
        except Exception:
            slot = (who_name or "").replace(" ", "_")
        key = f"{slot}.paralyzed"
        left = bcfg.getint(chan_id, key, fallback=0)

        if left > 0:
            left -= 1
            if left <= 0:
                if bcfg.has_option(chan_id, key):
                    bcfg.remove_option(chan_id, key)
                _save_battles(bcfg)
                await ctx.send(f"✅ **{who_name}** shakes off paralysis and can act again.")
                return False
            else:
                bcfg.set(chan_id, key, str(left))
                _save_battles(bcfg)
                await ctx.send(f"⛓️ **{who_name}** is paralyzed (**{left}** rounds remaining) and loses their action.")
                                    
                try:
                    ents = _sorted_entries(bcfg, chan_id)
                    names = [e["name"] for e in ents]
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur in names:
                        nxt = names[(names.index(cur) + 1) % len(names)]
                        bcfg.set(chan_id, "turn", nxt); _save_battles(bcfg)
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass
                return True
        return False


    def _get_save_target(self, t_cfg, vs: str = "para") -> int:
        """
        1) If the target file defines a save number explicitly (e.g., [saves].spell),
           use it.
        2) Otherwise honor `saveas = <Class> <Level>` or NM (Normal Man).
        3) Otherwise fall back to Fighter 1 defaults.
        """
        v = _canon_vs(vs)

                                                                        
        keys = [f"sv_{v}", f"save_{v}", v]
        if v == "para": keys += ["paralyze", "paralysis"]
        for sec in ("stats","saves"):
            for k in keys:
                try:
                    raw = get_compat(t_cfg, sec, k, fallback=None)
                except Exception:
                    raw = None
                if raw is None: 
                    continue
                s = str(raw).strip()
                if not s: 
                    continue
                try:
                    return int(s)
                except Exception:
                    pass

                                          
        saveas = _get_saveas_from_cfg(t_cfg)
        if saveas:
            cls, lvl = _parse_saveas(saveas)
            return _class_save_target(cls, lvl, v)

                               
        return _DEFAULT_F1.get(v, 14)

        
    def _roll_save(self, t_cfg, vs: str = "para", penalty: int = 0):
        """
        Return (success, roll_display, target, penalty_applied).

        - 'penalty' makes the save harder (subtracted from the roll).
        - Any equipped *Protection* item (ring/cloak/belt/pendant) adds +N to the roll.
        - 'roll_display' includes the protection bonus (but not the penalty),
          so callers that print "X vs DC" show the visible bonus.
        """

        target = self._get_save_target(t_cfg, vs)

        
        try:
            status_pen = (
                self._status_save_penalty_from_cfg(t_cfg) +
                self._status_save_penalty_from_battle(t_cfg)
            )
        except Exception:
            status_pen = 0

        eff_penalty = max(0, (penalty or 0) + status_pen)

        
        try:
            prot = max(0, int(_equipped_protection_bonus(t_cfg)))
        except Exception:
            prot = 0

        d20 = random.randint(1, 20)

        
        effective = d20 + prot - eff_penalty

        if target is None or str(target).strip() == "":
            return False, d20, None, eff_penalty

        success = (effective >= int(target))

        
        roll_display = d20 + prot
        return success, roll_display, int(target), eff_penalty



    def _weight_thresholds(self, race: str, STR: int) -> tuple[int, int]:
        """Return (light_limit, heavy_limit) by race&STR. Small races use the 'small' column."""
        s = max(3, min(int(STR or 10), 18))
        small = self._race_is_small(race)                                

                                                                                                   
        if s == 3:        med = (25, 60);  sml = (20, 40)
        elif s in (4, 5): med = (35, 90);  sml = (30, 60)
        elif 6 <= s <= 8: med = (50, 120); sml = (40, 80)
        elif 9 <= s <=12: med = (60, 150); sml = (50, 100)
        elif 13<= s <=15: med = (65, 165); sml = (55, 110)
        elif s in (16,17):med = (70, 180); sml = (60, 120)
        else:             med = (80, 195); sml = (65, 130)

        return sml if small else med


    def _armor_row_speeds(self, armor_name: str, armor_item: dict) -> tuple[int, int]:
        """
        Return (lightly_loaded_speed, heavily_loaded_speed) by armor category:
          - none or magic leather: (40, 30)
          - leather or magic metal: (30, 20)
          - metal: (20, 10)
        crude detection: name contains 'leather' => leather; 'mail'/'plate' => metal.
        'Magic ' prefix or item.magic truthy => magic.
        """
        name = (armor_name or "").lower()
        magic = name.startswith("magic ") or str((armor_item or {}).get("magic", "")).lower() in {"$true","true","1","yes","y"}

        if not armor_name:            
            return (40, 30)

        is_leather = "leather" in name
        is_metal   = any(w in name for w in ("mail", "plate", "metal"))

        if is_leather and magic:
            return (40, 30)
        if is_leather:
            return (30, 20)
        if is_metal and magic:
            return (30, 20)
        if is_metal:
            return (20, 10)
                                             
        return (30, 20)


    def _recompute_move(self, cfg) -> int:
        """Set stats.move based on armor row + load (eq_weight vs thresholds).
           Under light threshold → +10 bonus. Barbarians get +5."""
                            
        STR = getint_compat(cfg, "stats", "str", fallback=10)
        race_lc, class_lc = self._get_char_race_class(cfg)                           

                    
        light_lim, heavy_lim = self._weight_thresholds(race_lc, STR)

                               
        armor1 = ""
        armor1_item = None
        try:
            if cfg.has_option("eq", "armor1"):
                armor1 = cfg.get("eq", "armor1").strip()
                if armor1:
                    _c, armor1_item = self._item_lookup(armor1)
        except Exception:
            pass
        light_spd, heavy_spd = self._armor_row_speeds(armor1, armor1_item)

                         
        try:
            gear_w = float(str(get_compat(cfg, "stats", "eq_weight", fallback="")).strip() or "0")
        except Exception:
            gear_w = self._recompute_eq_weight(cfg)

        total_w = gear_w + self._coin_weight_from_cfg(cfg)                       

                                                      
        if total_w <= light_lim:
            mv = light_spd + 10
        elif total_w <= heavy_lim:
            mv = light_spd
        else:
            mv = heavy_spd

                                   
        if class_lc == "barbarian":
            mv += 5

        if not cfg.has_section("stats"):
            cfg.add_section("stats")
        cfg.set("stats", "move", str(mv))
        return mv


    def _tick_counter(bcfg, chan_id: str, slot: str, key: str):
        try:
            left = bcfg.getint(chan_id, f"{slot}.{key}", fallback=0)
        except Exception:
            left = 0
        if left > 0:
            left -= 1
            if left <= 0:
                if bcfg.has_option(chan_id, f"{slot}.{key}"):
                    bcfg.remove_option(chan_id, f"{slot}.{key}")
            else:
                bcfg.set(chan_id, f"{slot}.{key}", str(left))


    def _mi_consume_if_present(self, ctx, target_display: str) -> tuple[bool, int]:
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if not bcfg.has_section(chan_id):
                return (False, 0)
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, target_display) or target_display
            if key not in names:
                return (False, 0)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
            imgs_key = f"{slot}.mi_images"
            imgs = bcfg.getint(chan_id, imgs_key, fallback=0)
            if imgs <= 0:
                return (False, 0)
            imgs -= 1
            bcfg.set(chan_id, imgs_key, str(imgs))
            _save_battles(bcfg)
            return (True, imgs)
        except Exception:
            return (False, 0)


    def _misc_slots_weight(self, cfg) -> float:
        total = 0.0
        for slot in ("hands", "belt"):
            nm = (get_compat(cfg, "eq", slot, fallback="") or "").strip()
            if not nm:
                continue
            _c, it = self._item_lookup(nm)
            if it:
                total += float(self._item_weight(it) or 0.0)
        return total


    async def _apply_start_of_turn_oil(self, ctx, cfg_b, chan_id: str, actor_name: str, actor_path: str):
        burns = _take_oil_burn(cfg_b, chan_id, actor_name)
        if burns <= 0:
            return

        t_cfg = read_cfg(actor_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        total = 0
        lines = []
        for _ in range(burns):
            s, rolls, flat = roll_dice("1d8")
            raw = s + flat
            final, note = _apply_mitigation(raw, weapon_name="Oil (ongoing)", weapon_type="fire", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=actor_name)
            total += final
            line = f"1d8 [{', '.join(str(r) for r in rolls)}] → {raw}"
            if note:
                line += f" → **{final}** ({note})"
            else:
                line += f" → **{final}**"
            lines.append(line)

        new_hp = max(0, old_hp - total)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(actor_path, t_cfg)

                       
        embed = nextcord.Embed(
            title=f"🔥 Ongoing Oil burns {actor_name} at start of turn!",
            color=random.randint(0, 0xFFFFFF)
        )
        embed.add_field(name="Burns", value="\n".join(lines), inline=False)
        embed.add_field(name="HP", value=f"{old_hp} → **{new_hp}**", inline=False)
        await ctx.send(embed=embed)

                                                                                        
        if new_hp <= 0 and _is_monster_file(actor_path):
            try:
                names, scores = _parse_combatants(cfg_b, chan_id)
                key = _find_ci_name(names, actor_name) or actor_name
                if key in names:
                    names = [n for n in names if n != key]
                    if cfg_b.has_option(chan_id, key):
                        cfg_b.remove_option(chan_id, key)
                    slot = _slot(key)
                    for suf in (".dex", ".join", ".disp", ".oil", ".acpen"):
                        opt = f"{slot}{suf}"
                        if cfg_b.has_option(chan_id, opt):
                            cfg_b.remove_option(chan_id, opt)
                    _write_combatants(cfg_b, chan_id, names, scores)
                    if cfg_b.get(chan_id, "turn", fallback="") == key:
                        ents = _sorted_entries(cfg_b, chan_id)
                        cfg_b.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(cfg_b)
                    try:
                        msg_id = cfg_b.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(cfg_b, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(actor_path))
            except Exception:
                pass


    async def _apply_start_of_turn_web(self, ctx, bcfg, chan_id: str, who_name: str, who_path: str) -> bool:
        spells = self.bot.get_cog("SpellsCog") or self.bot.get_cog("Spells")
        if not spells or not hasattr(spells, "_apply_start_of_turn_web"):
            return False
        return await spells._apply_start_of_turn_web(ctx, bcfg, chan_id, who_name, who_path)

    
    def _weaponspec_enabled_for(self, cfg) -> bool:
                                               
        return getint_compat(cfg, "stats", "weaponspec_enabled", fallback=1) != 0


    def _set_weaponspec_enabled(self, cfg, enabled: bool):
        if not cfg.has_section("stats"):
            cfg.add_section("stats")
        cfg.set("stats", "weaponspec_enabled", "1" if enabled else "0")
    
    
    def _is_halfling_missile_weapon(self, canon_name: str, item: dict) -> bool:
        """
        True for sling / shortbow / longbow / light crossbow / heavy crossbow.
        Uses both normalized name and a loose type check fallback.
        """
        n = normalize_name(canon_name)
        by_name = n in {
            "sling", "shortbow", "longbow",
            "lightxbow", "heavyxbow",
            "lightcrossbow", "heavycrossbow"
        }
        t = (item.get("type", "") or "").lower()
        by_type = any(k in t for k in ("bow", "xbow", "crossbow", "sling"))
        return by_name or by_type

         
    def _virtual_weapon_for(self, race_lc: str, weapon: str, cfg=None):
        if not weapon:
            return None
        w = (weapon or "").strip().lower()
        alias = {"claws":"claw","talon":"claw","talons":"claw"}
        w = alias.get(w, w)

                                                                
        try:
            if cfg and _poly_active(cfg) and cfg.has_section("poly"):
                for key in (w, f"nat_{w}", f"natural_{w}"):
                    dmg = (get_compat(cfg, "poly", key, fallback="") or "").strip()
                    if dmg:
                        return (w.capitalize(), {"dmg": dmg.strip(), "type": "natural", "stat": "str", "plus": 0})
                                                                            
                raw = (get_compat(cfg, "poly", "attacks", fallback="") or "").strip()
                if raw:
                    for p in raw.split(","):
                        k, _, v = p.partition(":")
                        if k.strip().lower() == w and v.strip():
                            return (w.capitalize(), {"dmg": v.strip(), "type": "natural", "stat": "str", "plus": 0})
        except Exception:
            pass

                                                                                
        try:
            if cfg and _poly_active(cfg):
                form = (get_compat(cfg, "poly", "form", fallback="") or "").strip()
                if form and "_load_monster_form" in globals():
                    _disp, mcfg = _load_monster_form(form)
                    if mcfg:
                        nat = self._monster_naturals(mcfg)
                        dmg = nat.get(w)
                        if dmg:
                            return (w.capitalize(), {"dmg": dmg, "type": "natural", "stat": "str", "plus": 0})
        except Exception:
            pass

                                                                           
        return None


    def _pc_natural_attack_for(self, cfg, wkey: str):
                                                                         
        keys = [f"atk_{wkey}", f"dmg_{wkey}", wkey]
        spec = ""
        for sec in ("stats", "info"):
            for k in keys:
                v = get_compat(cfg, sec, k, fallback="").strip()
                if v:
                    spec = v; break
            if spec: break
        if not spec:
            return None
                                         
        return (wkey.title(), {
            "type": "natural",                                                      
            "dmg":  spec,                                                            
            "stat": "str",
            "plus": 0,
        })


    def _is_snake_staff_name(self, w: str) -> bool:
        n = re.sub(r"[^a-z0-9]+", "", (w or "").lower())
        return n in {"snakestaff", "snakestaff1", "snakestaff+1", "staffsnake", "snakestaffm"}              


    @dataclass
    class AttackOpts:
        primary: Optional[str] = None
        splash: List[str] = field(default_factory=list)
        rng_short: bool = False
        rng_long: bool = False
        bonus: int = 0
        extra_dmg_spec: Optional[str] = None
        extra_dmg_value: int = 0
        extra_dmg_rolls: List[int] = field(default_factory=list)
        sneak: bool = False
        charge: bool = False
        called: bool = False
        flank: bool = False
        twf: bool = False
        rage: bool = False
        fav: bool = False
        snipe: bool = False
        assassinate: bool = False
        snake: bool = False
        wrestle: bool = False
        subdual: bool = False
        repeat_times: int = 1
        raw_primary: Optional[str] = None
        raw_splash: List[str] = field(default_factory=list)


    def _norm(s: str) -> str:
        return re.sub(r"\s+", "", (s or "").lower())


    def _is_snake_staff_name(self, name: str) -> bool:
        n = _norm(name)
        return n in {"snakestaff", "snake_staff", "serpentstaff", "serpent_staff"}


    def _roll_extra_damage(raw: str) -> Tuple[int, List[int]]:
        m = re.fullmatch(r"\s*(\d+)d(\d+)\s*([+-]\s*\d+)?\s*", raw.lower())
        if not m:
            try: return int(raw.replace("+","").strip()), []
            except Exception: return 0, []
        s, rolls, flat = roll_dice(raw)
        return s + flat, rolls


    def _parse_attack_options(self, weapon: str, opts: Tuple[str, ...]) -> AttackOpts:
        """Single pass: flags, manual bonus/damage, implicit targets, splash."""
        out = AttackOpts()
        flag_tokens = {
            "short","long",
            "sneak","-s","-sneak","backstab",
            "charge","-c","-charge",
            "called","-k","-called",
            "flank","adv",
            "twf",
            "rage","-r","-rage",
            "fav","-fav","favored","-favored",
            "snipe","-sn","shot",
            "kill","death","-as","assassinate","-assassinate","deathstrike","-ds","-deathstrike",
            "snake","-snake",
            "wrestle","-w","-wrestle","grapple",
            "sub","-sub","-sub","nl","-nl","-nl","nonlethal","-nonlethal","-nonlethal",
            "-b","-bonus","-d","-dmg","-damage",
            "-t","-target","-splash","-sp",
            "-rr","-repeat","-attacks",
            "punch","fist","unarmed","kick",
        }
        i = 0
        want_snake_via_s = False
        weapon_is_snake = self._is_snake_staff_name(weapon)

        while i < len(opts):
            token = str(opts[i]).lower()

            if token in ("-splash", "-sp"):
                i += 1
                while i < len(opts) and str(opts[i]).lower() not in flag_tokens:
                    out.splash.append(opts[i]); i += 1
                continue

            if token in ("-t", "-target"):
                i += 1
                while i < len(opts) and str(opts[i]).lower() not in flag_tokens:
                    if out.primary is None:
                        out.primary = opts[i]
                    else:
                        out.splash.append(opts[i])
                    i += 1
                continue

            if token in ("-rr","-repeat","-attacks") and i + 1 < len(opts):
                try: out.repeat_times = max(1, min(10, int(str(opts[i+1]))))
                except Exception: out.repeat_times = 1
                i += 2; continue

            if token in ("fav","-fav","favored","-favored"):
                out.fav = True; i += 1; continue

            if token in ("kill","death","-as","assassinate","-assassinate","deathstrike","-ds","-deathstrike"):
                out.assassinate = True; i += 1; continue

            if token in ("sub","-sub","-sub","nl","-nl","-nl","nonlethal","-nonlethal","-nonlethal"):
                out.subdual = True; i += 1; continue

            if token == "short": out.rng_short, out.rng_long = True, False; i += 1; continue
            if token == "long":  out.rng_long,  out.rng_short = True, False; i += 1; continue

            if token in ("-b", "-bonus") and i + 1 < len(opts):
                try: out.bonus = int(str(opts[i + 1]).replace("+","").strip())
                except Exception: out.bonus = 0
                i += 2; continue

            if token in ("-d", "-dmg", "-damage") and i + 1 < len(opts):
                raw = str(opts[i+1]).strip()
                out.extra_dmg_spec = raw
                out.extra_dmg_value, out.extra_dmg_rolls = _roll_extra_damage(raw)
                i += 2; continue

            if token in ("snake", "-snake"): out.snake = True; i += 1; continue
            if token == "-s":
                if weapon_is_snake: want_snake_via_s = True
                else: out.sneak = True
                i += 1; continue

            if token in ("sneak", "-sneak", "backstab"): out.sneak = True; i += 1; continue
            if token in ("snipe", "-sn", "shot"):         out.snipe = True; i += 1; continue
            if token in ("flank","adv"):                  out.flank = True; i += 1; continue
            if token == "twf":                            out.twf = True; i += 1; continue
            if token in ("rage","-r","-rage"):           out.rage = True; i += 1; continue
            if token in ("charge", "-c", "-charge"):     out.charge = True; i += 1; continue
            if token in ("called", "-k", "-called"):     out.called = True; i += 1; continue
            if token in ("wrestle","-w","-wrestle","grapple"):
                out.wrestle = True; i += 1; continue

                               
            out.primary = out.primary or opts[i]
            if out.primary != opts[i]:
                out.splash.append(opts[i])
            i += 1

                                         
        if want_snake_via_s: out.snake = True

        out.raw_primary = out.primary
        out.raw_splash  = out.splash[:]
        return out


    async def _remove_from_battle_and_cleanup(self, ctx, pretty_name: str, tgt_path: str):
        """Remove a creature from initiative, delete its file, and refresh the pinned tracker."""
        bcfg = _load_battles()
        ch = str(ctx.channel.id)

                                                   
        if bcfg and bcfg.has_section(ch):
            names, scores = _parse_combatants(bcfg, ch)
            key = _find_ci_name(names, pretty_name) or pretty_name

            if key in names:
                names = [n for n in names if n != key]
                if bcfg.has_option(ch, key):
                    bcfg.remove_option(ch, key)

                                                                            
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")
                for suf in (
                    ".dex",".join",".disp",".oil",".acpen",".acbuf",".holds",".heldby",
                    ".paralyzed",".pain",".shield",".mi",".inw",".gas",
                    ".weakarmor",".x_weakenarmor",".growthanimals",".x_growthanimals"
                ):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(ch, opt):
                        bcfg.remove_option(ch, opt)

                _write_combatants(bcfg, ch, names, scores)

                                                                              
                if bcfg.get(ch, "turn", fallback="") == key:
                    ents = _sorted_entries(bcfg, ch)
                    bcfg.set(ch, "turn", ents[0]["name"] if ents else "")
                _save_battles(bcfg)

                                        
                try:
                    msg_id = bcfg.getint(ch, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, ch)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

                                                           
        try:
            if tgt_path:
                os.remove(os.path.abspath(tgt_path))
        except Exception:
            pass


    def _debug_eq_weapons(cfg):
        return ", ".join(f"{k}={v}" for k, v in _eq_weapon_slots(cfg))


    async def _attack_spiritual_hammer(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
        force_bonus: int | None = None,
    ) -> None:
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            embed = nextcord.Embed(
                title="🔨 Spiritual Hammer",
                description="*(Add a target: `!a spiritualhammer <target>`)*",
                color=0x8888FF,
            )
            await ctx.send(embed=embed)
            return

                                                    
        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            embed = nextcord.Embed(
                title="🔨 Spiritual Hammer",
                description=f"**{tokens[0]}**: *(not found)*",
                color=0xFF6666,
            )
            await ctx.send(embed=embed)
            return

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active, bonus = True, 0
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            ci = _find_ci_name(names, caster_name) or caster_name
            s = _slot(ci)
            rounds = bcfg.getint(chan_id, f"{s}.sph", fallback=0)
            bonus  = bcfg.getint(chan_id, f"{s}.sph_bonus", fallback=0)
            active = rounds > 0

        if force_bonus is not None:
            bonus = int(force_bonus)

        if not active:
            embed = nextcord.Embed(
                title="🔨 Spiritual Hammer",
                description=f"**{caster_name}** has no active Spiritual Hammer.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        classes_tbl = getattr(self, "classes", {})
        char_class = (get_compat(caster_cfg, "info", "class", fallback="Cleric") or "Cleric").strip()
        level = getint_compat(caster_cfg, "cur", "level", fallback=max(1, caster_level or 1))
        ab_list = (classes_tbl.get(char_class.lower(), {}) or {}).get("ab", [])
        ab = ab_list[min(level - 1, len(ab_list) - 1)] if ab_list else 0

        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab

                                      
        t_cfg = read_cfg(tgt_path)
        try:
            target_ac = int(str(get_compat(t_cfg, "stats", "ac", fallback="") or "").strip() or 10)
        except Exception:
            target_ac = 10

        is_crit = (d20 == 20)
        hit = is_crit or (total_to_hit >= target_ac)

        d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
        ab_str = f"+ {ab}" if ab >= 0 else f"{ab}"
        attack_line = f"{d20_face} {ab_str} = ``{total_to_hit}``"

        color = 0x66CC66 if hit else 0xCC6666
        embed = nextcord.Embed(
            title="🔨 Spiritual Hammer",
            description=f"**{caster_name}** directs the hammer at **{tgt_disp}**!",
            color=color,
        )
        embed.add_field(name="Attack roll", value=attack_line, inline=True)
                                                                             
        embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

        if hit and tgt_disp:
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
            except Exception:
                consumed, left = (False, 0)
            if consumed:
                embed.add_field(
                    name="Mirror Image",
                    value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                    inline=False
                )
                await ctx.send(embed=embed)
                return

        if not hit:
            await ctx.send(embed=embed)
            return

        dmg_sum, rolls, flat = roll_dice("1d6")
        raw_dmg = dmg_sum + flat + max(0, int(bonus))
        final, note = _apply_mitigation(
            raw_dmg,
            weapon_name="Spiritual Hammer",
            weapon_type="force",                                   
            t_cfg=t_cfg,
            is_magical=true,
        )

                  
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        dmg_line = f"1d6 {rolls_txt} + {bonus} = ``{raw_dmg}``"
        if note:
            dmg_line += f"\n→ **{note}** → ``{final}``"

        embed.add_field(name="Damage", value=dmg_line, inline=False)

                              
        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_tail = f"{before} → **{after}**"
        else:
            hp_tail = f"{old_hp} → **{new_hp}**"

        if new_hp <= 0:
            hp_tail += " ☠️ **DEAD!**"
        embed.add_field(name="Target HP", value=hp_tail, inline=False)

        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        await ctx.send(embed=embed)


    async def _attack_ghoulish_hands(
        self,
        ctx,
        attacker_cfg,
        attacker_name: str,
        attacker_level: int,
        tokens: list[str],
    ) -> None:
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            embed = nextcord.Embed(
                title="🧟‍♂️ Ghoulish Hands",
                description="*(Add a target: `!a ghoulishhands <target>`)*",
                color=0x8888FF,
            )
            await ctx.send(embed=embed)
            return

                     
        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            embed = nextcord.Embed(
                title="🧟‍♂️ Ghoulish Hands",
                description=f"**{tokens[0]}**: *(not found)*",
                color=0xFF6666,
            )
            await ctx.send(embed=embed)
            return

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active = True
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            att_key = _find_ci_name(names, attacker_name) or attacker_name
            s_att = _slot(att_key)
            rounds = bcfg.getint(chan_id, f"{s_att}.ghh", fallback=0)
            active = rounds > 0
        if not active:
            embed = nextcord.Embed(
                title="🧟‍♂️ Ghoulish Hands",
                description=f"**{attacker_name}** has no active Ghoulish Hands.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        classes_tbl = getattr(self, "classes", {})
        char_class = (get_compat(attacker_cfg, "info", "class", fallback="Fighter") or "Fighter").strip()
        level = getint_compat(attacker_cfg, "cur", "level", fallback=max(1, attacker_level or 1))
        ab_list = (classes_tbl.get(char_class.lower(), {}) or {}).get("ab", [])
        ab = ab_list[min(level - 1, len(ab_list) - 1)] if ab_list else 0

        STR = getint_compat(attacker_cfg, "stats", "str", fallback=10)
                                                                                 
        try:
            str_mod = int(str(get_compat(attacker_cfg, "stats", "str_modifier", fallback="")).strip())
        except Exception:
            str_mod = None
        if str_mod is None:
                                                                                  
            str_mod = osr_mod(STR)
        t_cfg = read_cfg(tgt_path)
        try:
            target_ac = int(str(get_compat(t_cfg, "stats", "ac", fallback="") or "").strip() or 10)
        except Exception:
            target_ac = 10

                            
        race = (get_compat(t_cfg, "info", "race", fallback="") or "").strip().lower()
        is_elf = "elf" in race                                   

        embed = nextcord.Embed(
            title="🧟‍♂️ Ghoulish Hands",
            description=f"**{attacker_name}** rakes at **{tgt_disp}** with ghastly claws!",
            color=0x9acd32,
        )

                                  
        def _one_claw(ordinal: int, cur_hp: int):
            d20 = random.randint(1, 20)
            is_crit = (d20 == 20)
            total = d20 + ab + str_mod
            hit = is_crit or total >= target_ac

            d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
            ab_str   = f"+ {ab}" if ab >= 0 else f"{ab}"
            mod_str  = f"+ {str_mod}" if str_mod >= 0 else f"{str_mod}"
            atk_text = f"{d20_face} {ab_str} {mod_str} = ``{total}``"
            embed.add_field(name=f"Claw #{ordinal} — Attack", value=atk_text, inline=True)
            embed.add_field(name=f"Claw #{ordinal} — Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                             
            if hit and tgt_disp:
                try:
                    consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
                except Exception:
                    consumed, left = (False, 0)
                if consumed:
                    embed.add_field(
                        name=f"Mirror Image (#{ordinal})",
                        value=f"Figment shredded. Images remaining: **{left}**.",
                        inline=False
                    )
                    return cur_hp, False                                       

            if not hit:
                embed.add_field(name=f"Claw #{ordinal} — Damage", value="*(no effect on miss)*", inline=False)
                return cur_hp, False

                                                            
            s, rolls, flat = roll_dice("1d4")
            raw = s + flat + max(0, str_mod)
            final, note = _apply_mitigation(raw, weapon_name="Ghoulish Hands", weapon_type="slashing", t_cfg=t_cfg)
            dmg_line = f"1d4 [{', '.join(str(r) for r in rolls)}] + {max(0, str_mod)} = ``{raw}``"
            if note:
                dmg_line += f"\n→ **{note}** → ``{final}``"
            embed.add_field(name=f"Claw #{ordinal} — Damage", value=dmg_line, inline=False)

            new_hp = max(0, cur_hp - final)

                                           
            if is_elf:
                embed.add_field(name=f"Claw #{ordinal} — Paralysis", value="Elf: **immune**.", inline=False)
            else:
                sv_ok, sv_roll, sv_target, _pen = self._roll_save(t_cfg, vs="para", penalty=0)
                if sv_ok:
                    embed.add_field(name=f"Claw #{ordinal} — Paralysis", value=f"Save vs Paralyze: {sv_roll} vs {sv_target} → **RESISTED**", inline=False)
                else:
                                                   
                    td, t_rolls, t_flat = roll_dice("2d8")
                    turns = td + t_flat
                    rounds = turns * 60
                    try:
                        if bcfg and bcfg.has_section(chan_id):
                            names, _ = _parse_combatants(bcfg, chan_id)
                            t_key = _find_ci_name(names, tgt_disp) or tgt_disp
                            s_tgt = _slot(t_key)
                            cur = bcfg.getint(chan_id, f"{s_tgt}.paralyzed", fallback=0)
                            bcfg.set(chan_id, f"{s_tgt}.paralyzed", str(max(cur, rounds)))                                              
                            _save_battles(bcfg)
                    except Exception:
                        pass
                    embed.add_field(
                        name=f"Claw #{ordinal} — Paralysis",
                        value=f"Save vs Paralyze: {sv_roll} vs {sv_target} → **FAIL** → Paralyzed **{turns} turns** ({rounds} rounds).",
                        inline=False
                    )

            return new_hp, True

                         
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)

                 
        hp_after_1, hit1 = _one_claw(1, old_hp)

                                                                            
        if hit1:
            t_cfg["cur"]["hp"] = str(hp_after_1)
            write_cfg(tgt_path, t_cfg)

                                   
        if hp_after_1 <= 0:
            pass
        else:
                     
            hp_after_2, hit2 = _one_claw(2, hp_after_1)
            if hit2:
                t_cfg2 = read_cfg(tgt_path)
                t_cfg2["cur"]["hp"] = str(hp_after_2)
                write_cfg(tgt_path, t_cfg2)

                                            
        final_hp = getint_compat(read_cfg(tgt_path), "cur", "hp", fallback=0)
        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(final_hp, mhp, width=10)
            tail = f"{before} → **{after}**"
        else:
            tail = f"{old_hp} → **{final_hp}**"
        if final_hp <= 0:
            tail += " ☠️ **DEAD!**"
        embed.add_field(name="Target HP", value=tail, inline=False)

                                                          
        if final_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try: os.remove(os.path.abspath(tgt_path))
            except Exception: pass

                                                              
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        await ctx.send(embed=embed)


    async def _attack_shillelagh(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
        force_hit_bonus: int | None = None,
        force_dmg_bonus: int | None = None,
        force_die: str | None = None,
    ) -> None:
        

        chan_id = str(ctx.channel.id)

        if not tokens:
            embed = nextcord.Embed(
                title="🪵 Shillelagh",
                description="*(Add a target: `!a shillelagh <target>`)*",
                color=0x5AAE61,
            )
            await ctx.send(embed=embed)
            return

                                                    
        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            embed = nextcord.Embed(
                title="🪵 Shillelagh",
                description=f"**{tokens[0]}**: *(not found)*",
                color=0xFF6666,
            )
            await ctx.send(embed=embed)
            return

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active, hit_bonus, dmg_bonus, die_code = True, 1, 1, "1d8"
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            ci = _find_ci_name(names, caster_name) or caster_name
            s = _slot(ci)
            rounds = bcfg.getint(chan_id, f"{s}.shl", fallback=0)
            hit_bonus = bcfg.getint(chan_id, f"{s}.shl_hit", fallback=1)
            dmg_bonus = bcfg.getint(chan_id, f"{s}.shl_dmg", fallback=1)
            die_code  = bcfg.get(chan_id,     f"{s}.shl_die", fallback="1d8")
            active = rounds > 0

        if force_hit_bonus is not None:
            hit_bonus = int(force_hit_bonus)
        if force_dmg_bonus is not None:
            dmg_bonus = int(force_dmg_bonus)
        if force_die is not None:
            die_code = str(force_die)

        if not active:
            embed = nextcord.Embed(
                title="🪵 Shillelagh",
                description=f"**{caster_name}** has no active Shillelagh.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        classes_tbl = getattr(self, "classes", {})
        ab = _get_ab_from_cfg_or_table(caster_cfg, classes_tbl, fallback_class="Druid", fallback_level=caster_level)

        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + hit_bonus

                                      
        t_cfg = read_cfg(tgt_path)
        try:
            target_ac = int(str(get_compat(t_cfg, "stats", "ac", fallback="") or "").strip() or 10)
        except Exception:
            target_ac = 10

        is_crit = (d20 == 20)
        hit = is_crit or (total_to_hit >= target_ac)

        d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
        ab_str = f"+ {ab}" if ab >= 0 else f"{ab}"
        hb_str = f"+ {hit_bonus}" if hit_bonus >= 0 else f"{hit_bonus}"
        attack_line = f"{d20_face} {ab_str} {hb_str} = ``{total_to_hit}``"

        color = 0x66CC66 if hit else 0xCC6666
        embed = nextcord.Embed(
            title="🪵 Shillelagh",
            description=f"**{caster_name}** strikes **{tgt_disp}** with an empowered club/staff!",
            color=color,
        )
        embed.add_field(name="Attack roll", value=attack_line, inline=True)
        embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                               
        if hit and tgt_disp:
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
            except Exception:
                consumed, left = (False, 0)
            if consumed:
                embed.add_field(
                    name="Mirror Image",
                    value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                    inline=False
                )
                await ctx.send(embed=embed)
                return

        if not hit:
            await ctx.send(embed=embed)
            return

        str_mod = _get_str_mod_from_cfg(caster_cfg)

        dmg_sum, rolls, flat = roll_dice(die_code)               
        raw_dmg = dmg_sum + flat + int(dmg_bonus) + int(str_mod)

                                                         
        final, note = _apply_mitigation(
            raw_dmg,
            weapon_name="Shillelagh",
            weapon_type="bludgeoning",
            t_cfg=t_cfg,
            is_magical=true,
        )

                  
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        dmg_line = f"{die_code} {rolls_txt} + {str_mod} + {dmg_bonus} = ``{raw_dmg}``"
        if note:
            dmg_line += f"\n→ **{note}** → ``{final}``"
        embed.add_field(name="Damage", value=dmg_line, inline=False)


                              
        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_tail = f"{before} → **{after}**"
        else:
            hp_tail = f"{old_hp} → **{new_hp}**"

        if new_hp <= 0:
            hp_tail += " ☠️ **DEAD!**"
        embed.add_field(name="Target HP", value=hp_tail, inline=False)

                                         
        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

                                                                                                  
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        await ctx.send(embed=embed)


    async def _attack_colorcloud(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active = False
        left = 0
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            left = bcfg.getint(chan_id, f"{s_me}.cc", fallback=0)
            active = left > 0

        color = 0x66CCFF if active else 0xAAAAAA
        desc  = (f"**{caster_name}** sweeps the cloud!" if active
                 else f"**{caster_name}** has no active Color Cloud.")
        embed = nextcord.Embed(title="🌫️ Color Cloud", description=desc, color=color)

        if active:
            embed.add_field(name="Cloud", value=f"Rounds remaining: **{left}**", inline=True)
            lines = self._apply_colorcloud_to_targets(chan_id, bcfg, caster_name, caster_level, tokens or [])
            if lines:
                embed.add_field(name="Effect", value="\n".join(lines), inline=False)

        await ctx.send(embed=embed)


    def _apply_colorcloud_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        
        lines = []

        def _save_vs_spells(t_cfg):
            for tag in ("spl","spell","spells"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"• **{raw}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)

                            
            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"• **{tgt_disp}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass

                                         
            s_tgt = None
            blind_left = 0
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key   = _find_ci_name(names, tgt_disp) or tgt_disp
                s_tgt = self._effect_slot_for(bcfg, chan_id, key)
                try:
                    blind_left = bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0)
                except Exception:
                    blind_left = 0

            if blind_left > 0:
                lines.append(f"• **{tgt_disp}**: 🙈 Already sightless — **no effect**.")
                continue

            hd = self._hd_or_level_from_cfg(t_cfg)
            try:
                caster_lvl = int(caster_level)
            except Exception:
                caster_lvl = 0

            needs_save = (hd > caster_lvl) or (hd >= 10)
            if needs_save:
                sv_ok, sv_roll, sv_dc, _ = _save_vs_spells(t_cfg)
                if sv_dc is not None:
                    if sv_ok:
                        lines.append(f"• **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} → **RESISTED**.")
                        continue
                    else:
                        lines.append(f"• **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} → **FAIL**.")
                else:
                    lines.append(f"• **{tgt_disp}** (HD {hd}): *(no save table — treating as failed)*")

                      
            if hd <= 4:
                u_s, u_rolls, _ = roll_dice("2d4")
                b_s, b_rolls, _ = roll_dice("1d4")
                u_rounds = max(0, u_s)
                b_rounds = max(0, b_s)

                if bcfg and bcfg.has_section(chan_id) and s_tgt:
                    prev = bcfg.getint(chan_id, f"{s_tgt}.paralyzed", fallback=0)
                    newv = max(prev, u_rounds)                  
                    if newv > 0:
                        bcfg.set(chan_id, f"{s_tgt}.paralyzed", str(newv))
                        bcfg.set(chan_id, f"{s_tgt}.paralyzed_by", "colorcloud")
                    if b_rounds > 0:
                        bcfg.set(chan_id, f"{s_tgt}.cc_blind_pending", str(b_rounds))
                        bcfg.set(chan_id, f"{s_tgt}.cc_blind_by", caster_name)
                    _save_battles(bcfg)

                lines.append(
                    f"• **{tgt_disp}** (HD {hd}): 😴 **UNCONSCIOUS** for **{u_rounds} rounds** "
                    f"({', '.join(str(r) for r in u_rolls)}) → then 🙈 **BLIND** for **{b_rounds} rounds** "
                    f"({', '.join(str(r) for r in b_rolls)})."
                )

            elif 5 <= hd <= 8:
                b_s, b_rolls, _ = roll_dice("1d4")
                b_rounds = max(0, b_s)
                if bcfg and bcfg.has_section(chan_id) and s_tgt and b_rounds > 0:
                    prev_bl = bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0)
                    new_bl  = max(prev_bl, b_rounds)
                    bcfg.set(chan_id, f"{s_tgt}.blind", str(new_bl))
                    bcfg.set(chan_id, f"{s_tgt}.blind_src", "colorcloud")
                    bcfg.set(chan_id, f"{s_tgt}.blind_by", caster_name)
                    _save_battles(bcfg)

                lines.append(
                    f"• **{tgt_disp}** (HD {hd}): 🙈 **BLIND** for **{b_rounds} rounds** "
                    f"({', '.join(str(r) for r in b_rolls)})."
                )

            else:
                if bcfg and bcfg.has_section(chan_id) and s_tgt:
                    prev_bl = bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0)
                    new_bl  = max(prev_bl, 1)
                    bcfg.set(chan_id, f"{s_tgt}.blind", str(new_bl))
                    bcfg.set(chan_id, f"{s_tgt}.blind_src", "colorcloud")
                    bcfg.set(chan_id, f"{s_tgt}.blind_by", caster_name)
                    _save_battles(bcfg)
                lines.append(f"• **{tgt_disp}** (HD {hd}): 🙈 **BLIND** for **1 round**.")

        return lines


    def _hd_or_level_from_cfg(self, t_cfg) -> int:
        
                                                                                  
        try:
            raw = str(get_compat(t_cfg, "base", "hd", fallback="")).strip()
            if raw:
                m = re.search(r"(\d+)", raw)                        
                if m:
                    return max(1, int(m.group(1)))
                                           
            raw2 = str(get_compat(t_cfg, "base", "hitdice", fallback="")).strip()
            if raw2:
                m2 = re.search(r"(\d+)", raw2)
                if m2:
                    return max(1, int(m2.group(1)))
        except Exception:
            pass

                                                                     
        try:
            lvl = getint_compat(t_cfg, "cur", "level", fallback=None)
            if lvl is not None:
                return max(1, int(lvl))
        except Exception:
            pass
        try:
            lvl2 = getint_compat(t_cfg, "info", "level", fallback=None)
            if lvl2 is not None:
                return max(1, int(lvl2))
        except Exception:
            pass

                     
        return 1


    def _apply_cloudkill_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        
        lines = []

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"• **{raw}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)

                                              
            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"• **{tgt_disp}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass
            try:
                if self._poison_immune(t_cfg):
                    lines.append(f"• **{tgt_disp}**: 🧪 Poison-immune — **no effect**.")
                    continue
            except Exception:
                pass

                                                        
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
            if old_hp is None:
                lines.append(f"• **{tgt_disp}**: ⚠️ No HP field — cannot resolve.")
                continue
            if old_hp <= 0:
                lines.append(f"• **{tgt_disp}**: already ☠️ **dead**.")
                continue

                              
            hd = self._hd_or_level_from_cfg(t_cfg)

                        
            died = False
            note = ""
            if hd <= 3:
                died = True
                note = "HD ≤ 3 — no save."
            else:
                                       
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
                if sv_dc is not None:
                    if sv_ok:
                        lines.append(f"• **{tgt_disp}** (HD {hd}): Save vs Poison {sv_roll} vs {sv_dc} → ✅ **RESISTED**")
                        continue
                    else:
                        note = f"Save vs Poison {sv_roll} vs {sv_dc} → **FAIL**"
                        died = True
                else:
                    note = "*(no save table — treating as failed)*"
                    died = True

                         
            if died:
                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)

                try:
                    is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
                except Exception:
                    is_mon = False

                if is_mon and bcfg and bcfg.has_section(chan_id):
                    try:
                        names, scores = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, tgt_disp) or tgt_disp
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            s = _slot(key)
                                                                              
                            for suf in (
                                ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                ".paralyzed",".blind",".blind_src",".blind_by",
                                ".cc_blind_pending",".cs_blind_pending",
                                ".cc",".cc_by",".cc_level",
                                ".ck",".ck_by",".ck_level",
                                ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                            ):
                                opt = f"{s}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names, scores)

                                                                                             
                            cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                            if cur_turn == key:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                    except Exception:
                        pass

                                                 
                    try:
                        import os
                        os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass

                                           
                try:
                                       
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    before = _life_bar(old_hp, mhp, width=10)
                    after  = _life_bar(0, mhp, width=10)
                    lines.append(f"• **{tgt_disp}** (HD {hd}): {note}\n{before} → **{after}** ☠️ **DEAD!**")
                except Exception:
                                             
                    lines.append(f"• **{tgt_disp}** (HD {hd}): {note}\nHP {old_hp} → **0** ☠️ **DEAD!**")

        return lines


    async def _attack_cloudkill(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

                                      
        active = False
        left = 0
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            left = bcfg.getint(chan_id, f"{s_me}.ck", fallback=0)
            active = left > 0

        color = 0x55DD55 if active else 0xAAAAAA
        desc  = (f"**{caster_name}** steers the killing fog!" if active
                 else f"**{caster_name}** has no active Cloudkill.")
        embed = nextcord.Embed(title="☣️ Cloudkill", description=desc, color=color)

        if active:
            embed.add_field(name="Cloud", value=f"Rounds remaining: **{left}**", inline=True)
            lines = self._apply_cloudkill_to_targets(chan_id, bcfg, caster_name, caster_level, tokens or [])
            if lines:
                embed.add_field(name="Effect", value="\n".join(lines), inline=False)

        await ctx.send(embed=embed)

                                                              
        try:
            bcfg2 = _load_battles()
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


    def _resolve_char_ci_local(self, name: str):
            """
            Case-insensitive resolver: try normal resolver; then look for <name>.coe or <name>.ini.
            Returns (display_name, path) or (name, None).
            """
            
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass

            base = (name or "").replace(" ", "_")
            want = {f"{base}.coe".lower(), f"{base}.ini".lower()}
            for fn in os.listdir("."):
                if fn.lower() in want:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        disp = (real or fn[:-4].replace("_", " "))
                        return disp, path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None


    def _hyp_break_if_targeted(self, chan_id: str, name_list: list[str]) -> None:
        try:
            bcfg = _load_battles()
        except Exception:
            return
        if not (bcfg and bcfg.has_section(chan_id)):
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        changed = False

        for nm in (name_list or []):
            key = _find_ci_name(names, nm) or nm
            try:
                s = _slot(key)
            except Exception:
                s = key.replace(" ", "_")

            if bcfg.has_option(chan_id, f"{s}.hyp"):
                                       
                for suf in (".hyp", ".hyp_by"):
                    opt = f"{s}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                        changed = True

        if changed:
            _save_battles(bcfg)


    def _apply_calllightning_to_targets(self, chan_id: str, bcfg, caster_name: str, die_spec: str, tokens: list[str]) -> list[str]:
        lines = []

                                                                      
        try:
            if bcfg and bcfg.has_section(chan_id) and tokens:
                self._hyp_break_if_targeted(chan_id, list(tokens))
        except Exception:
            pass

                                            
        dmg_sum, dmg_rolls, flat = roll_dice(die_spec)
        base = dmg_sum + flat
        lines.append(f"⚡ Bolt damage: **{die_spec}** [{', '.join(str(r) for r in dmg_rolls)}] → **{base}**")

        def _save_vs_spells(t_cfg):
            for tag in ("spl","spell","spells"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)                         

        for raw in tokens or []:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"• **{raw}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
            absorbs_electric = ("electric" in _collect_absorb_types(t_cfg))

                                     
            sv_ok, sv_roll, sv_dc, sv_pen = _save_vs_spells(t_cfg)
            if sv_dc is None:
                sv_ok = False
            if absorbs_electric:
                sv_ok = False             

            raw_dmg = base // 2 if sv_ok else base


                                                                   
            final, note = _apply_mitigation(raw_dmg, weapon_name="Call Lightning", weapon_type="electric", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(tgt_path, t_cfg)


                          
            if _is_monster_file(tgt_path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                hp_tail = f"{before} → {after}"
            else:
                hp_tail = f"{old_hp} → **{new_hp}**"
            dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""

            pen_txt = (f" - {abs(sv_pen)}" if sv_pen else "")
            sv_txt  = f" (Save vs Spells {sv_roll}{pen_txt} vs {sv_dc})" if sv_dc is not None else ""
            auto_txt = " (auto-fail: absorbs electric)" if absorbs_electric else ""
            amt_txt = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"
            res_txt = " **HALF**" if sv_ok else ""

            dup_heal = (final < 0) and note and ("heals" in note.lower())
            note_txt = (f" → **{note}**" if note else "")
            amt_part = ("" if dup_heal else f" → {amt_txt}")

            lines.append(
                f"• **{tgt_disp}**:{sv_txt}{auto_txt}{note_txt}{amt_part}{res_txt}\n"
                f"    {hp_tail}{dead_note}"
            )


            if new_hp <= 0:
                                                           
                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)

                try:
                    is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
                except Exception:
                    is_mon = False

                if is_mon and bcfg and bcfg.has_section(chan_id):
                    try:
                        names, scores = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, tgt_disp) or tgt_disp
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            s = _slot(key)
                                                                              
                            for suf in (
                                ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                ".paralyzed",".blind",".blind_src",".blind_by",
                                ".cc_blind_pending",".cs_blind_pending",
                                ".cc",".cc_by",".cc_level",
                                ".ck",".ck_by",".ck_level",
                                ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by",
                                                                                
                                ".hyp",".hyp_by",
                                ".cl",".cl_by",".cl_bolts",".cl_die",".cl_last_round"
                            ):
                                opt = f"{s}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)

                            _write_combatants(bcfg, chan_id, names, scores)

                                                                                             
                            cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                            if cur_turn == key:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                    except Exception:
                        pass

                                                 
                    try:
                        import os
                        os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass

        return lines


    async def _attack_calllightning(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        color = 0xAAAAAA
        desc  = f"**{caster_name}** cannot call a bolt right now."

        if not (bcfg and bcfg.has_section(chan_id)):
            embed = nextcord.Embed(title="⚡ Call Lightning", description=desc, color=color)
            await ctx.send(embed=embed); return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

        left_rounds = bcfg.getint(chan_id, f"{s_me}.cl", fallback=0)
        bolts_left  = bcfg.getint(chan_id, f"{s_me}.cl_bolts", fallback=0)
        die_spec    = bcfg.get(chan_id, f"{s_me}.cl_die", fallback="3d6")
        last_round  = bcfg.getint(chan_id, f"{s_me}.cl_last_round", fallback=0)
        cur_round   = bcfg.getint(chan_id, "round", fallback=1)
        turn_name   = bcfg.get(chan_id, "turn", fallback="")

        active = left_rounds > 0 and bolts_left > 0
        on_turn = (turn_name and (turn_name.lower() == me_key.lower()))

        if not active:
            desc = (f"**{caster_name}** has no active Call Lightning."
                    if left_rounds <= 0 else f"No bolts remaining ({bolts_left}).")
            embed = nextcord.Embed(title="⚡ Call Lightning", description=desc, color=color)
            await ctx.send(embed=embed); return

        if not on_turn:
            desc = f"**{caster_name}** can call a bolt only on their turn."
            embed = nextcord.Embed(title="⚡ Call Lightning", description=desc, color=color)
            await ctx.send(embed=embed); return

        if last_round == cur_round:
            desc = f"A bolt was already called this round."
            embed = nextcord.Embed(title="⚡ Call Lightning", description=desc, color=color)
            await ctx.send(embed=embed); return

        if not tokens:
            desc = "Add targets: `!a calllightning go1 go2 ...`"
            embed = nextcord.Embed(title="⚡ Call Lightning", description=desc, color=color)
            embed.add_field(name="Status", value=f"Rounds left: **{left_rounds}**, Bolts left: **{bolts_left}**, Die: **{die_spec}**", inline=False)
            await ctx.send(embed=embed); return

                                          
        try:
            self._hyp_break_if_targeted(chan_id, list(tokens))
        except Exception:
            pass

                       
        lines = self._apply_calllightning_to_targets(chan_id, bcfg, caster_name, die_spec, tokens or [])

                                          
        bcfg.set(chan_id, f"{s_me}.cl_bolts", str(max(0, bolts_left - 1)))
        bcfg.set(chan_id, f"{s_me}.cl_last_round", str(cur_round))
        _save_battles(bcfg)

                       
        color = 0x66CCFF
        embed = nextcord.Embed(title="⚡ Call Lightning", description=f"**{caster_name}** calls a bolt!", color=color)
        embed.add_field(name="Effect", value="\n".join(lines), inline=False)
                          
        left_rounds = bcfg.getint(chan_id, f"{s_me}.cl", fallback=0)
        bolts_left  = bcfg.getint(chan_id, f"{s_me}.cl_bolts", fallback=0)
        embed.add_field(name="Status", value=f"Rounds left: **{left_rounds}**, Bolts left: **{bolts_left}**, Die: **{die_spec}**", inline=False)

        await ctx.send(embed=embed)

                         
        try:
            if bcfg and bcfg.has_section(chan_id):
                await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


    def _effect_slot_for(self, cfg, chan_id: str, display_or_key: str) -> str:
        """
        Pick the slot string for an actor, preferring whichever candidate already
        has timers/queues (PAR/BL/cc/cs queues, etc.).
        """
                                                 
        cands = []
        try:
            cands.append(_slot(display_or_key))
        except Exception:
            pass
        cands.append((display_or_key or "").replace(" ", "_"))

        prefer = (
            "paralyzed","blind","cc_blind_pending","cs_blind_pending","cc",
            "magwep","ghh","magearmor","boneskin","sph","shl","light","darkness"
        )
        for s in cands:
            if any(cfg.has_option(chan_id, f"{s}.{k}") for k in prefer):
                return s
        return cands[0]


    def _conf_mark_if_targeted(self, chan_id: str, raw_names, by: str | None) -> None:
        """If a confused creature is targeted, mark it to RETALIATE vs the attacker next turn."""
        try:
            cfg = _load_battles()
            if not cfg.has_section(chan_id):
                return

            names, _ = _parse_combatants(cfg, chan_id)
            attacker = (by or "").strip()

            for nm in (raw_names or []):
                key = _find_ci_name(names, nm) or nm
                try:
                    s = _slot(key)
                except Exception:
                    s = str(key).replace(" ", "_")

                                                          
                if cfg.getint(chan_id, f"{s}.cn", fallback=0) > 0:
                    if attacker:
                        cfg.set(chan_id, f"{s}.cn_retaliate_by", attacker)
                                                                                      
                        cfg.set(chan_id, f"{s}.cn_retaliate_round", cfg.get(chan_id, "round", fallback="0"))

            _save_battles(cfg)
        except Exception:
            pass


    def _levels_count_for_hp(self, cfg) -> int:
        """How many HD-levels to apply CON bonus per die to. 
           If you have a more precise table (e.g., stops at 9th), replace here."""
        return max(1, getint_compat(cfg, "cur", "level", fallback=1))


    def _get_con_state(self, cfg):
        """Return (cur_con, temp_loss, perm_loss, peak_loss, base_con)."""
        cur_con = getint_compat(cfg, "stats", "con", fallback=10)
        temp    = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
        perm    = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)
        peak    = getint_compat(cfg, "cur", "con_loss_peak", fallback=temp)
        base    = cur_con + temp + perm
        return cur_con, temp, perm, peak, base


    def _set_con_state(self, cfg, *, cur_con=None, temp=None, perm=None, peak=None):
        """Write back any provided pieces + section safety."""
        if not cfg.has_section("cur"):   cfg.add_section("cur")
        if not cfg.has_section("stats"): cfg.add_section("stats")
        if cur_con is not None:
            cfg["stats"]["con"] = str(max(1, int(cur_con)))
        if temp is not None:
            cfg["cur"]["con_loss_temp"] = str(max(0, int(temp)))
        if perm is not None:
            cfg["cur"]["con_loss_perm"] = str(max(0, int(perm)))
        if peak is not None:
            cfg["cur"]["con_loss_peak"] = str(max(0, int(peak)))


    def _apply_con_change_adjust_hp(self, cfg, old_con: int, new_con: int):
        """Adjust max/current HP when CON modifier crosses a boundary."""
        old_mod = self._con_mod(old_con)
        new_mod = self._con_mod(new_con)
        if old_mod == new_mod:
            return 0            
        hd_levels = self._levels_count_for_hp(cfg)
        delta_hp = (new_mod - old_mod) * hd_levels

        cur_hp = getint_compat(cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(cfg, "max", "hp", fallback=cur_hp)
        max_hp = max(1, max_hp + delta_hp)
        cur_hp = min(cur_hp, max_hp)

        if not cfg.has_section("cur"): cfg.add_section("cur")
        if not cfg.has_section("max"): cfg.add_section("max")
        cfg["cur"]["hp"] = str(cur_hp)
        cfg["max"]["hp"] = str(max_hp)
        return delta_hp


    def _apply_conloss_points(self, cfg, points: int, permanent: bool = False) -> int:
        """
        Apply Constitution loss to a character and return the NET Max-HP delta
        caused by CON-mod boundary shifts.

        - If permanent=False (default), increases TEMPORARY loss (cur.con_loss_temp).
          Also updates 'con_loss_peak' to the highest temp loss reached in this episode.
        - If permanent=True, increases PERMANENT loss (cur.con_loss_perm).
        - In both cases, 'stats.con' (the current, effective CON) is decreased.
        - HP max is adjusted via _apply_con_change_adjust_hp(...) whenever the CON mod changes.

        Returns:
            int: total change to Max HP (can be negative, zero, or positive if somehow raising/lowering around a boundary)
        """
               
        n = max(0, int(points or 0))
        if n == 0:
            return 0

        hp_delta_total = 0

                                                                    
        cur_con, temp, perm, peak, base = self._get_con_state(cfg)
                                                         

        for _ in range(n):
                                               
            if permanent:
                new_temp = temp
                new_perm = perm + 1
            else:
                new_temp = temp + 1
                new_perm = perm
                                                                     
                peak = max(peak, new_temp)

                                                       
            new_con = max(1, base - new_temp - new_perm)

                                                                
            try:
                                                                 
                hp_delta_total += self._apply_con_change_adjust_hp(cfg, cur_con, new_con)
            except TypeError:
                                                                  
                hp_delta_total += self._apply_con_change_adjust_hp(cfg, new_con - cur_con)

                                                               
            cur_con, temp, perm = new_con, new_temp, new_perm

                                                      
        self._set_con_state(cfg, cur_con=cur_con, temp=temp, perm=perm, peak=peak)

        return hp_delta_total


    def _restore_one_con_point(self, cfg, require_save_for_final=True, owner_for_save_cfg=None):
        """
        Restore exactly 1 point of TEMPORARY CON loss, adjusting Max/Current HP if the CON mod changes.
        If this would be the final point of a multi-point episode, optionally require a Save vs Death.
        Returns: (message:str|None, hp_delta:int)
        """
                         
        cur_con, temp, perm, peak, base = self._get_con_state(cfg)

                            
        if temp <= 0:
            return None, 0

                                                                               
        is_final_point = bool(require_save_for_final and temp == 1 and max(peak, temp) >= 2)

        if is_final_point:
            ok, roll, dc, _ = self._roll_save(owner_for_save_cfg or cfg, vs="poi", penalty=0)
            if ok:
                                                                    
                old_con = cur_con
                                                                            
                new_con = min(base - (temp - 1) - perm, base - perm)
                hp_delta = self._apply_con_change_adjust_hp(cfg, old_con, new_con)
                                        
                self._set_con_state(cfg, cur_con=new_con, temp=0, perm=perm, peak=0)
                return f"Final CON point recovered. Save vs Death: {roll} vs {dc} → **SUCCESS**.", hp_delta
            else:
                                                                                 
                self._set_con_state(cfg, cur_con=cur_con, temp=0, perm=perm + 1, peak=0)
                return f"Final CON point recovery — Save vs Death: {roll} vs {dc} → **FAIL**. That point is **permanently lost**.", 0

                                                         
        old_con = cur_con
        new_con = min(base - (temp - 1) - perm, base - perm)                  
        hp_delta = self._apply_con_change_adjust_hp(cfg, old_con, new_con)

                                                                 
        new_temp = temp - 1
        new_peak = 0 if new_temp <= 0 else peak
        self._set_con_state(cfg, cur_con=new_con, temp=new_temp, perm=perm, peak=new_peak)

        return "CON +1 restored.", hp_delta


    def _is_elf_or_dwarf(self, cfg) -> bool:
        race = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()
        return race.startswith("elf") or race.startswith("dwarf")


    def _parse_monster_attack_spec(self, spec: str):
        """
        Returns (dice_expr:str, effects: dict). Supports tokens:
            • <NdM[+K]>               (damage roll)
            • conloss[=N|:N]          (default 1; sums if repeated)
            • strloss|strdrain|str[:N] (default 1; sums if repeated)
            • heal|leech|regenerate   (heals attacker equal to applied damage)
            • disease[<pct>%]         (sets disease and optional inline %)
            • drain|energydrain|leveldrain[:N] (level drain, default 1; sums)
            • paralysis[ <pct>][ :N]  (optional % and/or rounds)
            • stun[:N]                 (no damage; save vs Poison; on fail paralyzed N rounds, default 60)            
            • petrify|petrification|turn to stone
            • burrow: infestation
            • constrict[:NdM]
            • entangle[:NdM]
            • swallow/swallowany[:NdM]
            • hold|worry[:NdM]
            • attach[:NdM]  

        """
        

        spec = (spec or "").strip()
        if not spec:
            return "1d6", {}

        s = spec.lower()
        eff = {"conloss": 0, "heal": False}

                                                                
        for m in re.finditer(r"(?:^|\s)(?:sv|save)(?::|=)?([+-]?\d+)(?=\s|$)", s):
            try:
                n = int(m.group(1))
                eff["save_bonus"] = eff.get("save_bonus", 0) + n
            except Exception:
                pass

                                          
        for m in re.finditer(r"(?:^|\s)disease(?:\s*(\d+)%?)?(?=\s|$)", s):
            eff["disease"] = True
            if m.group(1):
                eff["disease_chance"] = int(m.group(1))

                  
        for m in re.finditer(r"(?:^|\s)conloss(?::|=)?(\d+)?(?=\s|$)", s):
            n = int(m.group(1)) if m.group(1) else 1
            eff["conloss"] = eff.get("conloss", 0) + max(1, n)

        m = re.search(r"(?:^|\s)mummy[-_ ]?rot(?::|=)?(\d+)?(?=\s|$)", s)
        if m:
            eff["disease"] = True
            eff["disease_kind"] = "mummyrot"
            if m.group(1):
                eff["disease_chance"] = int(m.group(1))                                   

                          
        for m in re.finditer(r"(?:^|\s)(?:strloss|strdrain|str)(?::|=)?(\d+)?(?=\s|$)", s):
            n = int(m.group(1)) if m.group(1) else 1
            eff["strloss"] = eff.get("strloss", 0) + max(1, n)

                      
        if re.search(r"(?:^|\s)(?:heal|leech|regenerate)(?=\s|$)", s):
            eff["heal"] = True

                                    
        ld_total = 0
        for m in re.finditer(r"(?:^|\s)(?:energy[-_ ]?drain|level[-_ ]?drain|drain)(?::|=)?(\d+)?(?=\s|$)", s):
            n = int(m.group(1)) if m.group(1) else 1
            ld_total += max(1, n)
        if ld_total > 0:
            eff["leveldrain"] = ld_total


                                                                                                            
        m = re.search(r"(?:^|\s)(?:poison|venom)(?:\s*([+-]\d+))?(?=\s|$)", s)
        if m:
            eff["poison"] = "saveordie"
            if m.group(1):
                eff["save_bonus"] = eff.get("save_bonus", 0) + int(m.group(1))


                    
        m = re.search(r"(?:^|\s)slow[-_ ]?venom(?:\s*([+-]\d+))?(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["venom_kind"] = "slow"
            eff["venom_die"] = (m.group(2) or "1d6").strip()
            eff["venom_dur"] = "2d4"          
            if m.group(1):
                eff["save_bonus"] = eff.get("save_bonus", 0) + int(m.group(1))
            elif "save_bonus" not in eff:
                eff["save_bonus"] = 2                                    

                    
        m = re.search(r"(?:^|\s)fast[-_ ]?venom(?:\s*([+-]\d+))?(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["venom_kind"] = "fast"
            eff["venom_die"] = (m.group(2) or "1d6").strip()
            eff["venom_dur"] = "2d4"           
            if m.group(1):
                eff["save_bonus"] = eff.get("save_bonus", 0) + int(m.group(1))
            elif "save_bonus" not in eff:
                eff["save_bonus"] = 2                                    


                                                                  
        for m in re.finditer(r"(?:^|\s)paralysis(?:\s*(\d+)%?)?(?::|=)?(\d+)?(?=\s|$)", s):
            eff["paralysis"] = True
            if m.group(1):
                eff["paralysis_chance"] = int(m.group(1))                                 
            if m.group(2):
                eff["paralysis_rounds"] = int(m.group(2))                                     

                                                                                    
        m = re.search(r"(?:^|\s)burn(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["burn"] = True
            eff["burn_die"] = (m.group(1) or "3d10").strip()


                                                                          
                                                              
        if re.search(r"(?:^|\s)(?:petrify|petrification|turn[-\s]*to[-\s]*stone)(?=\s|$)", s):
            eff["petrify"] = True

                                                                          
        m = re.search(r"(?:^|\s)constrict(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["constrict"] = True
            eff["constrict_dice"] = m.group(1) or "2d4"

                                                                      
        m = re.search(r"(?:^|\s)entangle(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["entangle"] = True
            eff["entangle_dice"] = m.group(1) or "1d8"

                                                                       
        m = re.search(r"(?:^|\s)swallow(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["swallow"] = True
            eff["swallow_dice"] = (m.group(1) or "1d8").strip()
            
                                                                             
                 
                                                                   
                                                                               
        m = re.search(r"(?:^|\s)swallowany(?:@(\d+))?(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["swallow"] = True                                        
            eff["swallow_any"] = True                            
            eff["swallow_dice"] = (m.group(2) or "1d8").strip()
            try:
                eff["swallow_thresh"] = int(m.group(1)) if m.group(1) else 19
            except Exception:
                eff["swallow_thresh"] = 19
    

                                                                        
        m = re.search(r"(?:^|\s)burrow(?=\s|$)", s)
        if m:
            eff["rotgrub"] = True

        m = re.search(r"(?:^|\s)(?:hold|worry|holdbite|latch|grab)(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["holdbite"] = True
            eff["holdbite_dice"] = (m.group(1) or "1d4").strip()

                                                   
                     
                                                                                   
                                                   
        m = re.search(r"(?:^|\s)stun(?::|=)?(\d+)?(?=\s|$)", s)
        if m:
            eff["stun"] = True
            eff["stun_rounds"] = int(m.group(1)) if m.group(1) else 60
            eff["nodmg"] = True                                                


        m = re.search(r"(?:^|\s)attach(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["leech"] = True
            eff["leech_dice"] = (m.group(1) or "1d6").strip()
                        
                                                                                          
                                                                                          
        m = re.search(r"(?:^|\s)(?:dissolve[-_ ]?armor|dissolvearmor)(?::|=)?(\d+d\d+(?:[+-]\d+)?)?(?=\s|$)", s)
        if m:
            eff["dissolvearmor"] = True
            eff["dissolve_dice"] = (m.group(1) or "2d8").strip()
 
            
                                    
        m = re.search(r"\b\d+d\d+(?:[+-]\d+)?\b", s)
        dice = m.group(0) if m else None

        return (dice or "1d6", eff)


    def _get_disease_chance(self, atk_cfg, attack_key=None, eff=None) -> int:
        """Chance in percent. Priority: inline spec > per-attack INI > global INI > default 5%."""
                          
        if eff and isinstance(eff, dict) and "disease_chance" in eff:
            try: return max(0, min(100, int(eff["disease_chance"])))
            except Exception: pass
                                                    
        if attack_key:
            try:
                v = self._gc(atk_cfg, f"disease_chance_{attack_key}") or ""
                if str(v).strip():
                    return max(0, min(100, int(v)))
            except Exception:
                pass
                                           
        try:
            v = self._gc(atk_cfg, "disease_chance") or ""
            if str(v).strip():
                return max(0, min(100, int(v)))
        except Exception:
            pass
        return 5                     


    def _tracker_add_tag(self, bcfg, chan_id, slot: str, tag: str):
        disp = bcfg.get(chan_id, f"{slot}.disp", fallback="").strip()
        toks = [t for t in disp.split() if t]
        if tag not in toks:
            toks.append(tag)
            bcfg.set(chan_id, f"{slot}.disp", " ".join(toks)); _save_battles(bcfg)


    def _tracker_remove_tag(self, bcfg, chan_id, slot: str, tag: str):
        disp = bcfg.get(chan_id, f"{slot}.disp", fallback="").strip()
        toks = [t for t in disp.split() if t]
        if tag in toks:
            toks = [t for t in toks if t != tag]
            if toks:
                bcfg.set(chan_id, f"{slot}.disp", " ".join(toks))
            else:
                                                                                  
                if bcfg.has_option(chan_id, f"{slot}.disp"):
                    bcfg.remove_option(chan_id, f"{slot}.disp")
            _save_battles(bcfg)


    @staticmethod
    def _infect_with_disease(tgt_name, tgt_cfg, tgt_path, bcfg, chan_id):
                                                                              
        if not tgt_cfg.has_section("cur"):
            tgt_cfg.add_section("cur")
        tgt_cfg["cur"]["disease"] = "1"
        write_cfg(tgt_path, tgt_cfg)

                                                                           
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_name) or tgt_name
            slot = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
            opt = f"{slot}.disp"
            if bcfg.has_option(chan_id, opt) and bcfg.get(chan_id, opt).strip().upper() == "DIS":
                bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)
        except Exception:
            pass


    def _cure_disease(self, tgt_name: str, tgt_cfg, tgt_path: str, bcfg, chan_id):
        if not tgt_cfg.has_section("cur"): tgt_cfg.add_section("cur")
        tgt_cfg["cur"]["disease"] = "0"
        write_cfg(tgt_path, tgt_cfg)
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_name) or tgt_name
            slot = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
            self._tracker_remove_tag(bcfg, chan_id, slot, "DIS")
        except Exception:
            pass


    async def _apply_turn_disease(self, ctx, bcfg, chan_id):
        """
        Call this once per !nt (one 10-minute turn passes).
        For each infected combatant: apply –1 CON (temp), then save vs Death;
        success cures, failure persists.
        """
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []

        if not names:
            return

        
        lines = []
        for name in names:
            disp, path = _resolve_char_ci(name)
            if not path: continue
            cfg = read_cfg(path)
            diseased = getint_compat(cfg, "cur", "disease", fallback=0) > 0
            if not diseased: continue

                                 
            hp_delta = self._apply_conloss_points(cfg, 1)
            write_cfg(path, cfg)
            cur_con, temp, perm, peak, base = self._get_con_state(cfg)
            line = f"**{disp}**: −1 CON (temp → {temp}; cur CON {cur_con})"
            if hp_delta != 0:
                                                                             
                max_hp = getint_compat(cfg, "max", "hp", fallback=0)
                line += f"; Max HP {'+' if hp_delta>0 else ''}{hp_delta} (from CON), now {max_hp}"

                                          
            ok, roll, dc, _ = self._roll_save(cfg, vs="poi", penalty=0)
            if ok:
                self._cure_disease(disp, cfg, path, bcfg, chan_id)
                line += f"\n→ Save vs Death: {roll} vs {dc} **SUCCESS** — disease **cured**."
            else:
                line += f"\n→ Save vs Death: {roll} vs {dc} **FAIL** — disease **persists**."

            lines.append(line)

        if lines:
            emb = nextcord.Embed(
                title="🦠 Disease Progression (Turn passes)",
                description="\n\n".join(lines),
                color=0x7f1d1d
            )
            await ctx.send(embed=emb)

    async def _auto_apply_negative_levels(
        self,
        ctx,
        target_name: str,
        tgt_cfg,
        tgt_path: str,
        n_levels: int = 1,
        source: str = "Energy Drain",
        embed=None,
    ):

        
        def _ef(name: str, value: str, inline: bool = False):
            try:
                if embed is not None and hasattr(embed, "add_field"):
                    embed.add_field(name=name, value=value, inline=inline)
            except Exception:
                pass

        
        try:
            found = _pfed_find_equipped(tgt_cfg)
        except Exception:
            found = None

        absorbed_lines = []
        if found:
            slot_pf, disp_pf, core_pf = found
            cur_pf, mx_pf = _pfed_seed_if_missing(tgt_cfg, tgt_path, core_pf)
            to_absorb = min(max(1, int(n_levels)), int(cur_pf or 0))
            if to_absorb > 0:
                new_cur, _mx  = _pfed_consume(tgt_cfg, tgt_path, core_pf, to_absorb)
                absorbed_lines.append(
                    f"🛡️ **Protection from Energy Drain** absorbs **{to_absorb}** negative level{'s' if to_absorb!=1 else ''} → charges **{new_cur}/{mx_pf}**."
                )
                if new_cur <= 0:
                    _pfed_disintegrate(tgt_cfg, tgt_path, slot_pf, disp_pf, core_pf)
                    absorbed_lines.append("✨ The device **disintegrates into golden sparkles.**")

                
                if to_absorb >= n_levels:
                    _ef("Energy Drain", "\n".join(absorbed_lines), inline=False)
                    return {"hp_after": getint_compat(tgt_cfg, "cur", "hp", fallback=0)}

                
                n_levels = max(0, int(n_levels) - to_absorb)
                if absorbed_lines:
                    _ef("Energy Drain", "\n".join(absorbed_lines), inline=False)

        
        cls = (get_compat(tgt_cfg, "info", "class", fallback="") or "").strip()
        sides = _class_hitdie_sides(cls)

        rolls_all = []
        total_loss = 0
        n_levels = max(1, int(n_levels))
        for _ in range(n_levels):
            s, rolls, flat = roll_dice(f"1d{sides}")
            loss = s + flat
            rolls_all.extend(rolls)
            total_loss += max(0, loss)

        cur_levels = getint_compat(tgt_cfg, "cur", "neg_levels", fallback=0)
        cur_pool   = getint_compat(tgt_cfg, "cur", "neg_hp_loss_total", fallback=0)
        new_levels = cur_levels + n_levels
        new_pool   = cur_pool + total_loss

        if not tgt_cfg.has_section("cur"):
            tgt_cfg.add_section("cur")
        tgt_cfg["cur"]["neg_levels"] = str(new_levels)
        tgt_cfg["cur"]["neg_hp_loss_total"] = str(new_pool)

        old_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
        hp_now = max(0, old_hp - total_loss)
        tgt_cfg["cur"]["hp"] = str(hp_now)
        write_cfg(tgt_path, tgt_cfg)
        _clamp_hp_to_cap(tgt_cfg, tgt_path)
        tgt_cfg = read_cfg(tgt_path)
        hp_after = getint_compat(tgt_cfg, "cur", "hp", fallback=hp_now)

        is_mon = _is_monster_file(tgt_path)
        locks_applied, locks_leftover = self._lock_highest_slots_now(tgt_cfg, n_levels)
        write_cfg(tgt_path, tgt_cfg)

        mhp = getint_compat(tgt_cfg, "max", "hp", fallback=0)
        cap = _effective_max_hp(tgt_cfg)

        _ef(
            "Energy Drain",
            f"**{source}** — {n_levels} negative level{'s' if n_levels!=1 else ''}\n"
            f"HP loss: {n_levels} × 1d{sides} → [{', '.join(map(str, rolls_all))}] = **{total_loss}**",
            inline=False
        )
        _ef("Penalties (cumulative)", f"• d20 rolls: **{-new_levels}**\n• Percentile rolls: **{-5 * new_levels}%**", inline=True)

        if not is_mon:
            _ef("HP", f"{old_hp} → **{hp_after}**\nCap: {mhp} − {new_pool} = **{cap}**", inline=True)

        if not is_mon:
            if locks_applied:
                piece = _format_lock_pieces(locks_applied)
                extra = f"\n({locks_leftover} lock{'s' if locks_leftover!=1 else ''} deferred to next long rest.)" if locks_leftover else ""
                _ef("Slots", f"Locked now: {piece}{extra}\nPrepared spells unchanged. L0 unaffected.", inline=False)
            else:
                _ef("Slots", "No slots available to lock right now. Will be enforced at next long rest.\nPrepared spells unchanged. L0 unaffected.", inline=False)

        if hp_after <= 0:
            _ef("Status", "☠️ **SLAIN BY ENERGY DRAIN** (GM adjudicates transformation if undead source).", inline=False)
        else:
            _ef("Status", f"Negative Levels: **{new_levels}**  •  Tracker tag: **[NL {new_levels}]**", inline=False)

        try:
            if hp_after <= 0 and _is_monster_file(tgt_path):
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    pretty = (target_name or "").strip()
                    key = _find_ci_name(names, pretty) or pretty
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        try: slot = _slot(key)
                        except Exception: slot = key.replace(" ", "_")
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return {
            "hp_after": hp_after,
            "n_levels_added": n_levels,
            "locks_applied": dict(locks_applied),
            "locks_leftover": locks_leftover,
            "rolls": list(rolls_all),
            "hp_loss": total_loss,
        }


    def _caster_profile(self, info_class: str, channel=None) -> dict | None:
        """
        Map sheet class → slot source, list source, book-based flag, and the
        casting ability used for CANTRIPS (L0). Honors HR: magethief_illusionist_list.
        """
        c = (info_class or "").strip().lower()

        if c in {"magic-user", "magicuser"}:
            return {"slots_class":"Magic-User","list_class":"Magic-User","book_based":True, "cantrip_ability":"int"}
        if c in {"illusionist"}:
            return {"slots_class":"Magic-User","list_class":"Illusionist","book_based":True, "cantrip_ability":"int"}
        if c in {"spellcrafter"}:
            return {"slots_class":"Spellcrafter","list_class":"Spellcrafter","book_based":True, "cantrip_ability":"int"}
        if c in {"necromancer"}:
            return {"slots_class":"Necromancer","list_class":"Necromancer","book_based":True, "cantrip_ability":"int"}
        if c in {"fightermage","fighter/magic-user","fighter-magic-user"}:
            return {"slots_class":"Magic-User","list_class":"Magic-User","book_based":True, "cantrip_ability":"int"}

        if c in {"magethief","mage/thief","mage-thief","magic-user/thief"}:
            use_illu = self._hr_enabled_proxy(channel, "magethief_illusionist_list", True)
            lst = "Illusionist" if use_illu else "Magic-User"
            return {"slots_class":"Magic-User","list_class":lst,"book_based":True, "cantrip_ability":"int"}

        if c in {"cleric"}:
            return {"slots_class":"Cleric","list_class":"Cleric","book_based":False, "cantrip_ability":"wis"}
        if c in {"paladin"}:
            return {"slots_class":"Paladin","list_class":"Cleric","book_based":False, "cantrip_ability":"wis"}
        if c in {"druid"}:
            return {"slots_class":"Druid","list_class":"Druid","book_based":False, "cantrip_ability":"wis"}

        return None


    def _monster_attack_is_named_ranged(self, attack_name: str) -> bool:
        
        k = re.sub(r"[^a-z0-9]+", "", (attack_name or "").lower())
        return k in {"longbow","shortbow","sling","lightxbow","heavyxbow"}


    def _pnm_active_for(self, bcfg, chan_id: str, target_disp: str | None) -> bool:
        """Return True if target has Protection from Normal Missiles active (bcfg slot '.pnm' > 0)."""
        try:
            if bcfg and bcfg.has_section(chan_id) and target_disp:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, target_disp) or target_disp
                s = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                return bcfg.getint(chan_id, f"{s}.pnm", fallback=0) > 0
        except Exception:
            pass
        return False


    def _pc_attack_is_normal_missile(self,
                                     canon_name: str,
                                     item: dict,
                                     is_oil: bool,
                                     is_holy: bool,
                                     weapon_type: str,
                                     short, med, longr,
                                     rng_long: bool,
                                     is_magical_attack: bool) -> bool:
        """Decide if a PC’s attack is a *normal* missile (subject to PFNM)."""
        if is_magical_attack:
            return False
        if is_oil:
            return True
                                                                                                
        if is_holy:
            return False

        wtyp = (weapon_type or "").lower()
        if wtyp in {"missile","ranged","bow","xbow","thrown"}:
            return True
        try:
            if self._is_halfling_missile_weapon(canon_name, item):
                return True
        except Exception:
            pass
        if any(bool(x) for x in (short, med, longr)) or rng_long:
            return True
        return False


    def _monster_naturals(self, mcfg):
        """
        Read natural attacks from a monster INI that looks like:
          [base]
          attacknames = Bite Claw Hug
          Bite = 1d8
          Claw = 1d4
          Hug  = 2d8
        Returns: {'bite':'1d8','claw':'1d4','hug':'2d8'}
        """
        try:
            names_raw = (get_compat(mcfg, "base", "attacknames", fallback="") or "").strip()
        except Exception:
            names_raw = ""
        names = [n for n in re.split(r"[,\s]+", names_raw) if n]                    

                                                                                 
        if not names:
            try:
                for k, v in mcfg.items("base"):
                    if re.match(r"^\s*\d+d\d+(\s*[+-]\s*\d+)?\s*$", str(v)):
                        names.append(k)
            except Exception:
                pass

        out = {}
        for nm in names:
            for key in (nm, nm.capitalize(), nm.lower()):
                dmg = (get_compat(mcfg, "base", key, fallback="") or "").strip()
                if dmg:
                    out[nm.lower()] = dmg
                    break
        return out


    async def _apply_start_of_turn_stoneskin(self, ctx, bcfg, chan_id, who_pretty: str, who_path: str):
        """
        Decrease the Stoneskin duration when a creature's turn begins.
        If the timer hits 0, clear any remaining pool.
        """
        try:
            if not (bcfg and bcfg.has_section(chan_id)):
                return
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, who_pretty) or who_pretty
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            rounds_key, pool_key, by_key = self._stone_keys(slot)
            dur = bcfg.getint(chan_id, rounds_key, fallback=0)
            if dur <= 0:
                return

            dur -= 1
            if dur <= 0:
                                                       
                left = bcfg.getint(chan_id, pool_key, fallback=0)
                for k in (rounds_key, pool_key, by_key):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k)
                _save_battles(bcfg)
                try:
                    embed = nextcord.Embed(
                        title="⏳ Stoneskin expires",
                        description=f"**{who_pretty}**’s skin returns to flesh. Any remaining buffer is lost.",
                        color=random.randint(0, 0xFFFFFF),
                    )
                    if left > 0:
                        embed.add_field(name="Unused buffer", value=f"{left}", inline=True)
                    await ctx.send(embed=embed)
                except Exception:
                    pass
            else:
                bcfg.set(chan_id, rounds_key, str(dur))
                _save_battles(bcfg)
        except Exception:
            pass


    def _canon_init_key(bcfg, chan_id: str, display_or_typed_name: str) -> str:
        """
        Return the exact initiative key for a combatant, matching case-insensitively.
        Falls back to whatever we were given if not in initiative yet.
        """
        if not (bcfg and bcfg.has_section(chan_id) and display_or_typed_name):
            return (display_or_typed_name or "").strip()
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []
        typed = (display_or_typed_name or "").strip()
        return _find_ci_name(names, typed) or typed


    def _ss_find_slot(self, bcfg, chan_id: str, target_disp: str) -> str:
        """
        Find the *initiative slot* that corresponds to a target display name.
        Tries (1) initiative name CI match, (2) .disp field exact match, else falls back.
        """
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []

                                           
        try:
            key = _find_ci_name(names, (target_disp or "").strip())
        except Exception:
            key = None
        if key:
            try:
                return _slot(key)
            except Exception:
                return key.replace(" ", "_")

                                                                 
        want = (target_disp or "").strip().lower()
        for n in names or []:
            try:
                s = _slot(n)
            except Exception:
                s = n.replace(" ", "_")
            disp = (bcfg.get(chan_id, f"{s}.disp", fallback="") or "").strip().lower()
            if disp == want or n.strip().lower() == want:
                return s

                                                                                 
        return (target_disp or "").replace(" ", "_")


    def _ss_resolve_slot(self, bcfg, chan_id: str, name_or_slot: str) -> str:
        """
        Resolve to the actual Stoneskin slot used in the tracker.
        If the given string already maps to a slot that has Stoneskin keys, keep it; else find it via _ss_find_slot.
        """
        s_guess = (name_or_slot or "").replace(" ", "_")
        try:
            _, pool_key, _ = self._stone_keys(s_guess)
            if bcfg.has_option(chan_id, pool_key):
                return s_guess
        except Exception:
            pass
        return self._ss_find_slot(bcfg, chan_id, name_or_slot)


    def _stoneskin_absorb(self, bcfg, chan_id: str, name_or_slot: str, dmg_in: int):
                                                      
        return self._ss_absorb_by_name(bcfg, chan_id, name_or_slot, dmg_in)


    def _ss_absorb_by_name(self, bcfg, chan_id, target_name_or_slot: str, incoming_dmg: int):
        if incoming_dmg <= 0 or not (bcfg and bcfg.has_section(chan_id)):
            return incoming_dmg, 0, None, False

        slot = self._ss_resolve_slot(bcfg, chan_id, target_name_or_slot)
        r_key, p_key, b_key, dur, pool = self._ss_read_keys_and_state(bcfg, chan_id, slot)

        if dur <= 0 or pool <= 0:
            return incoming_dmg, 0, (pool if pool > 0 else None), False

        absorbed  = min(incoming_dmg, pool)
        remain    = pool - absorbed
        dmg_after = incoming_dmg - absorbed

        if remain <= 0:
            for k in (r_key, p_key, b_key):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)

            for base in (f"{slot}.x_stoneskin", f"{slot}.x_stone"):
                for suf in ("", "_code", "_label", "_emoji", "_by"):
                    opt = f"{base}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)

            for opt in (
                f"{slot}.x_stonehp",
                f"{slot}.x_stone_pool",
                f"{slot}.stonerounds",
                f"{slot}.stonedur",
                f"{slot}.stone_pool",
            ):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
        else:
            bcfg.set(chan_id, p_key, str(remain))


        _save_battles(bcfg)
        return dmg_after, absorbed, remain, (remain <= 0)


    def _ss_soak(self, bcfg, chan_id, target_display_or_key, incoming):
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, target_display_or_key) or target_display_or_key
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")
        return self._ss_absorb_by_name(bcfg, chan_id, slot, incoming)


                                               
                             


    def _stone_keys(self, slot: str):
        s = (slot or "").strip()
        return (f"{s}.stone", f"{s}.stonehp", f"{s}.stone_by")


    def _ss_read_keys_and_state(self, bcfg, chan_id: str, slot: str):
        """Return (rounds_key, pool_key, by_key, dur, pool) with alias fallback."""
        r_key, p_key, b_key = self._stone_keys(slot)

        dur = bcfg.getint(chan_id, r_key, fallback=-1)
        if dur < 0:
            for rk in (f"{slot}.stone", f"{slot}.stonerounds", f"{slot}.stonedur"):
                v = bcfg.getint(chan_id, rk, fallback=-1)
                if v >= 0:
                    r_key, dur = rk, v
                    break
            else:
                dur = 0

        pool = bcfg.getint(chan_id, p_key, fallback=-1)
        if pool < 0:
            for pk in (f"{slot}.stonehp",
                       f"{slot}.ss_pool", f"{slot}.sspool",
                       f"{slot}.ssbuf", f"{slot}.stoneskin", f"{slot}.ss"):
                v = bcfg.getint(chan_id, pk, fallback=-1)
                if v >= 0:
                    p_key, pool = pk, v
                    break
            else:
                pool = 0

        return r_key, p_key, b_key, max(0, dur), max(0, pool)


    async def _attack_delayedblastfireball(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        chan_id = str(ctx.channel.id)

        color = 0xCC5533
        if not tokens:
            embed = nextcord.Embed(
                title="💣 Delayed Blast Fireball",
                description="Add targets: `!a delayedblastfireball goblin orc ...`",
                color=color
            )
            await ctx.send(embed=embed); return

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if not (bcfg and bcfg.has_section(chan_id)):
            embed = nextcord.Embed(
                title="💣 Delayed Blast Fireball",
                description="No armed DBF in this channel.",
                color=color
            )
            await ctx.send(embed=embed); return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

                       
        has_arm = (bcfg.has_option(chan_id, f"{s_me}.x_dbf") or
                   bcfg.has_option(chan_id, f"{s_me}.dbf_die"))
        if not has_arm:
            embed = nextcord.Embed(
                title="💣 Delayed Blast Fireball",
                description=f"**{caster_name}** has no armed DBF. Cast it first: `!cast delayedblastfireball`.",
                color=color
            )
            await ctx.send(embed=embed); return

                                                                  
        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
        if not cur_turn or cur_turn.lower() != me_key.lower():
            embed = nextcord.Embed(
                title="💣 Delayed Blast Fireball",
                description=f"**{caster_name}** can throw the bead only on their turn.",
                color=color
            )
            await ctx.send(embed=embed); return

                                                         
        die_spec = bcfg.get(chan_id, f"{s_me}.dbf_die", fallback="1d6")
        flat     = bcfg.getint(chan_id, f"{s_me}.dbf_flat", fallback=1)

                                                        
        total, rolls, add = roll_dice(die_spec)
        base_dmg = max(0, total + add + flat)

        lines = []
        any_hp_changes = False
        dead_monsters = []

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in tokens:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

                            
            cleared = self._mi_clear_all_if_present(ctx, pretty)
            if cleared:
                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")

                                       
            absorbs_fire = ("fire" in _collect_absorb_types(t_cfg))

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                ok = False
            if absorbs_fire:
                ok = False

            dmg = base_dmg // 2 if ok else base_dmg

            final, note = _apply_mitigation(dmg, weapon_name="Delayed Blast Fireball", weapon_type="fire", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

            dead_note = " ☠️ **DEAD!**" if new_hp <= 0 else ""
            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                hp_txt = f"{before} → {after}{dead_note}"
            else:
                hp_txt = f"{old_hp} → **{new_hp}**{dead_note}"

            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            res_txt  = "**RESIST**" if ok else "**FAIL**"
            auto_txt = " (auto-fail: absorbs fire)" if absorbs_fire else ""
            amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"

            dup_heal = (final < 0) and note and ("heals" in note.lower())
            amt_part = "" if dup_heal else f" → {amt_txt}"

            line = f"{pretty}: Save vs. Spells {sv_roll}{pen_txt} vs {sv_dc} → {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


                                
        if dead_monsters:
            try:
                names, scores = _parse_combatants(bcfg, chan_id)
                for pretty, path in dead_monsters:
                    key = _find_ci_name(names, pretty) or pretty
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                _write_combatants(bcfg, chan_id, names, scores)
                                        
                current_turn = bcfg.get(chan_id, "turn", fallback="")
                if current_turn and current_turn not in names:
                    ents = _sorted_entries(bcfg, chan_id)
                    bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                _save_battles(bcfg)
            except Exception:
                pass

            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass

                                                      
        for key in ("x_dbf","x_dbf_label","x_dbf_emoji","x_dbf_code","dbf_die","dbf_flat","dbf_by"):
            opt = f"{s_me}.{key}"
            if bcfg.has_option(chan_id, opt):
                bcfg.remove_option(chan_id, opt)
        _save_battles(bcfg)

                       
        rolls_txt = ", ".join(str(r) for r in rolls)
        head = f"💥 **{die_spec}** [{rolls_txt}] + **{flat}** = **{base_dmg}**"
        embed = nextcord.Embed(
            title="💣 Delayed Blast Fireball",
            description=f"**{caster_name}** hurls the bead! (20′ radius)",
            color=color
        )
        embed.add_field(name="Damage", value=head, inline=False)
        embed.add_field(name="Results", value="\n".join(lines) or "(no valid targets)", inline=False)
        await ctx.send(embed=embed)

                                                        
        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


    def _mi_clear_all_if_present(self, ctx, target_display: str) -> int:
        """
        For AoE: set images to 0 if present. Returns number cleared.
        """
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if not bcfg.has_section(chan_id):
                return 0
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, target_display) or target_display
            if key not in names:
                return 0
            _, imgs_key = self._mi_keys(bcfg, chan_id, key)
            imgs = bcfg.getint(chan_id, imgs_key, fallback=0)
            if imgs > 0:
                bcfg.set(chan_id, imgs_key, "0")
                _save_battles(bcfg)
            return imgs
        except Exception:
            return 0


    async def _attack_sword(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        

        chan_id = str(ctx.channel.id)

        if not tokens:
            embed = nextcord.Embed(
                title="🗡️ Sword",
                description="*(Add a target: `!a sword <target>`)*",
                color=0x8888FF,
            )
            await ctx.send(embed=embed)
            return

                                              
        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            embed = nextcord.Embed(
                title="🗡️ Sword",
                description=f"**{tokens[0]}**: *(not found)*",
                color=0xFF6666,
            )
            await ctx.send(embed=embed)
            return

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if not (bcfg and bcfg.has_section(chan_id)):
            embed = nextcord.Embed(
                title="🗡️ Sword",
                description="*(No active battle for tracking.)*",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key   = _find_ci_name(names, caster_name) or caster_name
        s_me     = self._effect_slot_for(bcfg, chan_id, me_key)

        rounds_left = bcfg.getint(chan_id, f"{s_me}.swd", fallback=0)
        if rounds_left <= 0:
            embed = nextcord.Embed(
                title="🗡️ Sword",
                description=f"**{caster_name}** has no active Sword.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        turn_name = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
        if not turn_name or turn_name.lower() != me_key.lower():
            embed = nextcord.Embed(
                title="🗡️ Sword",
                description=f"**{caster_name}** can direct the sword **only on their turn**.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        cur_round  = bcfg.getint(chan_id, "round", fallback=1)
        last_round = bcfg.getint(chan_id, f"{s_me}.swd_last_round", fallback=0)
        if last_round == cur_round:
            embed = nextcord.Embed(
                title="🗡️ Sword",
                description="Already attacked **this round**.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

                                                         
        try:
            self._hyp_break_if_targeted(chan_id, [tgt_disp])
        except Exception:
            pass

        classes_tbl = getattr(self, "classes", {})
        ftr_ab = (classes_tbl.get("fighter", {}) or {}).get("ab", [])
        level  = getint_compat(caster_cfg, "cur", "level", fallback=max(1, caster_level or 1))
        ab_ftr = ftr_ab[min(max(1, level) - 1, len(ftr_ab) - 1)] if ftr_ab else 0
        int_mod = getint_compat(caster_cfg, "stats", "int_modifier", fallback=0)

        d20 = random.randint(1, 20)
        is_crit = (d20 >= 19)               
        total_to_hit = d20 + ab_ftr + int_mod

                   
        t_cfg = read_cfg(tgt_path)
        try:
            target_ac = int(str(get_compat(t_cfg, "stats", "ac", fallback="") or "").strip() or 10)
        except Exception:
            target_ac = 10

        hit = is_crit or (total_to_hit >= target_ac)

        d20_face = "**20** 🎉" if d20 == 20 else ("**1** 💀" if d20 == 1 else str(d20))
        ab_txt   = f"+ {ab_ftr}" if ab_ftr >= 0 else str(ab_ftr)
        im_txt   = f"+ {int_mod}" if int_mod >= 0 else str(int_mod)
        attack_line = f"{d20_face} {ab_txt} {im_txt} = ``{total_to_hit}``"
        color = 0x66CC66 if hit else 0xCC6666

        embed = nextcord.Embed(
            title="🗡️ Sword",
            description=f"**{caster_name}** directs the blade at **{tgt_disp}**!",
            color=color,
        )
        embed.add_field(name="Attack roll", value=f"{attack_line}", inline=True)
        embed.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

        if hit and tgt_disp:
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
            except Exception:
                consumed, left = (False, 0)
            if consumed:
                bcfg.set(chan_id, f"{s_me}.swd_last_round", str(cur_round))
                _save_battles(bcfg)
                embed.add_field(
                    name="Mirror Image",
                    value=f"A figment is struck and shatters. Images remaining: **{left}**.",
                    inline=False
                )
                await ctx.send(embed=embed)
                return

        if not hit:
            bcfg.set(chan_id, f"{s_me}.swd_last_round", str(cur_round))
            _save_battles(bcfg)
            await ctx.send(embed=embed)
            return

        dmg_sum, rolls, flat = roll_dice("3d4")
        raw = dmg_sum + flat
        raw_crit = raw * 2 if is_crit else raw
        final, note = _apply_mitigation(
            raw_crit,
            weapon_name="Sword (spell)",
            weapon_type="force",
            t_cfg=t_cfg,
            is_magical=true,
        )

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        dmg_line = f"3d4 [{', '.join(str(r) for r in rolls)}] = ``{raw}``"
        if is_crit:
            dmg_line += f" → x2 = ``{raw_crit}``"
        if note:
            dmg_line += f"\n→ **{note}** → ``{final}``"
        if is_crit:
            embed.add_field(name="Critical", value="**19–20** → **CRITICAL HIT!**", inline=False)
        embed.add_field(name="Damage", value=dmg_line, inline=False)

                              
        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_tail = f"{before} → **{after}**"
        else:
            hp_tail = f"{old_hp} → **{new_hp}**"
        if new_hp <= 0:
            hp_tail += " ☠️ **DEAD!**"
        embed.add_field(name="Target HP", value=hp_tail, inline=False)

                              
        bcfg.set(chan_id, f"{s_me}.swd_last_round", str(cur_round))
        _save_battles(bcfg)

                               
        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                names2, scores2 = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names2, tgt_disp) or tgt_disp
                if key in names2:
                    names2 = [n for n in names2 if n != key]
                    if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                    s = _slot(key)
                    for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                        opt = f"{s}{suf}"
                        if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names2, scores2)
                    if bcfg.get(chan_id, "turn", fallback="") == key:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

                                
        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        await ctx.send(embed=embed)


    def _has_true_seeing(self, bcfg, chan_id: str, slot_att: str) -> bool:
                                                             
        for k in ("ts", "trueseeing", "x_trueseeing"):
            if bcfg.getint(chan_id, f"{slot_att}.{k}", fallback=0) > 0:
                return True
        return False


    def _is_invisible(self, bcfg, chan_id: str, slot_def: str) -> bool:
        return (bcfg.getint(chan_id, f"{slot_def}.inv", fallback=0) > 0
                or bcfg.getint(chan_id, f"{slot_def}.inv_perm", fallback=0) > 0)


    def _blur_active_for(self, bcfg, chan_id: str, slot_def: str) -> bool:
                                                
        return (bcfg.getint(chan_id, f"{slot_def}.x_blur", fallback=0) > 0
                or bcfg.getint(chan_id, f"{slot_def}.x_blur_perm", fallback=0) > 0)


    def _blur_clear_marks_for_attacker(self, bcfg, chan_id: str, slot_att: str):
        """Clear this attacker’s per-turn blur 'first attack' markers."""
        try:
            for opt_key, _ in list(bcfg.items(chan_id)):
                if opt_key.startswith(f"{slot_att}.blur_vs_"):
                    bcfg.remove_option(chan_id, opt_key)
            _save_battles(bcfg)
        except Exception:
            pass


    def _blur_penalty_for_attack(self, bcfg, chan_id: str, atk_name: str, slot_att: str, tgt_name: str):
        """
        Returns (penalty_int, note_text or None). Applies −4 for first attempt by this attacker vs this target
        this turn, then marks so future attempts this turn are −2.
        Suppressed if attacker has True Seeing or cannot see the target (e.g., target Invisible).
        """
                               
        names, _ = _parse_combatants(bcfg, chan_id)
        name_key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            slot_def = _slot(name_key)
        except Exception:
            slot_def = name_key.replace(" ", "_")

                                                                                              
        if not self._blur_active_for(bcfg, chan_id, slot_def):
            return 0, None
        if self._has_true_seeing(bcfg, chan_id, slot_att):
            return 0, "Attacker has **True Seeing** — Blur ignored."
        if self._is_invisible(bcfg, chan_id, slot_def):
            return 0, "Defender is **Invisible** — Blur irrelevant."

        used_key = f"{slot_att}.blur_vs_{slot_def}"
        if bcfg.has_option(chan_id, used_key):
            return -2, "Defender is **BLURRED** (−2 to this successive attack)."
                                      
        bcfg.set(chan_id, used_key, "1"); _save_battles(bcfg)
        return -4, "Defender is **BLURRED** (−4 to the first attack this turn)."


    def _displacement_active_for(self, bcfg, chan_id: str, slot_def: str) -> bool:
        return (bcfg.getint(chan_id, f"{slot_def}.x_displacement", fallback=0) > 0
                or bcfg.getint(chan_id, f"{slot_def}.x_displacement_perm", fallback=0) > 0)


    def _displacement_penalty_for_attack(self, bcfg, chan_id: str, atk_name: str, slot_att: str, tgt_name: str):
        """
        Returns (penalty_int, note_text or None) for Displacement only.
        −4 to hit if defender is displaced, unless attacker has True Seeing or cannot see the defender (e.g., defender Invisible).
        """
                               
        names, _ = _parse_combatants(bcfg, chan_id)
        name_key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            slot_def = _slot(name_key)
        except Exception:
            slot_def = name_key.replace(" ", "_")

        if not self._displacement_active_for(bcfg, chan_id, slot_def):
            return 0, None
        if self._has_true_seeing(bcfg, chan_id, slot_att):
            return 0, "Attacker has **True Seeing** — Displacement ignored."
        if self._is_invisible(bcfg, chan_id, slot_def):
            return 0, "Defender is **Invisible** — Displacement irrelevant."

        return -4, "Defender is **DISPLACED** (−4 to hit)."
           

    def _apply_stinkingcloud_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:

        def _resolve_char_ci_local(name: str):
                                                                  
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        def _is_constructish_cfg(t_cfg, disp: str) -> bool:
            try:
                blob = " ".join([
                    (get_compat(t_cfg, "base", "type", fallback="") or ""),
                    (get_compat(t_cfg, "info", "race", fallback="") or ""),
                    (disp or ""),
                ]).lower()
                for kw in ("construct", "golem", "animated object", "statue"):
                    if kw in blob: return True
            except Exception:
                pass
            return False

        lines = []
        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not (tgt_path and os.path.exists(tgt_path)):
                lines.append(f"• **{raw}**: ❌ *(not found)*"); continue

            t_cfg = read_cfg(tgt_path)

                         
            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"• **{tgt_disp}**: ☠️ Undead — **no effect**."); continue
            except Exception:
                pass
            if _is_constructish_cfg(t_cfg, tgt_disp):
                lines.append(f"• **{tgt_disp}**: 🛠️ Construct — **no effect**."); continue

                                                                                         
            try:
                if getattr(self, "_poison_immune", None) and self._poison_immune(t_cfg):
                    lines.append(f"• **{tgt_disp}**: 🧪 Poison-immune — **no effect**."); continue
            except Exception:
                pass

                                             
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                                                                                
                sv_ok = False

            if sv_ok:
                lines.append(f"• **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} → ✅ **RESISTED**")
                continue

                                                                              
            s, rolls, flat = roll_dice("1d4+1")
            add_rounds = s + flat

                                                                                                 
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")

                cur_left = bcfg.getint(chan_id, f"{slot}.x_nauseated", fallback=0)
                new_left = max(cur_left, int(add_rounds))
                bcfg.set(chan_id, f"{slot}.x_nauseated", str(new_left))
                bcfg.set(chan_id, f"{slot}.x_nauseated_code", "NA")
                bcfg.set(chan_id, f"{slot}.x_nauseated_label", "NA")
                bcfg.set(chan_id, f"{slot}.x_nauseated_by", caster_name)
                _save_battles(bcfg)

                lines.append(
                    f"• **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} → **FAIL** — "
                    f"**NAUSEATED** for **{add_rounds} rounds**"
                )
            else:
                lines.append(
                    f"• **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} → **FAIL** — "
                    f"would be **Nauseated** for **{add_rounds} rounds** (no active battle)."
                )

        return lines


    async def _attack_stinkingcloud(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active = False
        left = 0
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            left = bcfg.getint(chan_id, f"{s_me}.sc", fallback=0)
            active = left > 0

        color = 0x55DD55 if active else 0xAAAAAA
        desc  = (f"**{caster_name}** steers the reeking fog!" if active
                 else f"**{caster_name}** has no active Stinking Cloud.")
        embed = nextcord.Embed(title="💨 Stinking Cloud", description=desc, color=color)

        if active:
            embed.add_field(name="Cloud", value=f"Rounds remaining: **{left}**", inline=True)
            lines = self._apply_stinkingcloud_to_targets(chan_id, bcfg, caster_name, caster_level, tokens or [])
            if lines:
                embed.add_field(name="Effect", value="\n".join(lines), inline=False)

        await ctx.send(embed=embed)

                                
        try:
            bcfg2 = _load_battles()
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


    def _apply_stinkingcloud_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        
        lines = []
        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"• **{raw}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)

                                                                        
            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"• **{tgt_disp}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass
            try:
                if self._poison_immune(t_cfg):
                    lines.append(f"• **{tgt_disp}**: 🧪 Poison-immune — **no effect**.")
                    continue
            except Exception:
                pass

                                                         
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is not None and sv_ok:
                lines.append(f"• **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} → ✅ **RESISTED**")
                continue

            dur = random.randint(1, 4) + 1
                                                                                              
            slot = _choose_slot_for_effects(bcfg, chan_id, tgt_disp)
            base = f"{slot}.x_nausea"

            cur = bcfg.getint(chan_id, base, fallback=0)
            newv = max(cur, dur)                                                  
            bcfg.set(chan_id, base, str(newv))
            bcfg.set(chan_id, f"{base}_label", "NA")
            bcfg.set(chan_id, f"{base}_code",  "NA")
            bcfg.set(chan_id, f"{base}_by",    caster_name)
            _save_battles(bcfg)

            lines.append(f"• **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} →  🤢 **NAUSEATED** for **{dur}** rounds" + (f" *(now {newv})*" if newv != dur else ""))

        return lines


    def _true_seeing_active_for(self, bcfg, chan_id: str, name: str) -> bool:
        try:
            if not (bcfg and bcfg.has_section(chan_id) and name):
                return False
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, name) or name
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
                                                                             
            return (bcfg.getint(chan_id, f"{slot}.x_truesight", fallback=0) > 0) or\
                   (bcfg.getint(chan_id, f"{slot}.true",        fallback=0) > 0)
        except Exception:
            return False


    def _get_str_state(self, cfg):
        """Return (effective_str, temp_loss, base_str). We mirror your CON helpers."""
        eff = getint_compat(cfg, "stats", "str", fallback=None)
        if eff is None:
            eff = getint_compat(cfg, "base",  "str", fallback=10)                       
                                                
            if not cfg.has_section("stats"): cfg.add_section("stats")
            cfg["stats"]["str"] = str(eff)
        temp = getint_compat(cfg, "cur", "str_loss_temp", fallback=0)
        base = eff + temp                                                 
        return eff, temp, base


    def _set_str_state(self, cfg, *, eff=None, temp=None):
        """Persist effective STR and/or temp loss."""
        if eff is not None:
            if not cfg.has_section("stats"): cfg.add_section("stats")
            cfg["stats"]["str"] = str(max(0, int(eff)))
        if temp is not None:
            if not cfg.has_section("cur"): cfg.add_section("cur")
            cfg["cur"]["str_loss_temp"] = str(max(0, int(temp)))


    def _apply_strloss_points(self, pcfg, points: int) -> tuple[int, bool, bool]:
        """
        Apply N points of *temporary* STR loss. Returns (applied, died, collapsed_now).
        - Collapsed = STR <= 2 (can't move).
        - STR 0 = Dead (you can handle removal/loot elsewhere).
        """
        n = max(0, int(points or 0))
        if n == 0:
            return (0, False, False)

        eff, temp, base = self._get_str_state(pcfg)
        applied = 0
        died = False
        collapsed_now = False

        for _ in range(n):
            if eff <= 0:                         
                died = True
                break
            temp += 1
            eff  = max(0, eff - 1)
            applied += 1
            if eff == 0:
                died = True
                break

                 
        self._set_str_state(pcfg, eff=eff, temp=temp)

        if eff <= 2 and eff > 0:
            collapsed_now = True

        return (applied, died, collapsed_now)


    def _recover_one_point_of_str(self, pcfg) -> tuple[int, int, bool]:
        """
        Heal 1 point of STR if temp loss > 0. Returns (new_eff, new_temp, stood_up_now).
        """
        eff, temp, base = self._get_str_state(pcfg)
        if temp <= 0:
            return (eff, temp, False)

        new_temp = max(0, temp - 1)
        new_eff  = min(base, eff + 1)                                          
        stood_up = (eff <= 2 and new_eff >= 3)

        self._set_str_state(pcfg, eff=new_eff, temp=new_temp)
        return (new_eff, new_temp, stood_up)


    async def _attack_chill(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)

                    
        if not tokens:
            embed = nextcord.Embed(
                title="🥶 Chill (follow-up)",
                description="*(Add a target: `!a chill <target>` — only usable in the round after casting.)*",
                color=0x88CCFF,
            )
            await ctx.send(embed=embed)
            return

                     
        want_heat = any(t.lower() in {"-heat","-heat"} for t in tokens)
        names = [t for t in tokens if not t.startswith("-")]
        raw = names[0] if names else None
        if not raw:
            await ctx.send("🥶 **Chill** — *(No target provided.)*")
            return

                            
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        rounds_left, charges = 0, 0
        s_self = None
        if bcfg and bcfg.has_section(chan_id):
            try:
                names_b, _ = _parse_combatants(bcfg, chan_id)
                ci = _find_ci_name(names_b, caster_name) or caster_name
                s_self = _choose_slot_for_effects(bcfg, chan_id, ci) if '_choose_slot_for_effects' in globals() else _slot(ci)
                rounds_left = bcfg.getint(chan_id, f"{s_self}.chl", fallback=0)
                charges     = bcfg.getint(chan_id, f"{s_self}.chl_charges", fallback=0)
            except Exception:
                pass

        if rounds_left <= 0 or charges <= 0:
            await ctx.send("🥶 **Chill** — no follow-up is available.")
            return
        if rounds_left >= 2:
            await ctx.send("🥶 **Chill** — your follow-up is **not ready until next round**.")
            return

                        
        try:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
        except Exception:
            tgt_disp, tgt_path = None, None
        if not tgt_path:
            await ctx.send(f"🥶 **Chill** — **{raw}**: *(not found)*")
            return

        t_cfg = read_cfg(tgt_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            await ctx.send(f"🥶 **Chill** — **{tgt_disp}**: ⚠️ No HP field.")
            return
        if old_hp <= 0:
            await ctx.send(f"🥶 **Chill** — **{tgt_disp}** is already ☠️ **dead**.")
            return

                    
        d4 = random.randint(1, 4)
        new_hp = max(0, old_hp - d4)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        heat_bonus = 2 if want_heat else 0
        try:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", bonus=heat_bonus)
        except TypeError:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=(-heat_bonus))
        except Exception:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=0)
        if sv_dc is None:
            sv_ok = False

                                
        debuff_line = ""
        if not sv_ok and bcfg and bcfg.has_section(chan_id):
            rounds = random.randint(1, 6)
            try:
                slotT = _choose_slot_for_effects(bcfg, chan_id, tgt_disp)
            except Exception:
                slotT = tgt_disp.replace(" ", "_")
            bcfg.set(chan_id, f"{slotT}.x_chilldebuff",       str(rounds))
            bcfg.set(chan_id, f"{slotT}.x_chilldebuff_code",  "CH")
            bcfg.set(chan_id, f"{slotT}.x_chilldebuff_label", "Chilled (melee -1)")
            bcfg.set(chan_id, f"{slotT}.x_chilldebuff_emoji", "🥶")
            bcfg.set(chan_id, f"{slotT}.x_chilldebuff_by",    caster_name)

                                                                  
        if bcfg and bcfg.has_section(chan_id) and s_self:
            try:
                bcfg.set(chan_id, f"{s_self}.chl_charges", "0")
                bcfg.set(chan_id, f"{s_self}.chl", "0")
                _save_battles(bcfg)
            except Exception:
                pass

                                            
        try:
            is_monster = _is_monster_file(tgt_path)
        except Exception:
            is_monster = False

        try:
            if is_monster:
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp or 1)
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                hp_txt = f"{before} → **{after}**"
            else:
                hp_txt = f"{old_hp} → **{new_hp}**"
        except Exception:
            hp_txt = f"{old_hp} → **{new_hp}**"

        if new_hp <= 0:
            hp_txt += " ☠️ **DEAD!**"


        heat_txt = " (+2 from heat)" if want_heat else ""
        sv_txt = f"Save vs Paralysis {sv_roll} vs {sv_dc}{heat_txt} → " + ("✅ **RESISTED**" if sv_ok else "**FAIL**")
        if not sv_ok:
            debuff_line = "\n• **Debuff**: **Chilled** *(–1 melee hit & dmg)* for **1d6** rounds."
        embed = nextcord.Embed(
            title="🥶 Chill (follow-up)",
            description=(
                f"**{caster_name}** chills **{tgt_disp}**!\n"
                f"• Damage: **1d4 = {d4}**\n"
                f"{hp_txt}\n"
                f"• {sv_txt}{debuff_line}"
            ),
            color=0x88CCFF
        )
        
        
                                                         
        if new_hp <= 0 and is_monster and bcfg and bcfg.has_section(chan_id):
            try:
                names2, scores2 = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names2, tgt_disp) or tgt_disp
                if key in names2:
                    names2 = [n for n in names2 if n != key]
                    if bcfg.has_option(chan_id, key):
                        bcfg.remove_option(chan_id, key)
                    s = _slot(key)
                    for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                        opt = f"{s}{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names2, scores2)
                    if bcfg.get(chan_id, "turn", fallback="") == key:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

                                
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        
        await ctx.send(embed=embed)


    async def _do_chillray_shot(self, ctx, caster_name: str, caster_cfg, raw_target: str, want_heat: bool) -> str:
        

                 
        try:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw_target)
        except Exception:
            tgt_disp, tgt_path = None, None
        if not tgt_path:
            return f"• **{raw_target}**: *(not found)*"

        t_cfg = read_cfg(tgt_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            return f"• **{tgt_disp}**: ⚠️ No HP field."
        if old_hp <= 0:
            return f"• **{tgt_disp}**: already ☠️ **dead**."

                                            
        d4 = random.randint(1,4); base = d4 + 1
        new_hp = max(0, old_hp - base)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

                                           
        heat_bonus = 2 if want_heat else 0
        try:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", bonus=heat_bonus)
        except TypeError:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=(-heat_bonus))
        except Exception:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=0)
        if sv_dc is None:
            sv_ok = False

                              
        debuff_line = ""
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        if (not sv_ok) and bcfg:
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                rounds = random.randint(1,6)
                try:
                    slotT = _choose_slot_for_effects(bcfg, chan_id, tgt_disp) if '_choose_slot_for_effects' in globals() else _slot(tgt_disp)
                except Exception:
                    slotT = tgt_disp.replace(" ", "_")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff",       str(rounds))
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_code",  "CH")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_label", "Chilled (melee -1)")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_emoji", "🥶")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_by",    caster_name)
                _save_battles(bcfg)
                debuff_line = f"\n• **Debuff**: **Chilled** *(–1 melee hit & dmg)* for **{rounds}** rounds."

                 
        try:
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_txt = f"{before} → **{after}**"
        except Exception:
            hp_txt = f"{old_hp} → **{new_hp}**"

                                                 
        if new_hp <= 0:
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if is_mon and bcfg and bcfg.has_section(str(ctx.channel.id)):
                try:
                    names, scores = _parse_combatants(bcfg, str(ctx.channel.id))
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(str(ctx.channel.id), key):
                            bcfg.remove_option(str(ctx.channel.id), key)
                        s = key.replace(" ","_")
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(str(ctx.channel.id), opt):
                                bcfg.remove_option(str(ctx.channel.id), opt)
                        _write_combatants(bcfg, str(ctx.channel.id), names, scores)
                        if bcfg.get(str(ctx.channel.id), "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, str(ctx.channel.id))
                            bcfg.set(str(ctx.channel.id), "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass

        heat_txt = " (+2 from heat)" if want_heat else ""
        sv_txt = f"Save vs Paralysis {sv_roll} vs {sv_dc}{heat_txt} → " + ("✅ **RESISTED**" if sv_ok else "**FAIL**")
        tail = "  ☠️ **DEAD!**" if new_hp <= 0 else ""
        return (
            f"• **{tgt_disp}** is struck for **1d4+1 = {base}** cold.\n"
            f"{hp_txt}{tail}\n"
            f"• {sv_txt}{debuff_line}"
        )


    async def _attack_chillray(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        want_heat = any(t.lower() in {"-heat","-heat"} for t in tokens or [])
        names = [t for t in (tokens or []) if not t.startswith("-")]
        raw = names[0] if names else None

                 
        bcfg = None
        try:
            bcfg = _load_battles()
        except Exception:
            pass

        active = False
        if bcfg and bcfg.has_section(chan_id):
            try:
                names_b, _ = _parse_combatants(bcfg, chan_id)
                ci = _find_ci_name(names_b, caster_name) or caster_name
                s  = _choose_slot_for_effects(bcfg, chan_id, ci) if '_choose_slot_for_effects' in globals() else _slot(ci)
            except Exception:
                s = caster_name.replace(" ", "_")
            active = bcfg.getint(chan_id, f"{s}.cr", fallback=0) > 0

        if not active:
            await ctx.send("❄️ **Chill Ray** — no active ray to fire.")
            return
        if not raw:
            await ctx.send("❄️ **Chill Ray** — *(Add a target: `!a chillray <target>`)*")
            return

        text = await self._do_chillray_shot(ctx, caster_name, caster_cfg, raw, want_heat)
        embed = nextcord.Embed(title="❄️ Chill Ray", description=text, color=0x66DDEE)
        await ctx.send(embed=embed)

                                   
        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


    def _apply_stench_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        
        lines = []

                                                                            
        pen_levels = 0
        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                me_key = _find_ci_name(names, caster_name) or caster_name
                s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
                pen_levels = bcfg.getint(chan_id, f"{s_me}.stencha_pen", fallback=int(caster_level // 3))
        except Exception:
            pen_levels = int(caster_level // 3)

        for raw in tokens:
                     
            try:
                tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            except Exception:
                tgt_disp, tgt_path = self._resolve_char_ci(raw)
            if not tgt_path:
                lines.append(f"• **{raw}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)

                         
            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"• **{tgt_disp}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass
                             
            try:
                if self._poison_immune(t_cfg):
                    lines.append(f"• **{tgt_disp}**: 🧪 Poison-immune — **no effect**.")
                    continue
            except Exception:
                pass

                                                         
            try:
                ok, roll, dc, _ = self._roll_save(t_cfg, vs="poi", penalty=pen_levels)
            except TypeError:
                ok, roll, dc, _ = self._roll_save(t_cfg, vs="poi", bonus=(-pen_levels))
            pen_show = f" - {pen_levels if pen_levels else 0}"

            if ok:
                lines.append(f"• **{tgt_disp}**: Save vs Poison {roll}{pen_show} vs {dc} → ✅ **RESISTED**")
                continue

                                                    
            s2, _rolls2, flat2 = roll_dice("2d6")
            sick_r = s2 + flat2
            self._apply_sickened(bcfg, chan_id, tgt_disp, caster_name, sick_r, penalty=-2)
            lines.append(f"• **{tgt_disp}**: Save vs Poison {roll}{pen_show} vs {dc} → **FAIL** → **SICKENED** for **2d6 = {sick_r}** rounds.")

        return lines


    async def _attack_stench(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active = False
        left = 0
        pen = max(0, int(caster_level // 3))
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
            left   = bcfg.getint(chan_id, f"{s_me}.stencha", fallback=0)
            pen    = bcfg.getint(chan_id, f"{s_me}.stencha_pen", fallback=pen)
            active = left > 0

        color = 0x88BB66 if active else 0xAAAAAA
        desc  = (f"**{caster_name}** lets the reek roll over the foes!" if active
                 else f"**{caster_name}** has no active Stench aura.")
        embed = nextcord.Embed(title="🤢 Stench Aura", description=desc, color=color)

        if active:
            embed.add_field(name="Aura", value=f"Rounds remaining: **{left}**", inline=True)
            embed.add_field(name="Save penalty", value=f"**−{pen}**", inline=True)
            lines = self._apply_stench_to_targets(chan_id, bcfg, caster_name, caster_level, tokens or [])
            if lines:
                embed.add_field(name="Effect", value="\n".join(lines), inline=False)

        await ctx.send(embed=embed)

                                
        try:
            bcfg2 = _load_battles()
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


    def _apply_symbolofpain_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """Apply the PAIN status to targets: −4 to hit, −4 damage, −4 saves, with a 1-hour (600 rounds) tail."""
        lines = []
        tail_rounds = 600               

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"• **{raw}**: ❌ *(not found)*")
                continue

                                                                             
            try:
                t_cfg = read_cfg(tgt_path)
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"• **{tgt_disp}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass

            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key   = _find_ci_name(names, tgt_disp) or tgt_disp
                s_tgt = self._effect_slot_for(bcfg, chan_id, key)

                                                               
                bcfg.set(chan_id, f"{s_tgt}.pain_pen",     "-4")                             
                bcfg.set(chan_id, f"{s_tgt}.pain_dmg_pen", "-4")                              
                bcfg.set(chan_id, f"{s_tgt}.pain_sv_pen",  "-4")                                             

                                                                                 
                                                                
                                                                   
                                                                             
                                                                
                                                                           
                cur_tail = bcfg.getint(chan_id, f"{s_tgt}.x_pain_n", fallback=0)
                bcfg.set(chan_id, f"{s_tgt}.x_pain_n", str(max(cur_tail, tail_rounds)))
                bcfg.set(chan_id, f"{s_tgt}.x_pain_by", caster_name)

                _save_battles(bcfg)

                lines.append(f"• **{tgt_disp}**: 😖 **PAIN** — **−4** to hit, damage, and saving throws. Tail: **1 hour** after leaving.")
            except Exception:
                lines.append(f"• **{tgt_disp}**: ⚠️ error applying effect (GM adjudicates).")

        return lines


    async def _attack_symbolofpain(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        color = 0xAAAAAA
        desc  = f"**{caster_name}** has no active Symbol of Pain."
        embed = nextcord.Embed(title="🪡 Symbol of Pain", description=desc, color=color)

        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send(embed=embed)
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

                                                                      
        stored_lvl = bcfg.getint(chan_id, f"{s_me}.sop_level", fallback=int(caster_level))
        active_rounds = max(1, int(stored_lvl)) * 60

        sop_ready = bcfg.getint(chan_id, f"{s_me}.sop_ready", fallback=0) > 0
        sop_left  = bcfg.getint(chan_id, f"{s_me}.sop",       fallback=0)
        sp_left   = bcfg.getint(chan_id, f"{s_me}.x_sp_n",    fallback=0)

                                                                            
        sop_left = max(sop_left, sp_left)

                                                           
        just_triggered = False
        if sop_left <= 0 and sop_ready and tokens:
            sop_left = active_rounds
            bcfg.set(chan_id, f"{s_me}.sop", str(sop_left))

                                                                   
            bcfg.set(chan_id, f"{s_me}.x_sp_code",  "SP")
            bcfg.set(chan_id, f"{s_me}.x_sp_label", "Symbol of Pain")
            bcfg.set(chan_id, f"{s_me}.x_sp_emoji", "🪡")
            bcfg.set(chan_id, f"{s_me}.x_sp_n",     str(sop_left))
            _save_battles(bcfg)
            just_triggered = True

        active = sop_left > 0

        if active:
            color = 0xFF6666
            embed.color = color
            embed.description = f"**{caster_name}** invokes the symbol."
            embed.add_field(name="Symbol", value=f"Rounds remaining: **{sop_left}**", inline=True)

                                                          
            bcfg.set(chan_id, f"{s_me}.x_sp_n", str(sop_left))
            _save_battles(bcfg)

            if tokens:
                lines = self._apply_symbolofpain_to_targets(chan_id, bcfg, caster_name, stored_lvl, tokens or [])
                if lines:
                    embed.add_field(name="Effect", value="\n".join(lines), inline=False)
        else:
            if sop_ready:
                embed.add_field(
                    name="Rune",
                    value="Rune is **dormant**. Provide one or more targets to **trigger** it now.",
                    inline=False
                )
            else:
                embed.add_field(
                    name="Status",
                    value="No symbol is present (discharged or dispelled).",
                    inline=False
                )

        await ctx.send(embed=embed)


    def _apply_symboloffear_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Apply Symbol of Fear to targets:
          • Save vs Spells.
              - FAIL: Set fear timer for 1 round/level (FR). Note: −2 to all saves while panicked.
                      (Optionally add a PANIC x-tag.)
              - SUCCESS: SHAKEN for 1 round (–2 atk & saves) as a reminder x-tag.
        """
        lines = []
        rounds = max(1, int(caster_level or 1))

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path:
                lines.append(f"• **{pretty}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
                            
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)

            if sv_ok:
                                                                                             
                slot = self._effect_slot_for(bcfg, chan_id, pretty)
                                                                                       
                bcfg.set(chan_id, f"{slot}.x_shk_n",     "1")
                bcfg.set(chan_id, f"{slot}.x_shk_code",  "SHK")
                bcfg.set(chan_id, f"{slot}.x_shk_label", "Shaken")
                bcfg.set(chan_id, f"{slot}.x_shk_by",    caster_name)
                _save_battles(bcfg)

                lines.append(f"• **{pretty}**: Save {sv_roll} vs {sv_dc} → ✅ **RESISTED** → **SHAKEN 1 round** *(–2 atk & saves)*")
                continue

                                                                          
            slot = self._effect_slot_for(bcfg, chan_id, pretty)

                                                               
            bcfg.set(chan_id, f"{slot}.fear",     str(rounds))
            bcfg.set(chan_id, f"{slot}.fear_src", "symboloffear")
            bcfg.set(chan_id, f"{slot}.fear_by",  caster_name)

                                                                                        
            bcfg.set(chan_id, f"{slot}.x_pnc_n",     str(rounds))
            bcfg.set(chan_id, f"{slot}.x_pnc_code",  "PNC")
            bcfg.set(chan_id, f"{slot}.x_pnc_label", "Panic")
            bcfg.set(chan_id, f"{slot}.x_pnc_by",    caster_name)

            _save_battles(bcfg)

            lines.append(
                f"• **{pretty}**: Save {sv_roll} vs {sv_dc} → **FAIL** → 😵 **PANICKED** for **{rounds} rounds** — "
                f"drops held, flees (cowers if cornered). *While panicked: −2 to all saving throws.*"
            )

        return lines


    async def _attack_symboloffear(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        color = 0xAAAAAA
        desc  = f"**{caster_name}** has no active Symbol of Fear."
        embed = nextcord.Embed(title="😱 Symbol of Fear", description=desc, color=color)

        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send(embed=embed)
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

                                                    
        stored_lvl = bcfg.getint(chan_id, f"{s_me}.sof_level", fallback=int(caster_level))
        active_rounds = max(1, int(stored_lvl)) * 60

        sof_ready = bcfg.getint(chan_id, f"{s_me}.sof_ready", fallback=0) > 0
        sof_left  = bcfg.getint(chan_id, f"{s_me}.sof",       fallback=0)
        sf_left   = bcfg.getint(chan_id, f"{s_me}.x_sf_n",    fallback=0)

                                                                            
        sof_left = max(sof_left, sf_left)

                                                   
        just_triggered = False
        if sof_left <= 0 and sof_ready and tokens:
            sof_left = active_rounds
            bcfg.set(chan_id, f"{s_me}.sof", str(sof_left))

                                                
            bcfg.set(chan_id, f"{s_me}.x_sf_code",  "SF")
            bcfg.set(chan_id, f"{s_me}.x_sf_label", "Symbol of Fear")
            bcfg.set(chan_id, f"{s_me}.x_sf_emoji", "😱")
            bcfg.set(chan_id, f"{s_me}.x_sf_n",     str(sof_left))
            _save_battles(bcfg)
            just_triggered = True

        active = sof_left > 0

        if active:
            color = 0xFFCC66
            embed.color = color
            embed.description = f"**{caster_name}** invokes the symbol."
            embed.add_field(name="Symbol", value=f"Rounds remaining: **{sof_left}**", inline=True)

                                                          
            bcfg.set(chan_id, f"{s_me}.x_sf_n", str(sof_left))
            _save_battles(bcfg)

            if tokens:
                lines = self._apply_symboloffear_to_targets(chan_id, bcfg, caster_name, stored_lvl, tokens or [])
                if lines:
                    embed.add_field(name="Effect", value="\n".join(lines), inline=False)
        else:
            if sof_ready:
                embed.add_field(
                    name="Rune",
                    value="Rune is **dormant**. Provide one or more targets to **trigger** it now.",
                    inline=False
                )
            else:
                embed.add_field(
                    name="Status",
                    value="No symbol is present (discharged or dispelled).",
                    inline=False
                )

        await ctx.send(embed=embed)


    def _apply_symbolofdeath_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Apply Symbol of Death to targets:
          • If already marked SDOK (prior success) while active → skip re-save.
          • Else Save vs Spells or die.
          • On success (or PFED), stamp SDOK with countdown matching the symbol’s remaining duration.
        """
        
        lines = []
        names, _ = _parse_combatants(bcfg, chan_id)

        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
        sod_left = max(
            0,
            bcfg.getint(chan_id, f"{s_me}.sod",    fallback=0),
            bcfg.getint(chan_id, f"{s_me}.x_sd_n", fallback=0),
        )

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path:
                lines.append(f"• **{pretty}**: ❌ *(not found)*")
                continue

            
            try:
                t_cfg = read_cfg(tgt_path)
                if _is_undead_cfg(t_cfg, pretty):
                    lines.append(f"• **{pretty}**: ☠️ Undead — **no effect**.")
                    continue
            except Exception:
                pass

            
            try:
                s_tgt = self._effect_slot_for(bcfg, chan_id, pretty)
                if bcfg.getint(chan_id, f"{s_tgt}.x_sdok_n", fallback=0) > 0:
                    lines.append(f"• **{pretty}**: Already **resisted this symbol** — no further effect (until they leave & re-enter).")
                    continue
            except Exception:
                pass

            t_cfg = read_cfg(tgt_path)
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)

            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                sv_ok = False

            if sv_ok:
                
                s_tgt = self._effect_slot_for(bcfg, chan_id, pretty)
                if sod_left > 0:
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_n",     str(sod_left))
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_code",  "SDOK")
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_label", "Saved vs Symbol (Death)")
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_by",    caster_name)
                    _save_battles(bcfg)
                lines.append(f"• **{pretty}**: Save vs **Spells** {sv_roll} vs {sv_dc} → ✅ **RESISTED** *(won’t save again unless they leave & re-enter)*")
                continue

            
            used, pfed_note = _pfed_try_absorb_sp(t_cfg, tgt_path, tag="death")
            if used:
                try:
                    s_tgt = self._effect_slot_for(bcfg, chan_id, pretty)
                    if sod_left > 0:
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_n",     str(sod_left))
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_code",  "SDOK")
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_label", "Saved vs Symbol (Death)")
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_by",    caster_name)
                        _save_battles(bcfg)
                except Exception:
                    pass
                lines.append(f"• **{pretty}**: {pfed_note} *(won’t save again unless they leave & re-enter)*")
                continue

            
            died_text = "☠️ **DEAD!**"
            if old_hp is None:
                lines.append(f"• **{pretty}**: Save vs **Spells** → **FAIL** — {died_text}")
            else:
                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)

                try:
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    before = _life_bar(old_hp, mhp, width=10)
                    after  = _life_bar(0, mhp, width=10)
                    lines.append(f"• **{pretty}**: Save vs **Spells** {sv_roll} vs {sv_dc} → **FAIL**\n{before} → **{after}** {died_text}")
                except Exception:
                    lines.append(f"• **{pretty}**: Save vs **Spells** {sv_roll} vs {sv_dc} → **FAIL**\nHP {old_hp} → **0** {died_text}")

                
                try:
                    is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
                except Exception:
                    is_mon = False
                if is_mon and bcfg and bcfg.has_section(chan_id):
                    try:
                        names2, scores2 = _parse_combatants(bcfg, chan_id)
                        key2 = _find_ci_name(names2, pretty) or pretty
                        if key2 in names2:
                            names2 = [n for n in names2 if n != key2]
                            if bcfg.has_option(chan_id, key2):
                                bcfg.remove_option(chan_id, key2)
                            s2 = _slot(key2)
                            for suf in (
                                ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                ".paralyzed",".blind",".blind_src",".blind_by",
                                ".cc_blind_pending",".cs_blind_pending",
                                ".cc",".cc_by",".cc_level",
                                ".ck",".ck_by",".ck_level",
                                ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                            ):
                                opt = f"{s2}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names2, scores2)
                            cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                            if cur_turn == key2:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                    except Exception:
                        pass
                    try:
                        os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass

        return lines

    async def _attack_symbolofdeath(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        color = 0xAAAAAA
        desc  = f"**{caster_name}** has no active Symbol of Death."
        embed = nextcord.Embed(title="💀 Symbol of Death", description=desc, color=color)

        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send(embed=embed)
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

                                                            
        stored_lvl = bcfg.getint(chan_id, f"{s_me}.sod_level", fallback=int(caster_level))
        active_rounds = max(1, int(stored_lvl)) * 60

        sod_ready = bcfg.getint(chan_id, f"{s_me}.sod_ready", fallback=0) > 0
        sod_left  = bcfg.getint(chan_id, f"{s_me}.sod",       fallback=0)
        sd_left   = bcfg.getint(chan_id, f"{s_me}.x_sd_n",    fallback=0)

                                   
        sod_left = max(sod_left, sd_left)

                                                   
        if sod_left <= 0 and sod_ready and tokens:
            sod_left = active_rounds
            bcfg.set(chan_id, f"{s_me}.sod", str(sod_left))
            bcfg.set(chan_id, f"{s_me}.x_sd_code",  "SD")
            bcfg.set(chan_id, f"{s_me}.x_sd_label", "Symbol of Death")
            bcfg.set(chan_id, f"{s_me}.x_sd_emoji", "💀")
            bcfg.set(chan_id, f"{s_me}.x_sd_n",     str(sod_left))
            _save_battles(bcfg)

        active = sod_left > 0

        if active:
            color = 0x333333
            embed.color = color
            embed.description = f"**{caster_name}** invokes the symbol."
            embed.add_field(name="Symbol", value=f"Rounds remaining: **{sod_left}**", inline=True)

                                            
            bcfg.set(chan_id, f"{s_me}.x_sd_n", str(sod_left))
            _save_battles(bcfg)

            if tokens:
                lines = self._apply_symbolofdeath_to_targets(chan_id, bcfg, caster_name, stored_lvl, tokens or [])
                if lines:
                    embed.add_field(name="Effect", value="\n".join(lines), inline=False)
        else:
            if sod_ready:
                embed.add_field(name="Rune", value="Rune is **dormant**. Provide one or more targets to **trigger** it now.", inline=False)
            else:
                embed.add_field(name="Status", value="No symbol is present (discharged or dispelled).", inline=False)

        await ctx.send(embed=embed)

                                                                         
        try:
            bcfg2 = _load_battles()
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


    def _iter_carried_slots(self, cfg):
        """Return [(idx, 'carryN', name, qty)] for all carried slots (qty defaults to 1)."""
        
        out = []
        if not cfg.has_section("eq"):
            return out
        for opt, val in cfg.items("eq"):
            if opt.startswith("carry") and not opt.endswith("_qty"):
                m = re.fullmatch(r"carry(\d+)", opt)
                if not m:
                    continue
                idx = int(m.group(1))
                name = (val or "").strip()
                try:
                    q = int(cfg.get("eq", f"{opt}_qty", fallback="1"))
                except Exception:
                    q = 1
                out.append((idx, opt, name, max(1, q)))
        out.sort(key=lambda t: t[0])
        return out


    def _has_carried_item(self, cfg, canon_name: str) -> tuple[bool, int]:
        """(present?, total_qty) for a canon item across all carry slots."""
        want = normalize_name(canon_name)
        total = 0
        for _i, _k, nm, q in self._iter_carried_slots(cfg):
            if normalize_name(nm) == want:
                total += q
        return (total > 0), total


    def _consume_carried_item(self, cfg, canon_name: str, qty: int = 1) -> bool:
        """
        Remove qty from carried stacks of canon_name. Compacts carry slots.
        Returns True if fully removed, else False (insufficient carried qty).
        """
        if qty <= 0:
            return True
        want = normalize_name(canon_name)
        carried = self._iter_carried_slots(cfg)
        need = qty
        new_list = []
        for _idx, slot_key, nm, q in carried:
            if normalize_name(nm) == want and need > 0:
                take = min(q, need)
                q -= take
                need -= take
                if q > 0:
                    new_list.append((nm, q))
            else:
                new_list.append((nm, q))
        if need > 0:
            return False                      
                                  
        if not cfg.has_section("eq"):
            cfg.add_section("eq")
        for opt, _ in list(cfg.items("eq")):
            if opt.startswith("carry"):
                cfg.remove_option("eq", opt)
        for i, (nm, q) in enumerate(new_list, start=1):
            cfg.set("eq", f"carry{i}", nm)
            cfg.set("eq", f"carry{i}_qty", str(max(1, int(q))))
        return True


    @staticmethod
    def split_name_qty(raw: str) -> tuple[str, int]:
        
        s = (raw or "").strip()
        m = re.search(r'\b[x×]\s*(\d+)$', s, flags=re.I)
        if m:
            qty = int(m.group(1))
            name = s[:m.start()].strip()
            return (name, max(1, qty))
                                    
        m2 = re.search(r'\s(\d+)$', s)
        if m2:
            qty = int(m2.group(1))
            name = s[:m2.start()].strip()
            return (name, max(1, qty))
        return (s, 1)


    def _apply_eyebite_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]):
        

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rcfg = read_cfg(path)
                            real = get_compat(rcfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        def _hd_or_level_from_cfg(rcfg) -> int:
            try:
                v = getint_compat(rcfg, "cur", "level", fallback=None)
                if v is None:
                    v = getint_compat(rcfg, "stats", "hd", fallback=None)
                return max(1, int(v)) if v is not None else 1
            except Exception:
                return 1

        def _is_nonliving(rcfg) -> bool:
            ty = (str(get_compat(rcfg, "stats", "type", fallback="")) or
                  str(get_compat(rcfg, "info", "type",  fallback=""))).lower()
                                                            
            return any(k in ty for k in ("undead","construct","ooze","slime","golem"))

        def _roll_death_save(t_cfg):
                                                                 
            for tag in ("death","dr","deathray","death_ray"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)

        sick_rounds = max(1, int(caster_level) * 60)                
        coma_rounds = sick_rounds                                   
        lines = []
        applied_any = False

        for raw in tokens or []:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path or not os.path.exists(tgt_path):
                lines.append(f"• **{pretty}**: ❌ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
            if _is_nonliving(t_cfg):
                lines.append(f"• **{pretty}**: ❌ Non-living (undead/construct/ooze) — **no effect**.")
                continue

                             
            s_tgt = None
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    s_tgt = self._effect_slot_for(bcfg, chan_id, key)
                except Exception:
                    s_tgt = None

            hd = _hd_or_level_from_cfg(t_cfg)

                                               
            worst = None
            tier = ""
            if hd >= 10:
                tier = "≥10 HD"
                worst = "sickened"
            elif 5 <= hd <= 9:
                tier = "5–9 HD"
                worst = "panicked"
            else:
                tier = "≤4 HD"
                worst = "comatose"

                                                     
            sv_ok, sv_roll, sv_dc, _ = _roll_death_save(t_cfg)
            show_roll = "**20** 🎉" if sv_roll == 20 else ("**1** 💀" if sv_roll == 1 else str(sv_roll))
            avoided = sv_ok                     

                           
            apply_sick = False
            apply_panic = False
            apply_coma = False

            if hd >= 10:
                                                                     
                apply_sick = not avoided
            elif 5 <= hd <= 9:
                                                          
                apply_sick = True
                apply_panic = not avoided
            else:
                                                                     
                apply_sick = True
                apply_panic = True
                apply_coma = not avoided

                               
            notes = []
            if apply_coma and bcfg and bcfg.has_section(chan_id) and s_tgt:
                prev = bcfg.getint(chan_id, f"{s_tgt}.paralyzed", fallback=0)
                newv = max(prev, int(coma_rounds))
                if newv > 0:
                    bcfg.set(chan_id, f"{s_tgt}.paralyzed", str(newv))
                    bcfg.set(chan_id, f"{s_tgt}.paralyzed_by", "eyebite")
                                  
                self._clear_code_badges(bcfg, chan_id, s_tgt, "COMA")
                base = f"{s_tgt}.x_coma"
                bcfg.set(chan_id, base,               str(coma_rounds))
                bcfg.set(chan_id, f"{base}_label",    "Comatose")
                bcfg.set(chan_id, f"{base}_code",     "COMA")
                bcfg.set(chan_id, f"{base}_emoji",    "💤")
                bcfg.set(chan_id, f"{base}_by",       caster_name)
                notes.append(f"💤 **COMATOSE** for **{coma_rounds} rounds**.")

            if apply_panic and bcfg and bcfg.has_section(chan_id) and s_tgt:
                s, rolls, _ = roll_dice("1d4")
                fr = max(0, int(s))
                if fr > 0:
                    bcfg.set(chan_id, f"{s_tgt}.fear",     str(fr))
                    bcfg.set(chan_id, f"{s_tgt}.fear_src", "eyebite")
                    bcfg.set(chan_id, f"{s_tgt}.fear_by",  caster_name)
                    notes.append(f"😱 **PANICKED** for **{fr} rounds** ({', '.join(str(r) for r in rolls)}).")
                else:
                    notes.append("😱 **PANICKED** (brief).")

            if apply_sick and bcfg and bcfg.has_section(chan_id) and s_tgt:
                                                                              
                bcfg.set(chan_id, f"{s_tgt}.stench_pen", "-2")
                bcfg.set(chan_id, f"{s_tgt}.stench_label", "Sickened")
                bcfg.set(chan_id, f"{s_tgt}.stench_emoji", "🤢")
                base = f"{s_tgt}.x_stenchn"
                bcfg.set(chan_id, base,               str(sick_rounds))
                bcfg.set(chan_id, f"{base}_label",    "Sickened")
                bcfg.set(chan_id, f"{base}_code",     "SIC")
                bcfg.set(chan_id, f"{base}_emoji",    "🤢")
                bcfg.set(chan_id, f"{base}_by",       caster_name)
                notes.append(f"🤢 **SICKENED** for **{sick_rounds} rounds** (–2 atk/dmg/saves).")

            if notes:
                applied_any = True

                                      
            if sv_dc is not None:
                if avoided:
                    if worst == "sickened":
                                                          
                        lines.append(f"• **{pretty}** (HD {hd}, {tier}): Save vs Death {show_roll} vs {sv_dc} → ✅ avoids **Sickened**.")
                    else:
                        lines.append(f"• **{pretty}** (HD {hd}, {tier}): Save vs Death {show_roll} vs {sv_dc} → ✅ avoids **{worst.upper()}**.")
                else:
                    lines.append(f"• **{pretty}** (HD {hd}, {tier}): Save vs Death {show_roll} vs {sv_dc} → **FAIL**.")
            else:
                lines.append(f"• **{pretty}** (HD {hd}, {tier}): *(no save table — treating as failed)*")

            if notes:
                lines.append("  " + " ".join(notes))

            if bcfg and bcfg.has_section(chan_id) and s_tgt:
                _save_battles(bcfg)

                                              
        if applied_any:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    self._update_tracker_message                         
                                                                                                        
            except Exception:
                pass

        return applied_any, lines


    async def _attack_eyebite(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active = False
        left = 0
        can_use_now = True
        already_used_note = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            left = bcfg.getint(chan_id, f"{s_me}.eb", fallback=0)
            active = left > 0

                                           
            cur_rd = bcfg.getint(chan_id, "round", fallback=0)
            last_rd = bcfg.getint(chan_id, f"{s_me}.eb_last_round", fallback=-999)
            if tokens and cur_rd == last_rd:
                can_use_now = False
                already_used_note = f"Already used **Eyebite** this round (round {cur_rd})."

        color = 0x8A2BE2 if active else 0xAAAAAA
        desc  = (f"**{caster_name}** fixes a baleful stare…" if active
                 else f"**{caster_name}** has no active Eyebite.")
        embed = nextcord.Embed(title="👁️ Eyebite", description=desc, color=color)

        if active:
            embed.add_field(name="Window", value=f"Rounds remaining: **{left}**", inline=True)
            if tokens:
                if not can_use_now:
                    embed.add_field(name="Effect", value=already_used_note, inline=False)
                else:
                    applied, lines = self._apply_eyebite_to_targets(chan_id, bcfg, caster_name, caster_level, tokens)
                    if lines:
                        embed.add_field(name="Effect", value="\n".join(lines), inline=False)
                    if applied:
                        try:
                                                      
                            names, _ = _parse_combatants(bcfg, chan_id)
                            me_key = _find_ci_name(names, caster_name) or caster_name
                            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
                            cur_rd = bcfg.getint(chan_id, "round", fallback=0)
                            bcfg.set(chan_id, f"{s_me}.eb_last_round", str(cur_rd))
                            _save_battles(bcfg)
                                             
                            await self._update_tracker_message(ctx, bcfg, chan_id)
                        except Exception:
                            pass

        await ctx.send(embed=embed)


    def _equipped_weapon_names(self, cfg) -> list[str]:
        """Return the display names of currently equipped weapons for this character."""
        try:
            return list(self._eq_get_weapons(cfg) or [])
        except Exception:
            return []


    async def _prompt_paginated_selection(self, ctx, author, query: str, options: list[str], timeout_sec: float = 10.0) -> str | None:
        """
        Show a paginated list (10 per page). 
        Returns the chosen option string, or None on cancel/timeout.
        """
        page_size = 10
        total_pages = max(1, math.ceil(len(options) / page_size))
        page = 0
        deadline = asyncio.get_event_loop().time() + timeout_sec
        msg = None

        def make_embed():
            start = page * page_size
            chunk = options[start:start + page_size]
            listing = "\n".join(f"[{idx}] - {name}" for idx, name in enumerate(chunk, start=1))
            emb = nextcord.Embed(
                title="Multiple Matches Found",
                description=f"Your input was: `{query}`\nWhich one were you looking for? (Type the number or `c` to cancel)\n`n` for next page, `p` for previous",
                color=0x5865F2
            )
            emb.add_field(name=f"Page {page+1}/{total_pages}", value=listing or "*No items on this page*", inline=False)
            return emb, len(chunk)

        while True:
            remaining = deadline - asyncio.get_event_loop().time()
            if remaining <= 0:
                return None

            embed, count_on_page = make_embed()
            if msg is None:
                msg = await ctx.send(embed=embed)
            else:
                try:
                    await msg.edit(embed=embed)
                except Exception:
                    msg = await ctx.send(embed=embed)

            def check(m: nextcord.Message) -> bool:
                return (m.author.id == author.id) and (m.channel.id == ctx.channel.id)

            try:
                reply: nextcord.Message = await self.bot.wait_for("message", timeout=remaining, check=check)
            except asyncio.TimeoutError:
                return None

            content = reply.content.strip().lower()
            try:
                await reply.delete()
            except Exception:
                pass

            if content in {"c", "cancel"}:
                return None
            if content in {"n", "next"}:
                page = (page + 1) % total_pages
                continue
            if content in {"p", "prev", "previous"}:
                page = (page - 1) % total_pages
                continue
            if content.isdigit():
                n = int(content)
                if 1 <= n <= count_on_page:
                    start = page * page_size
                    return options[start + (n - 1)]
                                                             


    async def _resolve_weapon_from_partial(self, ctx, cfg, token: str, author) -> tuple[str | None, dict | None]:
        """
        Try to resolve `token` among **equipped** weapons with substring match.
        - If exactly one match → return it.
        - If multiple → interactive picker (10s).
        - If none → show 'not found' with suggestions; return (None, None).
        Returns (canon_name, item_dict) or (None, None) on fail.
        """
        token = (token or "").strip()
        eq = self._equipped_weapon_names(cfg)
        if not token or not eq:
            return (None, None)

                                                               
        t = token.lower()
        candidates = [w for w in eq if t in w.lower()]

                                                                                    
        if not candidates:
            starts = [w for w in eq if w.lower().startswith(t)]
            if starts:
                candidates = starts

        if not candidates:
                                             
            sug = difflib.get_close_matches(token, eq, n=5, cutoff=0.4)
            text = f"❌ Weapon not found for **{token}**."
            if sug:
                text += " Did you mean: " + ", ".join(f"`{s}`" for s in sug)
            else:
                text += " Currently equipped: " + (", ".join(f"`{w}`" for w in eq) if eq else "*none*")
            await ctx.send(text)
            return (None, None)

        if len(candidates) == 1:
            chosen = candidates[0]
        else:
            chosen = await self._prompt_paginated_selection(ctx, ctx.author, token, candidates, timeout_sec=10.0)
            if not chosen:
                await ctx.send("Selection timed out or was cancelled.")
                return (None, None)

                                                                   
        canon, item = self._item_lookup(chosen)
        if not item:
                                                                        
            canon, item = self.find_item(chosen)
        return (canon, item) if item else (None, None)


    async def _attack_controlhuman(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ) -> None:
        """
        Control Human (Potion): Gaze charm, 3 attempts while timer lasts.
        Usage: !a controlhuman <target> [-h|-hostile] [-nh|-nonhostile]
        """
        

        chan_id = str(ctx.channel.id)

        if not tokens:
            embed = nextcord.Embed(
                title="🧿 Control Human (Potion)",
                description="*(Add a humanoid target: `!a controlhuman <target>` — flags: `-h/-hostile`, `-nh/-nonhostile`)*",
                color=0x7A7ADB,
            )
            await ctx.send(embed=embed)
            return

        force_hostile = None                   
        raw_names: list[str] = []
        for t in tokens:
            tl = str(t).lower().strip()
            if tl in ("-h", "-hostile", "hostile", "+5"):
                force_hostile = True
            elif tl in ("-nh", "-nonhostile", "-calm", "nonhostile"):
                force_hostile = False
            else:
                raw_names.append(t)

        tgt_raw = raw_names[0] if raw_names else None
        if not tgt_raw:
            embed = nextcord.Embed(
                title="🧿 Control Human (Potion)",
                description="*(Add a humanoid target: `!a controlhuman <target>`)*",
                color=0x7A7ADB,
            )
            await ctx.send(embed=embed)
            return

        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(tgt_raw)
        if not tgt_path:
            embed = nextcord.Embed(
                title="🧿 Control Human (Potion)",
                description=f"**{tgt_raw}**: ❌ *(not found)*",
                color=0xFF6666,
            )
            await ctx.send(embed=embed)
            return

        t_cfg = read_cfg(tgt_path)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("❌ No initiative running here.")
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        ci = _find_ci_name(names, caster_name) or caster_name
        s = _slot(ci)

        rounds = bcfg.getint(chan_id, f"{s}.x_controlhuman", fallback=0)
        uses   = bcfg.getint(chan_id, f"{s}.controlhuman_uses", fallback=0)

        if rounds <= 0:
            await ctx.send(f"❌ **{caster_name}** has no active **Control Human** potion.")
            return
        if uses <= 0:
            await ctx.send(f"❌ **{caster_name}** has no **Control Human** uses left.")
            return

        ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
              str(get_compat(t_cfg, "info",  "type", fallback=""))).lower()
        non_humanoid = any(k in ty for k in (
            "undead","construct","golem","elemental","ooze","slime","plant",
            "vermin","beast","animal","dragon","demon","devil","fiend","ooze"
        ))
        if non_humanoid and "hum" not in ty:
            embed = nextcord.Embed(
                title="🧿 Control Human (Potion)",
                description=f"**{tgt_disp}**: not a humanoid — **no effect**.",
                color=0xFFAA33,
            )
            await ctx.send(embed=embed)
            return

        hostile = False
        if force_hostile is not None:
            hostile = bool(force_hostile)
        else:
            try:
                if bcfg.getint(chan_id, "round", fallback=0) >= 1:
                    hostile = True
            except Exception:
                pass
        bonus = 5 if hostile else 0

                                                                           
        used_vs = "Spells"
        sv_roll = None; sv_dc = None
        for vs_key in ("spell","sp","spells"):
            try:
                ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                if dc is not None:
                    sv_roll, sv_dc = r, dc
                    break
            except Exception:
                pass
        if sv_dc is None:
            sv_dc  = 15
            sv_roll = 10

        adj_roll = (sv_roll or 0) + bonus
        passed = adj_roll >= sv_dc
        d20_face = "**20** 🎉" if sv_roll == 20 else ("**1** 💀" if sv_roll == 1 else str(sv_roll))
        btxt = f" + {bonus}" if bonus else ""
        line = f"Save vs {used_vs}: {d20_face}{btxt} = ``{adj_roll}`` vs **{sv_dc}** → "

        uses_left = max(0, uses - 1)
        bcfg.set(chan_id, f"{s}.controlhuman_uses", str(uses_left))
        _save_battles(bcfg)
        if uses_left <= 0:
                                             
            _clear_control_timer(bcfg, chan_id, s, "controlhuman")                                        
            _save_battles(bcfg)
        if passed:
            color = 0xFF9966
            body = f"**{tgt_disp}** — {line}❌ **RESISTS**"
        else:
            color = 0x66CC88
            body = (
                f"**{tgt_disp}** — {line}"
                "💗 **CHARMED** — The target now regards the drinker as a trusted ally. "
                "Self-harm/ally-harming orders grant a new save at **+5** (GM adjudicates)."
            )

                                           
        code = bcfg.get(chan_id, f"{s}.x_controlhuman_code", fallback="CH") or "CH"

        embed = nextcord.Embed(
            title="🧿 Control Human (Potion)",
            description=body,
            color=color,
        )
        embed.add_field(name="Uses remaining", value=f"**{uses_left}**", inline=True)
        embed.add_field(name="Timer", value=f"**[{code} {rounds}]** on **{ci}**", inline=True)

        await ctx.send(embed=embed)

                                                                  
        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


    async def _attack_controlanimal(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        """
        Control Animal (Potion): Gaze charm vs **normal, non-magical animals**.
        Usage: !a controlanimal <target> [-h|-hostile] [-nh|-nonhostile]
        """
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Animal (Potion)",
                description="*(Add a target: `!a controlanimal <target>` — flags: `-h/-hostile`, `-nh/-nonhostile`)*",
                color=0x7A7ADB))
            return

                              
        force_hostile, names = None, []
        for t in tokens:
            tl = str(t).lower().strip()
            if tl in ("-h","-hostile","+5","hostile"): force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"): force_hostile = False
            else: names.append(t)
        tgt_raw = names[0] if names else None
        if not tgt_raw:
            await ctx.send("Usage: `!a controlanimal <target>`"); return

                     
        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try: return fn(name)
                except Exception: pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_"," ")), path
                        except Exception:
                            return fnm[:-4].replace("_"," "), path
            except Exception: pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(tgt_raw)
        if not tgt_path:
            await ctx.send(embed=nextcord.Embed(title="🧿 Control Animal (Potion)",
                                                description=f"**{tgt_raw}**: ❌ *(not found)*", color=0xFF6666)); return
        t_cfg = read_cfg(tgt_path)

                             
        try: bcfg = _load_battles()
        except Exception: bcfg = None
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("❌ No initiative running here."); return
        names, _ = _parse_combatants(bcfg, chan_id)
        ci = _find_ci_name(names, caster_name) or caster_name
        s = _slot(ci)
        rounds = bcfg.getint(chan_id, f"{s}.x_controlanimal", fallback=0)
        uses   = bcfg.getint(chan_id, f"{s}.controlanimal_uses", fallback=0)
        if rounds <= 0:
            await ctx.send(f"❌ **{caster_name}** has no active **Control Animal** potion."); return
        if uses <= 0:
            await ctx.send(f"❌ **{caster_name}** has no **Control Animal** uses left."); return

                                                
        ty = (str(get_compat(t_cfg,"stats","type",fallback="")) or str(get_compat(t_cfg,"info","type",fallback=""))).lower()
        is_animalish = ("animal" in ty) or ("beast" in ty)
        is_magical = any(k in ty for k in ("magical","enchanted","fae","fey","demon","devil","dragon","elemental","undead","construct"))
        if (not is_animalish) or is_magical:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Animal (Potion)",
                description=f"**{tgt_disp}**: not a **normal, non-magical animal** — **no effect**.",
                color=0xFFAA33)); return

                       
        hostile = False
        if force_hostile is not None: hostile = bool(force_hostile)
        else:
            try: hostile = bcfg.getint(chan_id, "round", fallback=0) >= 1
            except Exception: pass
        bonus = 5 if hostile else 0

                        
        used_vs="Spells"; sv_roll=None; sv_dc=None
        for vs_key in ("spell","sp","spells"):
            try:
                ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                if dc is not None: sv_roll, sv_dc = r, dc; break
            except Exception: pass
        if sv_dc is None: sv_dc=15; sv_roll=10
        adj = (sv_roll or 0) + bonus
        passed = adj >= sv_dc
        d20 = "**20** 🎉" if sv_roll==20 else ("**1** 💀" if sv_roll==1 else str(sv_roll))
        btxt = f" + {bonus}" if bonus else ""
        line = f"Save vs {used_vs}: {d20}{btxt} = ``{adj}`` vs **{sv_dc}** → "

                       
        uses_left = max(0, uses-1)
        bcfg.set(chan_id, f"{s}.controlanimal_uses", str(uses_left)); _save_battles(bcfg)
        if uses_left <= 0:
                                             
            _clear_control_timer(bcfg, chan_id, s, "controlanimal")                                        
            _save_battles(bcfg)
        code = bcfg.get(chan_id, f"{s}.x_controlanimal_code", fallback="CA") or "CA"
        if passed:
            color=0xFF9966; desc=f"**{tgt_disp}** — {line}❌ **RESISTS**"
        else:
            color=0x66CC88; desc=(f"**{tgt_disp}** — {line}💗 **CHARMED** — Obeys the drinker as an ally "
                                  "(self-harm/ally-harming orders grant a new save at **+5**).")

        embed = nextcord.Embed(title="🧿 Control Animal (Potion)", description=desc, color=color)
        embed.add_field(name="Uses remaining", value=f"**{uses_left}**", inline=True)
        embed.add_field(name="Timer", value=f"**[{code} {rounds}]** on **{ci}**", inline=True)
        await ctx.send(embed=embed)
        try: await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception: pass


    async def _attack_controlgiant(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        """
        Control Giant (Potion): Gaze charm vs **giants**.
        Usage: !a controlgiant <target> [-h|-hostile] [-nh|-nonhostile]
        """
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Giant (Potion)",
                description="*(Add a target: `!a controlgiant <target>` — flags: `-h/-hostile`, `-nh/-nonhostile`)*",
                color=0x7A7ADB)); return

        force_hostile, names = None, []
        for t in tokens:
            tl = str(t).lower().strip()
            if tl in ("-h","-hostile","+5","hostile"): force_hostile=True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"): force_hostile=False
            else: names.append(t)
        tgt_raw = names[0] if names else None
        if not tgt_raw:
            await ctx.send("Usage: `!a controlgiant <target>`"); return

        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try: return fn(name)
                except Exception: pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_"," ")), path
                        except Exception:
                            return fnm[:-4].replace("_"," "), path
            except Exception: pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(tgt_raw)
        if not tgt_path:
            await ctx.send(embed=nextcord.Embed(title="🧿 Control Giant (Potion)",
                                                description=f"**{tgt_raw}**: ❌ *(not found)*", color=0xFF6666)); return
        t_cfg = read_cfg(tgt_path)

        try: bcfg = _load_battles()
        except Exception: bcfg=None
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("❌ No initiative running here."); return
        names, _ = _parse_combatants(bcfg, chan_id)
        ci = _find_ci_name(names, caster_name) or caster_name
        s = _slot(ci)
        rounds = bcfg.getint(chan_id, f"{s}.x_controlgiant", fallback=0)
        uses   = bcfg.getint(chan_id, f"{s}.controlgiant_uses", fallback=0)
        if rounds <= 0:
            await ctx.send(f"❌ **{caster_name}** has no active **Control Giant** potion."); return
        if uses <= 0:
            await ctx.send(f"❌ **{caster_name}** has no **Control Giant** uses left."); return

        ty = (str(get_compat(t_cfg,"stats","type",fallback="")) or str(get_compat(t_cfg,"info","type",fallback=""))).lower()
        if "giant" not in ty:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Giant (Potion)",
                description=f"**{tgt_disp}**: not a **giant** — **no effect**.",
                color=0xFFAA33)); return

        hostile = False
        if force_hostile is not None: hostile = bool(force_hostile)
        else:
            try: hostile = bcfg.getint(chan_id, "round", fallback=0) >= 1
            except Exception: pass
        bonus = 5 if hostile else 0

        used_vs="Spells"; sv_roll=None; sv_dc=None
        for vs_key in ("spell","sp","spells"):
            try:
                ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                if dc is not None: sv_roll, sv_dc=r, dc; break
            except Exception: pass
        if sv_dc is None: sv_dc=15; sv_roll=10
        adj=(sv_roll or 0)+bonus
        passed = adj >= sv_dc
        d20 = "**20** 🎉" if sv_roll==20 else ("**1** 💀" if sv_roll==1 else str(sv_roll))
        btxt = f" + {bonus}" if bonus else ""
        line = f"Save vs Spells: {d20}{btxt} = ``{adj}`` vs **{sv_dc}** → "

        uses_left = max(0, uses-1)
        bcfg.set(chan_id, f"{s}.controlgiant_uses", str(uses_left)); _save_battles(bcfg)
        if uses_left <= 0:
                                             
            _clear_control_timer(bcfg, chan_id, s, "controlgiant")                                        
            _save_battles(bcfg)
        code = bcfg.get(chan_id, f"{s}.x_controlgiant_code", fallback="CG") or "CG"
        desc = f"**{tgt_disp}** — {line}" + ("❌ **RESISTS**" if passed else "💗 **CHARMED** — Obeys the drinker as an ally (new save at **+5** for self/ally-harm orders).")
        color = 0xFF9966 if passed else 0x66CC88
        embed = nextcord.Embed(title="🧿 Control Giant (Potion)", description=desc, color=color)
        embed.add_field(name="Uses remaining", value=f"**{uses_left}**", inline=True)
        embed.add_field(name="Timer", value=f"**[{code} {rounds}]** on **{ci}**", inline=True)
        await ctx.send(embed=embed)
        try: await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception: pass


    async def _attack_controldragon(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        """
        Control Dragon (Potion): Gaze charm vs **dragons**.
        Usage: !a controldragon <target> [-h|-hostile] [-nh|-nonhostile]
        """
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Dragon (Potion)",
                description="*(Add a target: `!a controldragon <target>` — flags: `-h/-hostile`, `-nh/-nonhostile`)*",
                color=0x7A7ADB)); return

        force_hostile, names = None, []
        for t in tokens:
            tl = str(t).lower().strip()
            if tl in ("-h","-hostile","+5","hostile"): force_hostile=True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"): force_hostile=False
            else: names.append(t)
        tgt_raw = names[0] if names else None
        if not tgt_raw:
            await ctx.send("Usage: `!a controldragon <target>`"); return

        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try: return fn(name)
                except Exception: pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_"," ")), path
                        except Exception:
                            return fnm[:-4].replace("_"," "), path
            except Exception: pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(tgt_raw)
        if not tgt_path:
            await ctx.send(embed=nextcord.Embed(title="🧿 Control Dragon (Potion)",
                                                description=f"**{tgt_raw}**: ❌ *(not found)*", color=0xFF6666)); return
        t_cfg = read_cfg(tgt_path)

        try: bcfg = _load_battles()
        except Exception: bcfg=None
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("❌ No initiative running here."); return
        names, _ = _parse_combatants(bcfg, chan_id)
        ci = _find_ci_name(names, caster_name) or caster_name
        s = _slot(ci)
        rounds = bcfg.getint(chan_id, f"{s}.x_controldragon", fallback=0)
        uses   = bcfg.getint(chan_id, f"{s}.controldragon_uses", fallback=0)
        if rounds <= 0:
            await ctx.send(f"❌ **{caster_name}** has no active **Control Dragon** potion."); return
        if uses <= 0:
            await ctx.send(f"❌ **{caster_name}** has no **Control Dragon** uses left."); return

        ty = (str(get_compat(t_cfg,"stats","type",fallback="")) or str(get_compat(t_cfg,"info","type",fallback=""))).lower()
        if "dragon" not in ty:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Dragon (Potion)",
                description=f"**{tgt_disp}**: not a **dragon** — **no effect**.",
                color=0xFFAA33)); return

        hostile=False
        if force_hostile is not None: hostile=bool(force_hostile)
        else:
            try: hostile = bcfg.getint(chan_id, "round", fallback=0) >= 1
            except Exception: pass
        bonus = 5 if hostile else 0

        used_vs="Spells"; sv_roll=None; sv_dc=None
        for vs_key in ("spell","sp","spells"):
            try:
                ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                if dc is not None: sv_roll, sv_dc=r, dc; break
            except Exception: pass
        if sv_dc is None: sv_dc=15; sv_roll=10
        adj=(sv_roll or 0)+bonus
        passed = adj >= sv_dc
        d20 = "**20** 🎉" if sv_roll==20 else ("**1** 💀" if sv_roll==1 else str(sv_roll))
        btxt = f" + {bonus}" if bonus else ""
        line = f"Save vs Spells: {d20}{btxt} = ``{adj}`` vs **{sv_dc}** → "

        uses_left = max(0, uses-1)
        bcfg.set(chan_id, f"{s}.controldragon_uses", str(uses_left)); _save_battles(bcfg)
        if uses_left <= 0:
                                             
            _clear_control_timer(bcfg, chan_id, s, "controldragon")                                        
            _save_battles(bcfg)
        code = bcfg.get(chan_id, f"{s}.x_controldragon_code", fallback="CD") or "CD"
        desc = f"**{tgt_disp}** — {line}" + ("❌ **RESISTS**" if passed else "💗 **CHARMED** — Obeys the drinker as an ally (new save at **+5** for self/ally-harm orders).")
        color = 0xFF9966 if passed else 0x66CC88
        embed = nextcord.Embed(title="🧿 Control Dragon (Potion)", description=desc, color=color)
        embed.add_field(name="Uses remaining", value=f"**{uses_left}**", inline=True)
        embed.add_field(name="Timer", value=f"**[{code} {rounds}]** on **{ci}**", inline=True)
        await ctx.send(embed=embed)
        try: await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception: pass


    async def _attack_controlplant(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        """
        Control Plant (Potion): Command **plant creatures** (save negates). Normal plants are GM-adjudicated.
        Usage: !a controlplant <target> [-h|-hostile] [-nh|-nonhostile]
        """
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Plant (Potion)",
                description="*(Add a target: `!a controlplant <target>` — flags: `-h/-hostile`, `-nh/-nonhostile`)*",
                color=0x7A7ADB)); return

        force_hostile, names = None, []
        for t in tokens:
            tl = str(t).lower().strip()
            if tl in ("-h","-hostile","+5","hostile"): force_hostile=True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"): force_hostile=False
            else: names.append(t)
        tgt_raw = names[0] if names else None
        if not tgt_raw:
            await ctx.send("Usage: `!a controlplant <target>`"); return

        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try: return fn(name)
                except Exception: pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_"," ")), path
                        except Exception:
                            return fnm[:-4].replace("_"," "), path
            except Exception: pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(tgt_raw)
        if not tgt_path:
            await ctx.send(embed=nextcord.Embed(title="🧿 Control Plant (Potion)",
                                                description=f"**{tgt_raw}**: ❌ *(not found)*", color=0xFF6666)); return
        t_cfg = read_cfg(tgt_path)

        try: bcfg = _load_battles()
        except Exception: bcfg=None
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("❌ No initiative running here."); return
        names, _ = _parse_combatants(bcfg, chan_id)
        ci = _find_ci_name(names, caster_name) or caster_name
        s = _slot(ci)
        rounds = bcfg.getint(chan_id, f"{s}.x_controlplant", fallback=0)
        uses   = bcfg.getint(chan_id, f"{s}.controlplant_uses", fallback=0)
        if rounds <= 0:
            await ctx.send(f"❌ **{caster_name}** has no active **Control Plant** potion."); return
        if uses <= 0:
            await ctx.send(f"❌ **{caster_name}** has no **Control Plant** uses left."); return

        ty = (str(get_compat(t_cfg,"stats","type",fallback="")) or str(get_compat(t_cfg,"info","type",fallback=""))).lower()
        if "plant" not in ty:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Plant (Potion)",
                description=f"**{tgt_disp}**: not a **plant creature** — **no effect** (normal plants are GM-adjudicated).",
                color=0xFFAA33)); return

        hostile=False
        if force_hostile is not None: hostile=bool(force_hostile)
        else:
            try: hostile = bcfg.getint(chan_id, "round", fallback=0) >= 1
            except Exception: pass
        bonus = 5 if hostile else 0

        used_vs="Spells"; sv_roll=None; sv_dc=None
        for vs_key in ("spell","sp","spells"):
            try:
                ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                if dc is not None: sv_roll, sv_dc=r, dc; break
            except Exception: pass
        if sv_dc is None: sv_dc=15; sv_roll=10
        adj=(sv_roll or 0)+bonus
        passed = adj >= sv_dc
        d20 = "**20** 🎉" if sv_roll==20 else ("**1** 💀" if sv_roll==1 else str(sv_roll))
        btxt = f" + {bonus}" if bonus else ""
        line = f"Save vs Spells: {d20}{btxt} = ``{adj}`` vs **{sv_dc}** → "

        uses_left = max(0, uses-1)
        bcfg.set(chan_id, f"{s}.controlplant_uses", str(uses_left)); _save_battles(bcfg)
        if uses_left <= 0:
                                             
            _clear_control_timer(bcfg, chan_id, s, "controlplant")                                        
            _save_battles(bcfg)
        code = bcfg.get(chan_id, f"{s}.x_controlplant_code", fallback="CP") or "CP"
        desc = f"**{tgt_disp}** — {line}" + ("❌ **RESISTS**" if passed else "💗 **CHARMED** — Behaves as if under **Charm Monster** (orders allowed; new save at **+5** if self/ally-harm).")
        color = 0xFF9966 if passed else 0x66CC88
        embed = nextcord.Embed(title="🧿 Control Plant (Potion)", description=desc, color=color)
        embed.add_field(name="Uses remaining", value=f"**{uses_left}**", inline=True)
        embed.add_field(name="Timer", value=f"**[{code} {rounds}]** on **{ci}**", inline=True)
        await ctx.send(embed=embed)
        try: await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception: pass


    async def _attack_controlundead(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        """
        Control Undead (Potion): On each activation, roll **3d6 HD pool** and command that many HD of undead.
          • Each named undead makes a Save vs Spells (hostile +5 applies).
          • On a failed save: mindless undead **obey exactly**; free-willed undead behave as if **Charm Person**.
          • HD is spent only on failed saves (like Charm Monster group mode).
          • Consumes **1 use** per activation while timer lasts.
        Usage: !a controlundead <targets...> [-h|-hostile] [-nh|-nonhostile]
        """
        
        chan_id = str(ctx.channel.id)

        if not tokens:
            await ctx.send(embed=nextcord.Embed(
                title="🧿 Control Undead (Potion)",
                description="*(Add targets: `!a controlundead skeleton1 zombie2` — flags: `-h/-hostile`, `-nh/-nonhostile`)*",
                color=0x7A7ADB)); return

        force_hostile, raw_names = None, []
        for t in tokens:
            tl = str(t).lower().strip()
            if tl in ("-h","-hostile","+5","hostile"): force_hostile=True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"): force_hostile=False
            else: raw_names.append(t)

        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try: return fn(name)
                except Exception: pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_"," ")), path
                        except Exception:
                            return fnm[:-4].replace("_"," "), path
            except Exception: pass
            return None, None

                                   
        try: bcfg = _load_battles()
        except Exception: bcfg=None
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("❌ No initiative running here."); return
        names, _ = _parse_combatants(bcfg, chan_id)
        ci = _find_ci_name(names, caster_name) or caster_name
        s = _slot(ci)
        rounds = bcfg.getint(chan_id, f"{s}.x_controlundead", fallback=0)
        uses   = bcfg.getint(chan_id, f"{s}.controlundead_uses", fallback=0)
        if rounds <= 0:
            await ctx.send(f"❌ **{caster_name}** has no active **Control Undead** potion."); return
        if uses <= 0:
            await ctx.send(f"❌ **{caster_name}** has no **Control Undead** uses left."); return

                                           
        uses_left = max(0, uses-1)
        bcfg.set(chan_id, f"{s}.controlundead_uses", str(uses_left)); _save_battles(bcfg)
        if uses_left <= 0:
                                             
            _clear_control_timer(bcfg, chan_id, s, "controlundead")                                        
            _save_battles(bcfg)
                           
        hostile=False
        if force_hostile is not None: hostile=bool(force_hostile)
        else:
            try: hostile = bcfg.getint(chan_id, "round", fallback=0) >= 1
            except Exception: pass
        bonus = 5 if hostile else 0

                              
        def _looks_undead(cfg, disp_nm: str):
            try:
                if _is_undead_cfg(cfg, disp_nm):                       
                    return True
            except Exception:
                pass
            ty = (str(get_compat(cfg,"stats","type",fallback="")) or str(get_compat(cfg,"info","type",fallback=""))).lower()
            if "undead" in ty: return True
            nm = (disp_nm or "").lower()
            undead_markers = ("skeleton","zombie","ghoul","wight","wraith","mummy","vampire","ghost","lich","spectre","shadow","revenant")
            return any(k in nm for k in undead_markers)

                             
        resolved = []
        for nm in raw_names:
            disp, pth = _resolve_any_ci(nm)
            if not pth:
                resolved.append({"disp": nm, "path": None, "hd": None, "note": "not found"}); continue
            cfg_t = read_cfg(pth)
            if not _looks_undead(cfg_t, disp or nm):
                resolved.append({"disp": disp or nm, "path": pth, "hd": None, "note": "not undead"}); continue
            hd = self._hd_or_level_from_cfg(cfg_t)
            resolved.append({"disp": disp or nm, "path": pth, "hd": hd, "note": None})

                          
        d_sum, d_rolls, d_flat = roll_dice("3d6")
        pool = max(0, d_sum + d_flat)

        lines = [f"Group control: **3d6** [{', '.join(str(r) for r in d_rolls)}] → **{pool} HD**"]
        used_vs="Spells"

                                                   
        def _is_mindless(cfg, disp_nm: str):
            try:
                iv = get_compat(cfg, "stats", "int", fallback="") or get_compat(cfg, "stats", "intelligence", fallback="")
                if str(iv).strip().isdigit() and int(str(iv).strip()) <= 2:
                    return True
            except Exception: pass
            nm = (disp_nm or "").lower()
            return any(k in nm for k in ("skeleton","zombie","plague zombie","mindless"))

                                                                          
        for r in resolved:
            if r["note"] == "not found":
                lines.append(f"• **{r['disp']}**: ❌ *(not found)*"); continue
            if r["note"] == "not undead":
                lines.append(f"• **{r['disp']}**: not undead — **no effect**."); continue
            hd = int(r["hd"] or 0)
            if pool < hd:
                lines.append(f"• **{r['disp']}** (HD {hd}): not enough HD remaining (**{pool}** left) — **skipped**.")
                continue

            t_cfg = read_cfg(r["path"])
                                                           
            sv_roll=None; sv_dc=None
            for vs_key in ("spell","sp","spells"):
                try:
                    ok0, rr, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                    if dc is not None: sv_roll, sv_dc = rr, dc; break
                except Exception: pass
            if sv_dc is None: sv_dc=15; sv_roll=10
            adj = (sv_roll or 0) + bonus
            passed = adj >= sv_dc
            d20 = "**20** 🎉" if sv_roll==20 else ("**1** 💀" if sv_roll==1 else str(sv_roll))
            btxt = f" + {bonus}" if bonus else ""
            line = f"{d20}{btxt} = ``{adj}`` vs **{sv_dc}** → "

            if passed:
                lines.append(f"• **{r['disp']}** (HD {hd}) — Save vs Spells: {line}❌ **RESISTS**.")
                                          
            else:
                pool -= hd
                if _is_mindless(t_cfg, r["disp"]):
                    lines.append(f"• **{r['disp']}** (HD {hd}) — Save vs Spells: {line}🧟 **COMMANDED** *(mindless: follows orders exactly)*.")
                else:
                    lines.append(f"• **{r['disp']}** (HD {hd}) — Save vs Spells: {line}💗 **CHARMED** *(free-willed: behaves as if **Charm Person**)*.")
                if pool <= 0:
                    break

        if pool > 0:
            lines.append(f"Unused HD remaining: **{pool}**")

        code = bcfg.get(chan_id, f"{s}.x_controlundead_code", fallback="CU") or "CU"
        embed = nextcord.Embed(
            title="🧿 Control Undead (Potion)",
            description="\n".join(lines),
            color=0x6699CC,
        )
        embed.add_field(name="Uses remaining", value=f"**{uses_left}**", inline=True)
        embed.add_field(name="Timer", value=f"**[{code} {rounds}]** on **{ci}**", inline=True)
        await ctx.send(embed=embed)
        try: await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception: pass


    def _safe_canon(self, item_name: str, it: dict | None) -> str:
        def _strip(s: str) -> str:
            return (s or "").split("@", 1)[0]                        
        fn = getattr(self, "_canon", None)
        if callable(fn):
            try:
                v = str(fn(item_name) or "").strip()
                if v:
                    return _strip(v)
            except Exception:
                pass
        if it:
            for k in ("charges_key", "id", "_id", "block", "name", "item_id"):
                v = str(it.get(k, "")).strip()
                if v:
                    return _strip(v)
        return _strip(str(item_name or ""))


    def _item_kind_with_charges(self, item_name: str, it: dict | None) -> str | None:
        """
        Returns 'wand' or 'staff' if this should track charges, else None.
        Uses either it['type'] or name heuristic (Wandof*/Staffof*).
        """
        ty = str((it or {}).get("type", "")).strip().lower()
        if ty in {"wand", "staff"}:
            return ty
        name_l = self._safe_canon(item_name, it).strip().lower()
        if name_l.startswith("wandof"):
            return "wand"
        if name_l.startswith("staffof"):
            return "staff"
        return None


    def _item_has_charges(self, item_name: str, it: dict | None) -> bool:
        return self._item_kind_with_charges(item_name, it) is not None


    def _charges_key(self, item_name: str, it: dict | None = None) -> str:
        
        name = str(item_name or "")
                                                              
        base_name = name.split("@", 1)[0]
                                                                          
        base = self._safe_canon(base_name, it).lower()
        core = "".join(ch for ch in base if ch.isalnum())

        m = re.search(r"@([A-Za-z0-9_-]+)$", name)
        if m:
            suffix = "".join(ch for ch in m.group(1).lower() if ch.isalnum())
            return f"{core}_{suffix}"
        return core


    def _charges_max_for_item(self, name: str, it: dict | None) -> int:
                  
        if it:
            mx = int(it.get("charges_max") or it.get("charges", {}).get("max") or 0)
            if mx:
                return mx
                            
        base = name.split("@", 1)[0].lower()
        if base.startswith("wandof"):
            return 20
        if base.startswith("staffof"):
            return 30
        return 20                        


    def _get_item_charges(self, cfg, key: str, default_max: int | None = None) -> tuple[int | None, int | None]:
        """
        Reads [charges].<key> as 'cur/max' or legacy 'cur'.
        Returns (cur, max) where either may be None if unset.
        """
        
        raw = str(get_compat(cfg, "charges", key, fallback="")).strip()
        if raw:
            m = re.match(r"^\s*(\d+)\s*/\s*(\d+)\s*$", raw)
            if m:
                return int(m.group(1)), int(m.group(2))
            try:
                cur = int(raw)                         
                return cur, (default_max or cur)
            except Exception:
                pass
        return None, default_max


    def _get_item_charges(self, cfg, key: str, default_max: int | None = None) -> tuple[int | None, int | None]:
        """
        Reads [charges].<key> as 'cur/max' or legacy 'cur'.
        Returns (cur, max) where either may be None if unset.
        """
        
        raw = str(get_compat(cfg, "charges", key, fallback="")).strip()
        if raw:
            m = re.match(r"^\s*(\d+)\s*/\s*(\d+)\s*$", raw)
            if m:
                return int(m.group(1)), int(m.group(2))
            try:
                cur = int(raw)                         
                return cur, (default_max or cur)
            except Exception:
                pass
        return None, default_max


    def _set_item_charges(self, cfg, path: str, key: str, cur: int, maxv: int | None = None) -> None:
        if not cfg.has_section("charges"):
            cfg.add_section("charges")
        if maxv is None:
            _, old_max = self._get_item_charges(cfg, key, default_max=None)
            maxv = old_max if old_max is not None else cur
        cfg.set("charges", key, f"{max(0, int(cur))}/{max(0, int(maxv))}")
        write_cfg(path, cfg)


    def _spend_item_charges(self, cfg, path: str, key: str, cost: int, default_max: int) -> tuple[bool, int, str]:
        """
        Try to spend 'cost' charges. Returns (ok, remaining_after, err_msg_if_any).
        """
        left, mx = self._get_item_charges(cfg, key, default_max)
        left = 0 if left is None else left
        mx = default_max if mx is None else mx
        if cost <= 0:
            return True, left, ""
        if left < cost:
            return False, left, f"❌ Not enough charges (has **{left}**, needs **{cost}**)."
        self._set_item_charges(cfg, path, key, left - cost, mx)
        return True, left - cost, ""


    def _alloc_item_id(self, n: int = 3) -> str:
        return secrets.token_hex(n)                                   


    def _add_charged_item_instance(self, cfg, char_path: str, canon_name: str, it: dict):
        """
        Create an instance token canon@<id>, put it in storage with qty=1,
        and seed per-instance charges in [charges].
        """
        token = f"{canon_name}@{self._alloc_item_id()}"
        storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
        if token not in storage:
            storage.append(token)
        if not cfg.has_section("item"):
            cfg.add_section("item")
        cfg.set("item", token.lower(), "1")
                                                                  
        cfg.set("item", canon_name.lower(), "0")

                                        
        mx = self._charges_max_for_item(canon_name, it)
        self._set_item_charges(cfg, char_path, self._charges_key(token, it), mx, mx)

        cfg.set("item", "storage", " ".join(storage))
        write_cfg(char_path, cfg)
        return token


    def _storage_tokens(self, cfg):
        return [t for t in (get_compat(cfg, "item", "storage", fallback="") or "").split() if t]


    def _pick_wand_instance(self, cfg, prefab_name: str):
                                                           
        want = self._safe_canon(prefab_name, None)
        want_n = self._norm(want)

                                                              
        for tok in self._storage_tokens(cfg):
            if "@" in tok and self._norm(tok).startswith(want_n):
                canon, it = self._item_lookup(tok.split("@", 1)[0])
                return tok, it

                                  
        canon, it = self._item_lookup(want)
        try:
            from utils.ini import getint_compat
            have = getint_compat(cfg, "item", want.lower(), fallback=0)
        except Exception:
            have = 0
        return (canon, it) if have > 0 else (None, None)


    def _pick_staff_instance(self, cfg, prefab_name: str):
                                     
        return self._pick_wand_instance(cfg, prefab_name)
        

    def _auto_seed_charges_on_add(self, cfg, path: str, item_name: str, *, mode: str = "new") -> None:
        """
        Seed charges for newly added wand/staff if not already present.
        mode: 'new' -> full (20/30), 'found' -> roll (2d10/3d10)
        """
        _c, it = self._item_lookup(item_name)
        if not self._item_has_charges(item_name, it):
            return
        key = self._charges_key(item_name, it)
        if cfg.has_section("charges") and cfg.has_option("charges", key):
            return
        maxv = self._charges_max_for_item(item_name, it)
        if mode == "found":
            dice = "3d10" if self._item_kind_with_charges(item_name, it) == "staff" else "2d10"
            total, rolls, flat = roll_dice(dice)                              
            cur = max(1, total + flat)
        else:
            cur = maxv
        self._set_item_charges(cfg, path, key, cur, maxv)


    def _migrate_legacy_charge_key(self, cfg, path: str, item_name: str, it: dict | None):
        
                                                                         
        new_key = self._charges_key(item_name, it)

                                        
        base = self._safe_canon(item_name, it).lower()
        core = "".join(ch for ch in base if ch.isalnum())
        m = re.search(r"@([A-Za-z0-9_-]+)$", str(item_name) or "")
        if m:
            suf = "".join(ch for ch in m.group(1).lower() if ch.isalnum())
            old_no_us = f"{core}{suf}"                                  
            bug_double = f"{core}{suf}_{suf}"                                  
        else:
            old_no_us = core
            bug_double = None

                                                     
        def _read(key):
            raw = (get_compat(cfg, "charges", key, fallback="") or "").strip()
            if not raw: return None, None
            if "/" in raw:
                a,b = raw.split("/",1)
                return int(a), int(b)
            try:
                a = int(raw); return a, None
            except: return None, None

        cur_best, max_best = _read(new_key)
        for k in (old_no_us, bug_double):
            if not k: continue
            c, mmax = _read(k)
            if c is None and mmax is None: continue
                                                                                 
            if cur_best is None or (c is not None and c < cur_best): cur_best = c
            if max_best is None or (mmax is not None and mmax > max_best): max_best = mmax

        if cur_best is not None or max_best is not None:
            if not cfg.has_section("charges"): cfg.add_section("charges")
                                          
            if max_best is None:
                max_best = self._charges_max_for_item(item_name, it)
            self._set_item_charges(cfg, path, new_key, cur_best if cur_best is not None else max_best, max_best)

                                                       
        for k in (old_no_us, bug_double):
            try:
                if k and k != new_key:
                    cfg.remove_option("charges", k)
            except Exception:
                pass
        write_cfg(path, cfg)


    async def _poison_touch_attempt(self, ctx, caster_cfg, caster_name: str, target_raw: str,
                                    *, bcfg=None, chan_id: str, caster_slot: str | None):
        """
        Performs one Poison Touch attempt:
          • Rolls touch attack (STR mod + AB).
          • On a real hit (not an image), target saves vs Poison or dies.
          • Discharges the spell on any real hit (save success or fail).
          • If the attack misses or hits a Mirror Image, the charge persists.
        """
        

        def _read_ac(t_cfg) -> int:
            try:
                v = getint_compat(t_cfg, "cur", "ac", fallback=None)
                if v is None: v = getint_compat(t_cfg, "base", "ac", fallback=10)
                return int(v)
            except Exception:
                return 10

        def _str_mod(cfg) -> int:
            try: s = getint_compat(cfg, "stats", "str", fallback=10)
            except Exception: s = 10
            if s <= 3: return -3
            if s <= 5: return -2
            if s <= 8: return -1
            if s <= 12: return 0
            if s <= 15: return +1
            if s <= 17: return +2
            return +3

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

                        
        tgt_disp, tgt_path = _resolve_ci(target_raw)
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"• **{target_raw}**: ❌ *(not found)*"]

        t_cfg = read_cfg(tgt_path)
        pretty = (tgt_disp or target_raw).upper()

                    
        try:
            if _is_undead_cfg(t_cfg, tgt_disp):
                return [f"• {pretty}: ☠️ Undead — **no effect**."]
        except Exception:
            pass
        try:
            if self._poison_immune(t_cfg):
                return [f"• {pretty}: 🧪 Poison-immune — **no effect**."]
        except Exception:
            pass

                                            
        str_m = _str_mod(caster_cfg)
        ab    = self._get_attack_bonus(caster_cfg)
        d_sum, d_rolls, _ = roll_dice("1d20")
        total = d_sum + str_m + ab
        ac_val = _read_ac(t_cfg)
        hit = (total >= ac_val)
        atk_line = f"• Attack roll: {d_rolls[0]} + {str_m} + {ab} = **{total}** → {'**HIT**' if hit else '**MISS**'}"

                               
        if not hit:
            return [atk_line, "• The poisonous touch **misses**. Charge **persists**."]

                                                                
        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            msg = f"• Mirror Image: a figment is struck and shatters (images left: **{left_imgs}**)."
            return [atk_line, msg, "• The poisonous touch **persists**."]

                                                    
        try:
            bc2 = _load_battles()
            if bc2 and bc2.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, [tgt_disp])
        except Exception:
            pass

                               
        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
        if sv_dc is None:
            sv_ok = False                             

        note = f"Save vs Poison {sv_roll} vs {sv_dc} → {'✅ **RESISTED**' if sv_ok else '❌ **FAIL**'}"

        out: list[str] = [atk_line, f"• {pretty}: {note}"]

                                                                  
        if bcfg and caster_slot:
            for suf in ("pt_until","pt","pt_by","pt_level"):
                opt = f"{caster_slot}.{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
            _save_battles(bcfg)

                             
        if not sv_ok:
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp if old_hp is not None else 1)
            if old_hp is None: old_hp = max_hp
            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = "0"
            write_cfg(tgt_path, t_cfg)

                                                                         
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False

            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (
                            ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                            ".paralyzed",".blind",".blind_src",".blind_by",
                            ".cc_blind_pending",".cs_blind_pending",
                            ".cc",".cc_by",".cc_level",".ck",".ck_by",".ck_level",
                            ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                            ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                        ):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass

                                                                   
            try:
                before = _life_bar(old_hp, max_hp, width=10)
                after  = _life_bar(0, max_hp, width=10)
                out.append(f"{before} → **{after}** ☠️ **DEAD!**")
            except Exception:
                out.append(f"HP {old_hp} → **0** ☠️ **DEAD!**")

        else:
            out.append("• The poison is delivered but **resisted**. The charge is **discharged**.")

                                                    
        try:
            if bcfg and bcfg.has_section(chan_id):
                await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return out


    async def _attack_poisontouch(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        
        chan_id = str(ctx.channel.id)

                           
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active = False
        left_rounds = 0
        s_me = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")

            now_r  = bcfg.getint(chan_id, "round", fallback=0)
            until  = bcfg.getint(chan_id, f"{s_me}.pt_until", fallback=0)

                                                
            if until and now_r <= until:
                active = True
                left_rounds = max(0, (until - now_r + 1))
            elif until and now_r > until:
                                                 
                for suf in ("pt_until", "pt", "pt_by", "pt_level"):
                    opt = f"{s_me}.{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)
                active = False

        color = 0x55DD55 if active else 0xAAAAAA
        desc  = (f"**{caster_name}**’s hand drips with venom!" if active
                 else f"**{caster_name}** has no active Poison Touch.")
        embed = nextcord.Embed(title="🧪 Poison Touch", description=desc, color=color)

        if active:
            embed.add_field(name="Charge", value=f"Rounds remaining: **{left_rounds}**", inline=True)

            effect_lines: list[str] = []
            target_note = ""

            if tokens:
                target = tokens[0]
                extras = tokens[1:]
                if extras:
                    target_note = f"\n*(Single target; ignoring: {', '.join(extras)})*"

                                                                                      
                out = await self._poison_touch_attempt(
                    ctx, caster_cfg, caster_name, target,
                    bcfg=bcfg, chan_id=chan_id, caster_slot=s_me
                )
                if out: effect_lines.extend(out)

            else:
                effect_lines.append("Use `!a poisontouch <target>` or `!a touch <target>` to deliver the poison.")

            if target_note:
                effect_lines.append(target_note)

            if effect_lines:
                embed.add_field(name="Effect", value="\n".join(effect_lines), inline=False)

        await ctx.send(embed=embed)

                                                                             
        try:
            bcfg2 = _load_battles()
            if bcfg2 and bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

    def _monster_ab_from_hd(self, cfg) -> int:
        # pull an integer HD from base.hd
        raw_hd = (get_compat(cfg, "base", "hd", fallback="") or "").strip()
        m = re.match(r"(\d+)", raw_hd)
        if not m:
            return 0
        hd = max(1, min(32, int(m.group(1))))

        try:
            sec = None
            for s in self._class_cp.sections():
                if s.lower() == "monster":
                    sec = s
                    break
            if not sec:
                return 0

            key = f"hd{hd}"
            if self._class_cp.has_option(sec, key):
                return self._class_cp.getint(sec, key)
        except Exception:
            pass
        return 0


    def _get_attack_bonus(self, cfg) -> int:
        """
        Attack Bonus for the caster:
        1) Prefer the same classes->ab table your !a command uses.
        2) Else look for a local copy on this cog.
        3) Else read a sheet override (stats.ab / attack_bonus).
        4) Else read class.lst [<Class>].ab row.
        """
        char_class = (get_compat(cfg, "info", "class", fallback="") or "").strip()
        lvl = max(1, getint_compat(cfg, "cur", "level", fallback=1))
        lc = char_class.lower()

        # Monsters: use HD-based table if we have it
        if lc == "monster":
            hd_ab = self._monster_ab_from_hd(cfg)
            if hd_ab:
                return hd_ab
                                                                           
        try:
            for cog in self.bot.cogs.values():
                tbl = getattr(cog, "classes", None)
                if isinstance(tbl, dict) and lc in tbl:
                    ab_list = tbl[lc].get("ab", [])
                    if ab_list:
                        idx = min(lvl - 1, len(ab_list) - 1)
                        return int(ab_list[idx])
        except Exception:
            pass

                                                                   
        try:
            ab_list = getattr(self, "classes", {}).get(lc, {}).get("ab", [])
            if ab_list:
                idx = min(lvl - 1, len(ab_list) - 1)
                return int(ab_list[idx])
        except Exception:
            pass

                                                              
        for key in ("ab", "attack_bonus", "attackbonus", "atk_bonus"):
            try:
                raw = get_compat(cfg, "stats", key, fallback=None)
                if raw is not None and str(raw).strip() != "":
                    return int(str(raw).strip())
            except Exception:
                pass

                                                                            
        try:
            sec = None
            for s in self._class_cp.sections():
                if s.lower() == char_class.lower():
                    sec = s; break
            if sec and self._class_cp.has_option(sec, "ab"):
                arr = [int(x) for x in self._class_cp.get(sec, "ab").split()]
                if arr:
                    idx = min(lvl - 1, len(arr) - 1)
                    return int(arr[idx])
        except Exception:
            pass

        return 0
            

    def _con_mod(self, v: int) -> int:
        if v <= 3:  return -3
        if v <= 5:  return -2
        if v <= 8:  return -1
        if v <= 12: return 0
        if v <= 15: return +1
        if v <= 17: return +2
        return +3
   

    def _with_l0(self, cfg, totals: dict[int,int], info_class: str, level: int) -> dict[int,int]:
        prof = self._caster_profile(info_class, ctx.channel) or {}
        abil = prof.get("cantrip_ability", "int")
        l0 = max(0, level + self._abil_mod(cfg, abil))
        totals = dict(totals)        
        totals[0] = l0
        return totals
            

    def _abil_mod(self, cfg_or_score, abil_key: str | None = None) -> int:
        """
        Compat shim:
          • _abil_mod(score)              -> returns mod for a numeric ability score
          • _abil_mod(cfg, "wis")         -> reads score from cfg[stats][wis], returns its mod
        """
        def _num_to_mod(v: int) -> int:
            if v <= 3:  return -3
            if v <= 5:  return -2
            if v <= 8:  return -1
            if v <= 12: return 0
            if v <= 15: return +1
            if v <= 17: return +2
            return +3

        if abil_key is None:
                          
            score = int(cfg_or_score)
        else:
                      
            score = getint_compat(cfg_or_score, "stats", abil_key, fallback=10)
        return _num_to_mod(score)


    def _lock_highest_slots_now(self, cfg, added_levels: int) -> tuple[dict[int,int], int]:
        """
        Spend (lock) one highest-level slot per newly-added negative level.
        Skips L0. Only spends *available* (unspent) slots.
        Returns (locks_applied_by_level, leftover_locks_not_applied_now).
        """
        added = max(0, int(added_levels))
        if added <= 0:
            return {}, 0

        info_class = get_compat(cfg, "info", "class", fallback="")
        level = getint_compat(cfg, "cur", "level", fallback=1)

                                                          
        profile = self._caster_profile(info_class, ctx.channel)
        if not profile:
                                             
            return {}, added

                                                                             
        cp = getattr(self, "_class_cp", None)
        if not cp:
                                                                                 
            try:
                bot = getattr(self, "bot", None)
                spells_cog = bot.get_cog("Spells") if bot else None
                cp = getattr(spells_cog, "_class_cp", None)
            except Exception:
                cp = None
        if not cp:
                                                              
            return {}, added

        totals = _slots_for_class_level(cp, profile["slots_class"], level)
        if not totals:
                                                
            return {}, added

                                                                  
        totals = self._with_l0(cfg, totals, info_class, level)
        _ensure_slots_for(cfg, totals)

        locks_remaining = added
        applied: dict[int, int] = {}

                                 
        spent = {L: getint_compat(cfg, "slots", f"l{L}_spent", fallback=0) for L in totals}

                                   
        for L in sorted(totals.keys(), reverse=True):
            if L == 0 or locks_remaining <= 0:
                continue
            have = int(totals.get(L, 0))
            if have <= 0:
                continue
            already_spent = spent.get(L, 0)
            avail = max(0, have - already_spent)
            if avail <= 0:
                continue

            take = min(avail, locks_remaining)
            new_spent = already_spent + take

            if not cfg.has_section("slots"):
                cfg.add_section("slots")
            cfg.set("slots", f"l{L}_spent", str(new_spent))

            applied[L] = applied.get(L, 0) + take
            locks_remaining -= take

        return applied, locks_remaining


    async def _attack_produce(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> None:
        """
        Follow-up for Produce Flame/Cold:
          !a produce <target> [-melee|-throw]
        • Once per round, on caster’s turn.
        • Attack roll: AB + STR (melee) OR AB + DEX (throw). No range penalty (throw; 50 ft limit not enforced here).
        • On hit: 1d6 + min(level, +5) fire/cold damage.
        • On ANY attempt (hit/miss/MI): reduce remaining duration by **10 rounds**. If it hits 0 or below, effect ends.
        • Does not function underwater.
        """
        

        chan_id = str(ctx.channel.id)

                       
        if not tokens:
            await ctx.send("🔥❄️ **Produce** — usage: `!a produce <target> [-melee|-throw]`")
            return

                                     
        mode = "throw"
        raw_list = []
        for t in tokens:
            s = str(t).strip()
            l = s.lower()
            if l in {"-melee","-m","melee","touch"}:
                mode = "melee"
            elif l in {"-throw","-t","throw"}:
                mode = "throw"
            else:
                raw_list.append(s)
        if not raw_list:
            await ctx.send("🔥❄️ **Produce** — add a target: `!a produce <target> [-melee|-throw]`")
            return
        target_raw = raw_list[0]

                             
        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg2 = read_cfg(path)
                            real = get_compat(cfg2, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(target_raw)
        if not tgt_path:
            await ctx.send(f"🔥❄️ **Produce** — **{target_raw}**: *(not found)*")
            return

                                      
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("🔥❄️ **Produce** — *(No active battle for tracking.)*")
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        try:
            s_me = self._effect_slot_for(bcfg, chan_id, me_key)
        except Exception:
            s_me = me_key.replace(" ", "_")

                                 
        rounds_left = bcfg.getint(chan_id, f"{s_me}.x_pfc", fallback=0)
        if rounds_left <= 0:
            await ctx.send(f"🔥❄️ **{caster_name}** has no active **Produce Flame/Cold**.")
            return

                                                               
        if bcfg.getint(chan_id, "underwater", fallback=0) > 0 or bcfg.getint(chan_id, f"{s_me}.underwater", fallback=0) > 0:
            await ctx.send("🌊 **Produce Flame/Cold** cannot be used **underwater**.")
            return

                                  
        turn_name = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
        if not turn_name or turn_name.lower() != me_key.lower():
            await ctx.send(f"🔥❄️ **{caster_name}** can use **Produce** **only on their turn**.")
            return

        cur_round  = bcfg.getint(chan_id, "round", fallback=1)
        last_round = bcfg.getint(chan_id, f"{s_me}.pfc_last_round", fallback=0)
        if last_round == cur_round:
            await ctx.send("🔥❄️ **Produce** — you already used it **this round**.")
            return

                                
        elem = (bcfg.get(chan_id, f"{s_me}.pfc_elem", fallback="fire") or "fire").lower()
        weapon_name = "Produce Flame" if elem == "fire" else "Produce Cold"
        dmg_type = "fire" if elem == "fire" else "cold"

                                   
        ab = self._get_attack_bonus(caster_cfg)
        STR = getint_compat(caster_cfg, "stats", "str", fallback=10)
        DEX = getint_compat(caster_cfg, "stats", "dex", fallback=10)
        def _abil_mod(v:int)->int:
            if v <= 3: return -3
            if v <= 5: return -2
            if v <= 8: return -1
            if v <= 12: return 0
            if v <= 15: return +1
            if v <= 17: return +2
            return +3
        atk_mod = _abil_mod(STR) if mode == "melee" else _abil_mod(DEX)

        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + atk_mod

                                                                       
        t_cfg = read_cfg(tgt_path)
        try:
            target_ac = int(str(get_compat(t_cfg, "stats", "ac", fallback="") or "").strip() or 10)
        except Exception:
            target_ac = 10

        hit = (d20 == 20) or (total_to_hit >= target_ac and d20 != 1)

                            
        
        color = 0xFF8844 if elem == "fire" else 0x66CCFF
        desc = (f"**{caster_name}** {'hurls' if mode=='throw' else 'presses'} "
                f"{'flame' if elem=='fire' else 'cold'} at **{tgt_disp}**!")
        emb = nextcord.Embed(title="🔥❄️ Produce", description=desc, color=color)
        ab_txt = f"{'DEX' if mode=='throw' else 'STR'} {atk_mod:+d}"
        emb.add_field(name="Attack roll", value=f"{d20} + {ab} + {ab_txt} = ``{total_to_hit}``", inline=False)
        emb.add_field(name="Result", value=("✅ **HIT!**" if hit else "❌ **MISS**"), inline=True)

                                        
        if hit and tgt_disp:
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
            except Exception:
                consumed, left = (False, 0)
            if consumed:
                                                                             
                rounds_left_after = max(0, rounds_left - 10)
                bcfg.set(chan_id, f"{s_me}.x_pfc", str(rounds_left_after))
                bcfg.set(chan_id, f"{s_me}.pfc_last_round", str(cur_round))

                                                                    
                if bcfg.get(chan_id, f"{s_me}.light_by", fallback="") == "ProduceFlameCold":
                    new_light = max(0, bcfg.getint(chan_id, f"{s_me}.light", fallback=0) - 10)
                    if new_light <= 0:
                        for opt in (f"{s_me}.light", f"{s_me}.light_by", f"{s_me}.light_src"):
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                    else:
                        bcfg.set(chan_id, f"{s_me}.light", str(new_light))

                                                            
                if rounds_left_after <= 0:
                    for suf in ("", "_code", "_label", "_emoji", "_by"):
                        opt = f"{s_me}.x_pfc{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                    for opt in (f"{s_me}.pfc_elem", f"{s_me}.pfc_last_round"):
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)

                _save_battles(bcfg)
                emb.add_field(name="Mirror Image", value=f"A figment is struck and shatters. Images remaining: **{left}**.", inline=False)

                                 
                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)                      
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

                await ctx.send(embed=emb)
                return

                              
        if hit:
            d, rolls, flat = roll_dice("1d6")
            bonus = min(5, max(0, int(caster_level or 0)))
            raw = d + flat + bonus
            final, note = _apply_mitigation(raw, weapon_name=weapon_name, weapon_type=dmg_type, t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=tgt_disp, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"): t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(tgt_path, t_cfg)

                                                                          
            dmg_line = f"1d6 [{', '.join(str(r) for r in rolls)}] + {bonus} = ``{raw}``"
            if note:
                dmg_line += f"\n→ **{note}**"
                if not ("heals" in note.lower() and final < 0):
                    dmg_line += f" → ``{final}``"
            else:
                dmg_line += f"\n→ ``{final}``"
            emb.add_field(name="Damage", value=dmg_line, inline=False)

                               
            if _is_monster_file(tgt_path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                hp_tail = f"{before} → **{after}**"
            else:
                hp_tail = f"{old_hp} → **{new_hp}**"
            if new_hp <= 0:
                hp_tail += " ☠️ **DEAD!**"
            emb.add_field(name="Target HP", value=hp_tail, inline=False)

                                                                                 
            ...

            if new_hp <= 0 and _is_monster_file(tgt_path):
                try:
                    names2, scores2 = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names2, tgt_disp) or tgt_disp
                    if key in names2:
                        names2 = [n for n in names2 if n != key]
                        if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                        s_t = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s_t}{suf}"
                            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names2, scores2)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)

                                      
                    try:
                        os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass
                except Exception:
                    pass


                                                              
        rounds_left_after = max(0, rounds_left - 10)
        bcfg.set(chan_id, f"{s_me}.x_pfc", str(rounds_left_after))
        bcfg.set(chan_id, f"{s_me}.pfc_last_round", str(cur_round))

                                                                     
        if bcfg.get(chan_id, f"{s_me}.light_by", fallback="") == "ProduceFlameCold":
            new_light = max(0, bcfg.getint(chan_id, f"{s_me}.light", fallback=0) - 10)
            if new_light <= 0:
                for opt in (f"{s_me}.light", f"{s_me}.light_by", f"{s_me}.light_src"):
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
            else:
                bcfg.set(chan_id, f"{s_me}.light", str(new_light))

                                                 
        if rounds_left_after <= 0:
            for suf in ("", "_code", "_label", "_emoji", "_by"):
                opt = f"{s_me}.x_pfc{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
            for opt in (f"{s_me}.pfc_elem", f"{s_me}.pfc_last_round"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)

            emb.add_field(name="End", value="The conjured **energy gutters out**.", inline=False)

        _save_battles(bcfg)

                         
        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)                      
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        await ctx.send(embed=emb)


    async def _aaf_end(self, ctx, bcfg, chan_id: str, who_name: str, reason: str = "ended", *, quiet_embed=None):
        """
        Revert a shapeshifted druid back to their original form/hp.
        - Restores max HP & HP from the saved snapshot.
        - Restores small 'stats' backup (ac/move/type/attacknames/damage/resist/reduce1/immune).
        - Clears AAF/x_AAF/poly keys set by the effect.
        - If quiet_embed is provided (an Embed), appends a note instead of sending a new message.
        """
        

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, who_name) or who_name
        try:
            s_me = _slot(key)
        except Exception:
            s_me = key.replace(" ", "_")

                        
        if bcfg.getint(chan_id, f"{s_me}.aaf", fallback=0) <= 0:
            return

                      
        disp, path = self._resolve_char_ci(key)
        if not path or not os.path.exists(path):
            return

        cfg = read_cfg(path)

                    
        old_hp  = getint_compat(cfg, "cur", "hp", fallback=0)
        prev_hp   = bcfg.getint(chan_id, f"{s_me}.aaf_prev_hp",  fallback=old_hp)
        prev_mhp  = bcfg.getint(chan_id, f"{s_me}.aaf_prev_mhp", fallback=max(prev_hp, old_hp))
        if not cfg.has_section("max"): cfg.add_section("max")
        if not cfg.has_section("cur"): cfg.add_section("cur")
        cfg["max"]["hp"] = str(prev_mhp)
        cfg["cur"]["hp"] = str(max(0, min(prev_hp, prev_mhp)))

                                                                                
        if not cfg.has_section("stats"): cfg.add_section("stats")
        for k in ("ac","move","type","attacknames","damage","resist","reduce1","immune"):
            v = bcfg.get(chan_id, f"{s_me}.aaf_backup_stats_{k}", fallback=None)
            if v is not None:
                if v == "":
                                                   
                    try: cfg.remove_option("stats", k)
                    except Exception: cfg["stats"][k] = ""
                else:
                    cfg["stats"][k] = v

        write_cfg(path, cfg)

                        
        for suf in ("aaf","aaf_by","aaf_form","aaf_prev_hp","aaf_prev_mhp"):
            opt = f"{s_me}.{suf}"
            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
        for suf in ("x_aaf","x_aaf_label","x_aaf_code","x_aaf_by"):
            opt = f"{s_me}.{suf}"
            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)

                                                                 
        pf = (bcfg.get(chan_id, f"{s_me}.aaf_form", fallback="") or "")
        if pf and (bcfg.get(chan_id, f"{s_me}.poly", fallback="") or "").lower() == pf.lower():
            if bcfg.has_option(chan_id, f"{s_me}.poly"):
                bcfg.remove_option(chan_id, f"{s_me}.poly")

        _save_battles(bcfg)

                         
        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        msg = f"🐾 **Animal Form** on **{who_name}** — {reason}; original form restored (HP **{prev_hp}/{prev_mhp}**)."
        if quiet_embed is not None:
            quiet_embed.add_field(name="Assume Animal Form", value=msg, inline=False)
        else:
            emb = nextcord.Embed(title="Shapeshift ends", description=msg, color=0x66AA66)
            await ctx.send(embed=emb)


    async def _aaf_revert_if_slain(self, ctx, bcfg, chan_id: str, tgt_name: str, tgt_cfg, tgt_path: str, embed_obj):
        """
        Call this right after you apply damage and compute new_hp.
        If target is a PC with AAF active and HP ≤ 0, auto-revert instead of leaving them dead.
        Appends a note into the same embed you’re already sending.
        """
        if _is_monster_file(tgt_path):
            return
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            s_tgt = _slot(key)
        except Exception:
            s_tgt = key.replace(" ", "_")

        if bcfg.getint(chan_id, f"{s_tgt}.aaf", fallback=0) <= 0:
            return

                                                 
        cur_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
        if cur_hp > 0:
            return

        await self._aaf_end(ctx, bcfg, chan_id, tgt_name, reason="animal body slain", quiet_embed=embed_obj)

        
    def _canon(self, name: str) -> str:
        return self.item_index.get(_normalize_name(name), name)


    async def _dissolve_body_armor(self, ctx, tgt_name: str, tgt_cfg, tgt_path: str, *, embed, reason: str = "Dissolve Armor"):
        """
        Destroys non-magical body armor (eq.armor1) immediately.
        Magical armor gets a Save vs Death (Poison/Death Ray), adding its + to the roll.
        Adjusts AC, weight, move, and removes one copy from inventory.
        Returns True if armor was destroyed, False otherwise.
        """
        

                                
        a1 = (get_compat(tgt_cfg, "eq", "armor1", fallback="") or "").strip()
        if not a1 or a1.lower() in {"none", "no armor", "unarmored"}:
            embed.add_field(name=reason, value="No **body armor** worn.", inline=False)
            return False

                                  
        if re.search(r"\b(glass|stone)\b", a1, flags=re.I):
            embed.add_field(name=reason, value=f"**{a1}** is stone/glass — **unaffected**.", inline=False)
            return False

                        
        mag_plus = _magic_plus_from_name(a1)

                                                                                                   
        if mag_plus > 0:
            ok0, roll, dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
            if dc is None:
                ok = False
                sv_txt = "—"
            else:
                ok = (roll + mag_plus) >= dc
                sv_txt = f"{roll}+{mag_plus} vs {dc}"

            if ok:
                embed.add_field(name=reason, value=f"**{a1}** (magical) **resists** dissolving. Save: {sv_txt}.", inline=False)
                return False

                                               
            save_line = f"Failed save: {sv_txt}."

        else:
            save_line = "Non-magical: no save."

                                            
        try:
            old_ac = int(str(get_compat(tgt_cfg, "stats", "ac", fallback="10")).strip() or "10")
        except Exception:
            old_ac = 10
        old_eq_w, old_coin_w, old_total_w = self._weights_snapshot(tgt_cfg)

                           
        if not tgt_cfg.has_section("eq"):
            tgt_cfg.add_section("eq")
        tgt_cfg.set("eq", "armor1", "")
                               
        a2 = (get_compat(tgt_cfg, "eq", "armor2", fallback="") or "").strip()
        tgt_cfg.set("eq", "armor", "1" if a2 else "0")

                                              
        try:
            canon, it = self._item_lookup(a1)
            base = (canon or a1).strip().lower()
            cur = int(str(tgt_cfg.get("item", base, fallback="0")).strip() or "0")
            if cur > 0:
                tgt_cfg.set("item", base, str(cur - 1))
                                                                                   
                stor = (get_compat(tgt_cfg, "item", "storage", fallback="") or "").split()
                removed_one = False
                for i, tok in enumerate(list(stor)):
                    if "@" in tok:
                        continue
                    if tok.lower() == (canon or a1).strip().lower():
                        del stor[i]; removed_one = True; break
                if removed_one:
                    tgt_cfg.set("item", "storage", " ".join(stor))
        except Exception:
            pass

                                 
        new_weight = self._recompute_eq_weight(tgt_cfg)
        new_ac     = self._recompute_ac(tgt_cfg, channel=ctx.channel)
        new_move   = self._recompute_move(tgt_cfg)
        write_cfg(tgt_path, tgt_cfg)

                                                                                
        new_eq_w   = self._eq_weight_cached(tgt_cfg)
        new_coin_w = self._coin_weight_from_cfg(tgt_cfg)
        new_total  = new_eq_w + new_coin_w

        embed.add_field(
            name=reason,
            value=(f"**{a1}** is **DISSOLVED**. {save_line}\n"
                   f"AC: {old_ac} → **{new_ac}**   •   "
                   f"Weight: {self._fmt_w(old_total_w)} → **{self._fmt_w(new_total)}**  "
                   f"(coins {self._fmt_coin_w(old_coin_w)} → {self._fmt_coin_w(new_coin_w)})  •  "
                   f"Move: **{new_move}**"),
            inline=False
        )
        return True
        

    async def _maybe_corrode_weapon_on_hit(self, ctx, attacker_cfg, attacker_path, attacker_name: str, target_cfg, target_name: str, weapon_slot: str, weapon_name: str, embed):
                                                                        
        specials = " ".join([
            get_compat(target_cfg, "stats", "special", fallback="") or "",
            get_compat(target_cfg, "base",  "special", fallback="") or "",
            get_compat(target_cfg, "info",  "special", fallback="") or "",
        ]).lower()
        if "dissolveweapon" not in specials:
            return

        if not weapon_name or not self._nonmagical_weapon(weapon_name):
                                                                                
            return

                                                                                              
                                                                                      
        removed = self._eq_remove_weapon_by_slot(attacker_cfg, weapon_slot)            
        if removed:
                                            
            try:
                canon, it = self._item_lookup(removed)
                base = (canon or removed).strip().lower()
                cur = int(str(attacker_cfg.get("item", base, fallback="0")).strip() or "0")
                if cur > 0:
                    attacker_cfg.set("item", base, str(cur - 1))
            except Exception:
                pass
                                       
            self._recompute_eq_weight(attacker_cfg)
            self._recompute_ac(attacker_cfg, channel=ctx.channel)
            self._recompute_move(attacker_cfg)
            write_cfg(attacker_path, attacker_cfg)
            embed.add_field(name="Corroded Weapon", value=f"**{removed}** is **dissolved** on contact with {target_name}.", inline=False)        
        
            
    def _eq_find_weapon_slot(self, cfg, display_name: str) -> str | None:
        """Return the attacker's equipped slot name (e.g., 'weapon1') for this display_name, or None."""
        try:
            if cfg.has_section("eq"):
                for k, v in cfg.items("eq"):
                    if k.lower().startswith("weapon"):
                        if normalize_name(v) == normalize_name(display_name):
                            return k
        except Exception:
            pass
        return None
            
            
    async def _apply_burn_on_hit(self, ctx, bcfg, chan_id, attacker_name: str, target_name: str, tgt_cfg, embed, burn_die: str = "3d10"):
        """
        Giant Catfish 'burn' rider:
          • Save vs Poison on hit.
          • On fail: BURN timer (3d10 rounds first time; +6 rounds on each further poisoning),
                     stacking penalty −1 each time (min −5).
          • Manual penalties: use -b N on !a/!aoo and -N on !save.
        Stores:
          x_burn = rounds left
          x_burn_label = "BURN"
          x_burn_code = "burn"
          burn_pen = negative int (e.g., -3)
        """
        

                                                                    
        try:
            if _is_undead_cfg(tgt_cfg, target_name):
                embed.add_field(name="Burn (poison)", value="☠️ Undead — **no effect**.", inline=False)
                return
        except Exception:
            pass
        try:
            if self._poison_immune(tgt_cfg):
                embed.add_field(name="Burn (poison)", value="🧪 Poison-immune — **no effect**.", inline=False)
                return
        except Exception:
            pass

                        
        ok, roll, dc, _pen = self._roll_save(tgt_cfg, vs="poi", penalty=0)
        if dc is None:
            ok = False                                                      

        if ok:
            embed.add_field(
                name="Burn (poison)",
                value=f"Save vs Poison: {roll} vs {dc} → ✅ **RESISTED**.",
                inline=False
            )
            return

                            
        try:
            names_all, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names_all, target_name) or target_name
            try: slot = _slot(key)
            except Exception: slot = key.replace(" ", "_")
        except Exception:
            slot = target_name.replace(" ", "_")

                                 
        cur_left = bcfg.getint(chan_id, f"{slot}.x_burn", fallback=0)
        cur_pen  = bcfg.getint(chan_id, f"{slot}.burn_pen", fallback=0)                    

                                                                             
        new_left = None
        dice_txt = None
        if cur_left > 0:
            new_left = cur_left + 6
        else:
            s, rolls, flat = roll_dice(burn_die or "3d10")
            new_left = s + flat
            dice_txt = f"{burn_die} [{', '.join(str(r) for r in rolls)}] → **{new_left}**"

                                                     
        new_pen = -1 if cur_pen == 0 else max(-5, cur_pen - 1)

                      
        bcfg.set(chan_id, f"{slot}.x_burn", str(max(0, new_left)))
        bcfg.set(chan_id, f"{slot}.x_burn_label", "BURN")
        bcfg.set(chan_id, f"{slot}.x_burn_code", "burn")
        bcfg.set(chan_id, f"{slot}.burn_pen", str(new_pen))
        _save_battles(bcfg)

                              
        pen_txt = f"−{abs(new_pen)}"
        dur_txt = (f"{dice_txt}" if dice_txt else f"+6 rounds → **{new_left}**")
        embed.add_field(
            name="Burn (poison)",
            value=(
                f"Save vs Poison: {roll} vs {dc} → **FAIL**\n"
                f"🔥 **BURN** active: {dur_txt}\n"
                f"Penalties (manual): attacks **{pen_txt}** (use `-b {abs(new_pen)}` with `!a`), "
                f"saves **{pen_txt}** (use `-{abs(new_pen)}` with `!save`)."
            ),
            inline=False
        )


    async def _apply_dance_poison_on_hit(
        self, ctx, bcfg, chan_id, attacker_name: str, target_name: str, tgt_cfg, embed, primary: bool = True
    ):
        """
        Giant Tarantula 'dance poison':
          Primary (from bite on hit):
            • Save vs Poison on hit.
            • On fail: DANCE timer 2d10 rounds.
            • Manual penalties: attacks −4; saves −4; Thief abilities disabled while dancing.
            • Each *round* the primary victim dances: Save vs Poison or take 1d4 damage.
            • Neutralize Poison cures the primary victim.
            • Dispel Magic stops the dance (any victim) if within area.
          Secondary (onlookers via !dance): Save vs Spells; on fail dance 2d4 rounds; no poison damage.
        Stores (on the victim’s slot):
          x_dance              = rounds left (int)
          x_dance_label        = "DANCE"
          x_dance_code         = "poi" (primary) or "ench" (secondary)  # for spell-clearing hooks
          x_dance_kind         = "primary" | "secondary"
        """

                                                        
        try:
            from math import inf                                                  
            if _is_undead_cfg(tgt_cfg, target_name):
                embed.add_field(name="Dance Poison", value="☠️ Undead — **no effect**.", inline=False)
                return
        except Exception:
            pass
        try:
            if self._poison_immune(tgt_cfg):
                embed.add_field(name="Dance Poison", value="🧪 Poison-immune — **no effect**.", inline=False)
                return
        except Exception:
            pass

                                                      
        if primary:
            ok, roll, dc, _ = self._roll_save(tgt_cfg, vs="poi", penalty=0)
            if dc is None:
                ok = False                                                 
            if ok:
                embed.add_field(
                    name="Dance Poison",
                    value=f"Save vs Poison: {roll} vs {dc} → ✅ **RESISTED**.",
                    inline=False
                )
                return
                                        
            s, r, f = roll_dice("2d10"); dur = s + f
            kind = "primary"; code = "poi"
            dur_txt = f"2d10 [{', '.join(str(x) for x in r)}] → **{dur}**"
            note = ("While dancing: **−4 to attacks**, **−4 to saving throws**; "
                    "**Thief abilities disabled**. Each round: Save vs Poison or take **1d4** damage.")
        else:
                                                                                                        
            s, r, f = roll_dice("2d4"); dur = s + f
            kind = "secondary"; code = "ench"
            dur_txt = f"2d4 [{', '.join(str(x) for x in r)}] → **{dur}**"
            note = ("While dancing: **−4 to attacks**, **−4 to saving throws**; "
                    "**Thief abilities disabled**. (No poison damage.)")

                               
        try:
            names_all, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names_all, target_name) or target_name
            try: slot = _slot(key)
            except Exception: slot = key.replace(" ", "_")
        except Exception:
            slot = target_name.replace(" ", "_")

                                
        bcfg.set(chan_id, f"{slot}.x_dance",        str(max(0, dur)))
        bcfg.set(chan_id, f"{slot}.x_dance_label",  "DANCE")
        bcfg.set(chan_id, f"{slot}.x_dance_code",   code)                                                                         
        bcfg.set(chan_id, f"{slot}.x_dance_kind",   kind)                            
        _save_battles(bcfg)

                          
        head = "🕷️ **DANCE POISON!**" if primary else "🕷️ **DANCE (secondary)!**"
        embed.add_field(
            name="Tarantula Venom",
            value=(f"{head}\nDuration: {dur_txt}\n{note}\n"
                   "Manual penalties: use `-b -4` with `!a` and `-4` with `!save`."),
            inline=False
        )


    def _hr_section_id(self, channel) -> str:
        """Return the persistent house-rules section for this channel."""
        base = _section_id(channel)                                        
        return f"{base}:hr"


    def _hr_enabled(self, channel, key: str, default: bool = True) -> bool:
        """
        Per-channel toggle, stored under <chan_base>:hr
          heroic_called_shot = 1/0
          quarterstaff_defense = 1/0
        """
        try:
            cfg = _load_battles()
            sec = self._hr_section_id(channel)
            if not cfg.has_section(sec):
                cfg.add_section(sec)
            if not cfg.has_option(sec, key):
                cfg.set(sec, key, "1" if default else "0")
                _save_battles(cfg)
            return cfg.getboolean(sec, key)
        except Exception:
            return default


    def _hr_set(self, channel, key: str, value: bool) -> None:
        try:
            cfg = _load_battles()
            sec = self._hr_section_id(channel)
            if not cfg.has_section(sec):
                cfg.add_section(sec)
            cfg.set(sec, key, "1" if value else "0")
            _save_battles(cfg)
        except Exception:
            pass


    def _hr_known(self) -> dict[str, dict]:
        return {
            "heroic_called_shot":   {"default": True, "desc": "Fighter/Ftr-Mage auto called shot on ≥4 to-hit margin."},
            "quarterstaff_defense": {"default": True, "desc": "+1 AC until next turn when attacking with quarterstaff (no TWF)."},
            "ability_4d6dl":        {"default": True, "desc": "Use 4d6 drop lowest for ability scores (instead of 3d6)."},
            "barbarian_leather_only":     {"default": True, "desc": "Barbarians may only wear leather armor (≤20 wt.); shields OK."},
            "barbarian_unarmored_defense":{"default": True, "desc": "Barbarians gain level-based AC when unarmored."},
            "classic_vancian_prep": {"default": False, "desc": "Prepare duplicate copies (e.g., Sleep x2). Modular OFF."},
            "magethief_illusionist_list": {"default": True, "desc": "Magethief uses Illusionist spells (OFF = Magic-User list)."},
            
        }


    def _hr_migrate_once(self, channel) -> None:
        """
        If legacy keys existed on <chan_base> (hr.heroic_called_shot, etc),
        move them into <chan_base>:hr and remove the old options.
        """
        try:
            cfg = _load_battles()
            base = _section_id(channel)
            sec_hr = self._hr_section_id(channel)
            moved = False

            if cfg.has_section(base):
                if not cfg.has_section(sec_hr):
                    cfg.add_section(sec_hr)

                for k, info in self._hr_known().items():
                    old_key = f"hr.{k}"
                    if cfg.has_option(base, old_key) and not cfg.has_option(sec_hr, k):
                        raw = cfg.get(base, old_key, fallback=None)
                        val = str(raw).strip().lower() in {"1","true","t","yes","y","on","enable","enabled"}
                        cfg.set(sec_hr, k, "1" if val else "0")
                        cfg.remove_option(base, old_key)
                        moved = True

            if moved:
                _save_battles(cfg)
        except Exception:
            pass


def setup(bot):
    bot.add_cog(Combat(bot))
