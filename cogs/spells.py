from __future__ import annotations
import os, re, random, configparser
import nextcord
import shutil
import io
import inspect
import math
import difflib
import asyncio
import secrets
import sys
import time
import collections
import datetime
from functools import partial
from typing import Dict, List, Tuple, Optional
from nextcord.ext import commands
from utils.ini import read_cfg, write_cfg, get_compat, getint_compat
from utils.players import get_active
from pathlib import Path

from cogs.initiative import (
    _load_battles, _parse_combatants, _write_combatants,
    _sorted_entries, _format_tracker_block, _life_bar, _slot, _save_battles,
    _find_ci_name, _load_monster_template, _choose_slot_for_effects,
    _find_ci_or_partial_name,
)

from cogs.combat import roll_dice, _apply_mitigation, _is_monster_file, _is_undead_cfg, _parse_combatants
from collections import Counter


ANIMAL_HD = {
    "Camel":2, "Donkey":2, "DraftHorse":3, "RidingHorse":2, "WarHorse":3,
    "Mule":2, "Pony":1, "LargeAnt":1, "HugeAnt":2, "GiantAnt":4,
    "Antelope":2, "Elk":3, "Moose":4, "CarnivorousApe":4,
    "Bat":1, "GiantBat":2, "BlackBear":4, "BrownBear":5, "PolarBear":6, "CaveBear":7,
    "GiantBee":1, "GiantBombadierBeetle":2, "GiantFireBeetle":1, "GiantOilBeetle":2, "GiantTigerBeetle":3,
    "Boar":3, "Cattle":2, "Aurochs":3, "Bison":4,
    "GiantCaveLocust":2, "GiantCentipede":1,
    "Cheetah":2,
    "GiantCrab":3,
    "Crocodile":2, "LargeCrocodile":6, "GiantCrocodile":15,
    "Deinonychus":3, "Pterodactyl":1, "Pteranodon":5, "Stegosaurus":11, "Triceratops":11, "TRex":18,
    "Dog":1, "RidingDog":2,
    "Eagle":2, "GiantEagle":4, "Elephant":10, "Falcon":1,
    "HugeBarracuda":5, "GiantBarracuda":9, "GiantBass":2, "GiantCatfish":8, "GiantPiranha":4,
    "GiantFly":2, "GiantFrog":2, "GiantToad":2,
    "Hawk":1, "GiantHawk":4,
    "Hyena":2, "Jaguar":4, "Leopard":4, "Panther":4, "Lion":5,
    "GiantDracolizard":4, "GiantGecko":3, "GiantHornedChameleon":5, "GiantLeech":6, "GiantTuatara":6,
    "LargeMonitorLizard":3, "HugeMonitorLizard":5, "GiantMonitorLizard":7,
    "MountainLion":3,
    "GiantOctopus":8,
    "Ostrich":3, "Emu":2,
    "Owl":1, "Parrot":1,
    "Rat":1, "GiantRat":1,
    "BlackRhinoceros":8, "WoollyRhinoceros":12,"Titanothere":12,
    "RockBaboon":2, "RotGrub":1,
    "SabretoothCat":8,
    "GiantScorpion":4,
    "SeaSerpent":6,
    "BullShark":2, "GreatWhiteShark":8, "MakoShark":4,
    "GiantShrew":1, "GiantVenomousShrew":1,
    "Python":5, "PitViper":1, "GiantPitViper":2, "SeaSnake":3, "SpittingCobra":1,
    "GiantBlackWidow":3, "GiantCrabSpider":2, "GiantTarantula":4,
    "GiantSquid":7,
    "Tiger":6,
    "SnappingTurtle":1,
    "KillerWhale":6, "Narwhal":12, "SpermWhale":36,
    "Wolf":2, "DireWolf":4,"GiantCaecilia": 6,
}

def _ak(s: str) -> str:
    return "".join(ch.lower() for ch in str(s) if ch.isalnum())


_ANIMAL_ALIAS = {}
for canon in ANIMAL_HD.keys():
    k = _ak(canon)
    _ANIMAL_ALIAS[k] = canon
    _ANIMAL_ALIAS[k + "s"] = canon

_ANIMAL_ALIAS["wolves"] = "Wolf"
_ANIMAL_ALIAS["sabretooth"] = "SabretoothCat"
_ANIMAL_ALIAS["sabertooth"] = "SabretoothCat"
_ANIMAL_ALIAS["saberetoothcat"] = "SabretoothCat"
_ANIMAL_ALIAS["sabretoothcat"] = "SabretoothCat"
_ANIMAL_ALIAS["greatwhiteshark"] = "GreatWhiteShark"
_ANIMAL_ALIAS["brownbear"] = "BrownBear"
_ANIMAL_ALIAS["blackbear"] = "BlackBear"
_ANIMAL_ALIAS["polarbear"] = "PolarBear"
_ANIMAL_ALIAS["warhorse"] = "WarHorse"
_ANIMAL_ALIAS["ridinghorse"] = "RidingHorse"
_ANIMAL_ALIAS["ridingdog"] = "RidingDog"
_ANIMAL_ALIAS["giantpitviper"] = "GiantPitViper"
_ANIMAL_ALIAS["seasnake"] = "SeaSnake"
_ANIMAL_ALIAS["giantcrabspider"] = "GiantCrabSpider"
_ANIMAL_ALIAS["giantblackwidow"] = "GiantBlackWidow"

def _canon_animal(tok: str) -> str | None:
    return _ANIMAL_ALIAS.get(_ak(tok))

def _prefix_from_kind(kind: str) -> str:
    """
    Nice short code from CamelCase â†’ e.g., GiantPitViper -> GPV; WarHorse -> WH; Wolf -> WO
    """
    parts = re.findall(r"[A-Z][a-z]*", kind) or [kind]
    code = "".join(p[0] for p in parts)[:3]
    if len(code) < 2:
        code = (code + kind.upper())[:2]
    return code

TURN_ROUNDS = 60

MONSTER_DIRS = ["monsters", "."]
SAVE_KEYS = ("poi", "wand", "para", "breath", "spell")


_ARCANE_UNLOCK = [(1,1),(3,2),(5,3),(7,4),(9,5),(11,6),(14,7)]

_DIVINE_UNLOCK = [(2,1),(4,2),(6,3),(8,4),(11,5),(12,6),(14,7)]

_PALADIN_UNLOCK = [(10,1),(12,2)]

def _sanity_patch_builtins() -> None:
    """If any built-in rows are wrong (from stale code), fix them in-place."""
    want_f1 = {"poi":12, "wand":13, "para":14, "breath":15, "spell":17}
    bad = False
    cur = globals().get("_DEFAULT_F1", {})
    if tuple(cur.get(k) for k in ("poi","wand","para","breath","spell")) !=\
       tuple(want_f1[k] for k in ("poi","wand","para","breath","spell")):
        globals()["_DEFAULT_F1"] = want_f1.copy()
        bad = True
    frow = globals().get("_BUILTIN_L1", {}).get("fighter", {})
    if tuple(frow.get(k) for k in ("poi","wand","para","breath","spell")) !=\
       tuple(want_f1[k] for k in ("poi","wand","para","breath","spell")):
        _BUILTIN_L1["fighter"] = want_f1.copy()
        bad = True
    if bad:

        pass

SAVE_KEYS = ("poi", "wand", "para", "breath", "spell")


_BUILTIN_L1 = {
    "fighter":   {"poi": 12, "wand": 13, "para": 14, "breath": 15, "spell": 17},
    "cleric":    {"poi": 11, "wand": 12, "para": 14, "breath": 16, "spell": 15},
    "magicuser": {"poi": 13, "wand": 14, "para": 13, "breath": 16, "spell": 15},
}
_DEFAULT_F1 = _BUILTIN_L1["fighter"]


_CLASS_SAVES: Optional[Dict[str, Dict[str, List[int]]]] = None
_CLASS_SAVES_SOURCE: Optional[str] = None
_CLASS_SAVES_OVERRIDE_PATH: Optional[str] = None
_CLASS_LST_ENV = "SEER_CLASS_LST"

_SAVE_KEY_CANON = {
    "poi": "poi", "poison": "poi", "death": "poi",
    "wand": "wand", "wands": "wand",
    "para": "para", "paralyze": "para", "paralysis": "para", "petrify": "para",
    "breath": "breath", "dragonbreath": "breath",
    "spell": "spell", "spells": "spell"
}

def _canon_vs(v: str) -> str:
    k = (str(v) or "").lower().replace(" ", "")
    return _SAVE_KEY_CANON.get(k, k)

def _norm_class_name(name: str) -> str:
    n = (name or "").strip().lower().replace("_", " ").replace("-", " ")

    exact = {
        "fighter": "fighter",
        "fightermage": "fightermage", "fighter mage": "fightermage",
        "magic user": "magic-user", "magic-user": "magic-user", "mu": "magic-user", "mage": "magic-user", "wizard": "magic-user",
        "cleric": "cleric", "druid": "druid", "thief": "thief", "assassin": "assassin",
        "ranger": "ranger", "paladin": "paladin", "barbarian": "barbarian",
        "illusionist": "illusionist", "necromancer": "necromancer", "spellcrafter": "spellcrafter",
        "nm": "nm", "normal man": "nm", "normalman": "nm",
    }
    return exact.get(n, n)

def _section_for_class(klass: str) -> str | None:
    """Return the exact class section (no prefix/fuzzy)."""
    _ensure_tables_loaded()
    k = _norm_class_name(klass)
    by_norm = { _norm_class_name(sec): sec for sec in (_CLASS_SAVES or {}).keys() }
    return by_norm.get(k)


def _load_class_saves_from_cache() -> dict[str, dict[str, list[int]]]:
    out = {}
    for sec, kv in _CLASS_CACHE.items():
        block = {}
        for key in ("poi", "wand", "para", "breath", "spell"):
            src = "spells" if key == "spell" and "spells" in kv else key
            vals = kv.get(src, [])
            block[key] = vals if isinstance(vals, list) else []
        out[sec] = block
    return out

def _find_class_lst_with_traces() -> Tuple[Optional[str], List[str]]:
    """Find class.lst using override, env, CWD, data, and file dir."""
    tried: List[str] = []

    if _CLASS_SAVES_OVERRIDE_PATH:
        p = os.path.abspath(_CLASS_SAVES_OVERRIDE_PATH)
        tried.append(p)
        if os.path.exists(p): return p, tried

    envp = os.environ.get(_CLASS_LST_ENV)
    if envp:
        p = os.path.abspath(envp)
        tried.append(p)
        if os.path.exists(p): return p, tried

    here = os.path.dirname(__file__)
    for p in [
        os.path.join(os.getcwd(), "class.lst"),
        os.path.join(os.getcwd(), "data", "class.lst"),
        os.path.join(here, "class.lst"),
        "class.lst",
    ]:
        tried.append(p)
        if os.path.exists(p): return p, tried
    return None, tried

def load_class_saves(path: Optional[str]) -> Dict[str, Dict[str, List[int]]]:
    """Parse class.lst into {class: {poi|wand|para|breath|spell: [20 ints]}}."""
    if not path: return {}
    cfg = configparser.ConfigParser()
    cfg.optionxform = str.lower
    with open(path, "r", encoding="utf-8") as f:
        cfg.read_file(f)
    out: Dict[str, Dict[str, List[int]]] = {}
    for sect in cfg.sections():
        vals = cfg[sect]
        row: Dict[str, List[int]] = {}
        for src in SAVE_KEYS:
            if src in vals:
                nums = [int(x) for x in re.findall(r"-?\d+", vals[src])]
                if not nums: continue
                if len(nums) < 20: nums = nums + [nums[-1]] * (20 - len(nums))
                row[src] = nums[:20]
        if row:
            out[_norm_class_name(sect)] = row
    return out

def _ensure_tables_loaded(force: bool=False) -> Optional[str]:
    """Load or reload tables. Returns the source path used (or None for builtin)."""
    global _CLASS_SAVES, _CLASS_SAVES_SOURCE
    if _CLASS_SAVES is not None and not force:
        return _CLASS_SAVES_SOURCE
    path, _tried = _find_class_lst_with_traces()
    tables = load_class_saves(path) if path else {}
    if tables:
        _CLASS_SAVES = tables
        _CLASS_SAVES_SOURCE = os.path.abspath(path) if path else None
    else:
        _CLASS_SAVES = {}
        _CLASS_SAVES_SOURCE = None
    return _CLASS_SAVES_SOURCE

def _get_f1_row() -> Dict[str, int]:
    """Fighter 1 row, from file if present; else builtin."""
    _ensure_tables_loaded()
    if _CLASS_SAVES and "fighter" in _CLASS_SAVES:
        row = _CLASS_SAVES["fighter"]
        return {k: int(row[k][0]) for k in SAVE_KEYS if k in row}
    return dict(_DEFAULT_F1)

def _parse_saveas(self, s: str) -> tuple[str, int]:
    """
    Accepts:
      â€¢ 'Fighter 5', 'fighter 05'
      â€¢ 'NM', 'Normal Man'
      â€¢ 'Fighter' (defaults to level 1)
    Returns (klass, level). Level may be ignored by special classes like NM.
    """
    t = (str(s) or "").strip()
    if not t:
        return "", 0
    norm = t.lower().replace("_", " ").replace("-", " ").strip()
    if norm in {"nm", "normal man", "normalman"}:
        return "NM", 1

    m = re.match(r"\s*([A-Za-z][A-Za-z\-\s]+?)\s+(\d+)\s*$", t)
    if m:
        return m.group(1).strip(), int(m.group(2))


    return t.title(), 1

def _class_save_target(klass: str, level: int, vs: str):
    _ensure_tables_loaded()

    v = _canon_vs(vs)
    k = _norm_class_name(klass)

    if k == "nm":
        base = _class_save_target("fighter", 1, v)
        return (base + 1) if isinstance(base, int) else None

    sec = _section_for_class(k)
    if not sec:
        return None

    arr = (_CLASS_SAVES or {}).get(sec, {}).get(v, [])
    if not isinstance(arr, list) or not arr:
        return None

    idx = max(0, min(int(level) - 1, len(arr) - 1))
    try:
        return int(arr[idx])
    except Exception:
        return None



def _get_saveas_from_cfg(t_cfg) -> Optional[str]:
    """Try to read 'saveas' from [base]/[stats]/[info] (case-insensitive)."""
    for sec in ("base","stats","info"):
        try:
            try:
                v = get_compat(t_cfg, sec, "saveas", fallback=None)
            except Exception:
                v = t_cfg.get(sec, "saveas", fallback=None) if hasattr(t_cfg, "get") else None
            if v:
                s = str(v).strip()
                if s:
                    return s
        except Exception:
            pass
    return None


def _norm_type_token(t: str | None) -> str:
    t = (t or "").strip().lower()
    if t in {"elec","electricity","lightning"}: return "electric"
    if t in {"acidic"}: return "acid"
    return t

def _collect_absorb_types(t_cfg) -> set[str]:
    def _tokset(s):
        return {x.strip().lower() for x in re.split(r"[,\s]+", str(s or "")) if x.strip()}

    def _merge_keys(cfg, section, *keys):
        out = set()
        for k in keys:
            out |= _tokset(get_compat(cfg, section, k, fallback=""))
        return out

    absorb = (_merge_keys(t_cfg, "base","absorb","absorb_types")
           |  _merge_keys(t_cfg, "stats","absorb","absorb_types")
           |  _merge_keys(t_cfg, "info","absorb","absorb_types"))


    try:
        mtype = (get_compat(t_cfg, "info", "monster_type", fallback="")
                 or get_compat(t_cfg, "info", "type", fallback="")).strip().lower()
        if mtype:
            for cand in (f"{mtype}.ini", os.path.join("mon", f"{mtype}.ini"), os.path.join("monsters", f"{mtype}.ini")):
                if os.path.exists(cand):
                    base_cfg = read_cfg(cand)
                    absorb |= (_merge_keys(base_cfg,"base","absorb","absorb_types")
                            |   _merge_keys(base_cfg,"stats","absorb","absorb_types")
                            |   _merge_keys(base_cfg,"info","absorb","absorb_types"))
                    break
    except Exception:
        pass

    return {_norm_type_token(x) for x in absorb if x}



_ITEM_KEYWORDS = {
    
    "blasting": {"names": ["BellofBlasting","DrumsofBlasting","HornofBlasting"], "handler": "_item_blasting"},
    "panic":    {"names": ["BellofPanic","DrumsofPanic","HornofPanic"],           "handler": "_item_panic"},
    "courage":  {"names": ["BellofCourage","DrumsofCourage","HornofCourage"],     "handler": "_item_courage"},
    "doom":     {"names": ["BellofDoom","DrumsofDoom","HornofDoom"],               "handler": "_item_doom"},
    "telekinesis": {
        "names": ["RingofTelekinesis", "PendantofTelekinesis"],
        "handler": "_item_telekinesis",
    },

    
    "invisibility": {"names": ["BeltofInvisibility","CloakofInvisibility","PendantofInvisibility","RingofInvisibility"], "handler": "_item_invisibility"},
    "levitation":   {"names": ["BootsofLevitation","PendantofLevitation","RingofLevitation"],                               "handler": "_item_levitation"},
    "speed":        {"names": ["BootsofSpeed","PendantofSpeed","RingofSpeed"],                                             "handler": "_item_speed"},
    "trueseeing":   {"names": ["LensofTrueSeeing","MirrorofTrueSeeing","PendantofTrueSeeing","RingofTrueSeeing"],          "handler": "_item_trueseeing"},

    
    "controlanimal": {"names": ["PendantofControlAnimal","RingofControlAnimal"], "handler": "_item_controlanimal"},
    "controlhuman":  {"names": ["PendantofControlHuman","RingofControlHuman"],   "handler": "_item_controlhuman"},
    "controlplant":  {"names": ["PendantofControlPlant","RingofControlPlant"],   "handler": "_item_controlplant"},
}

def _strip_instance(s: str) -> str:
    try: return self._strip_instance_tag(s)
    except Exception: return str(s).split("@",1)[0].strip()

def _base_item_name(self, s: str) -> str:
    if s is None:
        return ""
    txt = str(s).strip()
    
    txt = txt.replace("**", "")
    if " x" in txt:
        txt = txt.split(" x", 1)[0]
    
    try:
        return self._strip_instance_tag(txt)
    except Exception:
        return txt.split("@", 1)[0].strip()



def _get_idaily(cfg, key: str, default: int = 0) -> int:
    if not cfg.has_section("item_daily"): cfg.add_section("item_daily")
    return getint_compat(cfg, "item_daily", key, fallback=default)

def _set_idaily(cfg, key: str, val: int) -> None:
    if not cfg.has_section("item_daily"): cfg.add_section("item_daily")
    cfg.set("item_daily", key, str(max(0, int(val))))



def osr_mod(score: int) -> int:
    s = max(1, int(score))
    if s <= 3:   return -3
    if s <= 5:   return -2
    if s <= 8:   return -1
    if s <= 12:  return 0
    if s <= 15:  return +1
    if s <= 17:  return +2
    return +3

def _bfrpg_mod(score: int) -> int:
    """
    Basic Fantasy ability modifier:
    3:-3, 4â€“5:-2, 6â€“8:-1, 9â€“12:0, 13â€“15:+1, 16â€“17:+2, 18:+3 (cap at Â±3)
    """
    try:
        s = int(score)
    except Exception:
        s = 10
    if s <= 3:   return -3
    if s <= 5:   return -2
    if s <= 8:   return -1
    if s <= 12:  return 0
    if s <= 15:  return 1
    if s <= 17:  return 2
    return 3

def _hr_enabled_anywhere(channel, key: str, default: bool = True) -> bool:
    try:
        cfg = _load_battles()
        sec = f"{_section_id(channel)}:hr"
        return cfg.getboolean(sec, key, fallback=default)
    except Exception:
        return default

def _norm_key(s: str) -> str:
    return re.sub(r"[^a-z0-9]", "", s.lower())

def normalize_name(s: str) -> str:
    """normalize for matching: lowercase & alnum only"""
    return "".join(ch.lower() for ch in s if ch.isalnum())

def _mitigate_cold(dmg: int, t_cfg):
    """Apply simple cold mitigation (immune > reduce1 > resist). Returns (final, note)."""
    if dmg <= 0:
        return 0, ""
    resist, reduce1, immune = _defense_sets(t_cfg)
    if "cold" in immune:
        return 0, "Immune (cold)"
    if "cold" in reduce1:
        return 1 if dmg > 0 else 0, "Reduced to 1 (cold)"
    if "cold" in resist:
        return max(0, dmg // 2), "Resisted (cold)"
    return dmg, ""



def _resolve_effect_slot(bcfg, chan_id, name):
    try:
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, name) or name
        return _slot(key) if '_slot' in globals() else key.replace(" ", "_"), key
    except Exception:
        return name.replace(" ", "_"), name

def _get_save_number_for(target_cfg, cls_fallback="Fighter", lvl_fallback=1, kind="para") -> int:
    """
    Return the save target # for the given kind ('poi','wand','para','breath','spell').
    Prefers the .coe [saves] block. Otherwise compute from class & level via tables.
    """
    vs = _canon_vs(kind)


    try:
        v = getint_compat(target_cfg, "saves", vs, fallback=None)
        if isinstance(v, int) and v > 0:
            return v
    except Exception:
        pass


    try:
        sa = _get_saveas_from_cfg(target_cfg)
        if sa:
            cls_name, lvl = _parse_saveas(sa)
            return int(_class_save_target(cls_name, lvl, vs))
    except Exception:
        pass


    try:
        cls_name = (get_compat(target_cfg, "info", "class", fallback=cls_fallback) or cls_fallback)
    except Exception:
        cls_name = cls_fallback
    try:
        lvl = max(1, int(getint_compat(target_cfg, "cur", "level", fallback=lvl_fallback)))
    except Exception:
        lvl = max(1, int(lvl_fallback))

    return int(_class_save_target(cls_name, lvl, vs))

def _d(n: int) -> int:
    return random.randint(1, n)


def _norm(s: str) -> str:
    return "".join(ch.lower() for ch in str(s) if ch.isalnum())


async def _maybe_await(x):
    return await x if inspect.isawaitable(x) else x

def _slot_safe(name: str) -> str:
        try:
            return _slot(name)
        except Exception:
            return (name or "").replace(" ", "_")


def _load_spell_list(path: str = "spell.lst"):

    raw = ""
    try:
        with open(path, "r", encoding="utf-8") as f:
            raw = f.read()
    except FileNotFoundError:
        pass

    first = raw.find("[")
    trimmed = raw[first:] if first != -1 else ""

    cp = configparser.ConfigParser()
    cp.optionxform = str
    if trimmed:
        cp.read_string(trimmed)
    else:
        cp.read(path)


    by_class: dict[str, dict[int, list[str]]] = {}
    for sec in cp.sections():
        if sec.startswith("["):
            continue
        level_map = {}
        has_levels = False
        for k, v in cp.items(sec):
            m = re.fullmatch(r"l(\d+)", k.strip(), flags=re.I)
            if m:
                lvl = int(m.group(1))
                toks = [t for t in v.split() if t]
                level_map[lvl] = toks
                has_levels = True
        if has_levels:
            by_class[sec] = level_map

    return by_class, cp

def _resolve_effect_slot(cfg, chan_id: str, name_like: str) -> str:
    """
    Return the initiative slot key (the bit before the dot) that the tracker
    will use for `name_like` (matching canonical name, display name, etc.).
    """
    name_like = (name_like or "").strip()
    try:
        s1 = _slot(name_like)
    except Exception:
        s1 = name_like.replace(" ", "_")


    cands = [s1]


    try:
        names, _ = _parse_combatants(cfg, chan_id)
    except Exception:
        names = []
    ci = _find_ci_name(names, name_like)
    if ci:
        try:
            cands.insert(0, _slot(ci))
        except Exception:
            cands.insert(0, ci.replace(" ", "_"))


    disp0 = cfg.get(chan_id, f"{cands[0]}.disp", fallback="")
    if disp0 and disp0.strip().lower() != name_like.lower():
        cands.append(disp0.replace(" ", "_"))


    for nm in names:
        s = nm.replace(" ", "_")
        d = cfg.get(chan_id, f"{s}.disp", fallback="")
        if d and d.strip().lower() == name_like.lower():
            cands.insert(0, s)
            break


    prefer = ("dex","join","paralyzed","blind","cc","ck","light","darkness","mi",
              "magwep","ghh","sph","shl","hyp","cl","cn","db","inw","pnm","x_")
    section_items = list(cfg.items(chan_id))
    for s in cands:
        for opt, _ in section_items:
            if opt.startswith(f"{s}."):
                suf = opt.split(".", 1)[1]
                if any(suf.startswith(p) for p in prefer):
                    return s
    return cands[0]


def _load_slots_table(path: str = "class.lst"):
    cp = configparser.ConfigParser()
    cp.optionxform = str
    cp.read(path)
    return cp

def _slots_for_class_level(class_cp: configparser.ConfigParser, class_section: str, level: int) -> dict[int, int]:
    """
    Returns {1:slots_at_lvl1, 2:..., ... 7:...}. Missing = 0
    """

    sec_key = None
    for sec in class_cp.sections():
        if sec.lower() == class_section.lower():
            sec_key = sec
            break
    result = {i: 0 for i in range(1, 8)}
    if not sec_key:
        return result

    for spell_lvl in range(1, 8):
        key = f"spell{spell_lvl}"
        if key in class_cp[sec_key]:
            try:
                arr = [int(x) for x in class_cp[sec_key][key].split()]
                result[spell_lvl] = arr[min(max(1, level) - 1, len(arr) - 1)]
            except Exception:
                result[spell_lvl] = 0
    return result

def _is_animal_cfg(t_cfg, pretty: str | None = None) -> bool:
    """
    Heuristic: treat as an 'animal' if any of these fields contain 'animal':
      [stats].type, [base].type, [info].race, [info].monster_type.
    (Lenient: 'animal' match; GM decides 'fantastic nature' separately.)
    """
    def _lv(section: str, key: str) -> str:
        try:
            return str(get_compat(t_cfg, section, key, fallback="") or "").strip().lower()
        except Exception:
            return ""
    blob = " ".join([
        _lv("stats", "type"),
        _lv("base",  "type"),
        _lv("info",  "race"),
        _lv("info",  "monster_type"),
    ])
    return "animal" in blob

def _is_construct_cfg(t_cfg, pretty: str | None = None) -> bool:
    """
    Heuristic: treat as a construct if any of these fields mention it:
      [stats].type, [base].type, [info].race, [info].monster_type
    Matches 'construct', 'golem', 'automaton', 'clockwork', 'animated object', 'vehicle', etc.
    """
    def _lv(section: str, key: str) -> str:
        try:
            return str(get_compat(t_cfg, section, key, fallback="") or "").strip().lower()
        except Exception:
            return ""
    blob = " ".join([
        _lv("stats", "type"),
        _lv("base",  "type"),
        _lv("info",  "race"),
        _lv("info",  "monster_type"),
    ])

    tokens = {
        "construct","golem","automaton","clockwork","animated","animated object","statue",
        "guardian statue","homunculus","vehicle","ship","cart","wagon","war machine","robot","android"
    }
    return any(tok in blob for tok in tokens)

def _unlink_domcon(bcfg, chan_id: str, caster_key: str, target_key: str | None = None):
    """
    Clears the domination link both ways, if present.
    If target_key is None, it looks up caster_key.domcon to find it.
    """
    try:
        s_cast = _slot(caster_key) if '_slot' in globals() else caster_key.replace(" ","_")
    except Exception:
        s_cast = caster_key.replace(" ","_")


    if target_key is None and bcfg.has_option(chan_id, f"{s_cast}.domcon"):
        target_key = bcfg.get(chan_id, f"{s_cast}.domcon", fallback="").strip()


    if bcfg.has_option(chan_id, f"{s_cast}.domcon"):
        bcfg.remove_option(chan_id, f"{s_cast}.domcon")


    if target_key:
        try:
            s_tgt = _slot(target_key) if '_slot' in globals() else target_key.replace(" ","_")
        except Exception:
            s_tgt = target_key.replace(" ","_")
        for suf in ("domby","domcon_perm","domcon_un"):
            opt = f"{s_tgt}.{suf}"
            if bcfg.has_option(chan_id, opt):
                bcfg.remove_option(chan_id, opt)


def _ensure_section(cfg: configparser.ConfigParser, name: str):
    if not cfg.has_section(name):
        cfg.add_section(name)

def _read_list(cfg, section: str, key: str) -> list[str]:
    v = get_compat(cfg, section, key, fallback="").strip()
    return [t for t in v.split() if t]

def _write_list(cfg, section: str, key: str, items: list[str]):
    _ensure_section(cfg, section)
    cfg.set(section, key, " ".join(items))

def _read_per_level_list(cfg, section: str) -> dict[int, list[str]]:
    out = {}
    if cfg.has_section(section):
        for k, v in cfg.items(section):
            m = re.fullmatch(r"l(\d+)", k, flags=re.I)
            if m:
                out[int(m.group(1))] = [t for t in (v or "").split() if t]
    return out

def _write_per_level_list(cfg, section: str, data: dict[int, list[str]]):
    _ensure_section(cfg, section)
    for lvl, spells in data.items():
        cfg.set(section, f"l{lvl}", " ".join(spells))

def _ensure_slots_for(cfg, slots_total: dict[int, int]):
    """
    Ensure [slots] has l{n}_total / l{n}_spent for every level in slots_total
    (including L0), and clamp spent â‰¤ total. Returns True if anything changed.
    """
    _ensure_section(cfg, "slots")
    changed = False
    for lvl, total in slots_total.items():
        total = int(total or 0)
        key_t = f"l{lvl}_total"
        key_s = f"l{lvl}_spent"
        prev_t = getint_compat(cfg, "slots", key_t, fallback=None)
        prev_s = getint_compat(cfg, "slots", key_s, fallback=None)

        if prev_t is None or prev_t != total:
            cfg.set("slots", key_t, str(total)); changed = True

        if prev_s is None:
            cfg.set("slots", key_s, "0"); changed = True
        else:
            if prev_s > total:
                cfg.set("slots", key_s, str(total)); changed = True
    return changed

def _bubble_line(total: int, spent: int) -> str:
    """
    â— = available, â—‹ = spent.
    Empties appear on the RIGHT as you spend.
    """
    spent = max(0, min(spent, total))
    available = total - spent
    return "â—" * available + "â—‹" * spent

def _highest_caster_level(slots_total: dict[int, int]) -> int:
    lvls = [lvl for lvl, t in slots_total.items() if t and lvl >= 1]
    return max(lvls) if lvls else 0

def _underline_prepared(all_spells: list[str], prepared: list[str]) -> list[str]:
    """
    Underline up to the count a spell appears in prepared (case-insensitive).
    """

    prep_counts = {}
    for s in prepared:
        prep_counts[_norm(s)] = prep_counts.get(_norm(s), 0) + 1

    out = []
    for name in all_spells:
        key = _norm(name)
        if prep_counts.get(key, 0) > 0:
            out.append(f"__{name}__")
            prep_counts[key] -= 1
        else:
            out.append(name)
    return out

def _signed(n: int) -> str:
    return f"{'+' if n >= 0 else 'â€“'}{abs(n)}"

def _truthy(v) -> bool:
    return str(v).strip().lower() in {"1","true","yes","y","on"}


def _has_mummy_rot(cfg) -> bool:
    try:
        return getint_compat(cfg, "cur", "mummy_rot", fallback=0) > 0
    except Exception:
        return False


HIDE_RACES = {"humaar"}

async def _refresh_tracker_message(ctx, bcfg=None, chan_id: str | None = None) -> None:
    """Async helper to refresh the pinned initiative tracker message."""
    try:
        if bcfg is None:
            bcfg = _load_battles()
        if chan_id is None:
            chan_id = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan_id)):
            return
        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
        if not msg_id:
            return
        block = _format_tracker_block(bcfg, chan_id)
        msg = await ctx.channel.fetch_message(msg_id)
        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
    except Exception:
        pass

def _all_slots_for_display(bcfg, chan_id: str, disp: str, key_guess: str | None = None) -> set[str]:
    """Return every slot name that the tracker could attribute to this display name."""
    slots = set()

    if key_guess:
        try:
            slots.add(_slot(key_guess))
        except Exception:
            slots.add(key_guess.replace(" ", "_"))
    try:
        if '_resolve_effect_slot' in globals() and key_guess:
            slots.add(_resolve_effect_slot(bcfg, chan_id, key_guess))
    except Exception:
        pass


    disp_norm = (disp or "").strip().lower()
    try:
        for opt in bcfg.options(chan_id):

            if not opt.endswith(".disp"):
                continue
            val = (bcfg.get(chan_id, opt, fallback="") or "").strip().lower()
            if val == disp_norm:
                slot = opt[:-5]
                if slot:
                    slots.add(slot)
    except Exception:
        pass
    return slots

def _scrub_all_timers_for_code(bcfg, chan_id: str, slot: str, *, code: str, label: str, alias_key: str):
    """Remove any x_* timer on this slot whose _code matches or whose _label matches."""
    if not (bcfg and bcfg.has_section(chan_id) and slot):
        return
    to_nuke_bases = set()

    to_nuke_bases.add(f"{slot}.x_{alias_key}")


    try:
        for opt in bcfg.options(chan_id):
            if not opt.startswith(f"{slot}.x_"):
                continue
            if opt.endswith("_code"):
                val = (bcfg.get(chan_id, opt, fallback="") or "").strip().upper()
                if val == code.upper():
                    to_nuke_bases.add(opt[:-5])
            elif opt.endswith("_label"):
                val = (bcfg.get(chan_id, opt, fallback="") or "").strip().lower()
                if val == label.lower():
                    to_nuke_bases.add(opt[:-6])
    except Exception:
        pass


    for base in to_nuke_bases:
        for suf in ("", "_code", "_label", "_emoji", "_by"):
            key = f"{base}{suf}"
            if bcfg.has_option(chan_id, key):
                bcfg.remove_option(chan_id, key)

def _poly_active(cfg) -> bool:
    try:
        return cfg.has_section("poly") and bool(get_compat(cfg, "poly", "form", fallback="").strip())
    except Exception:
        return False

def _poly_apply_overlay(tcfg, form_cfg, form_name: str, kind: str):

    ac     = getint_compat(form_cfg, "base", "ac",    fallback=10)
    move   = getint_compat(form_cfg, "base", "move",  fallback=30)
    hd     = getint_compat(form_cfg, "base", "hd",    fallback=0)
    saveas = get_compat      (form_cfg, "base", "saveas", fallback="")


    names = (get_compat(form_cfg, "base", "attacknames", fallback="") or "").split()
    attacks_list = []
    for n in names:
        dice = (get_compat(form_cfg, "base", n, fallback="") or "").strip()
        if dice:
            attacks_list.append(f"{n}:{dice}")

    specials = []
    for n in ("breath",):
        dice = (get_compat(form_cfg, "base", n, fallback="") or "").strip()
        if dice:
            specials.append(f"{n}:{dice}")

    if not tcfg.has_section("poly"):
        tcfg.add_section("poly")


    tcfg.set("poly", "active",   "1")
    tcfg.set("poly", "kind",     kind)
    tcfg.set("poly", "form",     form_name)
    tcfg.set("poly", "ac",       str(ac))
    tcfg.set("poly", "move",     str(move))
    tcfg.set("poly", "hd",       str(hd))
    tcfg.set("poly", "specials", "|".join(specials))




    tcfg.set("poly", "attacks", ",".join(attacks_list))
    for seg in attacks_list:
        k, _, v = seg.partition(":")
        if k and v:
            tcfg.set("poly", k.strip().lower(), v.strip())


    if kind == "other" and saveas:
        tcfg.set("poly", "saveas", saveas)
    else:
        if tcfg.has_option("poly", "saveas"):
            tcfg.remove_option("poly", "saveas")


    tcfg.set("poly", "nogear", "1")

def _poly_clear_overlay(tcfg):
    if tcfg.has_section("poly"):
        tcfg.remove_section("poly")

def _load_class_cache(path: str = "class.lst"):
    cfg = configparser.ConfigParser(); cfg.optionxform = str; cfg.read(path)
    cache = {}
    for section in cfg.sections():
        cache[section] = {}
        for k, v in cfg.items(section):
            v = v.strip()
            if v and " " in v:
                parts = v.split()
                if all(p.lstrip("-").isdigit() for p in parts):
                    cache[section][k] = [int(p) for p in parts]
                else:
                    cache[section][k] = v
            else:
                if v.lstrip("-").isdigit():
                    cache[section][k] = int(v)
                else:
                    cache[section][k] = v
    return cache

_CLASS_CACHE = _load_class_cache()

def _load_monster_form(form: str):
    """Return (pretty_name, cfg) or (None, None). Accepts loose names."""
    base = re.sub(r"[^a-z0-9]+", "", (form or "").lower())
    if not base:
        return (None, None)

    path = os.path.join("monsters", f"{base}.ini")
    if os.path.exists(path):
        cfg = read_cfg(path)
        pretty = get_compat(cfg, "base", "name", fallback=form) or form
        return (pretty, cfg)


    want = f"{base}.ini"
    for fn in os.listdir("monsters"):
        if fn.lower() == want:
            cfg = read_cfg(os.path.join("monsters", fn))
            pretty = get_compat(cfg, "base", "name", fallback=form) or form
            return (pretty, cfg)
    return (None, None)

def _poly_kind(cfg): return cfg.get("poly", "kind", fallback="")

def _poly_attacks(cfg):
    raw = cfg.get("poly", "attacks", fallback="").strip()

    out = []
    for seg in raw.split("|"):
        if ":" in seg:
            n, d = seg.split(":", 1)
            out.append((n.strip(), d.strip()))
    return out

def _poly_active(cfg) -> bool:
    try:
        return cfg.has_section("poly") and bool(get_compat(cfg, "poly", "form", fallback="").strip())
    except Exception:
        return False

def _poly_saveas(cfg):
    if _poly_kind(cfg) == "other":
        return cfg.get("poly", "saveas", fallback="")
    return ""

def _stone_keys(slot):
    return (f"{slot}.stone", f"{slot}.stonehp", f"{slot}.stone_by")

def _stoneskin_absorb(self, bcfg, chan_id, target_pretty: str, incoming: int):
    """
    Reduce damage by Stoneskin pool on the defender (initiative entry).
    Returns (after_damage, absorbed, remain, discharged_bool).
    """
    if incoming <= 0 or not (bcfg and bcfg.has_section(chan_id)):
        return incoming, 0, None, False

    names, _ = _parse_combatants(bcfg, chan_id)
    key = _find_ci_name(names, target_pretty) or target_pretty
    try:
        slot = _slot(key)
    except Exception:
        slot = key.replace(" ", "_")

    rounds_key, pool_key, by_key = _stone_keys(slot)
    pool = bcfg.getint(chan_id, pool_key, fallback=0)
    dur  = bcfg.getint(chan_id, rounds_key, fallback=0)

    if pool <= 0 or dur <= 0:
        return incoming, 0, pool if pool > 0 else None, False

    absorbed = min(incoming, pool)
    pool_after = pool - absorbed
    after = incoming - absorbed

    if pool_after <= 0:

        for k in (rounds_key, pool_key, by_key):
            if bcfg.has_option(chan_id, k):
                bcfg.remove_option(chan_id, k)
        _save_battles(bcfg)
        return after, absorbed, 0, True
    else:
        bcfg.set(chan_id, pool_key, str(pool_after))
        _save_battles(bcfg)
        return after, absorbed, pool_after, False


WAND_COLOR = 0x3498DB

_TOKEN_RE = re.compile(r"--?[A-Za-z]+|[A-Za-z]+[0-9]+|[A-Za-z]+|[0-9]+", re.ASCII)
def _extract_targetish_tokens(rest_raw: str) -> list[str]:
    """From the raw tail, keep alnum clusters in order: 'le1', 'gn9', 'wo5', etc."""
    if not rest_raw:
        return []
    return _TOKEN_RE.findall(rest_raw)


def _merge_split_target_tokens(seq):
    out = []; i = 0
    while i < len(seq):
        t = str(seq[i]).strip()
        if not t: i += 1; continue
        if t.startswith("-"):
            out.append(t); i += 1; continue
        if re.fullmatch(r"[A-Za-z]{1,4}", t):
            acc = t; j = i + 1
            while j < len(seq):
                nxt = str(seq[j]).strip()
                if not nxt or nxt.startswith("-"):
                    break
                if re.fullmatch(r"[A-Za-z0-9]{1,6}", nxt):
                    acc += nxt; j += 1; continue
                if re.fullmatch(r"[_\-\s,.:;/\\]+", nxt):
                    j += 1; continue
                break
            if j > i + 1:
                out.append(acc); i = j; continue
        out.append(t); i += 1
    seen = set(); dedup = []
    for x in out:
        xl = x.lower()
        if xl not in seen:
            seen.add(xl); dedup.append(x)
    return dedup



def _sanitize_target_tokens(seq):
    out = []
    seen = set()
    for t in seq:
        s = str(t).strip()
        if not s or s.startswith("-"):
            continue
        s = re.sub(r"[^A-Za-z0-9]+", "", s)
        if not s:
            continue
        if s.isdigit():
            continue
        k = s.lower()
        if k not in seen:
            seen.add(k)
            out.append(s)
    return out


async def _apply_start_of_turn_stoneskin(self, ctx, bcfg, chan_id, who_pretty: str, who_path: str):
    """
    Decrease the Stoneskin duration when a creature's turn begins.
    If the timer hits 0, clear any remaining pool.
    """
    try:
        if not (bcfg and bcfg.has_section(chan_id)):
            return
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, who_pretty) or who_pretty
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")

        rounds_key, pool_key, by_key = _stone_keys(slot)
        dur = bcfg.getint(chan_id, rounds_key, fallback=0)
        if dur <= 0:
            return

        dur -= 1
        if dur <= 0:

            left = bcfg.getint(chan_id, pool_key, fallback=0)
            for k in (rounds_key, pool_key, by_key):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)
            _save_battles(bcfg)
            try:
                embed = nextcord.Embed(
                    title="â³ Stoneskin expires",
                    description=f"**{who_pretty}**â€™s skin returns to flesh. Any remaining buffer is lost.",
                    color=random.randint(0, 0xFFFFFF),
                )
                if left > 0:
                    embed.add_field(name="Unused buffer", value=f"{left}", inline=True)
                await ctx.send(embed=embed)
            except Exception:
                pass
        else:
            bcfg.set(chan_id, rounds_key, str(dur))
            _save_battles(bcfg)
    except Exception:
        pass




DISCORD_FIELD_LIMIT = 900

def _is_section_break(line: str) -> bool:
    """Detect a separator line like 'â€”', '---', 'â€”â€”', etc."""
    s = (line or "").strip()
    if s in {"â€”", "â€“", "---", "â€”â€”"}:
        return True
    return re.fullmatch(r"[-â€“â€”]{3,}", s) is not None

def _split_effect_sections(lines):
    """Split output into (main, notes) at the first section break."""
    for i, l in enumerate(lines or []):
        if _is_section_break(l):
            return lines[:i], lines[i+1:]
    return lines or [], []

def _add_long_field(embed, title, lines, limit=DISCORD_FIELD_LIMIT):
    """Add one or more fields, chunking to respect field length limits."""
    buf, first = "", True
    for raw in (lines or []):
        line = raw.rstrip("\n")
        add = (("\n" if buf else "") + line)
        if len(buf) + len(add) > limit:
            embed.add_field(name=title if first else f"{title} (cont.)", value=buf or "â€”", inline=False)
            buf, first = line, False
        else:
            buf = buf + add if buf else line
    if buf:
        embed.add_field(name=title if first else f"{title} (cont.)", value=buf or "â€”", inline=False)

def _split_effect_sections(lines):
    """If a 'â€”' divider is present, split into (main, notes)."""
    for i, l in enumerate(lines):
        if l.strip() == "â€”":
            return lines[:i], lines[i+1:]
    return lines, []

def _add_long_field(embed: nextcord.Embed, title: str, lines, limit: int = DISCORD_FIELD_LIMIT):
    """
    Add `lines` under `title`, chunking across fields to respect the 1024-char limit.
    """
    buf = ""
    first = True
    for line in (lines or []):
        line = str(line).rstrip("\n")
        add = (("\n" if buf else "") + line)
        if len(buf) + len(add) > limit:
            embed.add_field(name=title if first else f"{title} (cont.)", value=buf, inline=False)
            buf = line
            first = False
        else:
            buf += add
    if buf:
        embed.add_field(name=title if first else f"{title} (cont.)", value=buf, inline=False)

def _normalize_effect_output(out) -> tuple[str, list[str]]:
    """
    Accepts a string/list/dict from your effect and returns (header_line, body_lines).
    - For strings: splitlines(); head is first line (e.g., the 'ðŸ’¥ 6d6 = 21').
    - For lists: join into lines; head is first.
    - For dicts with 'text': same treatment.
    """
    if isinstance(out, dict):
        text = out.get("text") or ""
        lines = str(text).splitlines()
    elif isinstance(out, (list, tuple)):
        lines = [str(x) for x in out]
    else:
        lines = str(out or "").splitlines()

    head = lines[0] if lines else ""
    body = lines[1:] if len(lines) > 1 else []
    return head, body

async def _call_effect(self, fn_name: str, caster_level: int,
                       ctx, cfg, caster_name: str, targets: list[str], **kwargs):
    """
    Invoke a spell/effect by name using your common signature:
      (ctx, cfg, caster_name, caster_level, targets, **kwargs)
    Falls back to (ctx, cfg, caster_name, targets, **kwargs) if CL isn't in the signature.
    """
    fn = getattr(self, fn_name, None)
    if not callable(fn):
        return f"âš ï¸ Effect **{fn_name}** isnâ€™t implemented."
    sig = inspect.signature(fn)
    params = list(sig.parameters)
    if "caster_level" in params or len(params) >= 4:
        return await _maybe_await(fn(ctx, cfg, caster_name, caster_level, targets, **kwargs))
    else:
        return await _maybe_await(fn(ctx, cfg, caster_name, targets, **kwargs))

def _build_item_embed(title: str, *,
                      header_line: str | None,
                      effect_lines: list[str] | None,
                      source: str | None,
                      charges_text: str | None,
                      color: int | None = None) -> nextcord.Embed:
    """
    Uniform embed for items, mirroring your spell embeds:
      - Title at top
      - 'Roll' (the ðŸ’¥ line) as its own field
      - 'Effect' (per-target lines), chunked to fit
      - 'Source' and 'Charges' fields
    """
    embed = nextcord.Embed(title=title, color=color or random.randint(0, 0xFFFFFF))
    if source:
        embed.add_field(name="Source", value=source, inline=False)
    if header_line:
        embed.add_field(name="Roll", value=header_line, inline=False)
    if effect_lines:
        main, notes = _split_effect_sections(effect_lines)
        if main:
            _add_long_field(embed, "Effect", main)
        if notes:
            _add_long_field(embed, "Notes", notes)
    if charges_text:
        embed.add_field(name="Charges", value=charges_text, inline=False)
    return embed



_WEAPON_SPELLS = {

    "locateobject": {
        "per_day": 1,
        "list_class": "Magic-User",
        "caster_level": 8,
        "force_self": False,
        "label": "Seeker weapon",
    },


    "charmperson": {
        "per_day": 1,
        "list_class": "Magic-User",
        "caster_level": "wielder",
        "force_self": False,
        "label": "Charming weapon",
    },


    "light": {
        "per_day": 0,
        "list_class": "Magic-User",
        "caster_level": "wielder",
        "force_self": True,
        "label": "Light-casting weapon",
    },
}

def _norm_alias(name: str) -> str:
    return "".join(ch.lower() for ch in str(name) if ch.isalnum())

def _iter_equipped_item_names(cfg) -> list[str]:
    names = []

    sec_candidates = ("eq", "equip", "equipment", "wield")
    key_hint_substr = ("weapon", "weap", "wpn", "main", "mh", "off", "oh", "hand", "primary", "secondary")

    for sec in sec_candidates:
        if cfg.has_section(sec):

            for k, v in cfg.items(sec):
                lk = (k or "").lower()
                if any(h in lk for h in key_hint_substr):
                    nm = (v or "").strip()
                    if nm:
                        names.append(nm)

            try:
                v = cfg.get(sec, "weapon", fallback="")
                if v and v.strip():
                    names.append(v.strip())
            except Exception:
                pass


    for k in ("weapon", "weapon1", "weapon2", "mainhand", "offhand"):
        try:
            v = get_compat(cfg, "info", k, fallback="")
            if v and v.strip() not in names:
                names.append(v.strip())
        except Exception:
            pass


    seen = set(); out = []
    for n in names:
        key = n.lower()
        if key in seen:
            continue
        seen.add(key); out.append(n)
    return out


def _parse_hd_token(raw) -> int | None:
    """
    Parse HD tokens like '3', '3+1', '2-1', '1/2'. Returns an int HD (pips ignored).
    Returns None if unparseable.
    """
    if raw is None:
        return None
    s = str(raw).strip().lower()
    m = re.match(r'^\s*(\d+)\s*(?:([+-])\s*(\d+))?\s*$', s)
    if m:
        base = int(m.group(1))
        return max(1, base)
    if s in {"1/2", "Â½"}:
        return 1 
    try:
        val = int(float(s))
        return max(1, val)
    except Exception:
        return None


def _find_monster_ini(monster_type: str) -> str | None:
    """Case-insensitive lookup for monsters/<type>.ini."""
    if not monster_type:
        return None
    want = f"{monster_type}.ini".lower()
    for root in ("monsters", "./monsters", "."):
        try:
            for fn in os.listdir(root):
                if fn.lower() == want:
                    return os.path.join(root, fn)
        except Exception:
            pass
    return None


def _monster_hd_from_type(monster_type: str) -> int | None:
    """Load monsters/<type>.ini and return [base].hd (parsed to int)."""
    path = _find_monster_ini(monster_type)
    if not path:
        return None
    try:
        mcfg = read_cfg(path)
        raw = get_compat(mcfg, "base", "hd", fallback=None)
        if raw is None:
            raw = get_compat(mcfg, "stats", "hd", fallback=None)
        return _parse_hd_token(raw)
    except Exception:
        return None




def _name_tokens(s: str) -> list[str]:

    return sorted(re.findall(r"[A-Za-z0-9]+", str(s).lower()))

def _lookup_item_special(self, item_name: str) -> str:
    """
    Return the item's 'special' string from your item DB (if present), else "".
    Tries:
      1) exact section
      2) normalized section
      3) order-insensitive token match
    """
    try:
        cp = _lazy_item_db(self)
        if not cp:
            return ""


        if cp.has_section(item_name):
            return cp.get(item_name, "special", fallback="").strip()


        want_norm   = _norm_alias(item_name)
        want_tokens = _name_tokens(item_name)

        for sec in cp.sections():
            if _norm_alias(sec) == want_norm:
                return cp.get(sec, "special", fallback="").strip()


        for sec in cp.sections():
            sec_tokens = _name_tokens(sec)
            if sec_tokens == want_tokens or set(want_tokens).issubset(sec_tokens):
                val = cp.get(sec, "special", fallback="").strip()
                if val:
                    return val
    except Exception:
        pass
    return ""

def _find_weapon_grant_for_spell(self, cfg, alias_key: str):
    """
    If a currently-equipped item grants `alias_key`, return dict + meta.
    """
    meta = _WEAPON_SPELLS.get(alias_key)
    if not meta:
        return None, None

    for nm in _iter_equipped_item_names(cfg):
        spec = (_lookup_item_special(self, nm) or "")
        if not spec:
            continue


        spec_norm = _norm_alias(spec)
        if alias_key in spec_norm:

            section = "wcast"
            key = f"{_norm_alias(nm)}.{alias_key}"
            used = getint_compat(cfg, section, key, fallback=0)
            per_day = int(meta.get("per_day", 0) or 0)
            if per_day and used >= per_day:
                return {"item": nm, "meta": meta, "charge_key": (section, key), "exhausted": True}, None
            return {"item": nm, "meta": meta, "charge_key": (section, key), "exhausted": False}, meta


        parts = [ _norm_alias(p) for p in re.split(r"[,\|;/]", spec) if _norm_alias(p) ]
        if alias_key in parts:
            section = "wcast"
            key = f"{_norm_alias(nm)}.{alias_key}"
            used = getint_compat(cfg, section, key, fallback=0)
            per_day = int(meta.get("per_day", 0) or 0)
            if per_day and used >= per_day:
                return {"item": nm, "meta": meta, "charge_key": (section, key), "exhausted": True}, None
            return {"item": nm, "meta": meta, "charge_key": (section, key), "exhausted": False}, meta

    return None, None
def _weapon_spend_use(cfg, charge_key: tuple[str, str]):
    """Increment the per-day use counter for a weapon spell and persist."""
    if not charge_key:
        return
    section, key = charge_key
    if not cfg.has_section(section):
        cfg.add_section(section)
    cur = getint_compat(cfg, section, key, fallback=0)
    cfg.set(section, key, str(cur + 1))

def _weapon_reset_uses_on_long_rest(cfg):
    """Call this from !lr to reset all weapon-spell uses."""
    try:
        if cfg.has_section("wcast"):
            for opt in list(dict(cfg.items("wcast")).keys()):
                cfg.remove_option("wcast", opt)
    except Exception:
        pass

def _lazy_item_db(self):
    """
    Ensure an item config parser is available in self._item_cp.
    Tries a few common paths and caches the first one that loads.
    """
    cp = (getattr(self, "_item_cp", None)
          or getattr(self, "_weapon_cp", None)
          or getattr(self, "_weap_cp", None))
    if cp:
        return cp

    candidates = [
        "item.lst",
        "items.lst",
        os.path.join(os.path.dirname(__file__), "item.lst"),
        os.path.join(os.path.dirname(__file__), "data", "item.lst"),
        os.path.join(os.getcwd(), "item.lst"),
    ]
    for path in candidates:
        try:
            if os.path.exists(path):
                cfg = read_cfg(path)

                self._item_cp = cfg
                return cfg
        except Exception:
            pass
    return None

ARCANE_CLASSES_RAW = {
    "Magic-User", "Illusionist", "Necromancer", "Spellcrafter",
    "Fightermage", "Magethief"
}
ARCANE_CLASSES = {
    re.sub(r"[^a-z0-9]+", "", c.lower())
    for c in ARCANE_CLASSES_RAW
}


def _is_plant_cfg(cfg, fallback_name: str = "") -> bool:
    """
    Best-effort check whether a target is a plant-type creature.
    Looks in [stats]/[info] type fields and falls back to name heuristics.
    """
    ty = (
        (get_compat(cfg, "stats", "type", fallback="") or get_compat(cfg, "info", "type", fallback=""))
        or ""
    ).strip().lower()

    name = (get_compat(cfg, "info", "name", fallback="") or fallback_name or "").lower()

    if "plant" in ty:
        return True

    heuristics = ("treant", "shambling", "shambler", "myconid", "fungus", "violetfungus", "vine")
    return any(h in ty for h in heuristics) or any(h in name for h in heuristics)



def load_items(file_path: str):
    """
    Load item.lst and return (items_by_canon, index_by_normalized).
    Optional 'aliases' key per item may contain comma/space-separated synonyms.
    """
    cfg = configparser.ConfigParser()
    cfg.optionxform = str
    cfg.read(file_path)

    items = {}
    index = {}

    for section in cfg.sections():
        data = dict(cfg.items(section))

        items[section] = data


        index[normalize_name(section)] = section


        aliases = re.split(r'[,\s]+', data.get("aliases", "").strip())
        for alias in filter(None, aliases):
            index[normalize_name(alias)] = section

    return items, index



_PFED_SET = {
    "beltofprotectionfromenergydrain",
    "cloakofprotectionfromenergydrain",
    "pendantofprotectionfromenergydrain",
    "ringofprotectionfromenergydrain",
}

def _pfed_norm_name(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower()).split("@", 1)[0]

def _pfed_norm_token(s: str) -> str:
    return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

def _pfed_storage_remove_token(cfg, disp_name: str) -> bool:
    """Remove the display token from [item].storage (case/format-insensitive)."""
    try:
        if not cfg.has_section("item"):
            return False
        raw = (cfg.get("item", "storage", fallback="") or "").strip()
        if not raw:
            return False
        toks = [t for t in raw.split() if t.strip()]
        target = _pfed_norm_token(disp_name)
        new = [t for t in toks if _pfed_norm_token(t) != target]
        if len(new) != len(toks):
            cfg.set("item", "storage", " ".join(new))
            return True
    except Exception:
        pass
    return False


def _pfed_key(core: str, kind: str) -> str:
    return f"pfed_{core}_{kind}"  

def _pfed_find_equipped_in_cfg(cfg):
    """Return (slot, disp_name, core) for first equipped PFED item, else None."""
    try:
        if not cfg.has_section("eq"):
            return None
        for slot, val in cfg.items("eq"):
            base = (val or "").strip()
            if not base:
                continue
            core = _pfed_norm_name(base.split(" (", 1)[0])
            if core in _PFED_SET:
                return slot, base, core
    except Exception:
        pass
    return None

def _pfed_seed_if_missing_in_cfg(cfg, path: str, core: str) -> tuple[int, int]:
    """
    Seed (cur,max) in [pfed] with 2d6 if missing OR if both are 0 (brand-new device).
    Keys match combat.py: pfed_<core>_{cur,max}
    """
    cur = mx = None
    if cfg.has_section("pfed"):
        try:
            raw = (cfg.get("pfed", _pfed_key(core, "cur"), fallback="") or "").strip()
            if raw != "":
                cur = int(raw)
        except Exception:
            pass
        try:
            raw = (cfg.get("pfed", _pfed_key(core, "max"), fallback="") or "").strip()
            if raw != "":
                mx = int(raw)
        except Exception:
            pass

    
    if cur is None or mx is None or ((cur or 0) <= 0 and (mx or 0) <= 0):
        total = random.randint(1, 6) + random.randint(1, 6)
        cur = total
        mx = total
        if not cfg.has_section("pfed"):
            cfg.add_section("pfed")
        cfg.set("pfed", _pfed_key(core, "cur"), str(cur))
        cfg.set("pfed", _pfed_key(core, "max"), str(mx))
        write_cfg(path, cfg)

    return int(cur), int(mx)


def _pfed_consume_one_in_cfg(cfg, path: str, slot: str, disp_name: str, core: str) -> tuple[int, int, bool]:
    """Consume 1 PFED charge. Returns (new_cur, mx, disintegrated_bool)."""
    cur, mx = _pfed_seed_if_missing_in_cfg(cfg, path, core)
    if cur <= 0:
        return 0, mx, False

    new_cur = max(0, cur - 1)
    if not cfg.has_section("pfed"):
        cfg.add_section("pfed")
    cfg.set("pfed", _pfed_key(core, "cur"), str(new_cur))
    cfg.set("pfed", _pfed_key(core, "max"), str(mx))

    disintegrated = False
    if new_cur <= 0:
        
        try:
            if cfg.has_section("eq") and cfg.has_option("eq", slot):
                if (cfg.get("eq", slot, fallback="") or "").strip():
                    cfg.set("eq", slot, "")
        except Exception:
            pass

        
        try:
            if cfg.has_section("item"):
                base_norm = _pfed_norm_name(disp_name)
                for key in (core, base_norm):
                    raw = cfg.get("item", key, fallback=None)
                    if raw is None:
                        continue
                    try:
                        n = max(0, int(str(raw).strip()) - 1)
                    except Exception:
                        n = 0
                    if n <= 0:
                        
                        try: cfg.remove_option("item", key)
                        except Exception: pass
                        _pfed_storage_remove_token(cfg, disp_name)
                    else:
                        cfg.set("item", key, str(n))
                    break
        except Exception:
            pass

        disintegrated = True

    write_cfg(path, cfg)
    return new_cur, mx, disintegrated


def _pfed_try_absorb_sp(t_cfg, tgt_path: str, tag: str = "death") -> tuple[bool, str]:
    """
    If the target has a PFED device equipped and has â‰¥1 charge:
      - consume 1 charge,
      - return (True, pretty_note)
      - disintegrate and note when it hits 0.
    Else returns (False, "").
    """
    found = _pfed_find_equipped_in_cfg(t_cfg)
    if not found:
        return False, ""
    slot, disp, core = found
    cur, mx = _pfed_seed_if_missing_in_cfg(t_cfg, tgt_path, core)
    if cur <= 0:
        return False, ""

    new_cur, mx, gone = _pfed_consume_one_in_cfg(t_cfg, tgt_path, slot, disp, core)
    note = f"ðŸ›¡ï¸ **Protection from Energy Drain** negates the {tag} effect â€” charges **{new_cur}/{mx}**."
    if gone:
        note += " âœ¨ *(device disintegrates)*"
    return True, note




class SpellsCog(commands.Cog, name="Spells"):
    def _protection_bonus_from_equipped(self, cfg) -> int:
        """Return the highest +N from any *ofProtection+N equipped item
        (e.g., RingofProtection+2, CloakofProtection+1, BeltofProtection+3, PendantofProtection+1).
        Looks in common ring/neck/cloak/belt/hand/boot/helm/other slots in [eq].
        """
        slots = (
            "ring", "ring2",
            "neck", "pendant", "amulet",
            "cloak", "belt", "hands", "boots", "helm",
            "other1", "other2", "other3", "other4", "other5",
        )
        best = 0
        for key in slots:
            try:
                name = (get_compat(cfg, "eq", key, fallback="") or "").strip()
            except Exception:
                name = ""
            if not name or name == "â€”":
                continue
            m = re.search(r"ofprotection\+(\d+)$", name.lower())
            if m:
                try:
                    best = max(best, int(m.group(1)))
                except Exception:
                    pass
        return best

    def _get_effective_ac(self, t_cfg, fallback: int = 10) -> int:
        """Base AC from [stats].ac plus any *ofProtection+N worn by the target."""
        try:
            base = int(str(get_compat(t_cfg, "stats", "ac", fallback=str(fallback))).strip() or str(fallback))
        except Exception:
            base = int(fallback)
        try:
            prot = int(self._protection_bonus_from_equipped(t_cfg) or 0)
        except Exception:
            prot = 0
        return int(base) + int(prot)

    def __init__(self, bot):
        self.bot = bot
        self._spells_by_class, self._spell_cp = _load_spell_list()
        self._class_cp = _load_slots_table()
        self.items, self.item_index = load_items("item.lst")
        self._index = dict(self.item_index)
        try:
            self._item_cp = read_cfg("item.lst")
        except Exception:
            self._item_cp = None


        self.spell_levels = {}
        for cls, lvmap in (self._spells_by_class or {}).items():
            table = {}
            for key, names in (lvmap or {}).items():
                m = re.match(r"l(\d+)", str(key), re.I)
                if not m:
                    continue
                L = int(m.group(1))


                if isinstance(names, (list, tuple, set)):
                    raw_names = [str(x) for x in names]
                elif isinstance(names, str):
                    s = names.strip()

                    if s.startswith("[") and s.endswith("]"):
                        s = s[1:-1]
                    raw_names = re.split(r"[\s,|]+", s)
                else:

                    continue

                for nm in raw_names:
                    nm = nm.strip().strip("'").strip('"').strip()
                    if not nm:
                        continue

                    k = self._norm(nm)
                    table[k] = min(L, table.get(k, L))
            self.spell_levels[self._norm(cls)] = table


        combat_src = next((c for c in bot.cogs.values() if hasattr(c, "classes")), None)
        self.classes = getattr(combat_src, "classes", {})
        self._auto_timer_blacklist = {
            "mirrorimage", "invisibility", "web",
            "holdperson", "holdmonster", "shield",
            "magearmor", "boneskin", "spiritualhammer",
            "hypnoticpattern", "colorspray", "colorcloud", "rainbowpattern",
            "sleep", "light", "darkness", "continuallight", "continualdarkness",
            "cloudkill", "charmperson", "charmmonster","stinkingcloud",
            "shillelagh", "causefear", "confusion", "gaseousform",
            "drainblade", "immunitytonormalweapons", "protectionnormalmissiles",
            "polymorphself", "polymorphother","bestowcurse","removecurse","alterself",
            "invisible10", "improvedinvisibility","massinvisibility",
            "icestorm","feeblemind","fleshtostone","permanency","sword",
            "mislead","greaterfear","masssuggestion","trueseeing","demand","insanity",
            "scintillatingpattern","chill","chillray","ghoulishhands",
            "maggotspray","stench","commandundead","haltundead","rayofexhaustion",
            "vampirictouch","blacktentacles","causedisease","controlundead",
            "eyebite","breakrestrictions","heatmetal","chillmetal","weakenarmor","weakenweapon",
            "slow","charmconstructs","command","charmanimal","causeblindness",
            "growthofanimals","striking","windwalk","produceflamecold",
            "barkskin","tree","assumeanimalform","holdanimal","callwoodlandbeings",
            "summonanimals1", "summonanimals2", "summonanimals3","calllightning",
            "enervation","resistfire","resistcold","protectionfromfire","protectionfromlightning",
            "faeriefire",
        }


        self._spell_handlers = {
            "fireball": self._effect_fireball,
            "curelightwounds": self._effect_curelightwounds,
            "holdperson": self._effect_holdperson,
            "holdmonster": self._effect_holdmonster,
            "shield":   self._effect_shield,
            "magicmissile": self._effect_magic_missile,
            "arcaneblast": self._effect_arcane_blast,
            "web": self._effect_web,
            "arcanedagger": self._effect_arcane_dagger,
            "arcanedart": self._effect_arcane_dart,
            "cureminorwounds": self._effect_cure_minor_wounds,
            "lightningbolt": self._effect_lightning_bolt,
            "causelightwounds": self._effect_causelightwounds,
            "icestorm": self._effect_icestorm,
            "decayflesh": self._effect_decayflesh,
            "mirrorimage": self._effect_mirrorimage,
            "spiritualhammer": self._effect_spiritual_hammer,
            "ghoulishhands": self._effect_ghoulish_hands,
            "magearmor": self._effect_mage_armor,
            "boneskin": self._effect_boneskin,
            "cureseriouswounds": self._effect_cureseriouswounds,
            "causeseriouswounds": self._effect_causeseriouswounds,
            "flamestrike": self._effect_flamestrike,
            "shillelagh": self._effect_shillelagh,
            "light":    partial(self._cast_light_or_darkness, spell_name="light"),
            "darkness": partial(self._cast_light_or_darkness, spell_name="darkness"),
            "polymorphself":  partial(self._cast_polymorph, spell_name="polymorphself"),
            "polymorphother": partial(self._cast_polymorph, spell_name="polymorphother"),
            "colorspray": self._effect_colorspray,
            "colorcloud": self._effect_colorcloud,
            "cloudkill": self._effect_cloudkill,
            "stinkingcloud": self._effect_stinkingcloud,
            "hypnoticpattern": self._effect_hypnoticpattern,
            "rainbowpattern": self._effect_rainbowpattern,
            "charmperson": self._effect_charmperson,
            "calllightning": self._effect_calllightning,
            "charmmonster": self._effect_charmmonster,
            "confusion": self._effect_confusion,
            "drainblade": self._effect_drainblade,
            "immunitytonormalweapons": self._effect_inw,
            "protectionnormalmissiles": self._effect_protectionnormalmissiles,
            "sleep": self._effect_sleep,
            "continuallight": self._effect_continuallight,
            "continualdarkness": self._effect_continualdarkness,
            "causefear": self._cast_cause_fear,
            "invisibility": self._cast_invisibility,
            "gaseousform": self._effect_gaseous_form,
            "bestowcurse": self._effect_bestowcurse,
            "removecurse": self._effect_removecurse,
            "invisible10": self._cast_invisible10,
            "improvedinvisibility": self._cast_improvedinvisibility,
            "massinvisibility": self._cast_massinvisibility,
            "animatedead": self._cast_animatedead,
            "conjureelemental": self._cast_conjureelemental,
            "feeblemind": self._effect_feeblemind,
            "restoremind": self._effect_restoremind,
            "stoneskin": self._effect_stoneskin,
            "deathspell": self._effect_deathspell,
            "disintegrate": self._effect_disintegrate,
            "fleshtostone": self._effect_fleshtostone,
            "stonetoflesh": self._effect_stonetoflesh,
            "invisiblestalker": self._cast_invisiblestalker,
            "reincarnate": self._cast_reincarnate,
            "permanency": self._effect_permanency,
            "delayedblastfireball": self._effect_delayedblastfireball,
            "powerwordstun": self._effect_powerwordstun,
            "sword": self._effect_sword,
            "gazereflection": self._effect_gazereflection,
            "removefear": self._effect_removefear,
            "alterself": self._effect_alterself,
            "blur": self._cast_blur,
            "displacement": self._cast_displacement,
            "phantasmalkiller": self._effect_phantasmal_killer,
            "suggestion": self._effect_suggestion,
            "mislead": self._effect_mislead,
            "greaterfear": self._cast_greaterfear,
            "masssuggestion": self._effect_masssuggestion,
            "trueseeing": self._effect_trueseeing,
            "maze": self._effect_maze,
            "demand": self._effect_demand,
            "insanity": self._effect_insanity,
            "prismaticspray": self._effect_prismaticspray,
            "scintillatingpattern": self._effect_scintillatingpattern,
            "shades": self._cast_shades,
            "weird": self._effect_weird,
            "chill": self._effect_chill,
            "chillray": self._effect_chillray,
            "reanimation": self._cast_reanimation,
            "stench": self._effect_stench,
            "maggotspray": self._effect_maggotspray,
            "fireskullfamiliar": self._cast_fireskullfamiliar,
            "corpseservant": self._cast_corpseservant,
            "commandundead": self._cast_commandundead,
            "removeparalysis": self._effect_removeparalysis,
            "fossilize": self._effect_fossilize,
            "haltundead": self._effect_haltundead,
            "rayofexhaustion": self._effect_rayofexhaustion,
            "spiritwrack": self._effect_spiritwrack,
            "summonspirit": self._cast_summonspirit,
            "vampirictouch": self._effect_vampirictouch,
            "blacktentacles": self._effect_blacktentacles,
            "curedisease": self._effect_curedisease,
            "causedisease": self._effect_causedisease,
            "enervation": self._effect_enervation,
            "rotflesh": self._effect_rotflesh,
            "blight": self._effect_blight,
            "mummify": self._cast_mummify,
            "symbolofpain": self._effect_symbolofpain,
            "symboloffear": self._effect_symboloffear,
            "symbolofdeath": self._effect_symbolofdeath,
            "insectplague": self._cast_insectplague,
            "controlundead": self._cast_controlundead,
            "eyebite": self._effect_eyebite,
            "undeath": self._cast_undeath,
            "undeathtodeath": self._effect_undeathtodeath,
            "callhorseman": self._cast_callhorseman,
            "fingerofdeath": self._effect_fingerofdeath,
            "breakrestrictions": self._cast_breakrestrictions,
            "enhancearmor":      self._cast_enhancearmor,
            "weakenarmor":       self._cast_weakenarmor,
            "enhanceweapon":     self._cast_enhanceweapon,
            "weakenweapon":      self._cast_weakenweapon,
            "repair": self._effect_repair,
            "heatmetal": self._effect_heatmetal,
            "chillmetal": self._effect_chillmetal,
            "channelblast": self._cast_channelblast,
            "repair": self._effect_repair,
            "seriousrepair": self._effect_seriousrepair,
            "holdconstruct": self._effect_holdconstruct,
            "overtakeitem": self._effect_overtakeitem,
            "stoneshape": self._effect_stoneshape,
            "slow": self._cast_slow,
            "charmconstructs": self._effect_charmconstructs,
            "massarmorenhancement": self._cast_massarmorenhancement,
            "massweaponenhancement": self._cast_massweaponenhancement,
            "starlightblade": self._effect_starlightblade,
            "dominateconstruct": self._effect_dominateconstruct,
            "virtue": self._effect_virtue,
            "censure": self._effect_censure,
            "command": self._effect_command,
            "bless": self._effect_bless,
            "bane": self._effect_bane,
            "charmanimal": self._effect_charmanimal,
            "causeblindness": self._effect_causeblindness,
            "cureblindness": self._effect_cureblindness,
            "growthofanimals": self._effect_growthofanimals,
            "striking": self._cast_striking,
            "poisontouch": self._cast_poisontouch,
            "stickstosnakes": self._cast_stickstosnakes,
            "raisedead": self._cast_raisedead,
            "ringoflesserhealing": self._effect_ringoflesserhealing,
            "ringofgreaterhealing": self._effect_ringofgreaterhealing,
            "heal": self._effect_heal,
            "harm": self._effect_harm,
            "regenerate": self._effect_regenerate,
            "restoration": self._effect_restoration,
            "firestorm": self._effect_firestorm,
            "holyword": self._effect_holyword,
            "windwalk": self._effect_windwalk,
            "resurrection": self._cast_resurrection,
            "faeriefire": self._effect_faeriefire,
            "produceflamecold": self._effect_produceflamecold,
            "barkskin": self._effect_barkskin,
            "tree": self._effect_tree,
            "assumeanimalform": self._effect_assumeanimalform,
            "holdanimal": self._effect_holdanimal,
            "restorehealth": self._effect_restorehealth,
            "callwoodlandbeings": self._cast_callwoodlandbeings,
            "summonanimals1": self._cast_summonanimals1,
            "summonanimals2": self._cast_summonanimals2,
            "summonanimals3": self._cast_summonanimals3,
            "creepingdoom": self._cast_creepingdoom,
            "changestaff": self._cast_changestaff,
            "resistcold": self._effect_resistcold,
            "resistfire": self._effect_resistfire,
            "protectionfromfire": self._effect_protectionfromfire,
            "protectionfromlightning": self._effect_protectionfromlightning,

        }




    async def _attach_char_identity(self, embed, cfg, ctx):
        """
        Adds: character portrait (thumbnail) + Player: <display_name> w/ avatar.
        Safe to call even if fields are missing.
        """


        portrait_url = (
            get_compat(cfg, "info", "portrait", fallback="")
            or get_compat(cfg, "info", "portrait_url", fallback="")
        ).strip()
        if portrait_url:
            try:
                embed.set_thumbnail(url=portrait_url)
            except Exception:
                pass

    def all_spells_by_class(self) -> dict[str, list[tuple[str,int]]]:
            out = {}

            if getattr(self, "spell_levels", None):
                for clsname, table in self.spell_levels.items():
                    rows = []
                    for nm, v in (table or {}).items():
                        L = int(v[0] if isinstance(v, (list, tuple)) else v)
                        rows.append((nm, L))
                    rows.sort(key=lambda r: (r[1], r[0].lower()))
                    out[clsname] = rows
                return out


            for clsname, lvmap in (self._spells_by_class or {}).items():
                rows = []
                for key, names in (lvmap or {}).items():
                    m = re.search(r"(\d+)", str(key))
                    if not m:
                        continue
                    L = int(m.group(1))
                    for nm in re.split(r"[\s,]+", str(names).strip()):
                        if nm:
                            rows.append((nm, L))
                rows.sort(key=lambda r: (r[1], r[0].lower()))
                out[clsname] = rows
            return out

    def _spell_alias_map(self) -> dict[str, str]:
        """
        Optional short-hands. Keep minimal to avoid collisions.
        Add the ones you like; examples shown.
        """
        return {
            "mae": "MassArmorEnhancement",
            "massarmor": "MassArmorEnhancement",


        }


    async def _resolve_spell_from_partial(self, ctx, list_class: str, token: str, author) -> str | None:
        """
        Resolve a spell name by partial substring against the caster's spell list (list_class).
        - If one match â†’ return canonical section name.
        - If multiple â†’ interactive picker (reuses your paginated selector).
        - If none â†’ return None (caller can print suggestions).
        """
        token = (token or "").strip()
        if not token:
            return None


        alias = self._spell_alias_map().get(self._norm(token))
        if alias:
            return alias



        available: list[str] = []
        for sec in self._spell_cp.sections():
            lvl, canon = self._find_spell_level(list_class, sec)
            if lvl is not None and canon:
                available.append(canon)

        if not available:
            return None


        t = token.lower()
        cands = [s for s in available if s.lower().startswith(t)]
        if not cands:
            cands = [s for s in available if t in s.lower()]
        if not cands:

            cands = difflib.get_close_matches(token, available, n=8, cutoff=0.45)

        if not cands:
            return None
        if len(cands) == 1:
            return cands[0]


        chosen = await self._prompt_paginated_selection(ctx, author, token, cands, timeout_sec=10.0)
        return chosen

    def _spell_suggestions_for(self, list_class: str, token: str) -> list[str]:
        """Return a few nice suggestions for error messages."""
        pool: list[str] = []
        for sec in self._spell_cp.sections():
            lvl, canon = self._find_spell_level(list_class, sec)
            if lvl is not None and canon:
                pool.append(canon)
        return difflib.get_close_matches(token, pool, n=6, cutoff=0.4)

    def _norm(self, s: str) -> str:
        return re.sub(r"[^a-z0-9]+", "", str(s).lower())

    def _scroll_id_from_token(self, token: str | None) -> str | None:
        """
        Extract a numeric SpellScroll id from common user inputs.

        Accepts:
          â€¢ 11
          â€¢ @11 / #11
          â€¢ SpellScroll@11 / spellscr@11 / scroll@11
          â€¢ SpellScroll@11:Fireball  (anything after ':' is ignored)

        Returns the id as a string of digits, or None.
        """
        if token is None:
            return None
        s = str(token).strip()
        if not s:
            return None

        # drop common wrappers and trailing annotations
        s = s.strip()
        s = s.split(":", 1)[0].strip()

        # allow @11 or #11
        if s.startswith("@") or s.startswith("#"):
            s = s[1:].strip()

        # allow SpellScroll@11 (case-insensitive)
        if "@" in s:
            try:
                s = s.split("@", 1)[1].strip()
            except Exception:
                return None

        # final: must be digits
        if s.isdigit():
            return s
        return None
    def _item_lookup_strip_instance(self, name: str):
        """Like _item_lookup, but ignores '@<id>' suffix for DB lookups and returns (canon, item, sid)."""
        base = name.split("@", 1)[0]
        canon, item = self._item_lookup(base)
        sid = self._scroll_id_from_token(name)
        return canon, item, sid

    def _scroll_section_name(self, sid: str) -> str:
        return f"scroll:{sid}"

    def _ensure_scroll_index(self, cfg):
        if not cfg.has_section("scrollindex"):
            cfg.add_section("scrollindex")
            cfg.set("scrollindex", "next_id", "1")
        try:
            return int(cfg.get("scrollindex", "next_id"))
        except Exception:
            cfg.set("scrollindex", "next_id", "1")
            return 1

    def _alloc_scroll_id(self, cfg) -> int:
        nxt = self._ensure_scroll_index(cfg)
        cfg.set("scrollindex", "next_id", str(nxt + 1))
        return nxt

    def _read_scroll_rec(self, cfg, sid: str) -> dict | None:
        sec = self._scroll_section_name(sid)
        if not cfg.has_section(sec): return None
        cls = (get_compat(cfg, sec, "class", fallback="") or "").strip()
        spells = (get_compat(cfg, sec, "spells", fallback="") or "").strip()
        spent  = (get_compat(cfg, sec, "spent",  fallback="") or "").strip()
        readm  = (get_compat(cfg, sec, "readmagic", fallback="0") or "0").strip()
        label  = (get_compat(cfg, sec, "label", fallback="") or "").strip()

        spell_list = [s for s in spells.split("|") if s]
        spent_list = [int(x) if str(x).strip().isdigit() else 0 for x in spent.split(",") if str(x).strip()!=""]
        while len(spent_list) < len(spell_list): spent_list.append(0)
        if len(spent_list) > len(spell_list): spent_list = spent_list[:len(spell_list)]
        return {
            "sid": sid,
            "class": cls,
            "spells": spell_list,
            "spent": spent_list,
            "readmagic": 1 if readm == "1" else 0,
            "label": label,
        }

    def _write_scroll_rec(self, cfg, rec: dict) -> None:
        sec = self._scroll_section_name(rec["sid"])
        if not cfg.has_section(sec): cfg.add_section(sec)
        cfg.set(sec, "class", str(rec.get("class","")))
        cfg.set(sec, "spells", "|".join(rec.get("spells", [])))
        cfg.set(sec, "spent",  ",".join(str(int(x)) for x in rec.get("spent", [])))
        cfg.set(sec, "readmagic", "1" if rec.get("readmagic") else "0")
        if rec.get("label"):
            cfg.set(sec, "label", rec["label"])
        else:
            try: cfg.remove_option(sec, "label")
            except Exception: pass

    def _delete_scroll_rec(self, cfg, sid: str) -> None:
        sec = self._scroll_section_name(sid)
        try:
            cfg.remove_section(sec)
        except Exception:
            pass

    def _class_name(self, cfg) -> str:
        return (get_compat(cfg, "info", "class", fallback="") or "").strip()

    def _is_arcane_class(self, clsname: str) -> bool:
        return self._norm(clsname) in ARCANE_CLASSES

    def _max_spell_level_for_class(self, cfg, clsname: str) -> int | None:
        """
        Return the highest spell level the caster can cast *right now*.
        Prefer the live [slots] totals in the character file, else fall back
        to a simple heuristic.
        """
        try:
            max_lvl = 0
            for L in range(1, 8):
                tot = getint_compat(cfg, "slots", f"l{L}_total", fallback=0)
                if (tot or 0) > 0:
                    max_lvl = L
            if max_lvl > 0:
                return max_lvl
        except Exception:
            pass


        lvl = getint_compat(cfg, "cur", "level", fallback=1)
        if self._is_arcane_class(clsname):
            return min(7, max(1, (int(lvl) + 1) // 2))
        return min(7, max(1, (int(lvl) + 1) // 2))

    def _find_spell_level(self, scroll_class: str, spell_name: str) -> int | None:
        try:
            cls = self._norm(scroll_class)
            sn  = self._norm(spell_name)
            v = self.spell_levels.get(cls, {}).get(sn, None)
            if isinstance(v, (list, tuple)):

                return int(v[0])
            return int(v) if v is not None else None
        except Exception:
            return None

    def _pc_knows_spell(self, caster_cfg, caster_class: str, spell_name: str) -> bool:
        """
        Best-effort check whether an arcane caster *knows* a spell (for scroll failure chance).
        Returns False if unknown or cannot be determined.
        """
        sn = self._norm(spell_name)

        # Preferred: per-level spellbook list (used by !cast)
        try:
            if "_read_per_level_list" in globals():
                book = _read_per_level_list(caster_cfg, "spellbook")
                if isinstance(book, dict):
                    have = set()
                    for _lv, arr in book.items():
                        if not arr:
                            continue
                        for s in arr:
                            if s is None:
                                continue
                            have.add(self._norm(str(s)))
                    if have:
                        return sn in have
        except Exception:
            pass

        # Fallback: legacy [book] spells
        try:
            book = get_compat(caster_cfg, "book", "spells", fallback="")
            if book:
                have = {self._norm(s) for s in book.split()}
                return sn in have
        except Exception:
            pass

        # If unknown, apply penalty (safe default)
        return False

    def _pick_carried_scroll_with_spell(self, cfg, want_cls: str, want_spell: str, require_readmagic: bool, carried_only=True) -> tuple[str, dict] | None:
        """
        Return (token, rec) for a carried SpellScroll that contains an unspent copy of want_spell and class matches.
        If multiple candidates, picks the first. You can extend to prefer specific IDs with -s.
        """
        want_spell_n = self._norm(want_spell)
        want_cls_n = self._norm(want_cls)

        tokens = []
        try:
            for _idx, slot_key, nm, q in self._iter_carried_slots(cfg):
                sid = self._scroll_id_from_token(nm)
                if not sid: continue
                rec = self._read_scroll_rec(cfg, sid)
                if not rec: continue
                rec_cls_eq_n = self._norm(self._scroll_class_equiv(rec.get("class",""), ctx.channel))
                if rec_cls_eq_n != want_cls_eq_n:
                    continue
                if require_readmagic and self._is_arcane_class(rec["class"]) and not rec.get("readmagic"):
                    continue

                for s, used in zip(rec["spells"], rec["spent"]):
                    if not used and self._norm(s) == want_spell_n:
                        tokens.append((nm, rec))
                        break
        except Exception:
            pass
        if tokens:
            return tokens[0]

        return None

    def _mark_scroll_spell_spent_and_cleanup(self, cfg, token: str, spell_name: str) -> bool:
        """
        Mark one copy of spell_name as spent on the given token's scroll.
        If all spells are spent afterwards, remove the scroll item from inventory (consume one)
        and delete its [scroll:<id>] section. Recalculates carry weight.
        """
        sid = self._scroll_id_from_token(token)
        if not sid: return False
        rec = self._read_scroll_rec(cfg, sid)
        if not rec: return False
        sn = self._norm(spell_name)


        for i, (s, used) in enumerate(zip(rec["spells"], rec["spent"])):
            if not used and self._norm(s) == sn:
                rec["spent"][i] = 1
                break
        else:
            return False


        self._write_scroll_rec(cfg, rec)


        if all(int(x) == 1 for x in rec["spent"]):

            try:
                self._consume_one_anywhere_and_recalc(cfg, f"SpellScroll@{sid}")
            except Exception:

                pass
            self._delete_scroll_rec(cfg, sid)
        return True

    def _hr_enabled_proxy(self, channel, key: str, default: bool = True) -> bool:
        """
        Ask the Combat cog for a per-channel house-rule value.
        Falls back to `default` if the cog or method isn't available.
        """
        try:
            combat = self.bot.get_cog("Combat")
            if combat and hasattr(combat, "_hr_enabled"):
                return bool(combat._hr_enabled(channel, key, default=default))
        except Exception:
            pass
        return default

    def _caster_profile(self, info_class: str, channel=None) -> dict | None:
        """
        Map sheet class â†’ slot source, list source, book-based flag, and the
        casting ability used for CANTRIPS (L0). Honors HR: magethief_illusionist_list.
        """
        c = (info_class or "").strip().lower()

        if c in {"magic-user", "magicuser"}:
            return {"slots_class":"Magic-User","list_class":"Magic-User","book_based":True, "cantrip_ability":"int"}
        if c in {"illusionist"}:
            return {"slots_class":"Magic-User","list_class":"Illusionist","book_based":True, "cantrip_ability":"int"}
        if c in {"spellcrafter"}:
            return {"slots_class":"Spellcrafter","list_class":"Spellcrafter","book_based":True, "cantrip_ability":"int"}
        if c in {"necromancer"}:
            return {"slots_class":"Necromancer","list_class":"Necromancer","book_based":True, "cantrip_ability":"int"}
        if c in {"fightermage","fighter/magic-user","fighter-magic-user"}:
            return {"slots_class":"Magic-User","list_class":"Magic-User","book_based":True, "cantrip_ability":"int"}

        if c in {"magethief","mage/thief","mage-thief","magic-user/thief"}:
            use_illu = self._hr_enabled_proxy(channel, "magethief_illusionist_list", True)
            lst = "Illusionist" if use_illu else "Magic-User"
            return {"slots_class":"Magic-User","list_class":lst,"book_based":True, "cantrip_ability":"int"}

        if c in {"cleric"}:
            return {"slots_class":"Cleric","list_class":"Cleric","book_based":False, "cantrip_ability":"wis"}
        if c in {"paladin"}:
            return {"slots_class":"Paladin","list_class":"Cleric","book_based":False, "cantrip_ability":"wis"}
        if c in {"druid"}:
            return {"slots_class":"Druid","list_class":"Druid","book_based":False, "cantrip_ability":"wis"}

        return None


    def _abil_mod(self, cfg, abil: str) -> int:
        key = f"{abil.lower()}_modifier"
        try:
            return int(str(get_compat(cfg, "stats", key, fallback="0")).strip() or "0")
        except Exception:
            return 0

    def _with_l0(self, cfg, totals: dict[int,int], info_class: str, level: int, *, channel=None) -> dict[int,int]:
        prof = self._caster_profile(info_class, channel) or {}
        abil = prof.get("cantrip_ability", "int")
        l0 = max(0, level + self._abil_mod(cfg, abil))
        totals = dict(totals)
        totals[0] = l0
        return totals

    def _find_spell_level(self, list_class: str, spell_name_in: str) -> tuple[int | None, str | None]:
        """Return (level, canonical_name) for a spell on a given class list, or (None, None) if not found."""
        cls_map = self._spells_by_class.get(list_class, None)
        if not cls_map:
            try:
                needle_cls = _norm(list_class)
                if not hasattr(self, "_spells_by_class_norm"):
                    self._spells_by_class_norm = { _norm(k): v for k, v in self._spells_by_class.items() }
                cls_map = self._spells_by_class_norm.get(needle_cls, {}) or {}
            except Exception:
                cls_map = {}
        needle = _norm(spell_name_in)
        for lvl, names in cls_map.items():
            for n in names:
                if _norm(n) == needle:
                    return lvl, n
        return None, None

    def _prepared_remove_n(self, prepared: dict[int, list[str]], spell_name: str, n: int) -> tuple[int, int]:
        """
        Remove up to n instances of spell_name (case-insensitive) from prepared across all levels.
        Returns (removed_count, level_found_or_-1).
        """
        key = _norm(spell_name)
        removed = 0
        found_lvl = -1
        for lvl in sorted(prepared.keys()):
            lst = prepared[lvl]
            i = 0
            while i < len(lst) and removed < n:
                if _norm(lst[i]) == key:
                    if found_lvl == -1:
                        found_lvl = lvl
                    lst.pop(i)
                    removed += 1
                    continue
                i += 1
            prepared[lvl] = lst
            if removed >= n:
                break
        return removed, found_lvl


    def _resolve_char_ci(self, name: str) -> tuple[str | None, str | None]:
        """Case-insensitive '<name>.coe' resolver â†’ (pretty_display_name, path)."""
        if not name:
            return None, None
        base = name.replace(" ", "_")
        target = f"{base}.coe".lower()
        for fn in os.listdir("."):
            if fn.lower() == target:
                path = fn
                try:
                    cfg = read_cfg(path)
                    real = get_compat(cfg, "info", "name", fallback=None)
                    return (real or fn[:-4].replace("_", " ")), path
                except Exception:
                    return fn[:-4].replace("_", " "), path
        return None, None

    def _is_monster_file_path(self, path: str) -> bool:
        """Heuristic: PCs have owner_id; monsters typically don't."""
        try:
            cfg = read_cfg(path)
            owner = get_compat(cfg, "info", "owner_id", fallback="")
            return not bool(str(owner).strip())
        except Exception:
            return False

    def _hyp_break_if_targeted(self, chan_id: str, raw_targets: list[str]) -> int:
        """
        Wake targets from Hypnotic Pattern if they are even *targeted* by something.
        Clears HYP regardless of counter value (0 while concentrating, or >0 after drop).
        Returns count of combatants woken.
        """
        try:
            bcfg = _load_battles()
        except Exception:
            return 0
        if not bcfg or not bcfg.has_section(chan_id):
            return 0

        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []

        woken = 0
        for raw in (raw_targets or []):
            if not raw:
                continue
            name = str(raw).strip().strip(",.;")
            if not name:
                continue

            key = _find_ci_name(names, name) or name
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            had = False

            for opt in (f"{slot}.hyp", f"{slot}.hyp_by"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
                    had = True

            if had:
                woken += 1

        if woken:
            _save_battles(bcfg)
        return woken

    def _apply_mitig_safe(self, amount: int, *, weapon_name: str, weapon_type: str, t_cfg) -> tuple[int, str]:
        """Use your real mitigation if available; else pass-through."""
        try:
            return self._apply_mitigation(amount, weapon_name=weapon_name, weapon_type=weapon_type, t_cfg=t_cfg)
        except Exception:
            return max(0, int(amount)), ""

    def _roll_save_simple(self, t_cfg, vs: str, penalty: int = 0) -> tuple[bool, int, int, int]:
        """
        Minimal save roller: reads class.lst [<class>].spell (or the correct key)
        and picks value by level. Returns (ok, roll, target, applied_penalty).
        """
        vs_key = str(vs or "").strip().lower()
        vs_key = {"spells":"spell", "spell":"spell"}.get(vs_key, vs_key)

        char_class = (get_compat(t_cfg, "info", "class", fallback="") or "").strip()
        level = getint_compat(t_cfg, "cur", "level", fallback=1)

        cp = configparser.ConfigParser(); cp.optionxform = str; cp.read("class.lst")

        sec = None
        for s in cp.sections():
            if s.lower() == char_class.lower():
                sec = s; break


        target = 15
        if sec and cp.has_option(sec, vs_key):
            try:
                arr = [int(x) for x in cp[sec][vs_key].split()]
                target = arr[min(max(1, level)-1, len(arr)-1)]
            except Exception:
                pass

        d20 = random.randint(1, 20)
        tgt_eff = max(1, target + ( -penalty if penalty else 0))
        prot = int(self._protection_bonus_from_equipped(t_cfg) or 0)
        ok = (d20 + prot) >= tgt_eff
        return ok, d20, target, penalty

    def _battle_helpers(self):
        """Fetch your initiative helpers if they exist; else return no-op lambdas."""
        gh = globals()
        return (
            gh.get("_load_battles"), gh.get("_save_battles"), gh.get("_parse_combatants"),
            gh.get("_write_combatants"), gh.get("_sorted_entries"), gh.get("_find_ci_name"),
            gh.get("_slot"), gh.get("_format_tracker_block"),
        )

    def _refresh_tracker(self, channel: nextcord.abc.GuildChannel):
        try:
            _load_battles, _save_battles, *_rest = self._battle_helpers()
            if not _load_battles:
                return
            bcfg = _load_battles()
            chan_id = str(channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if not msg_id:
                    return
                _, _, _, _, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
                block = _format_tracker_block(bcfg, chan_id)
                content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                msg = None
                try:
                    msg = self.bot.get_channel(channel.id)
                except Exception:
                    pass
                if msg:

                    try:
                        m = None
                        m = self.bot.loop.create_task(channel.fetch_message(msg_id))
                    except Exception:
                        pass
        except Exception:
            pass

    def _kill_remove_from_initiative(self, ctx, pretty_name: str, tgt_path: str):
        """Remove dead monster from initiative and delete file, if helpers exist."""
        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
            chan_id = str(ctx.channel.id)
            if _load_battles:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty_name) or pretty_name
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        slot = _slot(key) if _slot else key.replace(" ", "_")
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass
        except Exception:
            pass

    def _monster_ab_from_hd(self, cfg) -> int:
        # pull an integer HD from base.hd
        raw_hd = (get_compat(cfg, "base", "hd", fallback="") or "").strip()
        m = re.match(r"(\d+)", raw_hd)
        if not m:
            return 0
        hd = max(1, min(32, int(m.group(1))))

        try:
            sec = None
            for s in self._class_cp.sections():
                if s.lower() == "monster":
                    sec = s
                    break
            if not sec:
                return 0

            key = f"hd{hd}"
            if self._class_cp.has_option(sec, key):
                return self._class_cp.getint(sec, key)
        except Exception:
            pass
        return 0

    def _get_attack_bonus(self, cfg) -> int:
        """
        Attack Bonus for the caster:
        1) Prefer the same classes->ab table your !a command uses.
        2) Else look for a local copy on this cog.
        3) Else read a sheet override (stats.ab / attack_bonus).
        4) Else read class.lst [<Class>].ab row.
        """
        char_class = (get_compat(cfg, "info", "class", fallback="") or "").strip()
        lvl = max(1, getint_compat(cfg, "cur", "level", fallback=1))
        lc = char_class.lower()

        # Monsters: use HD-based table if we have it
        if lc == "monster":
            hd_ab = self._monster_ab_from_hd(cfg)
            if hd_ab:
                return hd_ab

        try:
            for cog in self.bot.cogs.values():
                tbl = getattr(cog, "classes", None)
                if isinstance(tbl, dict) and lc in tbl:
                    ab_list = tbl[lc].get("ab", [])
                    if ab_list:
                        idx = min(lvl - 1, len(ab_list) - 1)
                        return int(ab_list[idx])
        except Exception:
            pass


        try:
            ab_list = getattr(self, "classes", {}).get(lc, {}).get("ab", [])
            if ab_list:
                idx = min(lvl - 1, len(ab_list) - 1)
                return int(ab_list[idx])
        except Exception:
            pass


        for key in ("ab", "attack_bonus", "attackbonus", "atk_bonus"):
            try:
                raw = get_compat(cfg, "stats", key, fallback=None)
                if raw is not None and str(raw).strip() != "":
                    return int(str(raw).strip())
            except Exception:
                pass


        try:
            sec = None
            for s in self._class_cp.sections():
                if s.lower() == char_class.lower():
                    sec = s; break
            if sec and self._class_cp.has_option(sec, "ab"):
                arr = [int(x) for x in self._class_cp.get(sec, "ab").split()]
                if arr:
                    idx = min(lvl - 1, len(arr) - 1)
                    return int(arr[idx])
        except Exception:
            pass

        return 0

    def _set_status_rounds(self, ctx, pretty_name: str, key: str, rounds: int, *, by: str = ""):
        """
        Store a round-based status on an initiative entry: e.g., key='paralyzed'.
        Writes:
            <slot>.paralyzed = <rounds>
            <slot>.paralyzed_by = <by>   (optional)
        """
        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
            if not _load_battles:
                return

            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if not bcfg.has_section(chan_id):
                return

            names, _scores = _parse_combatants(bcfg, chan_id)
            key_name = _find_ci_name(names, pretty_name) or pretty_name
            s = _slot(key_name)
            bcfg.set(chan_id, f"{s}.{key}", str(max(0, int(rounds))))
            if by:
                bcfg.set(chan_id, f"{s}.{key}_by", by)
            _save_battles(bcfg)
        except Exception:
            pass



    async def _apply_start_of_turn_web(self, ctx, bcfg, chan_id: str, who_name: str, who_path: str) -> bool:
        """
        Start-of-turn Web handler (canonical):
          â€¢ If .webignite == "1": deal 2d4 fire, then clear ALL web flags.
          â€¢ If .web > 0: decrement; if TRAPPED and eligible, roll save to ENTANGLED.
          â€¢ Expiry clears web flags.
        Returns True if the creature died and (if a monster) was removed.
        """
        if not (bcfg and bcfg.has_section(chan_id) and who_name and who_path):
            return False


        names, _ = _parse_combatants(bcfg, chan_id)
        ci_key = _find_ci_name(names, who_name) or who_name
        try:
            slot = _choose_slot_for_effects(bcfg, chan_id, ci_key)
        except Exception:
            try:
                slot = _slot(ci_key)
            except Exception:
                slot = ci_key.replace(" ", "_")


        dur_key = f"{slot}.web"
        st_key  = f"{slot}.web_state"
        ign_key = f"{slot}.webignite"
        can_key = f"{slot}.web_canbrk"


        legacy_st = f"{slot}.webstate"
        if (not bcfg.has_option(chan_id, st_key)) and bcfg.has_option(chan_id, legacy_st):
            legacy = (bcfg.get(chan_id, legacy_st, fallback="E") or "E").strip()
            mapped = "T" if legacy.lower().startswith("t") else "E"
            bcfg.set(chan_id, st_key, mapped)
            bcfg.remove_option(chan_id, legacy_st)
            _save_battles(bcfg)


        if not (bcfg.has_option(chan_id, dur_key) or bcfg.get(chan_id, ign_key, fallback="") == "1"):
            return False


        t_cfg = read_cfg(who_path)
        disp  = get_compat(t_cfg, "info", "name", fallback=who_name)
        is_mon = _is_monster_file(who_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)


        if bcfg.get(chan_id, ign_key, fallback="") == "1":
            bcfg.remove_option(chan_id, ign_key)

            s, rolls, flat = roll_dice("2d4")
            raw = s + flat
            final, note = _apply_mitigation(raw, weapon_name="Burning Web", weapon_type="fire", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(who_path, t_cfg)


            for suf in (".web", ".web_state", ".web_canbrk", ".webignite"):
                opt = f"{slot}{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
            _save_battles(bcfg)


            rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
            dead_suffix = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""

            lines = []
            dline = f"2d4 {rolls_txt} = **{raw}**"
            if note:
                dline += f"\nâ†’ **{note}**"
                if not ("heals" in note.lower() and final < 0):
                    dline += f" â†’ **{final}**"
            else:
                amt_txt = (f"**heals {abs(final)}**" if final < 0 else f"**{final}**")
                dline += f"\nâ†’ {amt_txt}"
            lines.append(dline)

            if is_mon:
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                lines.append(f"HP {_life_bar(old_hp, mhp2, 10)} â†’ **{_life_bar(new_hp, mhp2, 10)}**{dead_suffix}")
            else:
                lines.append(f"HP {old_hp} â†’ **{new_hp}**{dead_suffix}")

            embed = nextcord.Embed(
                title=f"ðŸ”¥ Burning Web: {disp} takes damage and is freed",
                description="\n".join(lines),
                color=0xE25822
            )
            await ctx.send(embed=embed)


            if new_hp <= 0 and is_mon:
                try:
                    names2, scores2 = _parse_combatants(bcfg, chan_id)
                    if ci_key in names2:
                        names2 = [n for n in names2 if n != ci_key]
                        if bcfg.has_option(chan_id, ci_key):
                            bcfg.remove_option(chan_id, ci_key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                    ".web",".web_state",".web_canbrk",".webignite"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names2, scores2)
                        if bcfg.get(chan_id, "turn", fallback="") == ci_key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try: os.remove(os.path.abspath(who_path))
                except Exception: pass


            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

            return (new_hp <= 0 and is_mon)


        if bcfg.has_option(chan_id, dur_key):
            remaining = max(0, bcfg.getint(chan_id, dur_key, fallback=0) - 1)
            state     = (bcfg.get(chan_id, st_key, fallback="E") or "E").upper()
            canbrk    = (bcfg.get(chan_id, can_key, fallback="0") == "1")


            if remaining > 0 and state == "T":
                qualifies = canbrk
                if not canbrk:

                    try:
                        STR = getint_compat(t_cfg, "stats", "str", fallback=10)
                        HD  = getint_compat(t_cfg, "cur", "level", fallback=1)
                        qualifies = (STR >= 13 or HD >= 4)
                    except Exception:
                        qualifies = False

                if qualifies:
                    ok, r, dc, pen = self._roll_save(t_cfg, vs="death", penalty=0)
                    res = "ENTANGLED" if ok else "TRAPPED"
                    await ctx.send(f"ðŸ•¸ï¸ {disp}: Start-of-turn save vs Death {r} vs {dc} â†’ **{res}**")
                    if ok:
                        state = "E"


            if remaining <= 0:
                for suf in (".web",".web_state",".web_canbrk"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)
                await ctx.send(f"ðŸ•¸ï¸ **Web expires on {disp}.**")
            else:
                bcfg.set(chan_id, dur_key, str(remaining))
                bcfg.set(chan_id, st_key, state)
                _save_battles(bcfg)


            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

        return False

    @commands.command(name="ignite")
    async def ignite_web(self, ctx, *names):
        """
        GM-only (change if you want): Ignite webs on the given targets (or 'all' to hit everyone who is webbed).
        Those targets will take 2d4 at the start of their next turn and be freed from webs afterward.
        Usage:
          !ignite GO1
          !ignite go1 bu2
          !ignite all
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg.has_section(chan_id):
            await ctx.send("âŒ No battle running here.")
            return

        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("âŒ Only the GM can ignite webs in this battle.")
            return

        names_list, _ = _parse_combatants(bcfg, chan_id)
        if not names_list:
            await ctx.send("No combatants to affect.")
            return

        targets: list[str] = []
        if not names:
            await ctx.send("Usage: `!ignite <name ...>` or `!ignite all`")
            return

        if len(names) == 1 and str(names[0]).lower() == "all":

            for n in names_list:
                s = _slot(n)
                if bcfg.has_option(chan_id, f"{s}.web"):
                    targets.append(n)
        else:
            for raw in names:
                hit = _find_ci_name(names_list, raw) or None
                if hit:
                    targets.append(hit)

        if not targets:
            await ctx.send("No matching webbed targets found.")
            return

        ignited = []
        for n in targets:
            s = _slot(n)

            if not bcfg.has_option(chan_id, f"{s}.web"):
                continue
            bcfg.set(chan_id, f"{s}.webignite", "1")
            ignited.append(bcfg.get(chan_id, f"{s}.disp", fallback=n))

        _save_battles(bcfg)

        if ignited:
            await ctx.send("ðŸ”¥ Ignited webs on: " + ", ".join(f"**{x}**" for x in ignited))
        else:
            await ctx.send("No one was currently webbed to ignite.")


    @commands.command(name="sb")
    async def spellbook(self, ctx, *args):
        """
        !sb              : show PREPARED spells + slot bubbles
        !sb all          : show ALL you can prepare (underline prepared) + slot bubbles
        !sb add <Spell>  : add a spell to your spellbook (book-based casters)
        """

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return

        info_class = get_compat(cfg, "info", "class", fallback="")
        profile = self._caster_profile(info_class, ctx.channel)
        if not profile:
            await ctx.send(f"âŒ **{char_name}** ({info_class or 'â€”'}) is not a spellcaster.")
            return

        level = getint_compat(cfg, "cur", "level", fallback=1)


        if len(args) >= 1 and args[0].lower() == "add":
            if not profile["book_based"]:
                await ctx.send("âŒ Your class does not use a spellbook.")
                return
            if len(args) < 2:
                await ctx.send("âŒ Usage: `!sb add <SpellName>`")
                return
            spell_name_in = " ".join(args[1:]).strip()
            await self._cmd_add_to_book(ctx, cfg, path, char_name, profile, spell_name_in, level)
            return

        show_all = (len(args) >= 1 and args[0].lower() == "all")
        await self._cmd_show_sb(ctx, cfg, path, char_name, profile, level, show_all=show_all)

    async def _cmd_show_sb(self, ctx, cfg, path, char_name, profile, level: int, *, show_all: bool):


        totals = _slots_for_class_level(self._class_cp, profile["slots_class"], level)
        info_class = get_compat(cfg, "info", "class", fallback="")
        totals = self._with_l0(cfg, totals, info_class, level, channel=ctx.channel)
        changed = _ensure_slots_for(cfg, totals)
        if changed:
            write_cfg(path, cfg)


        spent = {lvl: getint_compat(cfg, "slots", f"l{lvl}_spent", fallback=0) for lvl in totals.keys()}


        prepared = _read_per_level_list(cfg, "prepared")


        list_class = profile["list_class"]
        class_spells = self._spells_by_class.get(list_class, {})


        can_cast_levels = {lvl for lvl, t in totals.items() if t > 0}

        if profile["book_based"]:

            all_known = _read_per_level_list(cfg, "spellbook")
        else:

            all_known = {lvl: list(class_spells.get(lvl, [])) for lvl in sorted(can_cast_levels) if lvl in class_spells}


        if show_all:

            levels_to_show = sorted(set(all_known.keys()) | set(prepared.keys()))

            if not profile["book_based"]:
                levels_to_show = [lvl for lvl in levels_to_show if lvl in can_cast_levels]
        else:

            levels_to_show = sorted({lvl for lvl, lst in prepared.items() if lst} | {lvl for lvl, t in totals.items() if t})


        try:
            underline_fn = _underline_prepared
        except NameError:
            def underline_fn(pool_names: list[str], prepared_names: list[str]) -> list[str]:
                cnt = Counter(n.strip().lower() for n in (prepared_names or []))
                out = []
                for name in sorted(pool_names or [], key=str.lower):
                    key = name.strip().lower()
                    if cnt.get(key, 0) > 0:
                        out.append(f"__{name}__")
                        cnt[key] -= 1
                    else:
                        out.append(name)
                return out


        def chunk_names(names: list[str], *, max_len: int = 1000, sep: str = ", ") -> list[str]:
            if not names:
                return ["â€”"]
            chunks, cur = [], ""
            for n in names:
                piece = (sep if cur else "") + n
                if len(cur) + len(piece) > max_len:
                    chunks.append(cur or n)
                    cur = n
                else:
                    cur += piece
            if cur:
                chunks.append(cur)
            return chunks


        all_fields: list[tuple[str, str]] = []

        for lvl in sorted(levels_to_show):
            t = totals.get(lvl, 0)
            s = spent.get(lvl, 0)
            bubbles = _bubble_line(t, s) if t > 0 else ""
            header = f"**Level 0 (Cantrips)**  {bubbles}" if lvl == 0 else f"**Level {lvl}**  {bubbles}"

            if show_all:
                pool = list(all_known.get(lvl, []))
                prep = prepared.get(lvl, [])
                shown = underline_fn(pool, prep) if pool else []
            else:
                shown = prepared.get(lvl, [])

            for i, chunk in enumerate(chunk_names(shown, max_len=1000)):
                fname = header if i == 0 else f"{header} (cont.)"
                all_fields.append((fname, chunk))


        base_title = f"ðŸ“– {char_name} â€” Spellbook"
        if show_all:
            base_title += " (All available; prepared are underlined)"

        color = random.randint(0, 0xFFFFFF)
        per_embed = 25
        total_pages = max(1, math.ceil(len(all_fields) / per_embed))

        if not all_fields:
            embed = nextcord.Embed(title=base_title, color=color)
            embed.add_field(name="Spells & Slots", value="â€”", inline=False)
            embed.set_footer(text="Legend: â— = available slot, â—‹ = spent slot")
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)
            return

        page = 1
        for start in range(0, len(all_fields), per_embed):
            embed = nextcord.Embed(
                title=(base_title if total_pages == 1 else f"{base_title} â€” Page {page}/{total_pages}"),
                color=color
            )
            for name, val in all_fields[start:start+per_embed]:
                embed.add_field(name=name, value=val, inline=False)
            embed.set_footer(text="Legend: â— = available slot, â—‹ = spent slot")
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)
            page += 1

    async def _cmd_add_to_book(self, ctx, cfg, path, char_name, profile, spell_name_in: str, level: int):
        """
        Add a spell to the character's spellbook (book-based casters).
        Looks up the spell (case/space-insensitive) in the class list and stores it under [spellbook].l<level>.
        """

        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

        list_class = profile.get("list_class")
        class_spells = self._spells_by_class.get(list_class, {})
        if not class_spells:
            await ctx.send(f"âš ï¸ No spell list found for **{list_class or 'â€”'}**.")
            return

        target = _norm(spell_name_in)


        found_level = None
        found_name  = None
        for lvl in sorted(class_spells.keys()):
            for name in class_spells.get(lvl, []):
                if _norm(name) == target:
                    found_level = int(lvl)
                    found_name  = name
                    break
            if found_name:
                break

        if not found_name:

            all_names = [n for lst in class_spells.values() for n in lst]
            sugg = difflib.get_close_matches(spell_name_in, all_names, n=8, cutoff=0.6)
            msg = f"âŒ Spell **{spell_name_in}** not found for **{list_class}**."
            if sugg:
                msg += "\nTry one of: " + ", ".join(sugg)
            await ctx.send(msg)
            return


        book = _read_per_level_list(cfg, "spellbook")
        existing = [s.strip().lower() for s in book.get(found_level, [])]
        if found_name.strip().lower() in existing:
            await ctx.send(f"â„¹ï¸ **{found_name}** (Level {found_level}) is already in {char_name}â€™s spellbook.")
            return


        new_list = list(book.get(found_level, [])) + [found_name]
        new_list = sorted(set(new_list), key=lambda x: x.lower())
        book[found_level] = new_list


        if not cfg.has_section("spellbook"):
            cfg.add_section("spellbook")
        for lvl, names in book.items():
            cfg.set("spellbook", f"l{int(lvl)}", "\n".join(names))
        write_cfg(path, cfg)

        await ctx.send(f"âœ… Added **{found_name}** to **{char_name}**â€™s spellbook (Level {found_level}).\nUse `!sb all` to view everything you can prepare.")



    def _resolve_public_list_class(self, class_name: str, *, channel=None) -> tuple[str, str]:
        """
        Returns (display_name, list_class) for !spells.
        display_name is the title shown to users; list_class is which list to render.
        Honors HR: magethief_illusionist_list.
        """
        x = (class_name or "").strip().lower()

        if hasattr(self, "_CLASS_ABBR") and x in self._CLASS_ABBR:
            target = self._CLASS_ABBR[x]
            return target, target

        if any(k in x for k in ("magethief", "mage-thief", "mage/thief", "magic-user/thief", "mage thief")):
            use_illu = self._hr_enabled_proxy(channel, "magethief_illusionist_list", True)
            return "Magethief", ("Illusionist" if use_illu else "Magic-User")

        if any(k in x for k in ("fightermage", "fighter-magic-user", "fighter/magic-user", "fighter mage")):
            return "Fightermage", "Magic-User"
        if "paladin" in x:
            return "Paladin", "Paladin"

        for k in self._spells_by_class.keys():
            if k.lower() == x:
                return k, k

        if x in {"magic-user", "magicuser"}:
            return "Magic-User", "Magic-User"

        t = (class_name or "").strip()
        return t, t


    @commands.command(name="spells")
    async def spells_for_class(self, ctx, *, class_name: str = None):
        if not class_name:
            await ctx.send("â„¹ï¸ Usage: `!spells <Class>` (e.g., Magic-User, Cleric, Druid, Illusionist, Spellcrafter, Necromancer, Paladin)")
            return

        display, sec = self._resolve_public_list_class(class_name, channel=ctx.channel)


        if not sec:

            for k in self._spells_by_class.keys():
                if k.lower() == class_name.strip().lower():
                    sec = k
                    display = k
                    break

        if not sec or sec not in self._spells_by_class:
            await ctx.send(f"âŒ Class **{class_name}** not found in spell.lst.")
            return

        by_lvl = self._spells_by_class[sec]
        embed = nextcord.Embed(title=f"{display or sec} Spells", color=random.randint(0, 0xFFFFFF))

        for lvl in sorted(by_lvl.keys()):
            label = "Level 0 (Cantrips)" if lvl == 0 else f"Level {lvl}"
            names = by_lvl[lvl]
            text = " â€¢ ".join(names) if names else "â€”"
            for chunk_start in range(0, len(text), 1000):
                chunk = text[chunk_start:chunk_start+1000]
                embed.add_field(name=label if chunk_start == 0 else f"{label} (cont.)", value=chunk or "â€”", inline=False)


        if (display or sec) and display != sec:
            embed.set_footer(text=f"Using {sec} spell list")

        await ctx.send(embed=embed)


    _CLASS_ABBR = {
        "cle": "Cleric",
        "mu":  "Magic-User",
        "nec": "Necromancer",
        "dru": "Druid",
        "il":  "Illusionist",
        "sp":  "Spellcrafter",
        "fm": "Fightermage",
        "pa": "Paladin",
        "mt": "Magethief",
    }

    @staticmethod
    def _format_desc(raw: str) -> str:
        parts = [p.strip() for p in re.split(r"\s*//\s*", (raw or "").strip()) if p.strip()]
        return "\n\n".join(parts) if parts else ""

    @staticmethod
    def _pretty_duration(code: str) -> str:
        """
        Formats your duration codes into readable English.
        Supported (case/space-insensitive):
          - permanent, instantaneous, concentration/conc
          - <N>r / <N>t / <N>m / <N>h / <N>d / <N>y   (rounds/turns/minutes/hours/days/years)
          - <N>rlvl, <N>tlvl, <N>mlvl, <N>hlvl|<N>hrlvl, <N>dlvl, <N>ylvl  (per level)
          - <N><unit>plus1lvl  (e.g. 5rplus1lvl â†’ 5 rounds + 1/level)
          - <A>d<B>t           (e.g. 2d8t â†’ 2d8 turns)
          - <N><unit><K>lvl    (e.g. 1r3lvl â†’ 1 round every 3 levels)
          - <N>u<K>lvl         (e.g. 1u2lvl â†’ 1 use every 2 levels; no expiration until used)
          - two-part composites like 4d12h, 1h30m, 2t10m
        Notes:
          - turn = 10 minutes (60 rounds), round â‰ˆ 10 seconds (initiative time)
        """

        if not code:
            return ""

        raw = code.strip()
        c = raw.lower().replace(" ", "")


        c = re.sub(r'hr(?=(?:lvl|$))', 'h', c)

        def unit_word(u: str, n: int, *, per_level=False) -> str:
            names = {'r': 'round', 't': 'turn', 'm': 'minute', 'h': 'hour', 'd': 'day', 'y': 'year'}
            w = names.get(u, u)
            if per_level:
                return f"{w}/level" if n == 1 else f"{w}s/level"
            return w if n == 1 else f"{w}s"


        if c in {"instant", "instantaneous", "inst"}:
            return "Instantaneous"
        if c in {"perm", "permanent"}:
            return "Permanent"
        if c in {"concentration", "conc"}:
            return "Concentration"
        if c == "special":
            return "Special"


        m = re.fullmatch(r'(\d+)d(\d+)t', c)
        if m:
            a, b = int(m.group(1)), int(m.group(2))
            return f"{a}d{b} turns"


        m = re.fullmatch(r'(\d+)u(\d+)lvl', c)
        if m:
            n = int(m.group(1)); k = int(m.group(2))
            return f"{n} {'use' if n==1 else 'uses'} every {k} levels (no expiration until used)"



        m = re.fullmatch(r'(\d+)([rtmhyd])(\d+)([rtmhyd])', c)
        if m:
            n1, u1, n2, u2 = int(m.group(1)), m.group(2), int(m.group(3)), m.group(4)
            return f"{n1} {unit_word(u1, n1)}, {n2} {unit_word(u2, n2)}"


        m = re.fullmatch(r'(\d+)([rtmhd])plus1lvl', c)
        if m:
            n = int(m.group(1)); u = m.group(2)
            return f"{n} {unit_word(u, n)} + 1/level"


        m = re.fullmatch(r'(\d+)([rtmhd])(\d+)lvl', c)
        if m:
            n = int(m.group(1)); u = m.group(2); k = int(m.group(3))
            return f"{n} {unit_word(u, n)} every {k} levels"


        m = re.fullmatch(r'(\d+)([rtmhyd])lvl', c)
        if m:
            n = int(m.group(1)); u = m.group(2)
            return f"{n} {unit_word(u, n, per_level=True)}"


        m = re.fullmatch(r'(\d+)([rtmhyd])', c)
        if m:
            n = int(m.group(1)); u = m.group(2)
            return f"{n} {unit_word(u, n)}"


        legacy = {
            "lplus1d4r": "Level + 1d4 rounds",
        }
        if c in legacy:
            return legacy[c]


        return ""

    @staticmethod
    def _pretty_range(rng_raw: str, inc_raw: str | None = None) -> str:
        rng = (rng_raw or "").strip().lower()
        inc = (inc_raw or "").strip()
        out = ""
        m = re.fullmatch(r"(\d+)\s*rad", rng)
        if m:
            n = int(m.group(1))
            out = f"{n}-ft radius (centered on caster)"
        else:
            if re.fullmatch(r"\d+", rng):
                out = f"{int(rng)} ft"
            elif rng in {"self", "touch"}:
                out = rng.capitalize()
            else:
                out = rng_raw or ""
        if inc:
            try:
                inc_n = int(inc)
                out += f" (+{inc_n}/level)"
            except ValueError:
                pass
        return out



    @staticmethod
    def _format_desc(raw: str) -> str:
        parts = [p.strip() for p in re.split(r"\s*//\s*", (raw or "").strip()) if p.strip()]
        return "\n\n".join(parts) if parts else ""

    @staticmethod
    def _pretty_duration(code: str) -> str:
        """
        Formats your duration codes into readable English.
        Supported (case/space-insensitive):
          - permanent, instantaneous, concentration/conc
          - <N>r / <N>t / <N>m / <N>h / <N>d / <N>y   (rounds/turns/minutes/hours/days/years)
          - <N>rlvl, <N>tlvl, <N>mlvl, <N>hlvl|<N>hrlvl, <N>dlvl, <N>ylvl  (per level)
          - <N><unit>plus1lvl  (e.g. 5rplus1lvl â†’ 5 rounds + 1/level)
          - <A>d<B>t           (e.g. 2d8t â†’ 2d8 turns)
          - <N><unit><K>lvl    (e.g. 1r3lvl â†’ 1 round every 3 levels)
          - <N>u<K>lvl         (e.g. 1u2lvl â†’ 1 use every 2 levels; no expiration until used)
          - two-part composites like 4d12h, 1h30m, 2t10m
        Notes:
          - turn = 10 minutes (60 rounds), round â‰ˆ 10 seconds (initiative time)
        """

        if not code:
            return ""

        raw = code.strip()
        c = raw.lower().replace(" ", "")


        c = re.sub(r'hr(?=(?:lvl|$))', 'h', c)

        def unit_word(u: str, n: int, *, per_level=False) -> str:
            names = {'r': 'round', 't': 'turn', 'm': 'minute', 'h': 'hour', 'd': 'day', 'y': 'year'}
            w = names.get(u, u)
            if per_level:
                return f"{w}/level" if n == 1 else f"{w}s/level"
            return w if n == 1 else f"{w}s"


        if c in {"instant", "instantaneous", "inst"}:
            return "Instantaneous"
        if c in {"perm", "permanent"}:
            return "Permanent"
        if c in {"concentration", "conc"}:
            return "Concentration"
        if c == "special":
            return "Special"


        m = re.fullmatch(r'(\d+)d(\d+)t', c)
        if m:
            a, b = int(m.group(1)), int(m.group(2))
            return f"{a}d{b} turns"


        m = re.fullmatch(r'(\d+)u(\d+)lvl', c)
        if m:
            n = int(m.group(1)); k = int(m.group(2))
            return f"{n} {'use' if n==1 else 'uses'} every {k} levels (no expiration until used)"



        m = re.fullmatch(r'(\d+)([rtmhyd])(\d+)([rtmhyd])', c)
        if m:
            n1, u1, n2, u2 = int(m.group(1)), m.group(2), int(m.group(3)), m.group(4)
            return f"{n1} {unit_word(u1, n1)}, {n2} {unit_word(u2, n2)}"


        m = re.fullmatch(r'(\d+)([rtmhd])plus1lvl', c)
        if m:
            n = int(m.group(1)); u = m.group(2)
            return f"{n} {unit_word(u, n)} + 1/level"


        m = re.fullmatch(r'(\d+)([rtmhd])(\d+)lvl', c)
        if m:
            n = int(m.group(1)); u = m.group(2); k = int(m.group(3))
            return f"{n} {unit_word(u, n)} every {k} levels"


        m = re.fullmatch(r'(\d+)([rtmhyd])lvl', c)
        if m:
            n = int(m.group(1)); u = m.group(2)
            return f"{n} {unit_word(u, n, per_level=True)}"


        m = re.fullmatch(r'(\d+)([rtmhyd])', c)
        if m:
            n = int(m.group(1)); u = m.group(2)
            return f"{n} {unit_word(u, n)}"


        legacy = {
            "lplus1d4r": "Level + 1d4 rounds",
        }
        if c in legacy:
            return legacy[c]


        return ""

    @staticmethod
    def _pretty_range(rng_raw: str, inc_raw: str | None = None) -> str:
        rng = (rng_raw or "").strip().lower()
        inc = (inc_raw or "").strip()
        out = ""
        m = re.fullmatch(r"(\d+)\s*rad", rng)
        if m:
            n = int(m.group(1))
            out = f"{n}-ft radius (centered on caster)"
        else:
            if re.fullmatch(r"\d+", rng):
                out = f"{int(rng)} ft"
            elif rng in {"self", "touch"}:
                out = rng.capitalize()
            else:
                out = rng_raw or ""
        if inc:
            try:
                inc_n = int(inc)
                out += f" (+{inc_n}/level)"
            except ValueError:
                pass
        return out

    @commands.command(name="info")
    async def info_spell_class_or_race(self, ctx, *, name: str):
        """
        !info Fireball  -> reads [Fireball] from spell.lst
        !info Paladin   -> reads [Paladin] from class.lst
        !info Dwarf     -> reads [Dwarf] from race.lst
        !info Dagger    -> reads [Dagger] from item.lst
        Optional overrides:
          !info class: cleric
          !info spell: magic missile
          !info race: elf
          !info item: dagger
        """

        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", (s or "").lower())


        def _format_desc(text: str) -> str:
            text = (text or "").strip()
            if not text:
                return ""
            paras = [p.strip() for p in text.split("//") if p.strip()]
            return "\n\n".join(paras)

        def _signed(n: int) -> str:
            return f"{'+' if n >= 0 else 'â€“'}{abs(n)}"

        def _get_ci(sec, key, default=""):
            kl = key.lower()
            for k, v in sec.items():
                if k.lower() == kl:
                    return v
            return default


        if not hasattr(self, "_class_cp"):
            cp = configparser.ConfigParser()
            cp.optionxform = str
            cp.read("class.lst")
            self._class_cp = cp
        if not hasattr(self, "_race_cp"):
            rp = configparser.ConfigParser()
            rp.optionxform = str
            rp.read("race.lst")
            self._race_cp = rp

        if not hasattr(self, "_item_cp"):
            ip = configparser.ConfigParser()
            ip.optionxform = str
            ip.read("item.lst")
            self._item_cp = ip

        class_cp = self._class_cp
        race_cp  = self._race_cp


        raw = (name or "").strip()
        m = re.match(r'^(?:(class|cls|c|spell|sp|s|race|rc|r|item|it|i|gear|weap|weapon|armor|arm|eq)\s*:\s*)?(.*)$', raw, flags=re.I)
        mode = (m.group(1) or "").lower()
        query = (m.group(2) or "").strip()
        needle = _norm(query)

        force_class = mode in {"class","cls","c"}
        force_spell = mode in {"spell","sp","s"}
        force_race  = mode in {"race","rc","r"}
        force_item  = mode in {"item","it","i","gear","weap","weapon","armor","arm","eq"}


        class_map = { _norm(sec): sec for sec in class_cp.sections() if sec.lower() != "monster" }
        race_map  = { _norm(sec): sec for sec in race_cp.sections() }

        item_cp  = self._item_cp
        item_map = { _norm(sec): sec for sec in item_cp.sections() }


        sec_item = item_map.get(needle)


        if not sec_item:
            try:
                canon, it = self.find_item(query)
                if canon and canon in item_cp.sections():
                    sec_item = canon
            except Exception:
                pass

        sec_class = class_map.get(needle)
        sec_race  = race_map.get(needle)


        def _find_spell_section(q: str):
            if self._spell_cp.has_section(q):
                return q
            n = _norm(q)
            for s in self._spell_cp.sections():
                if _norm(s) == n:
                    return s
            return None

        sec_spell = _find_spell_section(query)
        if sec_spell and not force_spell and _norm(sec_spell) in class_map:

            sec_spell = None

        # If the user explicitly forced race: or class:, ignore spell/item matches.
        # This lets things like race:darkvision or class:accuracy pull from race.lst/class.lst
        # even if a spell or item with the same name exists.
        if force_race and sec_race:
            sec_spell = None
            sec_item = None
        if force_class and sec_class:
            sec_spell = None
            sec_item = None


        chosen = None
        if force_class and sec_class:
            chosen = ("class", sec_class)
        elif force_spell and sec_spell:
            chosen = ("spell", sec_spell)
        elif force_race and sec_race:
            chosen = ("race", sec_race)
        elif force_item and sec_item:
            chosen = ("item", sec_item)
        else:

            if sec_class and not sec_spell and not sec_race and not sec_item:
                chosen = ("class", sec_class)
            elif sec_class and (sec_spell or sec_race or sec_item):
                chosen = ("class", sec_class)
            elif sec_spell:
                chosen = ("spell", sec_spell)
            elif sec_race:
                chosen = ("race", sec_race)
            elif sec_item:
                chosen = ("item", sec_item)

        if not chosen:
            await ctx.send(f"âŒ No spell, class, race, or item named **{query}** found.")
            return

        kind, sec = chosen


        if kind == "class":
            def _int_list(s):
                try:
                    return [int(x) for x in str(s).split()]
                except Exception:
                    return []

            all_classes = [s for s in class_cp.sections() if s.lower() != "monster"]

            def _xp_anchor(secname):
                opts = class_cp[secname]
                for key in ("xp9","xp10","xp8","xp7","xp6","xp5","xp4","xp3","xp2"):
                    if key in opts:
                        try: return int(opts[key])
                        except: pass
                return None

            def _ab_l10(secname):
                arr = _int_list(class_cp[secname].get("AB", "")) or [0]
                return arr[min(9, len(arr)-1)]

            opts = class_cp[sec]

            # ---- Detect whether this section is a full class or just a class ability entry ----
            keys_lower = {k.lower() for k in opts.keys()}

            has_xp   = any(k.startswith("xp") for k in keys_lower)
            has_hp   = ("hp9" in keys_lower) or ("hp20" in keys_lower)
            has_ab   = "ab" in keys_lower
            has_spells = any(k.startswith("spell") for k in keys_lower)  # spell1, spell2, etc.
            has_saves  = any(k in keys_lower for k in ("poi","wand","para","breath","spell"))

            is_full_class = has_xp or has_hp or has_ab or has_spells or has_saves

            if not is_full_class:
                # -------- Class ability definition (e.g. [Accuracy] with only desc=) --------
                raw_desc = opts.get("desc", "") or ""
                desc = _format_desc(raw_desc) if raw_desc.strip() else \
                       "_(No description yet â€” add `desc=` to this class ability in class.lst.)_"

                ability_norm = _norm(sec)

                def _tokset(s):
                    return {_norm(t) for t in re.split(r"[,\s/|]+", str(s or "")) if t.strip()}

                # Find all *classes* that reference this ability in their skills= line.
                appears_in = []
                for csec in all_classes:
                    if csec == sec:
                        continue
                    c_opts = class_cp[csec]
                    skills_line = c_opts.get("skills", "") or ""
                    if not skills_line.strip():
                        continue
                    if ability_norm in _tokset(skills_line):
                        appears_in.append(csec)

                appears_in.sort(key=str.lower)
                classes_txt = ", ".join(appears_in) if appears_in else "â€”"

                embed = nextcord.Embed(
                    title=sec,
                    description=desc,
                    color=random.randint(0, 0xFFFFFF)
                )
                embed.add_field(name="Type", value="Class Ability", inline=True)
                embed.add_field(name="Appears In Classes", value=classes_txt, inline=False)

                await ctx.send(embed=embed)
                return

            # ===================== Full class (existing behavior) =====================

            desc = _format_desc(opts.get("desc", "")) or "_(No description yet â€” add `desc=` to this class in class.lst.)_"

            cls_norm = _norm(sec)
            allowed_races = []
            for rsec in race_cp.sections():
                r_opts = race_cp[rsec]

                if _truthy(r_opts.get("hidden", "")) or _truthy(r_opts.get("secret", "")):
                    continue
                if _norm(rsec) in HIDE_RACES:
                    continue

                cls_line = (r_opts.get("class", "") or "")

                toks = { _norm(t) for t in re.split(r"[,\s/|]+", cls_line) if t.strip() }
                if "any" in toks or "*" in toks or cls_norm in toks:
                    allowed_races.append(rsec)

            allowed_races.sort(key=str.lower)
            allowed_races_txt = ", ".join(allowed_races) if allowed_races else "â€”"

            hd_line = ""
            if "hp9" in opts:
                die = opts.get("hp9","").strip()
                after9 = opts.get("hp20","").strip()
                hd_line = f"{die} (then +{after9} / level after 9th)" if after9 else die

            prereqs = []
            for k, v in opts.items():
                if k.lower().endswith("min"):
                    stat = k[:-3].upper()
                    try: prereqs.append(f"{stat} {int(v)}+")
                    except: pass
            prereq_text = ", ".join(prereqs) if prereqs else "â€”"

            def _int_list(s):
                try: return [int(x) for x in str(s).split()]
                except: return []
            ab_arr = _int_list(opts.get("AB", ""))
            def _ab_at(n): return ab_arr[min(max(n-1,0), len(ab_arr)-1)] if ab_arr else 0
            ab_milestones = f"L1 **+{_ab_at(1)}**, L5 **+{_ab_at(5)}**, L10 **+{_ab_at(10)}**"

            my_xp = _xp_anchor(sec)

            def _save_at_level(level):
                out = []
                for key, label in (("poi","Death/Poison"),("wand","Wands"),("para","Paralysis/Petrify"),
                                   ("breath","Dragon Breath"),("spell","Spells")):
                    arr = _int_list(opts.get(key, ""))
                    val = arr[min(max(level-1,0), len(arr)-1)] if arr else "â€”"
                    out.append(f"{label}: {val}")
                return "\n".join(out)

            embed = nextcord.Embed(
                title=sec,
                description=desc,
                color=random.randint(0, 0xFFFFFF)
            )
            embed.add_field(name="Allowed Races", value=allowed_races_txt, inline=False)
            if hd_line:
                embed.add_field(name="Hit Dice", value=hd_line, inline=True)
            embed.add_field(name="Prime Requisites", value=prereq_text, inline=True)
            embed.add_field(
                name="Progression & Ratings",
                value=(
                    f"XP to 9th: **{my_xp if my_xp is not None else 'â€”'}**\n"
                    f"Attack Progression: {ab_milestones}\n"
                ),
                inline=False
            )
            skills_text = (opts.get("skills", "") or "â€”").replace(" ", ", ")
            embed.add_field(name="Class Abilities", value=skills_text, inline=False)
            embed.add_field(name="Saving Throws (Level 1)", value=_save_at_level(1), inline=False)
            await ctx.send(embed=embed)
            return



        if kind == "race":
            opts = race_cp[sec]

            # Detect whether this section is a full race or just a racial ability definition.
            keys_lower = {k.lower() for k in opts.keys()}

            has_class_line = "class" in keys_lower
            has_banned     = "banned" in keys_lower

            has_minmax = any(k.endswith("min") or k.endswith("max") for k in keys_lower)
            has_saves  = any(k in keys_lower for k in ("poi", "wand", "para", "breath", "spell"))

            # If it has none of the usual "race" fields, treat it as a racial ability entry.
            is_full_race = has_class_line or has_banned or has_minmax or has_saves

            if not is_full_race:
                # Racial ability / trait definition (e.g. [QuickLearner] with desc= only).

                raw_desc = opts.get("desc", "") or ""
                desc = _format_desc(raw_desc) if raw_desc.strip() else \
                       "_(No description yet â€” add `desc=` to this racial ability in race.lst.)_"

                ability_norm = _norm(sec)

                def _tokset(s):
                    import re as _re
                    return {_norm(t) for t in _re.split(r"[,\s/|]+", str(s or "")) if t.strip()}

                # Find all *races* that reference this ability in their skills= line.
                appears_in = []
                for rsec in race_cp.sections():
                    if rsec == sec:
                        continue

                    r_opts = race_cp[rsec]

                    # Skip other ability-only sections (no class= line).
                    if not (r_opts.get("class", "") or "").strip():
                        continue

                    # Respect hidden/secret and HIDE_RACES, like the class-handling code.
                    if _truthy(r_opts.get("hidden", "")) or _truthy(r_opts.get("secret", "")):
                        continue
                    if _norm(rsec) in HIDE_RACES:
                        continue

                    skills_line = r_opts.get("skills", "") or ""
                    if ability_norm in _tokset(skills_line):
                        appears_in.append(rsec)

                appears_in.sort(key=str.lower)
                races_txt = ", ".join(appears_in) if appears_in else "â€”"

                embed = nextcord.Embed(
                    title=sec,
                    description=desc,
                    color=random.randint(0, 0xFFFFFF)
                )
                embed.add_field(name="Type", value="Racial Ability", inline=True)
                embed.add_field(name="Appears In Races", value=races_txt, inline=False)

                await ctx.send(embed=embed)
                return

            # ========= Full race (existing behavior) =========

            desc = _format_desc(opts.get("desc", "")) or "_(No description yet â€” add `desc=` to this race in race.lst.)_"

            cls_line = (opts.get("class", "") or "").strip()
            if cls_line:
                allowed_classes = ", ".join(cls_line.split())
            else:
                allowed_classes = "â€”"

            banned_line = (opts.get("banned", "") or "").strip()
            banned_txt = ", ".join(banned_line.split()) if banned_line else "â€”"

            MIN_KEYS = ("str","dex","con","int","wis","cha")
            mins, maxs = [], []
            for k, v in opts.items():
                kl = k.lower()
                for ab in MIN_KEYS:
                    if kl == f"{ab}min":
                        try: mins.append(f"{ab.upper()} {int(v)}+")
                        except: pass
                    if kl == f"{ab}max":
                        try: maxs.append(f"{ab.upper()} {int(v)}")
                        except: pass
            min_text = ", ".join(mins) if mins else "â€”"
            max_text = ", ".join(maxs) if maxs else "â€”"

            skills_text = (opts.get("skills", "") or "â€”").replace(" ", ", ")

            SAVE_LABELS = {
                "poi":"Death/Poison",
                "wand":"Wands",
                "para":"Paralysis/Petrify",
                "breath":"Dragon Breath",
                "spell":"Spells",
            }
            save_mod_lines = []
            for key, label in SAVE_LABELS.items():
                if key in opts:
                    try:
                        n = int(str(opts.get(key)).strip())
                        save_mod_lines.append(f"{label}: {_signed(n)}")
                    except:
                        pass
            save_mod_text = "\n".join(save_mod_lines) if save_mod_lines else "â€”"

            SKILL_LABELS = {
                "openlock":"Open Lock",
                "removetrap":"Remove Trap",
                "pickpocket":"Pick Pockets",
                "movesilently":"Move Silently",
                "climbwall":"Climb Walls",
                "climb":"Climb Walls",
                "hide":"Hide in Shadows",
                "listen":"Listen",
                "tracking":"Tracking",
                "track":"Tracking",
            }
            th_lines = []
            for k, v in opts.items():
                kl = k.lower()
                if kl in SKILL_LABELS:
                    try:
                        n = int(str(v).strip())
                        th_lines.append(f"{SKILL_LABELS[kl]}: {_signed(n)}%")
                    except:
                        pass
            thief_mod_text = "\n".join(th_lines) if th_lines else "â€”"

            embed = nextcord.Embed(
                title=sec,
                description=desc,
                color=random.randint(0, 0xFFFFFF)
            )
            embed.add_field(name="Allowed Classes", value=allowed_classes, inline=False)
            embed.add_field(name="Ability Minimums", value=min_text, inline=True)
            embed.add_field(name="Ability Maximums", value=max_text, inline=True)
            embed.add_field(name="Racial Abilities", value=skills_text, inline=False)
            embed.add_field(name="Saving Throw Modifiers", value=save_mod_text, inline=True)
            embed.add_field(name="Thief/Skill Modifiers", value=thief_mod_text, inline=True)
            embed.add_field(name="Weapon / Gear Restrictions", value=banned_txt, inline=False)

            await ctx.send(embed=embed)
            return



        if kind == "item":
            opts = item_cp[sec]
            desc = _format_desc(_get_ci(opts, "desc", "")) or "_(No description yet â€” add `desc=` to this item in item.lst.)_"


            price   = _get_ci(opts, "price", "")
            weight  = _get_ci(opts, "weight", "")
            itype   = _get_ci(opts, "type", "")
            size    = _get_ci(opts, "size", "")
            hands   = _get_ci(opts, "hands", "")
            stat    = _get_ci(opts, "stat", "")
            dmg     = _get_ci(opts, "dmg", "") or _get_ci(opts, "damage", "")
            ac_base = _get_ci(opts, "AC", "") or _get_ci(opts, "ac", "")
            armor2  = _get_ci(opts, "armor2", "")
            short_r = _get_ci(opts, "short", "")
            med_r   = _get_ci(opts, "med", "") or _get_ci(opts, "medium", "")
            long_r  = _get_ci(opts, "long", "")


            armor2_truthy = str(armor2).strip().lower().replace("$","") in {"1","true","yes"}

            embed = nextcord.Embed(
                title=sec,
                description=desc,
                color=random.randint(0, 0xFFFFFF)
            )

            cat_raw = (_get_ci(opts, "cat", "") or "").strip().lower()
            if cat_raw:
                if cat_raw in {"auto", "automated"}:
                    category_text = "Automated"
                elif cat_raw in {"manual", "man", "roleplay", "rp"}:
                    category_text = "Manual (roleplay)"
                else:
                    category_text = cat_raw.title()
                embed.add_field(name="Category", value=category_text, inline=True)


            def _fmt_num(x):
                if x == "" or x is None: return "â€”"
                try:
                    f = float(str(x))
                    return str(int(f)) if f.is_integer() else f"{f}"
                except:
                    return str(x)

            embed.add_field(name="Price", value=f"{_fmt_num(price)} gp", inline=True)
            embed.add_field(name="Weight", value=f"{_fmt_num(weight)}", inline=True)


            basics = []
            if itype: basics.append(f"Type: {itype}")
            if size:  basics.append(f"Size: {size.upper()}")
            if hands: basics.append(f"Hands: {hands}")
            if basics:
                embed.add_field(name="Basics", value="\n".join(basics), inline=True)


            if ac_base or armor2_truthy:
                if armor2_truthy:

                    bonus_txt = f"+{ac_base}" if str(ac_base).strip() not in {"", "0"} else "+1"
                    embed.add_field(name="Defense", value=f"Shield: {bonus_txt} AC", inline=False)
                elif ac_base:
                    embed.add_field(name="Defense", value=f"Armor AC: **{ac_base}**", inline=False)


            if dmg or stat or short_r or med_r or long_r:
                lines = []
                if dmg:  lines.append(f"Damage: {dmg}")
                if stat: lines.append(f"Attack Stat: {stat.upper()}")
                rng_bits = [b for b in (short_r, med_r, long_r) if str(b).strip() != ""]
                if rng_bits:

                    s = short_r or "â€”"; m = med_r or "â€”"; l = long_r or "â€”"
                    lines.append(f"Range (S/M/L): {s}/{m}/{l}")
                if lines:
                    embed.add_field(name="Weapon Stats", value="\n".join(lines), inline=False)

            await ctx.send(embed=embed)
            return


        sec_spell = sec

        raw_desc = self._spell_cp.get(sec_spell, "desc", fallback="").strip()\
                   if self._spell_cp.has_option(sec_spell, "desc") else ""
        desc = _format_desc(raw_desc) or "_(No description yet â€” add `desc=` to this spell in spell.lst.)_"


        class_lines = []
        levels_found = {}
        for k, v in self._spell_cp.items(sec_spell):
            kl = k.strip().lower()
            if kl in self._CLASS_ABBR:
                try:
                    lvl = int(str(v).strip())
                    levels_found[self._CLASS_ABBR[kl]] = lvl
                except ValueError:
                    pass
        if levels_found:
            for cls in sorted(levels_found.keys()):
                lvl = levels_found[cls]
                class_lines.append(f"{cls} â€” {'Cantrip' if lvl==0 else f'Level {lvl}'}")
        else:

            appears = []
            sneed = _norm(sec_spell)
            for cls, by_lvl in self._spells_by_class.items():
                for lvl, names in by_lvl.items():
                    if any(_norm(n) == sneed for n in names):
                        appears.append((cls, lvl))
            appears.sort(key=lambda t: (t[0], t[1]))
            if appears:
                class_lines = [f"{cls} â€” {'Cantrip' if lvl==0 else f'Level {lvl}'}" for cls, lvl in appears]


        range_raw = self._spell_cp.get(sec_spell, "range", fallback="").strip()\
                    if self._spell_cp.has_option(sec_spell, "range") else ""
        inc_raw = ""
        for key in ("rngeperlvl","rngperlvl","rangeperlvl","rangeperlevel"):
            if self._spell_cp.has_option(sec_spell, key):
                inc_raw = self._spell_cp.get(sec_spell, key, fallback="").strip()
                break
        pretty_range = self._pretty_range(range_raw, inc_raw) if range_raw else ""

        duration_raw = self._spell_cp.get(sec_spell, "duration", fallback="").strip()\
                       if self._spell_cp.has_option(sec_spell, "duration") else ""
        pretty_duration = self._pretty_duration(duration_raw) if duration_raw else ""


        handlers = getattr(self, "_spell_handlers", {}) or {}
        is_automated = _norm(sec_spell) in handlers
        category_text = "Automated" if is_automated else "Manual (roleplay)"

        embed = nextcord.Embed(title=sec_spell, description=desc, color=random.randint(0, 0xFFFFFF))


        embed.add_field(name="Category", value=category_text, inline=True)

        if class_lines:
            embed.add_field(name="Class & Level", value="\n".join(class_lines), inline=False)
        if pretty_range:
            embed.add_field(name="Range", value=pretty_range, inline=True)
        if pretty_duration:
            embed.add_field(name="Duration", value=pretty_duration, inline=True)

        await ctx.send(embed=embed)


    async def _choose_prepared_to_replace(self, ctx, author, lvl: int, cur: list[str], new_name: str) -> int | None:
        """
        Show a paginated picker of current prepared spells (for this level).
        Returns the INDEX in `cur` to replace, or None if cancelled/timeout.
        Note: duplicates are fine; we replace the first occurrence of the chosen name.
        """
        if not cur:
            await ctx.send(f"âŒ There are no prepared Level {lvl} spells to replace.")
            return None


        options = [s for s in cur]
        query = f"replace L{lvl} with {new_name}"
        chosen = await self._prompt_paginated_selection(ctx, author, query, options, timeout_sec=10.0)
        if not chosen:
            await ctx.send("Selection timed out or was cancelled.")
            return None


        try:
            return cur.index(chosen)
        except ValueError:
            chosen_lc = chosen.lower()
            for i, s in enumerate(cur):
                if s.lower() == chosen_lc:
                    return i
            return None

    @commands.command(name="prepare", aliases=["prep"])
    async def prepare_spell(self, ctx, *, spell_spec: str):
        """
        Prepare a spell.

        Modular (default): prepare a unique list up to your Level-N slots; duplicates arenâ€™t needed.
        Classic Vancian (if HR 'classic_vancian_prep' is ON): you may prepare duplicates (e.g., Sleep x2).

        Usage:
          !prepare Sleep
          !prepare "Magic Missile"
          !hr on classic_vancian_prep   # to allow Sleep x2, duplicates
        """


        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return

        info_class = get_compat(cfg, "info", "class", fallback="")
        profile = self._caster_profile(info_class, ctx.channel)
        if not profile:
            await ctx.send(f"âŒ **{char_name}** ({info_class or 'â€”'}) is not a spellcaster.")
            return
        level = getint_compat(cfg, "cur", "level", fallback=1)


        classic = _hr_enabled_anywhere(ctx.channel, "classic_vancian_prep", default=False)


        mult = 1
        m = re.fullmatch(r"\s*(.+?)\s+(?:x|Ã—)?(\d+)\s*$", spell_spec, flags=re.I)
        spell_name_in = spell_spec.strip()
        if m:
            spell_name_in = m.group(1).strip()
            try:
                mult = max(1, int(m.group(2)))
            except Exception:
                mult = 1


        lvl, canon = self._find_spell_level(profile["list_class"], spell_name_in)
        if lvl is None:
            await ctx.send(f"âŒ **{spell_name_in}** isnâ€™t on the **{profile['list_class']}** list.")
            return


        totals = _slots_for_class_level(self._class_cp, profile["slots_class"], level)
        totals = self._with_l0(cfg, totals, info_class, level, channel=ctx.channel)
        if _ensure_slots_for(cfg, totals):
            write_cfg(path, cfg)
        total_slots = int(totals.get(lvl, 0))


        if profile["book_based"]:
            book = _read_per_level_list(cfg, "spellbook")
            known = set(book.get(lvl, []))
            if canon not in known:
                await ctx.send(f"âŒ You donâ€™t have **{canon}** (L{lvl}) in your spellbook.")
                return
        else:
            if lvl >= 1 and total_slots <= 0:
                await ctx.send(f"âŒ You canâ€™t cast Level {lvl} spells yet.")
                return


        prepared = _read_per_level_list(cfg, "prepared")
        cur = list(prepared.get(lvl, []) or [])

        if classic:

            free = max(0, total_slots - len(cur))
            if free <= 0:
                await ctx.send(f"âŒ No Level {lvl} slots free to prepare another spell.")
                return
            to_add = min(mult, free)
            cur_new = cur + ([canon] * to_add)

            prepared[lvl] = cur_new
            _write_per_level_list(cfg, "prepared", prepared)
            write_cfg(path, cfg)
            note = (f" (requested x{mult}, added x{to_add} due to slot limit)"
                    if mult > to_add else (f" (x{mult})" if mult > 1 else ""))
            await ctx.send(f"âœ… Prepared **{canon}** (L{lvl}) for **{char_name}**{note}.")
            return

        else:


            seen = set()
            cur_unique = [s for s in cur if not (s in seen or seen.add(s))]

            if canon in cur_unique:

                extra = f" _(modular prep: duplicates not needed; 'x{mult}' ignored.)_" if mult > 1 else ""
                await ctx.send(f"âŒ **{canon}** (L{lvl}) is already prepared.{extra}")
                return

            if len(cur_unique) < total_slots:
                cur_new = cur_unique + [canon]
            else:

                idx = await self._choose_prepared_to_replace(ctx, ctx.author, lvl, cur_unique, canon)
                if idx is None:
                    await ctx.send("âŒ No changes made.")
                    return
                cur_new = list(cur_unique)
                cur_new[idx] = canon


            if len(cur_new) > total_slots:
                await ctx.send(f"âš ï¸ Internal guard: change would exceed L{lvl} prepared limit. Aborting.")
                return


            cur_new.sort()
            prepared[lvl] = cur_new
            _write_per_level_list(cfg, "prepared", prepared)
            write_cfg(path, cfg)

            extra = f" _(modular prep: 'x{mult}' ignored.)_" if mult > 1 else ""
            await ctx.send(f"âœ… Prepared **{canon}** (L{lvl}) for **{char_name}**{extra}.")
            return

    @commands.command(name="unprepare")
    async def unprepare_spell(self, ctx, *, spell_spec: str):
        """
        Remove prepared instances of a spell.
        Usage:
          !unprepare Sleep
          !unprepare Sleep x2
          !unprepare Sleep all
        Removes from the levels where itâ€™s currently prepared (usually just one).
        """

        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return


        n = 1
        s = spell_spec.strip()
        if re.search(r"\ball\b", s, flags=re.I):
            n = 10**6
            spell_name_in = re.sub(r"\ball\b", "", s, flags=re.I).strip()
        else:
            m = re.fullmatch(r"\s*(.+?)\s+x?(\d+)\s*$", s, flags=re.I)
            if m:
                spell_name_in = m.group(1).strip()
                try:
                    n = max(1, int(m.group(2)))
                except Exception:
                    n = 1
            else:
                spell_name_in = s

        prepared = _read_per_level_list(cfg, "prepared")
        removed, lvl_found = self._prepared_remove_n(prepared, spell_name_in, n)

        if removed <= 0:
            await ctx.send(f"â„¹ï¸ **{spell_name_in}** isnâ€™t currently prepared.")
            return

        _write_per_level_list(cfg, "prepared", prepared)
        write_cfg(path, cfg)

        lvl_txt = "" if lvl_found < 0 else f" (L{lvl_found})"
        if n >= 10**6:
            await ctx.send(f"âœ… Unprepared **all** instances of **{spell_name_in}**{lvl_txt} for **{char_name}**.")
        elif removed == 1:
            await ctx.send(f"âœ… Unprepared **{spell_name_in}**{lvl_txt} for **{char_name}**.")
        else:
            await ctx.send(f"âœ… Unprepared **{spell_name_in}** Ã—{removed}{lvl_txt} for **{char_name}**.")

    @commands.command(name="lr")
    async def long_rest(self, ctx):
        """
        Long rest:
          â€¢ Everyone: restore 1 HP (cannot exceed effective cap if negative-HP pool is present).
          â€¢ Everyone: restore 1 CON point per day (if any temp CON loss). If this is the final
            point of a multi-point loss, make a Save vs Death (no adjustments) to recover it;
            on failure, that last point becomes permanent. (No save needed if you only ever lost 1.)
          â€¢ Spellcasters: restore slots; for each Negative Level keep one highest-level slot spent, working down.
            L0 (cantrips) are unaffected. Prepared lists are NOT cleared.
        """


        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return

        info_class = get_compat(cfg, "info", "class", fallback="")
        profile = self._caster_profile(info_class, ctx.channel)


        old_hp   = getint_compat(cfg, "cur", "hp", fallback=0)
        max_hp   = getint_compat(cfg, "max", "hp", fallback=old_hp)
        neg_pool = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
        eff_cap  = max(0, max_hp - max(0, neg_pool))
        heal_amt = 1 if old_hp < eff_cap else 0
        new_hp   = min(eff_cap, old_hp + heal_amt)
        if not cfg.has_section("cur"): cfg.add_section("cur")
        cfg["cur"]["hp"] = str(new_hp)

        cfg["cur"]["loh_used"] = "0"


        con_msg = None

        con_msg, con_hp_delta = self._restore_one_con_point(
            cfg,
            require_save_for_final=True,
            owner_for_save_cfg=cfg
        )


        if con_hp_delta:

            max_hp   = getint_compat(cfg, "max", "hp", fallback=new_hp)
            neg_pool = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
            eff_cap  = max(0, max_hp - max(0, neg_pool))
            cur_hp   = getint_compat(cfg, "cur", "hp", fallback=new_hp)
            if cur_hp > eff_cap:
                cfg["cur"]["hp"] = str(eff_cap)
                new_hp = eff_cap
            else:
                new_hp = cur_hp


        level = getint_compat(cfg, "cur", "level", fallback=1)
        neg_levels = getint_compat(cfg, "cur", "neg_levels", fallback=0)

        lines = []
        desc_parts = []
        if profile:
            totals = _slots_for_class_level(self._class_cp, profile["slots_class"], level)
            totals = self._with_l0(cfg, totals, info_class, level, channel=ctx.channel)
            _ensure_slots_for(cfg, totals)

            spent = {lvl: 0 for lvl in totals}
            locks_applied_by_level = {}
            locks_remaining = max(0, int(neg_levels))

            if locks_remaining > 0:
                total_lockable = sum(v for L, v in totals.items() if L > 0 and v > 0)
                locks_to_apply = min(locks_remaining, total_lockable)
                for L in sorted([x for x in totals.keys() if x > 0], reverse=True):
                    if locks_to_apply <= 0: break
                    have = int(totals.get(L, 0))
                    if have <= 0: continue
                    take = min(have, locks_to_apply)
                    spent[L] = take
                    locks_applied_by_level[L] = take
                    locks_to_apply -= take
                locks_remaining_after = locks_remaining - sum(locks_applied_by_level.values())
            else:
                locks_remaining_after = 0

            if not cfg.has_section("slots"): cfg.add_section("slots")
            for lvl in totals.keys():
                cfg.set("slots", f"l{lvl}_spent", str(spent.get(lvl, 0)))


            for lvl in sorted(totals.keys()):
                if totals[lvl] <= 0: continue
                lines.append(f"**L{lvl}**  {_bubble_line(totals[lvl], spent.get(lvl, 0))}  ({totals[lvl]} slot{'s' if totals[lvl]!=1 else ''})")

            desc_parts.append("You may change prepared spells now!")
            if neg_levels > 0:
                desc_parts.insert(0, f"All spell slots restored **except** for **{neg_levels}** slot{'s' if neg_levels != 1 else ''} locked by Negative Levels.")
                if locks_applied_by_level:
                    pieces = [f"L{L}Ã—{n}" for L, n in sorted(locks_applied_by_level.items(), reverse=True)]
                    desc_parts.append("Locked this rest: " + ", ".join(pieces))
                if locks_remaining_after > 0:
                    desc_parts.append(f"(Note: {locks_remaining_after} Negative Level{'s' if locks_remaining_after != 1 else ''} had no remaining slots to lock.)")
                desc_parts.append("L0 (cantrips) are unaffected.")


        used_wcasts = []
        try:
            if cfg.has_section("wcast"):
                for opt, val in cfg.items("wcast"):

                    if "." in opt:
                        item_norm, alias_key = opt.split(".", 1)
                        meta = _WEAPON_SPELLS.get(alias_key)
                        if meta and int(meta.get("per_day", 0) or 0) > 0:
                            used_wcasts.append((item_norm, alias_key))
        except Exception:
            used_wcasts = []


        _weapon_reset_uses_on_long_rest(cfg)
        write_cfg(path, cfg)

        def _reset_item_daily_counters(cfg) -> list[str]:
            """
            Reset per-day/per-rest item counters. Returns list of keys that were reset.
            We reset any [item_daily] key that ends with:
              - _used (e.g., hornofdoom_used)
              - _uses (e.g., trueseeing_uses)
              - _rounds_used (e.g., speed_rounds_used)
            """
            reset = []
            if not cfg.has_section("item_daily"):
                return reset
            for k, v in list(cfg.items("item_daily")):
                kl = k.lower()
                if kl.endswith("_used") or kl.endswith("_uses") or kl.endswith("_rounds_used"):
                    if str(v).strip() != "0":
                        cfg.set("item_daily", k, "0")
                        reset.append(k)
            return reset


        
        if not cfg.has_section("item_daily"):
            cfg.add_section("item_daily")

        
        resets = _reset_item_daily_counters(cfg)

        write_cfg(path, cfg)  

        if resets:
            lines.append("â€¢ **Magic Items**: per-rest counters **refreshed**.")



        write_cfg(path, cfg)


        embed = nextcord.Embed(
            title=f"{char_name} â€” Long Rest",
            description="\n".join(desc_parts) if desc_parts else "Rest complete.",
            color=nextcord.Color.green()
        )


        def _norm_name(n: str) -> str:
            return "".join(ch.lower() for ch in str(n) if ch.isalnum())

        norm_to_display = {}
        for nm in _iter_equipped_item_names(cfg):
            norm_to_display[_norm_name(nm)] = nm


        recharged_lines = []
        for item_norm, alias_key in used_wcasts:
            meta = _WEAPON_SPELLS.get(alias_key, {})
            per_day = int(meta.get("per_day", 0) or 0)
            if per_day <= 0:
                continue


            list_class = meta.get("list_class", "Magic-User")
            _lvl, canon = self._find_spell_level(list_class, alias_key)
            spell_label = canon or alias_key

            display_item = norm_to_display.get(item_norm, item_norm)
            uses_txt = f"{per_day}/day" if per_day != 1 else "1/day"
            recharged_lines.append(f"ðŸ—¡ï¸ **{display_item}** â€” {spell_label} refreshed ({uses_txt})")

        if recharged_lines:
            embed.add_field(
                name="Item Powers",
                value="Refreshed on long rest:\n" + "\n".join(recharged_lines),
                inline=False
            )


        hp_line = f"{old_hp} â†’ **{new_hp}** / {getint_compat(cfg,'max','hp',fallback=new_hp)}"
        if neg_pool > 0:
            hp_line += f"  (cap {eff_cap})"

        if con_hp_delta:
            add_tail += f"  â€¢  (max HP {'+' if con_hp_delta>0 else ''}{con_hp_delta} from CON)"
        embed.add_field(name="HP", value=hp_line, inline=False)


        if con_msg:
            cur_con, temp, perm, peak, base = self._get_con_state(cfg)
            embed.add_field(
                name="Constitution",
                value=f"{con_msg}\nCurrent CON: **{cur_con}**  â€¢  Temp loss: {temp}  â€¢  Permanent loss: {perm}",
                inline=False
            )

        if lines:
            embed.add_field(name="Slots", value="\n".join(lines), inline=False)
            embed.set_footer(text="Legend: â— = available slot, â—‹ = spent slot")

        await self._attach_char_identity(embed, cfg, ctx)
        await ctx.send(embed=embed)

    @commands.command(name="ss", aliases=["slot", "slots"])
    async def adjust_spell_slots(self, ctx, *args):
        """
        Manually adjust REMAINING spell slots for your ACTIVE spellcaster.

        Usage:
          !ss 1 -1     â†’ spend one 1st-level slot
          !ss 0 +3     â†’ regain 3 cantrip slots
          !ss 1 0      â†’ set remaining 1st-level slots to 0
          !ss 2 =2     â†’ set remaining 2nd-level slots to 2
          !ss 3 max    â†’ set remaining 3rd-level slots to full

        Notes:
          â€¢ This changes *remaining* slots (via l{n}_spent), not your total capacity.
          â€¢ After the change, your regular !sb view is shown (with bubbles).
        """


        if len(args) < 2:
            await ctx.send("Usage: `!ss <level 0-7> <+N|-N|N|=N|max>`")
            return

        lvl_raw, val_raw = args[0], args[1]
        try:
            lvl = int(str(lvl_raw))
            if not (0 <= lvl <= 7):
                raise ValueError
        except ValueError:
            await ctx.send("âŒ Level must be an integer 0â€“7 (e.g., `!ss 1 -1`).")
            return


        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return

        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return

        info_class = get_compat(cfg, "info", "class", fallback="")
        profile = self._caster_profile(info_class, ctx.channel)
        if not profile:
            await ctx.send(f"âŒ **{char_name}** ({info_class or 'â€”'}) is not a spellcaster.")
            return

        level_char = getint_compat(cfg, "cur", "level", fallback=1)


        totals = _slots_for_class_level(self._class_cp, profile["slots_class"], level_char)
        totals = self._with_l0(cfg, totals, info_class, level_char, channel=ctx.channel)
        if _ensure_slots_for(cfg, totals):
            write_cfg(path, cfg)

        total = int(totals.get(lvl, 0))
        spent_key = f"l{lvl}_spent"
        spent = max(0, getint_compat(cfg, "slots", spent_key, fallback=0))
        remaining = max(0, total - spent)


        val = val_raw.strip().lower()
        new_remaining = remaining

        if val in {"max", "full"}:
            new_remaining = total
        elif re.fullmatch(r"[+-]\s*\d+", val):
            try:
                delta = int(val.replace(" ", ""))
            except ValueError:
                delta = 0
            new_remaining = remaining + delta
        elif re.fullmatch(r"=\s*\d+", val):
            try:
                new_remaining = int(val.split("=", 1)[1])
            except ValueError:
                await ctx.send("âŒ Couldnâ€™t parse that number. Try `+N`, `-N`, `N`, `=N`, or `max`.")
                return
        elif re.fullmatch(r"\d+", val):
            new_remaining = int(val)
        else:
            await ctx.send("âŒ Usage: `!ss <level 0-7> <+N|-N|N|=N|max>`")
            return


        new_remaining = max(0, min(total, new_remaining))
        new_spent = total - new_remaining


        _ensure_section(cfg, "slots")
        cfg.set("slots", spent_key, str(new_spent))
        write_cfg(path, cfg)


        delta = new_remaining - remaining
        chg = f" ({'+' if delta >= 0 else ''}{delta})" if delta != 0 else ""
        bubbles = _bubble_line(total, new_spent) if total > 0 else "â€”"
        lvl_label = f"L{lvl}"

        await ctx.send(f"ðŸ”® **{char_name}** {lvl_label} slots: {bubbles}{chg}")

    def _class_to_abbr(self) -> dict[str, str]:
        """
        Reverse of _CLASS_ABBR plus a few helpful extras.
        Produces: {"Cleric":"cle", "Magic-User":"mu", ... "Magethief":"mt", "Fightermage":"fm"}
        """
        base = {v: k for (k, v) in self._CLASS_ABBR.items()}

        base.setdefault("Magethief", "mt")
        base.setdefault("Fightermage", "fm")
        base.setdefault("Paladin", "pa")
        return base

    @commands.command(name="spellsync")
    @commands.has_permissions(manage_guild=True)
    async def sync_spell_class_tags(self, ctx):
        """
        Admin/GM: scan class lists in spell.lst and ensure each spell section has the proper class=level tags.
        Example: if FalseVision is on Magethief L6, writes [FalseVision] mt=6.
        Creates a backup: spell.lst.bak
        """

        by_class, cp = _load_spell_list()
        class_to_abbr = self._class_to_abbr()


        def _norm(s: str) -> str:
            return "".join(ch.lower() for ch in str(s) if ch.isalnum())

        norm_to_sec = { _norm(sec): sec for sec in cp.sections() }

        updated_pairs = 0
        added_sections = 0
        classes_processed = []
        classes_skipped = []

        for cls_name, levels in sorted(by_class.items()):
            abbr = class_to_abbr.get(cls_name)
            if not abbr:
                classes_skipped.append(cls_name)
                continue
            classes_processed.append(f"{cls_name} ({abbr})")

            for lvl, names in levels.items():
                for name in names:
                    key = _norm(name)

                    if key in norm_to_sec:
                        sec = norm_to_sec[key]
                    else:
                        sec = name
                        try:
                            cp.add_section(sec)
                            norm_to_sec[key] = sec
                            added_sections += 1
                        except configparser.DuplicateSectionError:

                            sec = [s for s in cp.sections() if _norm(s) == key][0]


                    cur = cp.get(sec, abbr, fallback=None)
                    if cur is None or str(cur).strip() != str(lvl):
                        cp.set(sec, abbr, str(lvl))
                        updated_pairs += 1


        try:
            shutil.copyfile("spell.lst", "spell.lst.bak")
        except Exception:
            pass
        with open("spell.lst", "w", encoding="utf-8") as f:
            cp.write(f)


        self._spells_by_class, self._spell_cp = _load_spell_list()


        processed_txt = ", ".join(classes_processed) if classes_processed else "â€”"
        skipped_txt = ", ".join(classes_skipped) if classes_skipped else "â€”"
        await ctx.send(
            f"âœ… **Spell list synced.**\n"
            f"â€¢ Updated/added class tags: **{updated_pairs}**\n"
            f"â€¢ New spell sections created: **{added_sections}**\n"
            f"â€¢ Classes processed: {processed_txt}\n"
            f"â€¢ Classes without an abbreviation (skipped): {skipped_txt}\n"
            f"*(Backup written to `spell.lst.bak`.)*"
        )



    def _is_known_duration(self, raw: str) -> tuple[bool, str]:
        """
        Returns (known, pretty). Known if _pretty_duration returns a non-empty string.
        """
        pretty = self._pretty_duration(raw)
        return (bool(pretty), pretty)

    @staticmethod
    def _scan_effects(desc: str) -> dict:
        """
        Very lightweight effect scan:
          - save: looks for 'save' / 'saving throw' (+ category hint if nearby)
          - damage: XdY (+Z) that mentions 'damage' near it or phrases like 'deals XdY'
          - heal:  words like heal/cure/restore/regenerate (+ dice if present)
        Returns a dict with booleans and small detail lists to show in the report.
        """
        text = (desc or "").strip()
        low  = text.lower()


        has_save = False
        save_hint = None
        if re.search(r'\bsav(?:e|ing throw)s?\b', low):
            has_save = True
            m = re.search(
                r'(?:sav(?:e|ing throw)s?\s*(?:vs\.?|against)?\s*)([A-Za-z/ ]{1,30})',
                low
            )
            if m:
                save_hint = m.group(1).strip().rstrip('.,;)').replace('\n',' ')

                for canon in ["death/poison","wands","paralysis/petrification","breath","spells","paralysis","petrification","poison","death","breath weapon"]:
                    if canon in save_hint:
                        save_hint = canon
                        break


        dice_pat = r'\b\d+d\d+(?:\s*[+\-â€“]\s*\d+)?(?:\s*(?:/|per)\s*level)?\b'
        dice_iter = list(re.finditer(dice_pat, low))


        near_damage = any(
            ("damage" in low[max(0,m.start()-24): m.end()+24])
            for m in dice_iter
        ) or bool(re.search(r'\bdeal(?:s|t)?\s+' + dice_pat, low))
        has_damage = near_damage or "damage" in low

        dmg_tokens = []
        if has_damage:
            for m in dice_iter:
                if "damage" in low[max(0,m.start()-24): m.end()+24]:
                    dmg_tokens.append(m.group(0))
                if len(dmg_tokens) >= 2:
                    break


        heal_words = bool(re.search(r'\bheal(?:ing)?\b|\bcure\b|\brestor\w*\b|\bregenerat\w*\b', low))
        has_heal = heal_words
        heal_tokens = []
        if has_heal:
            for m in dice_iter:

                heal_tokens.append(m.group(0))
                if len(heal_tokens) >= 2:
                    break

        return {
            "save": has_save,
            "save_hint": save_hint,
            "damage": has_damage,
            "damage_tokens": dmg_tokens,
            "heal": has_heal,
            "heal_tokens": heal_tokens,
        }

    async def _send_paged_list(self, ctx, title: str, lines: list[str], *, color=0x2b6cb0, per_page_chars=3500):
        """
        Split long reports safely across multiple embeds.
        """
        if not lines:
            embed = nextcord.Embed(title=title, description="_None_", color=color)
            await ctx.send(embed=embed)
            return
        page, acc, idx = [], 0, 1
        for line in lines:
            ln = line.rstrip()
            if acc + len(ln) + 1 > per_page_chars or len(page) >= 40:
                embed = nextcord.Embed(title=f"{title} (page {idx})", description="\n".join(page), color=color)
                await ctx.send(embed=embed)
                page, acc, idx = [], 0, idx + 1
            page.append(ln)
            acc += len(ln) + 1
        if page:
            embed = nextcord.Embed(title=f"{title}" + ("" if idx == 1 else f" (page {idx})"),
                                   description="\n".join(page), color=color)
            await ctx.send(embed=embed)



    @commands.command(name="spellscan")
    @commands.has_permissions(manage_guild=True)
    async def spellscan(self, ctx):
        """
        Scan spell.lst for:
          â€¢ Unrecognized duration codes (using the same rules as !info)
          â€¢ Spells that likely need !cast handling (save / damage / heal)
        Outputs are paged across embeds to avoid 6000-char limits.
        """
        unknown_duration_lines = []
        flagged_effect_lines   = []


        for sec in self._spell_cp.sections():

            if sec.startswith("["):
                continue


            raw_dur = self._spell_cp.get(sec, "duration", fallback="").strip()\
                      if self._spell_cp.has_option(sec, "duration") else ""
            known, pretty = self._is_known_duration(raw_dur)
            if raw_dur and not known:
                unknown_duration_lines.append(f"â€¢ **{sec}** â€” `duration={raw_dur}`")


            desc = self._spell_cp.get(sec, "desc", fallback="")
            fx = self._scan_effects(desc)

            if fx["save"] or fx["damage"] or fx["heal"]:
                tags = []
                if fx["save"]:
                    tags.append("save" + (f" [{fx['save_hint']}]" if fx["save_hint"] else ""))
                if fx["damage"]:
                    if fx["damage_tokens"]:
                        tags.append("damage " + "[" + ", ".join(fx["damage_tokens"]) + "]")
                    else:
                        tags.append("damage")
                if fx["heal"]:
                    if fx["heal_tokens"]:
                        tags.append("heal " + "[" + ", ".join(fx["heal_tokens"]) + "]")
                    else:
                        tags.append("heal")

                tail = f" â€” {', '.join(tags)}"

                if raw_dur and known and pretty:
                    tail += f" â€¢ duration: *{pretty}*"
                elif raw_dur and not known:
                    tail += f" â€¢ duration: `? {raw_dur}`"

                flagged_effect_lines.append(f"â€¢ **{sec}**{tail}")


        await self._send_paged_list(ctx, "Spellscan â€” Unrecognized Duration Codes", unknown_duration_lines, color=0xc53030)
        await self._send_paged_list(ctx, "Spellscan â€” Spells Needing !cast Logic (save/damage/heal)", flagged_effect_lines, color=0x2f855a)


    def _parse_cast_expr(self, expr: str):
        """
        Returns (spell_name, targets:list[str], ignore_slots:bool, rest_raw:str, targets_field:str)

        Flags handled here (consumed, not passed as targets):
          -i / -ignore / -ignoreslots
          -w / -wand / -weapon  (treated same as -i: free casting / item casting)
          -sc / -scroll / -scrolls  (scroll mode, also free casting)
          -t / -target <...>  (explicit targets)
          -s / -sid / -scrollid <id>  (scroll selector; only consumed if next token is a scroll id)
        """
        s = (expr or "").strip()
        spell = ""
        rest = ""
        m = re.match(r'^\s*(?:"([^"]+)"|\'([^\']+)\'|(\S+))(?:\s+(.*))?$', s)
        if m:
            spell = (m.group(1) or m.group(2) or m.group(3) or "").strip()
            rest  = (m.group(4) or "").strip()
        else:
            spell = s
            rest  = ""

        tokens = [t for t in rest.split() if t]

        ignore = False
        targets: list[str] = []
        i = 0
        while i < len(tokens):
            tk = tokens[i].lower()

            # ignore slot / free cast flags
            if tk in ("-i", "-ignore", "-ignoreslots", "-w", "-wand", "-weapon"):
                ignore = True
                i += 1
                continue

            # scroll mode flags also imply ignore-slots
            if tk in ("-sc", "-scroll", "-scrolls"):
                ignore = True
                i += 1
                continue

            # explicit target list
            if tk in ("-s", "-sid", "-scrollid", "-scroll"):
                # Scroll-id selector. Always consume so it never becomes a target token.
                # (Validation/parsing of the id happens later in the scroll handler.)
                ignore = True
                if i + 1 < len(tokens) and not str(tokens[i + 1]).startswith("-"):
                    i += 2
                else:
                    i += 1
                continue

            # normal positional args (targets / spell args)
            targets.append(tokens[i])
            i += 1

        def _pretty_target_name(raw: str) -> str:
            disp, _ = self._resolve_char_ci(raw)
            return (disp or (raw[:1].upper() + raw[1:]))

        targets_field = ", ".join(_pretty_target_name(t) for t in targets) or "â€”"
        return spell, targets, ignore, rest, targets_field



    @staticmethod
    def _dec_timer(cfg_b, chan_id: str, slot: str, key: str, remove_fields: tuple[str, ...] = ()):
        """Decrement <slot>.<key> by 1; if it hits 0, remove it and any extra fields given."""
        try:
            left = cfg_b.getint(chan_id, f"{slot}.{key}", fallback=0)
        except Exception:
            left = 0
        if left > 0:
            left -= 1
            if left <= 0:

                if cfg_b.has_option(chan_id, f"{slot}.{key}"):
                    cfg_b.remove_option(chan_id, f"{slot}.{key}")

                for k in remove_fields:
                    if cfg_b.has_option(chan_id, f"{slot}.{k}"):
                        cfg_b.remove_option(chan_id, f"{slot}.{k}")
            else:
                cfg_b.set(chan_id, f"{slot}.{key}", str(left))

    @staticmethod
    def _two_letter_code_from_name(name: str, alias_key: str) -> str:
        """
        2-letter code:
          â€¢ Multiword: initials (DetectEvil â†’ DE, ProtectionFromEvil â†’ PF, Anti-MagicShell â†’ AM)
          â€¢ Single word: first 2 letters (Silence15 â†’ SI)
        Notes:
          â€¢ Hyphens/underscores split words.
          â€¢ Numbers don't count as a word for initials.
        """
        s = (name or "").strip()
        s = re.sub(r"[-_]+", " ", s)


        tokens = []
        for part in re.split(r"\s+", s):
            if not part:
                continue
            tokens.extend(re.split(r"(?<!^)(?=[A-Z0-9])", part))

        alpha_tokens = [t for t in tokens if t and t[0].isalpha()]
        if len(alpha_tokens) >= 2:
            initials = "".join(t[0] for t in alpha_tokens)
            return (initials[:2] or "XX").upper()

        letters_only = "".join(ch for ch in alias_key if ch.isalpha())
        return (letters_only[:2] or alias_key[:2] or "XX").upper()


    def _resolve_partial_target(self, bcfg, chan_id: str, token: str):
        """
        Resolve a target name by exact CI match, then prefix, then substring.
        Also supports "normalized" matching (strip non-alphanum) so WO-5 == "wo5".
        Finally, falls back to a tiny fuzzy match (edit distance) to forgive 1â€“2 typos.
        Returns (resolved_name | None, suggestions_list_if_ambiguous).
        """
        tok = (token or "").strip()
        if not tok:
            return None, []
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            return None, []

        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", str(s).lower())

        tl = tok.lower()
        nt = _norm(tok)

        for n in names:
            if n.lower() == tl or _norm(n) == nt:
                return n, []

        prefix = [n for n in names if n.lower().startswith(tl) or _norm(n).startswith(nt)]
        if len(prefix) == 1:
            return prefix[0], []
        if len(prefix) > 1:
            return None, prefix[:8]

        subs = [n for n in names if (tl in n.lower()) or (nt and nt in _norm(n))]
        if len(subs) == 1:
            return subs[0], []
        if len(subs) > 1:
            return None, subs[:8]

        def _lev(a: str, b: str) -> int:
            if a == b:
                return 0
            la, lb = len(a), len(b)
            if la == 0 or lb == 0:
                return max(la, lb)
            dp = list(range(lb + 1))
            for i in range(1, la + 1):
                prev = dp[0]
                dp[0] = i
                ca = a[i-1]
                for j in range(1, lb + 1):
                    temp = dp[j]
                    cost = 0 if ca == b[j-1] else 1
                    dp[j] = min(dp[j] + 1, dp[j-1] + 1, prev + cost)
                    prev = temp
            return dp[lb]

        scored = []
        for n in names:
            ln = n.lower()
            nn = _norm(n)
            s1 = _lev(tl, ln[:len(tl)]) if ln else 99
            s2 = _lev(nt, nn[:len(nt)]) if nt else 99
            s3 = _lev(tl, ln)
            score = min(s1, s2, s3)
            scored.append((score, n))

        if not scored:
            return None, []

        scored.sort(key=lambda x: (x[0], len(x[1])))
        best = scored[0][0]
        threshold = 1 if len(tl) <= 4 else 2
        if best <= threshold:
            ties = [n for d, n in scored if d == best]
            if len(ties) == 1:
                return ties[0], []
            return None, ties[:8]

        return None, []


    def _spell_target_policy(self, alias_key: str) -> dict:
        """
        Return policy bits for how 'targets' should be treated for a given spell.
        alias_key is normalized: alnum-only, lowercase (e.g., 'animatedead', 'striking').
        Fields:
          resolve_targets: bool  -> run combatant name resolution (WO5, goblin, etc)
          merge_split: bool      -> merge W + O5 -> WO5 token fragments
          fuzzy: bool            -> allow typo-tolerant name matching
        """
        default = {"resolve_targets": True, "merge_split": True, "fuzzy": True}


        custom = {
            "animatedead",
            "reanimation",
            "alterself",
            "polymorphself",
            "corpseservant",
            "conjureelemental",
            "summonspirit",
            "mummify",
            "channelblast",
            "stickstosnakes",
            "produceflamecold",
            "assumeanimalform",
            "restorehealth",
            "callwoodlandbeings",
            "insectplague",
            "creepingdoom",
        }
        if alias_key in custom:
            base = {"resolve_targets": False, "merge_split": True, "fuzzy": False}
            if alias_key == "channelblast":
                base["keep_numbers"] = True
            return base

        return default

    @commands.command(name="cast")
    async def cast_spell(self, ctx, *, expr: str):
        """
        Cast a spell.

        Usage:
          !cast <SpellName> [targets...]

        Flags:
          -i                 Ignore spell slots (free cast)
          -s [id]            Cast from a carried Spell Scroll (SpellScroll@id). No slots.
                             If multiple matching scrolls, pass id from `!scrolls`.
                             Scroll is consumed even if it fizzles.
          -w                 Cast only if an equipped item/weapon/wand can cast it. No slots.
                             Errors if no matching equipped item power is found.

        Examples:
          !cast Fireball
          !cast CureLightWounds bob
          !cast Fireball -s
          !cast Fireball -s 5
          !cast Light -w
        """


        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return

        try:
            bcfgX = _load_battles()
            chanX = str(ctx.channel.id)
            if bcfgX and bcfgX.has_section(chanX):
                namesX, _ = _parse_combatants(bcfgX, chanX)
                keyX  = _find_ci_name(namesX, char_name) or char_name
                slotX = _choose_slot_for_effects(bcfgX, chanX, keyX) if '_choose_slot_for_effects' in globals() else _slot(keyX)
                if bcfgX.getint(chanX, f"{slotX}.gas", fallback=0) > 0:
                    await ctx.send("â›” You cannot cast while in **Gaseous Form**!")
                    return
        except Exception:
            pass
        try:
            bcfgX = _load_battles()
            chanX = str(ctx.channel.id)
            if bcfgX and bcfgX.has_section(chanX):
                namesX, _ = _parse_combatants(bcfgX, chanX)
                keyX  = _find_ci_name(namesX, char_name) or char_name
                slotX = _choose_slot_for_effects(bcfgX, chanX, keyX) if '_choose_slot_for_effects' in globals() else _slot(keyX)
                tree_left = max(
                    bcfgX.getint(chanX, f"{slotX}.tree",    fallback=0),
                    bcfgX.getint(chanX, f"{slotX}.x_tree",  fallback=0),
                )
                if tree_left > 0:
                    await ctx.send("â›” You are in **Tree Form** â€” you canâ€™t cast spells. Use `!conc drop` to dismiss it.")
                    return
        except Exception:
            pass
        try:
            bcfgA = _load_battles()
            chanA = str(ctx.channel.id)
            if bcfgA and bcfgA.has_section(chanA):
                namesA, _ = _parse_combatants(bcfgA, chanA)
                keyA  = _find_ci_name(namesA, char_name) or char_name
                slotA = _choose_slot_for_effects(bcfgA, chanA, keyA) if '_choose_slot_for_effects' in globals() else _slot(keyA)
                if bcfgA.getint(chanA, f"{slotA}.aaf", fallback=0) > 0:
                    await ctx.send("â›” You canâ€™t cast while in **Animal Form**.")
                    return
        except Exception:
            pass

        import shlex

        spell_name_in, targets, ignore_slots, rest_raw, targets_field = self._parse_cast_expr(expr)

        # Parse raw expr so we can detect flags that _parse_cast_expr strips
        try:
            raw_toks = shlex.split(expr or "")
        except Exception:
            raw_toks = (expr or "").split()

        tail = raw_toks[1:] if len(raw_toks) > 1 else []
        scroll_flag = any((t or "").lower() in ("-s", "-sid", "-scrollid", "-scroll", "-sc", "-scrolls") for t in tail)
        weapon_force = any((t or "").lower() in ("-w", "-weapon", "-wand", "-weap", "-wpn") for t in tail)

        # Fix: alias_guess must exist before weapon grant search
        alias_guess = _norm_alias(spell_name_in)

        scroll_cast_level = None
        scroll_list_class = None

        # --- SpellScroll preflight ---
        if scroll_flag:
            sid = None
            for i, t in enumerate(tail):
                if (t or "").lower() in ("-s", "-sid", "-scrollid", "-scroll"):
                    if i + 1 < len(tail):
                        sid = self._scroll_id_from_token(tail[i + 1])
                        break

            pre = await self._precast_spellscroll(ctx, cfg, char_name, spell_name_in, sid)
            if pre is False:
                return

            scroll_cast_level = int(pre["effective_level"])
            scroll_list_class = pre["list_class"]
            ignore_slots = True  # do NOT spend slots on scroll cast


        # ---- flags from rest_raw ----
        rtoks = []
        try:
            rtoks = shlex.split(rest_raw or "")
        except Exception:
            rtoks = (rest_raw or "").split()

        scroll_flag = any((t or "").lower() in ("-sc", "-scroll", "-scrolls", "-s") for t in rtoks)
        weapon_force = any((t or "").lower() in ("-w", "-weapon", "-wpn", "-weap") for t in rtoks)

        # Detect scroll id selector if present
        sid = None
        for j, t in enumerate(rtoks):
            if (t or "").lower() in ("-s", "-scroll", "-sc", "-scrolls") and j + 1 < len(rtoks):
                try:
                    sid_try = self._scroll_id_from_token(rtoks[j + 1])
                except Exception:
                    sid_try = None
                if sid_try:
                    sid = sid_try
                    break

        from_scroll = False
        scroll_list_class = None

        
        info_class = get_compat(cfg, "info", "class", fallback="")
        profile = self._caster_profile(info_class, ctx.channel)

        weapon_grant, weapon_meta = _find_weapon_grant_for_spell(self, cfg, alias_guess)
        if weapon_force:
            if not weapon_grant or not weapon_meta:
                await ctx.send(f"âŒ `-w` was given, but you donâ€™t have an equipped item that can cast **{spell_name_in}**.")
                return

        weapon_casting = bool(weapon_grant and weapon_meta and not weapon_grant.get("exhausted"))

        if weapon_grant and weapon_grant.get("exhausted"):
            await ctx.send(f"â›” **{weapon_grant['item']}**â€™s {alias_guess} power is expended for today. Use `!lr` to refresh.")
            return

        if not profile and not weapon_casting:
            await ctx.send(f"âŒ **{char_name}** ({info_class or 'â€”'}) is not a spellcaster.")
            return

        level = getint_compat(cfg, "cur", "level", fallback=1)

        resolved_prepared = await self._resolve_prepared_spell_from_partial(ctx, cfg, spell_name_in, ctx.author)
        if resolved_prepared:
            spell_name_in = resolved_prepared

        list_class = weapon_meta.get("list_class", "Magic-User") if weapon_casting else (scroll_list_class or profile["list_class"])


        spell_name_in = self._spell_alias_map().get(self._norm(spell_name_in), spell_name_in)

        lvl, canon = self._find_spell_level(list_class, spell_name_in)
        if lvl is None:
            resolved = await self._resolve_spell_from_partial(ctx, list_class, spell_name_in, ctx.author)
            if resolved:
                spell_name_in = resolved
                lvl, canon = self._find_spell_level(list_class, spell_name_in)

        if lvl is None:
            sugg = self._spell_suggestions_for(list_class, spell_name_in)
            msg = f"âŒ **{spell_name_in}** isnâ€™t on the **{list_class}** list."
            if sugg:
                msg += " Did you mean: " + ", ".join(f"`{s}`" for s in sugg)
            await ctx.send(msg)
            return
            

        has_break = False
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                s_me = _resolve_effect_slot(bcfg, chan_id, char_name)
                has_break = bcfg.getint(chan_id, f"{s_me}.x_break", fallback=0) > 0
        except Exception:
            has_break = False


        if not weapon_casting and profile["book_based"] and not has_break and not ignore_slots:
            book = _read_per_level_list(cfg, "spellbook")
            if canon not in set(book.get(lvl, [])):
                await ctx.send(f"âŒ You donâ€™t have **{canon}** (L{lvl}) in your spellbook.")
                return


        if not weapon_casting:
            totals = _slots_for_class_level(self._class_cp, profile["slots_class"], level)
            totals = self._with_l0(cfg, totals, info_class, level, channel=ctx.channel)
            if _ensure_slots_for(cfg, totals):
                write_cfg(path, cfg)
            total = int(totals.get(lvl, 0))
            spent_key = f"l{lvl}_spent"
            spent = getint_compat(cfg, "slots", spent_key, fallback=0)

            if not ignore_slots:
                if total <= 0:
                    await ctx.send(f"âŒ You canâ€™t cast Level {lvl} spells.")
                    return
                if spent >= total:
                    lab = "cantrips" if lvl == 0 else f"L{lvl}"
                    await ctx.send(f"âŒ No available **{lab}** slots.")
                    return
        else:
            totals = {}; total = 0; spent_key = ""; spent = 0; ignore_slots = True

        if weapon_casting:
            cl = weapon_meta.get("caster_level", "wielder")
            effective_level = (level if cl == "wielder" else int(cl))
            level = max(1, int(effective_level))

        alias_key = "".join(ch.lower() for ch in canon if ch.isalnum())
        policy = self._spell_target_policy(alias_key)

        rest_sans_flags = re.sub(r'(?<!\S)(?:-i|-ignore|-ignoreslots)\b', '', rest_raw or '', flags=re.I)
        raw_toks = _extract_targetish_tokens(rest_sans_flags)

        if not raw_toks:
            if targets:
                raw_toks.extend(list(targets))
            if targets_field:
                for t in targets_field:
                    if t not in raw_toks:
                        raw_toks.append(t)

        if raw_toks and policy.get("merge_split", True):
            raw_toks = _merge_split_target_tokens(raw_toks)

        raw_toks = _sanitize_target_tokens(raw_toks)
        if not policy.get("keep_numbers", False):
            raw_toks = [t for t in raw_toks if not re.fullmatch(r"[0-9]+", t)]

        # --- Arcane Dagger: allow range tokens without treating them as targets ---
        range_flags = []
        if alias_key in {"arcanedagger"} and raw_toks:
            kept = []
            for tok in raw_toks:
                k = str(tok).strip().lower()
                if k in ("short", "s"):
                    range_flags.append("short")
                elif k in ("medium", "med", "m"):
                    range_flags.append("medium")
                elif k in ("long", "l"):
                    range_flags.append("long")
                else:
                    kept.append(tok)
            raw_toks = kept

        if policy.get("resolve_targets", True):
            try:
                bcfgR = _load_battles()
                chanR = str(ctx.channel.id)
                if raw_toks and bcfgR and bcfgR.has_section(chanR):
                    resolved = []
                    for tok in raw_toks:
                        name, sugg = self._resolve_partial_target(bcfgR, chanR, tok)
                        if name:
                            resolved.append(name)
                        elif sugg:
                            await ctx.send(
                                "âš ï¸ Ambiguous target `{}` â€” did you mean: {}?"
                                .format(tok, ", ".join(f"`{s}`" for s in sugg))
                            )
                            return
                        else:
                            await ctx.send(
                                f"âš ï¸ Unknown target `{tok}` â€” add them to initiative or use full name."
                            )
                            return
                    targets = resolved
                else:
                    targets = []
            except Exception:
                targets = []
        else:
            targets = raw_toks

        # Re-attach range tokens for Arcane Dagger so effect can read them
        if range_flags:
            targets = list(targets or [])
            targets.extend(range_flags)

        if weapon_casting and weapon_meta.get("force_self") and alias_guess == "light":
            targets = []

        try:
            if policy.get("resolve_targets", True) and targets:
                self._hyp_break_if_targeted(str(ctx.channel.id), list(targets))
        except Exception:
            pass
        try:
            if policy.get("resolve_targets", True) and targets:
                self._conf_mark_if_targeted(str(ctx.channel.id), list(targets), by=char_name)
        except Exception:
            pass

        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                turn_name = bcfg.get(chan_id, "turn", fallback="")
                if char_name in names and char_name == turn_name:
                    try:
                        slot_self = _slot(char_name)
                    except Exception:
                        slot_self = char_name.replace(" ", "_")
                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass

        DISCORD_FIELD_LIMIT = 1024

        def _split_effect_sections(lines):
            for i, l in enumerate(lines):
                if l.strip() == "â€”":
                    return lines[:i], lines[i+1:]
            return lines, []

        def _add_long_field(embed, title, lines, limit=DISCORD_FIELD_LIMIT):
            buf = ""; first = True
            for line in lines:
                line = line.rstrip("\n")
                add = (("\n" if buf else "") + line)
                if len(buf) + len(add) > limit:
                    embed.add_field(name=title if first else f"{title} (cont.)", value=buf, inline=False)
                    buf = line; first = False
                else:
                    buf += add
            if buf:
                embed.add_field(name=title if first else f"{title} (cont.)", value=buf, inline=False)

        needle = _norm(canon)
        sec = None
        if self._spell_cp.has_section(canon):
            sec = canon
        else:
            for s in self._spell_cp.sections():
                if _norm(s) == needle:
                    sec = s; break

        desc = ""; pretty_range = ""; pretty_duration = ""; auto_timer_note = None
        suppress_auto_timer = False

        if sec:
            raw_desc = self._spell_cp.get(sec, "desc", fallback="").strip() if self._spell_cp.has_option(sec, "desc") else ""
            desc = self._format_desc(raw_desc) or "_(No description yet â€” add `desc=` in spell.lst.)_"

            range_raw = self._spell_cp.get(sec, "range", fallback="").strip() if self._spell_cp.has_option(sec, "range") else ""
            inc_raw = ""
            for key in ("rngeperlvl","rngperlvl","rangeperlvl","rangeperlevel"):
                if self._spell_cp.has_option(sec, key):
                    inc_raw = self._spell_cp.get(sec, key, fallback="").strip(); break
            if range_raw:
                pretty_range = self._pretty_range(range_raw, inc_raw) or range_raw

            dur_raw = self._spell_cp.get(sec, "duration", fallback="").strip() if self._spell_cp.has_option(sec, "duration") else ""

            if dur_raw and not suppress_auto_timer and alias_key not in getattr(self, "_auto_timer_blacklist", set()):
                try:
                    rounds_auto = self._duration_to_rounds(dur_raw, level)
                except Exception:
                    rounds_auto = 0

                is_concentration = str(dur_raw).strip().lower().startswith("concentration")
                if not rounds_auto and not is_concentration:
                    norm = (dur_raw or "").strip().lower()
                    norm = (norm
                            .replace("rounds", "rd").replace("round", "rd")
                            .replace("turns", "tr").replace("turn", "tr")
                            .replace("per level", "/level").replace("per lvl", "/level").replace("/lvl", "/level"))
                    m = re.search(r"(\d+)\s*rd\s*/\s*level", norm)
                    if m:
                        rounds_auto = int(m.group(1)) * max(1, int(level or 1))
                    else:
                        m = re.search(r"(\d+)\s*rd\b", norm)
                        if m:
                            rounds_auto = int(m.group(1))
                    if not rounds_auto:
                        m = re.search(r"(\d+)\s*tr\s*/\s*level", norm)
                        if m:
                            rounds_auto = int(m.group(1)) * 60 * max(1, int(level or 1))
                        else:
                            m = re.search(r"(\d+)\s*tr\b", norm)
                            if m:
                                rounds_auto = int(m.group(1)) * 60

                if is_concentration or (rounds_auto and rounds_auto > 0):
                    try:
                        bcfgA = _load_battles()
                        chanA = str(ctx.channel.id)
                        if bcfgA and bcfgA.has_section(chanA):

                            raw_targets = list(targets) if isinstance(targets, (list, tuple)) and targets else [char_name]
                            if alias_key in {"corpseservant","summonspirit"}:
                                raw_targets = [char_name]

                            try:
                                namesA, _scoresA = _parse_combatants(bcfgA, chanA)
                            except Exception:
                                namesA = []

                            def _norm_ci(name: str) -> str:
                                try:
                                    hit = _find_ci_name(namesA, name)
                                    return hit or name
                                except Exception:
                                    return name

                            seen = set(); tlist = []
                            for t in raw_targets:
                                k = _norm_ci(str(t).strip()); key = k.lower()
                                if not k or key in seen: continue
                                seen.add(key); tlist.append(k)

                            base_key = f"x_{alias_key}"
                            code     = self._two_letter_code_from_name(canon, alias_key)
                            emap = {
                                "detectinvisible":"ðŸ”","detectevil":"ðŸ”","detectgood":"ðŸ”","detectmagic":"ðŸ”","holdportal":"ðŸšª",
                                "phantasmalimage":"ðŸŽ­","phantasmalforce":"ðŸŽ­","spectralforce":"ðŸŽ­","advancedillusion":"ðŸŽ­",
                                "programmedillusion":"ðŸŽ­","projectedimage":"ðŸŽ­"
                            }
                            em = emap.get(alias_key, "â±ï¸")

                            display_names = []
                            for tgt in tlist:
                                slotT = _resolve_effect_slot(bcfgA, chanA, tgt)
                                bcfgA.set(chanA, f"{slotT}.{base_key}",          str(int(rounds_auto)))
                                bcfgA.set(chanA, f"{slotT}.{base_key}_code",     code)
                                bcfgA.set(chanA, f"{slotT}.{base_key}_label",    canon)
                                bcfgA.set(chanA, f"{slotT}.{base_key}_emoji",    em)
                                bcfgA.set(chanA, f"{slotT}.{base_key}_by",       char_name)
                                disp = bcfgA.get(chanA, f"{slotT}.disp", fallback=tgt)
                                display_names.append(disp)

                            _save_battles(bcfgA)

                            def _summarize_names(names: list[str], limit: int = 6) -> str:
                                if len(names) <= limit: return ", ".join(names)
                                return ", ".join(names[:limit]) + f", and {len(names)-limit} more"

                            who_txt = _summarize_names(display_names)
                            if rounds_auto > 0:
                                auto_timer_note = f"Started timer **[{code} {int(rounds_auto)}]** on **{who_txt}**."
                            else:
                                auto_timer_note = f"Started **[{code}]** (concentration) on **{who_txt}**."

                            try:
                                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                                if ini and hasattr(ini, "_update_tracker_message"):
                                    await ini._update_tracker_message(ctx, bcfgA, chanA)
                            except Exception:
                                pass
                    except Exception as e:
                        await ctx.send(f"âš ï¸ Auto-timer failed: {type(e).__name__}: {e}")
                        raise

        def _truncate(txt: str, limit: int = 900) -> str:
            return (txt if len(txt) <= limit else (txt[:limit-1] + "â€¦"))

        delta_note = "(ignored)"
        new_spent = spent
        if not ignore_slots:
            new_spent = min(spent + 1, max(total, spent + 1))
            cfg.set("slots", spent_key, str(new_spent))
            write_cfg(path, cfg)
            delta_note = "(-1)"

        bubbles = _bubble_line(total, new_spent) if total > 0 else ""
        level_label = "L0 (Cantrips)" if lvl == 0 else f"L{lvl}"

        title = f"{char_name} casts **{canon}**!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        portrait_url = (
            get_compat(cfg, "info", "portrait", fallback="")
            or get_compat(cfg, "info", "portrait_url", fallback="")
        ).strip()
        if portrait_url:
            try:
                embed.set_thumbnail(url=portrait_url)
            except Exception:
                pass

        facts = []
        if pretty_range:    facts.append(f"**Range:** {pretty_range}")
        if pretty_duration: facts.append(f"**Duration:** {pretty_duration}")
        if facts:
            embed.add_field(name="Spell", value="\n".join(facts), inline=False)
        if weapon_casting:
            src = weapon_grant["item"]
            per_day = int(weapon_meta.get("per_day", 0) or 0)
            uses_txt = "at-will" if per_day == 0 else "1/day"
            note = weapon_meta.get("label") or "Weapon power"
            embed.add_field(
                name="Source",
                value=f"ðŸ—¡ï¸ **{src}** â€” {note} ({uses_txt})\nEffective caster level: **{level}**",
                inline=False
            )

        invis_broke = False; invis_broke_note = None
        try:
            bcfg2 = _load_battles()
            chan2 = str(ctx.channel.id)
            if bcfg2 and bcfg2.has_section(chan2):
                names2, _ = _parse_combatants(bcfg2, chan2)
                key2 = _find_ci_name(names2, char_name) or char_name
                try:
                    s_self = _slot(key2)
                except Exception:
                    s_self = key2.replace(" ", "_")

                inv_left = bcfg2.getint(chan2, f"{s_self}.inv", fallback=0)
                inv_perm = bcfg2.getint(chan2, f"{s_self}.inv_perm", fallback=0)
                inv_type = (bcfg2.get(chan2, f"{s_self}.inv_type", fallback="").strip().lower()
                            or ("perm" if inv_perm > 0 else "norm"))

                if inv_left > 0 or inv_perm > 0:
                    def _clear_inv(slot: str):
                        bcfg2.set(chan2, f"{slot}.inv", "0")
                        for suf in ("inv_by", "inv_type", "inv_gid", "inv_leader", "inv_perm"):
                            opt = f"{slot}.{suf}"
                            if bcfg2.has_option(chan2, opt):
                                bcfg2.remove_option(chan2, opt)

                    if inv_type in {"imp","improved"}:
                        pass
                    elif inv_type == "group":
                        gid = bcfg2.get(chan2, f"{s_self}.inv_gid", fallback="")
                        is_leader = bcfg2.getint(chan2, f"{s_self}.inv_leader", fallback=0) > 0
                        if is_leader and gid:
                            names_all, _ = _parse_combatants(bcfg2, chan2)
                            for nm in names_all:
                                try:
                                    s = _slot(nm)
                                except Exception:
                                    s = nm.replace(" ", "_")
                                same_gid = (bcfg2.get(chan2, f"{s}.inv_gid", fallback="") == gid)
                                has_invis = (bcfg2.getint(chan2, f"{s}.inv", fallback=0) > 0 or
                                             bcfg2.getint(chan2, f"{s}.inv_perm", fallback=0) > 0)
                                if same_gid and has_invis:
                                    _clear_inv(s)
                            invis_broke = True
                            invis_broke_note = "Casting a spell ends **Invisible10** for the **entire group**."
                        else:
                            _clear_inv(s_self); invis_broke = True
                            invis_broke_note = "Casting a spell ends **Invisible10** on **you** (others remain invisible)."
                    else:
                        _clear_inv(s_self); invis_broke = True
                        if inv_type in {"mass"} or inv_perm > 0:
                            invis_broke_note = "Casting a spell ends **Mass Invisibility** on the caster."
                        else:
                            invis_broke_note = "Casting a spell ends **Invisibility** on the caster."
                    if invis_broke:
                        _save_battles(bcfg2)
        except Exception:
            pass

        if invis_broke and invis_broke_note:
            embed.add_field(name="Note", value=invis_broke_note, inline=False)
        if auto_timer_note:
            embed.add_field(name="Timer", value=auto_timer_note, inline=False)

        handler = self._spell_handlers.get(alias_key)
        suppress_auto_timer = False
        if handler:
            try:
                cast_level = scroll_cast_level if scroll_cast_level is not None else level
                result = handler(ctx, cfg, char_name, cast_level, targets)

                if inspect.isawaitable(result):
                    result = await result

                effect_lines = []
                meta = {}
                if isinstance(result, dict):
                    text = result.get("text") or ""
                    suppress_auto_timer = bool(result.get("suppress_timer"))
                    effect_lines = [s for s in str(text).splitlines()] if text else []
                elif isinstance(result, (list, tuple)):
                    meta = result[-1] if result and isinstance(result[-1], dict) else {}
                    suppress_auto_timer = bool(meta.get("suppress_timer", False))
                    effect_lines = [str(x) for x in result if not isinstance(x, dict)]
                elif isinstance(result, str):
                    effect_lines = result.splitlines()
                elif result is not None:
                    effect_lines = [str(result)]

                main, notes = _split_effect_sections(effect_lines)
                if main and (pretty_range or pretty_duration):
                    drops = ("Range:", "**Range:**", "Duration:", "**Duration:**")
                    main = [ln for ln in main if not ln.strip().startswith(drops)]
                if main:
                    _add_long_field(embed, "Effect", main)
                if notes:
                    _add_long_field(embed, "Notes", notes)
            except Exception as e:
                embed.add_field(name="Effect", value=f"âš ï¸ Error in spell effect: {e}", inline=False)

        if desc:
            embed.add_field(name="Description", value=_truncate(desc), inline=False)

        if weapon_casting:
            embed.add_field(
                name="Slots",
                value=f"ðŸ”® Item power: **no spell slots used**.",
                inline=False
            )
        else:
            if bubbles:
                embed.add_field(
                    name="Slots",
                    value=f"ðŸ”® **{char_name}** {level_label} slots: {bubbles}  {delta_note}",
                    inline=False
                )
            else:
                embed.add_field(
                    name="Slots",
                    value=f"ðŸ”® **{char_name}** {level_label} slots: â€”  {delta_note}",
                    inline=False
                )

        await ctx.send(embed=embed)

        if weapon_casting and int(weapon_meta.get("per_day", 0) or 0) > 0:
            _weapon_spend_use(cfg, weapon_grant.get("charge_key"))
            write_cfg(path, cfg)

        alias_name = "".join(ch.lower() for ch in canon if ch.isalnum())
        cmd = self.bot.get_command(alias_name)
        if cmd:
            try:
                await ctx.invoke(cmd, *( [rest_raw] if rest_raw else [] ))
            finally:
                try:
                    if not targets and rest_raw:
                        toks = [t for t in re.split(r"\s+", rest_raw.strip()) if t and not t.startswith("-")]
                        if toks:
                            woke = self._hyp_break_if_targeted(str(ctx.channel.id), toks)
                            if woke:
                                try:
                                    await self._update_tracker_message(ctx, _load_battles(), str(ctx.channel.id))
                                except Exception:
                                    pass
                except Exception:
                    pass


    @commands.command(name="mcast")
    async def monster_cast(self, ctx, mon_name: str, *, expr: str):
        """
        GM-only: Make a monster cast an innate spell (uses per-day from .coe).
        Usage:
          !mcast UN1 curelightwounds Testman
          !mcast go2 "dimension door" -t Testman
          !mcast un1 curelightwounds -i  # ignore use (GM freebie)
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)

        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("âŒ No initiative running here. Use `!init` first.")
            return

        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("âŒ Only the GM can use `!mcast` in this battle.")
            return


        names, _scores = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, mon_name) or mon_name
        path = f"{key.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Combatant file not found for **{key}**.")
            return

        cfg = read_cfg(path)
        is_mon = bool(get_compat(cfg, "info", "monster_type", fallback="").strip())
        if not is_mon:
            await ctx.send(f"âŒ **{key}** is not a monster (try `!cast` for PCs).")
            return


        try:
            slotX = _choose_slot_for_effects(bcfg, chan_id, key) if '_choose_slot_for_effects' in globals() else _slot(key)
            if bcfg.getint(chan_id, f"{slotX}.gas",  fallback=0) > 0:
                await ctx.send("â›” This creature is in **Gaseous Form** and canâ€™t cast.")
                return
            tree_left = max(
                bcfg.getint(chan_id, f"{slotX}.tree",   fallback=0),
                bcfg.getint(chan_id, f"{slotX}.x_tree", fallback=0),
            )
            if tree_left > 0:
                await ctx.send("â›” This creature is in **Tree Form** and canâ€™t cast.")
                return
            if bcfg.getint(chan_id, f"{slotX}.aaf", fallback=0) > 0:
                await ctx.send("â›” This creature is in **Animal Form** and canâ€™t cast.")
                return
        except Exception:
            pass


        spell_name_in, targets, ignore_uses, rest_raw, _targets_field = self._parse_cast_expr(expr)

        if not spell_name_in:
            await ctx.send("âŒ Usage: `!mcast <MonsterName> <SpellName> [targets/flags...]`")
            return


        try:
            if targets:
                self._hyp_break_if_targeted(str(ctx.channel.id), list(targets))
                self._conf_mark_if_targeted(str(ctx.channel.id), list(targets), by=key)
        except Exception:
            pass


        def _alias_key(s: str) -> str:
            return "".join(ch.lower() for ch in str(s) if ch.isalnum())

        mon_sp = cfg["mon_spells"] if cfg.has_section("mon_spells") else {}
        mon_lf = cfg["mon_left"]   if cfg.has_section("mon_left") else {}

        listed = set(str(mon_sp.get("list", "")).split())
        if not listed:
            await ctx.send(f"âŒ **{key}** has no innate spells.")
            return

        ask_key = _alias_key(spell_name_in)

        ask_key = self._spell_alias_map().get(ask_key, ask_key)


        if ask_key not in listed:

            norm_to_listed = {s: s for s in listed}
            if ask_key not in norm_to_listed:

                avail = ", ".join(f"`{s}`" for s in sorted(listed))
                await ctx.send(f"âŒ **{spell_name_in}** isnâ€™t one of {key}â€™s innate spells. Available: {avail}")
                return


        total = int(mon_sp.get(f"{ask_key}_total", "0") or "0")
        left  = int(mon_lf.get(f"{ask_key}_left",  str(total)) or str(total))
        if not ignore_uses and left <= 0:
            await ctx.send(f"âŒ **{key}** has no uses left of `{ask_key}` ({left}/{total}). Add `-i` to ignore.")
            return


        try:
            level = int(mon_sp.get("caster_level", cfg.get("cur", "level", fallback="1")))
        except Exception:
            level = max(1, int(cfg.get("cur", "level", fallback="1")))



        def _find_canon_section(name: str) -> tuple[str|None, str|None]:
            n = self._norm(name)
            if self._spell_cp.has_section(name):
                return name, name
            for s in self._spell_cp.sections():
                if self._norm(s) == n:
                    return s, s

            ali = self._spell_alias_map().get(n, n)
            for s in self._spell_cp.sections():
                if self._norm(s) == ali:
                    return s, s
            return None, None

        sec, canon = _find_canon_section(ask_key)
        if not sec:
            await ctx.send(f"âŒ Spell reference not found for **{spell_name_in}**.")
            return


        try:
            turn_name = bcfg.get(chan_id, "turn", fallback="")



            if key in names and key == turn_name:

                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
                except Exception:
                    pass
        except Exception:
            pass


        owner_user = None
        oid = None
        try:
            owner_id_s = (get_compat(cfg, "info", "owner_id", fallback="") or "").strip()
            if owner_id_s:
                try:
                    oid = int(owner_id_s)
                except Exception:
                    oid = None
        except Exception:
            pass

        if oid:

            owner_user = ctx.guild.get_member(oid) if ctx.guild else None
            if owner_user is None:
                owner_user = ctx.bot.get_user(oid) if hasattr(ctx, "bot") else None
            if owner_user is None:
                try:
                    owner_user = await ctx.bot.fetch_user(oid) if hasattr(ctx, "bot") else None
                except Exception:
                    owner_user = None

        if owner_user is None:

            owner_user = ctx.author

        title = f"{key} casts **{canon}**!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        try:
            name = getattr(owner_user, "display_name", str(owner_user))
            icon = getattr(getattr(owner_user, "display_avatar", None), "url", None)
            embed.set_author(name=f"{name}", icon_url=icon or nextcord.Embed.Empty)
        except Exception:
            embed.add_field(name="Player", value=getattr(owner_user, "mention", str(owner_user)), inline=False)


        pretty_range = self._pretty_range(self._spell_cp.get(sec, "range", fallback="").strip(),
                                          next((self._spell_cp.get(sec, k, fallback="").strip()
                                                for k in ("rngeperlvl","rngperlvl","rangeperlvl","rangeperlevel")
                                                if self._spell_cp.has_option(sec, k)), ""))
        if pretty_range:
            embed.add_field(name="Spell", value=f"**Range:** {pretty_range}", inline=False)

        pretty_duration = self._spell_cp.get(sec, "duration", fallback="").strip()
        if pretty_duration:
            if not embed.fields:
                embed.add_field(name="Spell", value=f"**Duration:** {pretty_duration}", inline=False)
            else:

                embed.set_field_at(0, name="Spell",
                                   value=embed.fields[0].value + f"\n**Duration:** {pretty_duration}",
                                   inline=False)


        src = mon_sp.get("source", get_compat(cfg, "info", "monster_type", fallback="Monster"))
        embed.add_field(name="Source", value=f"ðŸ‘¹ **{src}** â€” innate magic\nEffective caster level: **{level}**", inline=False)


        invis_broke_note = None
        try:
            s_self = _choose_slot_for_effects(bcfg, chan_id, key) if '_choose_slot_for_effects' in globals() else _slot(key)
            inv_left = bcfg.getint(chan_id, f"{s_self}.inv", fallback=0)
            inv_perm = bcfg.getint(chan_id, f"{s_self}.inv_perm", fallback=0)
            inv_type = (bcfg.get(chan_id, f"{s_self}.inv_type", fallback="").strip().lower()
                        or ("perm" if inv_perm > 0 else "norm"))
            if inv_left > 0 or inv_perm > 0:
                def _clear_inv(slot: str):
                    bcfg.set(chan_id, f"{slot}.inv", "0")
                    for suf in ("inv_by","inv_type","inv_gid","inv_leader","inv_perm"):
                        opt = f"{slot}.{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                if inv_type not in {"imp","improved"}:
                    if inv_type == "group":
                        gid = bcfg.get(chan_id, f"{s_self}.inv_gid", fallback="")
                        is_leader = bcfg.getint(chan_id, f"{s_self}.inv_leader", fallback=0) > 0
                        if is_leader and gid:
                            for nm in names:
                                try:
                                    s = _slot(nm)
                                except Exception:
                                    s = nm.replace(" ", "_")
                                if bcfg.get(chan_id, f"{s}.inv_gid", fallback="") == gid and (
                                   bcfg.getint(chan_id, f"{s}.inv", fallback=0) > 0 or
                                   bcfg.getint(chan_id, f"{s}.inv_perm", fallback=0) > 0):
                                    _clear_inv(s)
                            invis_broke_note = "Casting a spell ends **Invisible10** for the **entire group**."
                        else:
                            _clear_inv(s_self)
                            invis_broke_note = "Casting a spell ends **Invisible10** on the caster."
                    else:
                        _clear_inv(s_self)
                        invis_broke_note = "Casting a spell ends **Invisibility** on the caster."
                _save_battles(bcfg)
        except Exception:
            pass
        if invis_broke_note:
            embed.add_field(name="Note", value=invis_broke_note, inline=False)



        def _truncate(txt: str, limit: int = 900) -> str:
            return txt if len(txt) <= limit else (txt[:limit-1] + "â€¦")

        desc = ""
        if self._spell_cp.has_option(sec, "desc"):
            raw_desc = self._spell_cp.get(sec, "desc", fallback="").strip()
            desc = self._format_desc(raw_desc) or ""

        auto_timer_note = None
        try:






            pass
        except Exception:
            pass
        if auto_timer_note:
            embed.add_field(name="Timer", value=auto_timer_note, inline=False)


        alias_key = "".join(ch.lower() for ch in canon if ch.isalnum())
        handler = self._spell_handlers.get(alias_key)
        if handler:
            try:
                result = handler(ctx, cfg, key, level, targets)
                if inspect.isawaitable(result):
                    result = await result
                effect_lines = []
                if isinstance(result, dict):
                    txt = result.get("text") or ""
                    effect_lines = [s for s in str(txt).splitlines()] if txt else []
                elif isinstance(result, (list, tuple)):
                    meta = result[-1] if result and isinstance(result[-1], dict) else {}
                    effect_lines = [str(x) for x in result if not isinstance(x, dict)]
                elif isinstance(result, str):
                    effect_lines = result.splitlines()
                elif result is not None:
                    effect_lines = [str(result)]

                if effect_lines:

                    effect = "\n".join(effect_lines)
                    if len(effect) > 1024:

                        embed.add_field(name="Effect", value=effect[:1024], inline=False)
                        rest = effect[1024:]
                        while rest:
                            embed.add_field(name="Effect (cont.)", value=rest[:1024], inline=False)
                            rest = rest[1024:]
                    else:
                        embed.add_field(name="Effect", value=effect, inline=False)
            except Exception as e:
                embed.add_field(name="Effect", value=f"âš ï¸ Error in spell effect: {e}", inline=False)

        if desc:
            embed.add_field(name="Description", value=_truncate(desc), inline=False)


        if ignore_uses:
            uses_line = f"ðŸª„ `{ask_key}` uses: **{left}/{total}** (ignored)"
        else:
            new_left = max(0, left - 1)
            if not cfg.has_section("mon_left"):
                cfg.add_section("mon_left")
            cfg.set("mon_left", f"{ask_key}_left", str(new_left))
            write_cfg(path, cfg)
            uses_line = f"ðŸª„ `{ask_key}` uses: **{new_left}/{total}**"

        embed.add_field(name="Innate Uses", value=uses_line, inline=False)

        await ctx.send(embed=embed)


        try:
            await self._update_tracker_message(ctx, _load_battles(), chan_id)
        except Exception:
            pass

    @commands.command(name="maddspell")
    async def monster_add_spell(self, ctx, mon_name: str, *args):
        """
        GM-only: Add N uses of a spell to an individual monster's innate list.
        Usage:
          !maddspell UN1 CureLightWounds 1
          !maddspell go2 "Cause Light Wounds" 2 -cl 6
        Notes:
          - Works on the spawned monster (.coe), not the template .ini.
          - Adds to both <key>_total and <key>_left (remaining uses).
          - -cl N optionally sets/overrides caster_level in [mon_spells].
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)

        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("âŒ No initiative running here. Use `!init` first.")
            return

        dm_id = bcfg.get(chan_id, "DM", fallback="")
        if str(ctx.author.id) != str(dm_id):
            await ctx.send("âŒ Only the GM can use `!maddspell` in this battle.")
            return


        names, _scores = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, mon_name) or mon_name
        path = f"{key.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Combatant file not found for **{key}**.")
            return

        cfg = read_cfg(path)
        is_mon = bool(get_compat(cfg, "info", "monster_type", fallback="").strip())
        if not is_mon:
            await ctx.send(f"âŒ **{key}** is not a monster.")
            return



        tokens = [str(a).strip() for a in args if str(a).strip()]
        if not tokens:
            await ctx.send("âŒ Usage: `!maddspell <MonsterName> <SpellName> [count] [cl N]`")
            return


        cl_override = None
        i = 0
        t2 = []
        while i < len(tokens):
            t = tokens[i].lower()
            if t in ("-cl", "-cl") and i + 1 < len(tokens) and re.fullmatch(r"-?\d+", tokens[i+1]):
                cl_override = int(tokens[i+1])
                i += 2
            else:
                t2.append(tokens[i]); i += 1
        tokens = t2


        count = 1
        if tokens and re.fullmatch(r"-?\d+", tokens[-1]):
            try:
                count = int(tokens[-1])
                tokens = tokens[:-1]
            except Exception:
                pass
        if count <= 0:
            await ctx.send("âŒ Count must be a positive integer.")
            return

        if not tokens:
            await ctx.send("âŒ Missing spell name. Example: `!maddspell UN1 CureLightWounds 1`")
            return

        spell_name_in = " ".join(tokens).strip()


        def _alias_key(s: str) -> str:
            return "".join(ch.lower() for ch in str(s) if ch.isalnum())

        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

        def _find_canon_section(name: str) -> tuple[str|None, str|None]:
            n = _norm(name)
            if self._spell_cp.has_section(name):
                return name, name
            for s in self._spell_cp.sections():
                if _norm(s) == n:
                    return s, s

            ali = self._spell_alias_map().get(n, n)
            for s in self._spell_cp.sections():
                if _norm(s) == ali:
                    return s, s
            return None, None

        sec, canon = _find_canon_section(spell_name_in)
        if not sec:

            wanted = _norm(spell_name_in)
            cands = []
            for s in self._spell_cp.sections():
                ns = _norm(s)
                if ns.startswith(wanted[:max(3, min(6, len(wanted)))]) or wanted.startswith(ns[:3]):
                    cands.append(s)
                if len(cands) >= 10:
                    break
            hint = "\nâ€¢ " + "\nâ€¢ ".join(cands) if cands else ""
            await ctx.send(f"âŒ Spell not found: **{spell_name_in}**.{hint}")
            return


        key_token = _alias_key(canon)


        if not cfg.has_section("mon_spells"): cfg.add_section("mon_spells")
        if not cfg.has_section("mon_left"):   cfg.add_section("mon_left")

        mon_sp = cfg["mon_spells"]
        mon_lf = cfg["mon_left"]


        listed = set(str(mon_sp.get("list", "")).split())
        if key_token not in listed:
            listed.add(key_token)
            mon_sp["list"] = " ".join(sorted(listed))


        total_key = f"{key_token}_total"
        left_key  = f"{key_token}_left"

        prev_total = int(mon_sp.get(total_key, "0") or "0")
        prev_left  = int(mon_lf.get(left_key,  str(prev_total)) or str(prev_total))

        new_total = max(0, prev_total + count)
        new_left  = max(0, prev_left + count)

        mon_sp[total_key] = str(new_total)
        mon_lf[left_key]  = str(new_left)


        if cl_override is not None:
            mon_sp["caster_level"] = str(max(1, cl_override))
        elif "caster_level" not in mon_sp or not str(mon_sp.get("caster_level", "")).strip():

            try:
                mon_sp["caster_level"] = cfg.get("cur", "level", fallback="1")
            except Exception:
                mon_sp["caster_level"] = "1"


        if not mon_sp.get("source", "").strip():
            mon_sp["source"] = get_compat(cfg, "info", "monster_type", fallback=key) or key


        write_cfg(path, cfg)
        cl_show = mon_sp.get("caster_level", "1")
        await ctx.send(
            f"âœ… Added **{count}** use(s) of **{canon}** to **{key}**.\n"
            f"â€¢ Uses: **{new_left}/{new_total}**\n"
            f"â€¢ Caster level: **{cl_show}**\n"
            f"â€¢ Spells now: {', '.join(f'`{s}`' for s in sorted(listed))}"
            )
    async def _effect_fireball(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        chan_id = str(ctx.channel.id)
        dice_spec = f"{max(1, caster_level)}d6"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        lines, any_hp_changes = [], False
        dead_monsters: list[tuple[str, str]] = []

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in targets:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            cleared = self._mi_clear_all_if_present(ctx, pretty)
            if cleared:
                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")

            absorbs_fire = ("fire" in _collect_absorb_types(t_cfg))

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                ok = False

            rf_bonus = self._rc_rf_save_bonus(t_cfg, chan_id, pretty, "fire")
            pff_bonus = self._pf_other_save_bonus(chan_id, pretty, "fire")
            total_bonus = rf_bonus + pff_bonus

            if absorbs_fire:
                ok = False
            else:
                try:
                    eff_roll = sv_roll - (sv_pen or 0)
                    if sv_dc is not None and not ok and (eff_roll + total_bonus) >= sv_dc:
                        ok = True
                except Exception:
                    pass

            override = self._pf_other_damage_override(base_dmg, ok, chan_id, pretty, "fire")
            pre_mit = (override if override is not None else (base_dmg // 2 if ok else base_dmg))

            final, note = _apply_mitigation(pre_mit, weapon_name="Fireball", weapon_type="fire",
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"): t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)
            any_hp_changes = True

            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10); after = _life_bar(new_hp, mhp2, width=10)
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            pen_txt   = f" - {sv_pen}" if sv_pen else ""
            bonus_txt = (f" + {total_bonus}" if total_bonus else "")
            res_txt   = "**RESIST**" if ok else "**FAIL**"
            auto_txt  = " (auto-fail: absorbs fire)" if absorbs_fire else ""
            amt_txt   = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"
            dup_heal  = (final < 0) and note and ("heals" in note.lower())
            amt_part  = "" if dup_heal else f" â†’ {amt_txt}"

            line = f"{pretty}: Save vs. Spells {sv_roll}{pen_txt}{bonus_txt} vs {sv_dc} â†’ {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
            if note: line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))

        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass

        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        head = f"ðŸ’¥ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}**"
        return head + "\n" + "\n".join(lines)


    async def _effect_flamestrike(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        FlameStrike: 6d8 fire, save vs Spells for half.
        - One roll for all targets (classic)
        - Lifebars for monsters, numeric for PCs
        - Removes dead monsters from initiative and deletes their files
        - Refreshes pinned tracker
        """
        chan_id = str(ctx.channel.id)


        dice_spec = f"{max(1, 6)}d8"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in targets:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            cleared = self._mi_clear_all_if_present(ctx, pretty)
            if cleared:
                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")


            absorbs_fire = ("fire" in _collect_absorb_types(t_cfg))

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None: ok = False

            rf_bonus  = self._rc_rf_save_bonus(t_cfg, chan_id, pretty, "fire")
            pff_bonus = self._pf_other_save_bonus(chan_id, pretty, "fire")
            total_bonus = rf_bonus + pff_bonus

            if absorbs_fire:
                ok = False
            else:
                eff = sv_roll - (sv_pen or 0)
                if sv_dc is not None and not ok and (eff + total_bonus) >= sv_dc:
                    ok = True

            override = self._pf_other_damage_override(base_dmg, ok, chan_id, pretty, "fire")
            pre_mit  = override if override is not None else (base_dmg // 2 if ok else base_dmg)

            final, note = _apply_mitigation(pre_mit, weapon_name="Flame Strike", weapon_type="fire",
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            res_txt  = "**RESIST**" if ok else "**FAIL**"
            auto_txt = " (auto-fail: absorbs fire)" if absorbs_fire else ""
            amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"

            dup_heal = (final < 0) and note and ("heals" in note.lower())
            amt_part = "" if dup_heal else f" â†’ {amt_txt}"

            line = f"{pretty}: Save vs. Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)

                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:

                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)

                            slot = _slot(key)
                            for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)

                    _write_combatants(bcfg, chan_id, names, scores)


                    current_turn = bcfg.get(chan_id, "turn", fallback="")
                    if current_turn and current_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")

                    _save_battles(bcfg)
            except Exception:
                pass


            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        head = f"â˜„ï¸ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}**"
        return head + "\n" + "\n".join(lines)

    def _roll_save(self, t_cfg, vs: str = "para", penalty: int = 0) -> tuple[bool, int, int, int]:
        """
        Return (success, d20, target, penalty_applied).
        'penalty' lowers the roll (i.e., makes the save harder).
        """
        try:
            penalty = int(penalty or 0) + int(getattr(self, "_item_save_penalty", 0) or 0)
        except Exception:
            penalty = int(penalty or 0)

        target = self._get_save_target(t_cfg, vs)
        d20 = random.randint(1, 20)
        prot = int(self._protection_bonus_from_equipped(t_cfg) or 0)
        effective = d20 + prot - penalty
        success = (effective >= target)
        return success, d20, target, penalty


    def _get_save_target(self, t_cfg, vs: str = "para") -> int:
        """
        1) If the target file defines a save number explicitly (e.g., [saves].spell),
           use it.
        2) Otherwise honor `saveas = <Class> <Level>` or NM (Normal Man).
        3) Otherwise fall back to Fighter 1 defaults.
        """
        v = _canon_vs(vs)


        keys = [f"sv_{v}", f"save_{v}", v]
        if v == "para": keys += ["paralyze", "paralysis"]
        for sec in ("stats","saves"):
            for k in keys:
                try:
                    raw = get_compat(t_cfg, sec, k, fallback=None)
                except Exception:
                    raw = None
                if raw is None:
                    continue
                s = str(raw).strip()
                if not s:
                    continue
                try:
                    return int(s)
                except Exception:
                    pass


        saveas = _get_saveas_from_cfg(t_cfg)
        if saveas:
            cls, lvl = _parse_saveas(saveas)
            return _class_save_target(cls, lvl, v)


        return _DEFAULT_F1.get(v, 14)

    async def _effect_curelightwounds(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Cure Light Wounds
        - Heals living target (first only; defaults to caster).
        - If the target is UNDEAD: make an attack roll (d20 + AB + WIS mod) vs AC.
          On HIT, deal holy damage equal to the healing roll; on MISS, no effect.
        - Lifebars for monsters; numeric for PCs.
        - Removes slain undead monsters from initiative and deletes their files.
        """

        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **Cure Light Wounds**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        dice_spec = "1d8"
        try:
            sec = None
            for s in self._spell_cp.sections():
                if "".join(ch.lower() for ch in s if ch.isalnum()) == "curelightwounds":
                    sec = s; break
            if sec:
                raw_desc = self._spell_cp.get(sec, "desc", fallback="") if self._spell_cp.has_option(sec, "desc") else ""
                m = re.search(r"\b\d+d\d+(?:\s*[+\-]\s*\d+)?\b", (raw_desc or ""), flags=re.I)
                if m:
                    dice_spec = m.group(0).replace(" ", "")
        except Exception:
            pass


        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)


        if _is_undead_cfg(t_cfg, pretty):

            wis_mod = self._abil_mod(caster_cfg, "wis")
            ab = self._get_attack_bonus(caster_cfg)


            try:
                target_ac = self._get_effective_ac(t_cfg)
            except Exception:
                target_ac = 10


            d20 = random.randint(1, 20)
            total_to_hit = d20 + ab + (wis_mod or 0)
            hit = (d20 == 20) or (total_to_hit >= target_ac)


            head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
            atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")

            if not hit:
                return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"


            final, note = _apply_mitigation(amount, weapon_name="Cure Light Wounds (reversed)", weapon_type="holy", t_cfg=t_cfg)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            line = f"{pretty}: {atk_line}\n**Holy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"


            if new_hp <= 0 and _is_monster_file(path):
                try:
                    self._kill_remove_from_initiative(ctx, pretty, path)
                except Exception:
                    pass


            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

            return head + "\n" + line


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

        if old_hp <= 0:
            head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
            line = f"{pretty}: already **DEAD** â€” cannot be healed by this spell."
            return head + "\n" + line

        new_hp = min(max_hp, old_hp + amount)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, width=10)
            after  = _life_bar(new_hp, max_hp, width=10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
        line = f"{pretty}: **+{amount} HP** â€¢ {hp_txt}"
        return head + "\n" + line


    def _is_humanoid_cfg(self, t_cfg, pretty_name: str = "") -> bool:
        """
        Loose heuristic: PCs are humanoid; otherwise look for common humanoid races/types.
        """
        txt = " ".join(filter(None, [
            str(get_compat(t_cfg, "info", "name", fallback="")),
            str(get_compat(t_cfg, "info", "monster_type", fallback="")),
            str(get_compat(t_cfg, "stats", "type", fallback="")),
            pretty_name or ""
        ])).lower()


        owner = str(get_compat(t_cfg, "info", "owner_id", fallback="")).strip()
        if owner:
            return True

        HUMANOID_TOKENS = {
            "humanoid","human","elf","dwarf","halfling","gnome","half-elf","half-orc",
            "orc","goblin","hobgoblin","bugbear","kobold","gnoll","lizard man","lizardman",
            "troglodyte","bandit","brigand","cultist","acolyte","thief","cleric","mage",
            "acolyte","guard","mercenary","pirate","brigand","tribesman","orcish","goblinoid",
            "ogre"
        }
        return any(tok in txt for tok in HUMANOID_TOKENS)

    def _too_large_for_hold(self, t_cfg, pretty_name: str = "") -> bool:
        """
        Hold Person: 'Creatures larger than ogres will not be affected.'
        Treat Huge+/â€˜giant/dragon/titanâ€™ as too large; ogres are OK.
        """
        txt = " ".join(filter(None, [
            str(get_compat(t_cfg, "stats", "size", fallback="")),
            str(get_compat(t_cfg, "info", "monster_type", fallback="")),
            str(get_compat(t_cfg, "stats", "type", fallback="")),
            pretty_name or ""
        ])).lower()


        if any(s in txt for s in ("huge", "gargantuan", "colossal")):
            return True


        BIG_TOKENS = {"storm giant","stone giant","cloud giant","fire giant","frost giant",
                      "hill giant","giant","titan","dragon","wyrm","hydra","behemoth","roc"}
        return any(tok in txt for tok in BIG_TOKENS)


    async def _effect_holdperson(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Hold Person
          â€¢ Single target â†’ Save vs Spells at â€“2 (harder to resist).
          â€¢ Group cast (2+ names) â†’ roll 1d4; only that many are *affected* (each gets a normal save).
          â€¢ Only living humanoids (not undead). Creatures larger than ogres are unaffected.
          â€¢ On failed save: PARALYZED for 2d8 *turns* (== turns*60 rounds). No change to initiative order here.
        """


        resolved: list[tuple[str, str, str | None]] = []
        for raw in (targets or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            resolved.append((raw, (disp or raw), path))

        if not any(p for _, _, p in resolved):
            return "ðŸ§¿ **Hold Person** â€” _(no valid targets found)_"


        group_mode = (len([1 for _, _, p in resolved if p]) >= 2)

        chosen = []
        roll_note = ""
        if group_mode:
            d, rolls, flat = roll_dice("1d4")
            k = min(d + flat, len([1 for _, _, p in resolved if p]))
            pool = [(r, d, p) for (r, d, p) in resolved if p]
            random.shuffle(pool)
            chosen = pool[:k]
            roll_note = f" â€” group cast: 1d4 â†’ **{k}**"
        else:
            for tup in resolved:
                if tup[2]:
                    chosen = [tup]
                    break

        lines = []
        for raw, disp, path in chosen:
            pretty_up = (disp or raw).upper()
            if not path:
                lines.append(f"{pretty_up}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
                  str(get_compat(t_cfg, "info",  "type", fallback=""))).lower()


            is_undead = False
            try:
                is_undead = _is_undead_cfg(t_cfg, disp)
            except Exception:
                is_undead = ("undead" in ty)

            if is_undead:
                lines.append(f"{pretty_up}: undead â€” not a living humanoid (no effect)")
                continue


            non_humanoid = any(k in ty for k in (
                "undead","construct","golem","elemental","ooze","slime","plant",
                "magical","beast","animal","dragon","demon","devil","fiend"
            ))
            if non_humanoid and "hum" not in ty:
                lines.append(f"{pretty_up}: not a humanoid (no effect)")
                continue


            too_large = False
            try:
                too_large = self._too_large_for_hold(t_cfg, disp)
            except Exception:

                sz = str(get_compat(t_cfg, "stats", "size", fallback="")).lower()
                too_large = any(k in sz for k in ("huge","gargantuan","colossal","enormous"))
            if too_large:
                lines.append(f"{pretty_up}: too large (larger than ogre) â€” no effect")
                continue


            penalty = 2 if not group_mode else 0
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=penalty)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            if ok:
                lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **RESISTED**")
                continue


            t_sum, t_rolls, t_flat = roll_dice("2d8")
            turns = t_sum + t_flat
            rounds = turns * 60
            try:

                self._set_status_rounds(ctx, disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ ðŸ§Š **PARALYZED** *(for {turns} turns)*")

        head = f"ðŸ§¿ **Hold Person**{roll_note}"
        return head + "\n" + "\n".join(lines)


    async def _effect_holdmonster(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Hold Monster (BFRPG)
          â€¢ Like Hold Person, but affects *any living creature* (animals, dragons, etc.).
          â€¢ Undead / constructs (and similar non-living) are unaffected.
          â€¢ Single target â†’ Save vs Spells at â€“2 (harder to resist).
          â€¢ Group cast (2+ valid names) â†’ roll 1d4; only that many are *affected* (each gets a normal save).
          â€¢ Failed save: PARALYZED for 2d8 *turns* (turns*60 rounds).
          â€¢ Range 180 ft (not enforced here to keep parity with Hold Person).
          â€¢ Cleric 4, Magic-User 5, Illusionist 6 (for reference only).
        """
        


        resolved: list[tuple[str, str, str | None]] = []
        for raw in (targets or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            resolved.append((raw, (disp or raw), path))

        if not any(p for _, _, p in resolved):
            return "ðŸ§¿ **Hold Monster** â€” _(no valid targets found)_"


        group_mode = (len([1 for _, _, p in resolved if p]) >= 2)

        chosen = []
        roll_note = ""
        if group_mode:
            d, rolls, flat = roll_dice("1d4")
            k = min(d + flat, len([1 for _, _, p in resolved if p]))
            pool = [(r, d, p) for (r, d, p) in resolved if p]
            random.shuffle(pool)
            chosen = pool[:k]
            roll_note = f" â€” group cast: 1d4 â†’ **{k}**"
        else:
            for tup in resolved:
                if tup[2]:
                    chosen = [tup]
                    break

        lines = []
        for raw, disp, path in chosen:
            pretty_up = (disp or raw).upper()
            if not path:
                lines.append(f"{pretty_up}: *(not found)*")
                continue

            t_cfg = read_cfg(path)



            is_undead = False
            try:

                is_undead = _is_undead_cfg(t_cfg, disp)
            except Exception:
                ty_mix = (
                    str(get_compat(t_cfg, "stats", "type", fallback="")) or
                    str(get_compat(t_cfg, "info",  "type", fallback=""))
                ).lower()
                is_undead = "undead" in ty_mix

            if is_undead:
                lines.append(f"{pretty_up}: undead â€” not living (no effect)")
                continue


            ty_all = (
                str(get_compat(t_cfg, "stats", "type", fallback="")) or
                str(get_compat(t_cfg, "info",  "type", fallback=""))
            ).lower()


            NONLIVING_KEYS = (
                "construct", "golem", "animated", "elemental",
                "ooze", "slime", "jelly",
                "plant", "fungus", "mold"
            )
            if any(k in ty_all for k in NONLIVING_KEYS):
                lines.append(f"{pretty_up}: not a living creature (no effect)")
                continue





            penalty = 2 if not group_mode else 0
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=penalty)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            if ok:
                lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **RESISTED**")
                continue


            t_sum, t_rolls, t_flat = roll_dice("2d8")
            turns = t_sum + t_flat
            rounds = turns * 60
            try:
                self._set_status_rounds(ctx, disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ ðŸ§Š **PARALYZED** *(for {turns} turns)*")

        head = f"ðŸ§¿ **Hold Monster**{roll_note}"
        return head + "\n" + "\n".join(lines)

    async def _effect_removeparalysis(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Remove Paralysis (Cleric/Necromancer 2)
        Range: Touch â€¢ Duration: Instantaneous
        Frees a touched creature from paralysis caused by spells or monsters (e.g., ghoul).
        Tracker:
          â€¢ Clears <slot>.paralyzed and related metadata if found.
        """
        

        def _resolve_char_ci_local(name: str):

            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        lines = [f"ðŸ§Š **Remove Paralysis**: {caster_name} lays a freeing hand."]
        if not tokens:
            lines.append("*(Usage: `!cast removeparalysis <target [target ...]>`)*")
            return lines


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)

        changed_any = False

        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ not found.")
                continue


            slot = None
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    slot = (_choose_slot_for_effects(bcfg, chan_id, key)
                            if '_choose_slot_for_effects' in globals() else _slot(key))
                except Exception:
                    slot = (tgt_disp or raw).replace(" ", "_")
            else:
                slot = (tgt_disp or raw).replace(" ", "_")


            par_found = False
            par_rounds = None
            if bcfg and bcfg.has_section(chan_id):
                try:
                    par_rounds = bcfg.getint(chan_id, f"{slot}.paralyzed", fallback=0)
                    if par_rounds and par_rounds > 0:
                        par_found = True

                    if not par_found and bcfg.has_option(chan_id, f"{slot}.paralyzed_perm"):
                        if bcfg.getint(chan_id, f"{slot}.paralyzed_perm", fallback=0) > 0:
                            par_found = True
                except Exception:
                    pass

            if not par_found:
                lines.append(f"â€¢ **{tgt_disp}**: no tracked **Paralysis** â€” **no effect**.")
                continue


            if bcfg and bcfg.has_section(chan_id):
                for base in ("paralyzed", "paralyzed_by",
                             "paralyzed_perm",
                             "cc_blind_pending","cs_blind_pending","cc_blind_by","cs_blind_by"):
                    opt = f"{slot}.{base}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)


                try:
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass

            changed_any = True
            rem_txt = f" (was **{par_rounds} rounds** left)" if (par_rounds and par_rounds > 0) else ""
            lines.append(f"â€¢ **{tgt_disp}**: **Paralysis removed**{rem_txt}.")

        return lines



    async def _effect_shield(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Shield (MU1): Self. Duration 5 rounds + 1/level.
        Grants AC +3 vs melee, +6 vs missile. (Ignoring Magic Missile nullification for now.)
        Creates/refreshes a timed status in initiative and shows in tracker.
        """
        duration_rds = 5 + max(0, int(caster_level))


        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
        except Exception:
            _load_battles = _save_battles = _parse_combatants = _write_combatants = _sorted_entries = _find_ci_name = _slot = _format_tracker_block = None


        try:
            if _load_battles:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, caster_name) or caster_name
                    slot = _slot(key) if _slot else key.replace(" ", "_")


                    bcfg.set(chan_id, f"{slot}.shield", str(duration_rds))

                    bcfg.set(chan_id, f"{slot}.shield_by", caster_name)
                    _save_battles(bcfg)


                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass

        return (f"ðŸ›¡ï¸ **Shield**: AC **+3** vs melee, **+6** vs missile\n"
                f"Duration: **{duration_rds} rounds**")


    async def _effect_magic_missile(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Magic Missile:
          â€¢ Missiles: 1 + âŒŠ(level-1)/3âŒ‹, capped at 5 (1/4/7/10/13+ â†’ 1..5 missiles)
          â€¢ Never misses; each missile deals 1d6+1 (we roll per target)
          â€¢ If target has Shield active in initiative (.shield>0), missiles are fully blocked
          â€¢ If more distinct targets than missiles, extras are ignored (noted)
          â€¢ If fewer targets than missiles, we round-robin the missiles across those targets
          â€¢ Applies mitigation, HP change, lifebars, death cleanup, tracker refresh
        """
        chan_id = str(ctx.channel.id)


        n_missiles = min(5, 1 + max(0, (caster_level - 1) // 3))
        if n_missiles <= 0:
            n_missiles = 1

        if not targets:
            return f"âœ¨ **Magic Missile** â€” L{caster_level}: **{n_missiles}** missile(s). Add at least one target (e.g., `!cast magicmissile goblin`)."


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        resolved = []
        for raw in targets:
            disp, path = _resolve_char_ci(raw)
            resolved.append((disp or raw, path))


        valids = [(d, p) for (d, p) in resolved if p]
        if not valids:
            lines = []
            for d, p in resolved:
                if not p:
                    lines.append(f"{d}: *(not found)*")
            head = f"âœ¨ **Magic Missile** â€” L{caster_level}: **{n_missiles}** missile(s)."
            return head + ("\n" + "\n".join(lines) if lines else "")


        counts = collections.defaultdict(int)
        for i in range(n_missiles):
            d, p = valids[i % len(valids)]
            counts[(d, p)] += 1


        distinct_requested = []
        seen = set()
        for d, p in resolved:
            key = d.lower()
            if key not in seen:
                seen.add(key)
                distinct_requested.append((d, p))
        extra_note = ""
        if len(distinct_requested) > n_missiles:
            extras = [d for (d, p) in distinct_requested[n_missiles:] if d]
            if extras:
                extra_note = f"\n*(Extra targets ignored this cast: {', '.join(extras)})*"


        def _has_shield_active(pretty_name: str) -> bool:
            try:
                bcfg = _load_battles()
                if not bcfg or not bcfg.has_section(chan_id):
                    return False
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty_name) or pretty_name
                try:
                    s = _slot(key)
                except Exception:
                    s = key.replace(" ", "_")
                return bcfg.getint(chan_id, f"{s}.shield", fallback=0) > 0
            except Exception:
                return False


        lines = []
        any_hp_changes = False
        dead_monsters = []

        for (pretty, path), m in counts.items():
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue


            if _has_shield_active(pretty):
                blocked = "missiles" if m > 1 else "missile"
                lines.append(f"{pretty}: {m} {blocked} â†’ ðŸ›¡ï¸ **BLOCKED by Shield**")
                continue

            t_cfg = read_cfg(path)


            dice_sum, rolls, flat0 = roll_dice(f"{m}d6")
            raw_total = dice_sum + m


            final_total, note = _apply_mitigation(raw_total, weapon_name="Magic Missile", weapon_type="force", t_cfg=t_cfg)


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final_total)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True


            rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
            head = f"{pretty}: {m}Ã—(1d6+1) {rolls_txt} + {m} = **{raw_total}**"
            if note:
                head += f"\nâ†’ **{note}** â†’ **{final_total}**"


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                tail = f" â€¢ {before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                tail = f" â€¢ {old_hp} â†’ **{new_hp}**{dead_note}"

            lines.append(head + tail)


            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    if bcfg.get(chan_id, "turn", fallback="") and bcfg.get(chan_id, "turn") not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


        head = f"âœ¨ **Magic Missile** â€” L{caster_level}: **{n_missiles}** missile(s)"
        return head + "\n" + "\n".join(lines) + extra_note

    async def _effect_arcane_blast(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Arcane Blast (Cantrip):
          â€¢ No attack roll; target gets Save vs Death Ray to negate
          â€¢ Damage: 1d4 (L1â€“5), 2d4 at L6+
          â€¢ Range note: 30 ft (60 ft at L12+)
          â€¢ Affects creatures (magical â€˜forceâ€™), not inanimate objects
          â€¢ Single-target; if multiple names given, only the first valid is used (others noted)
          â€¢ Applies mitigation, HP change, lifebars, death cleanup, tracker refresh
        """
        

        chan_id = str(ctx.channel.id)


        dmg_spec = "1d4" if caster_level < 6 else "2d4"
        range_txt = "30 ft" if caster_level < 12 else "60 ft"

        if not targets:
            return f"âš¡ **Arcane Blast** â€” {dmg_spec} (Save vs Death to negate) â€¢ Range {range_txt}\n*(Add a target, e.g., `!cast arcaneblast goblin`.)*"


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        resolved = [(_resolve_char_ci(raw)[0] or raw, _resolve_char_ci(raw)[1]) for raw in targets]
        first_valid = next(((d, p) for d, p in resolved if p), None)


        head = f"âš¡ **Arcane Blast** â€” {dmg_spec} (Save vs Death to negate) â€¢ Range {range_txt}"


        if not first_valid:
            lines = [f"{d}: *(not found)*" for d, p in resolved]
            return head + "\n" + "\n".join(lines)

        pretty, path = first_valid
        extras = [d for (d, p) in resolved[1:]]
        extra_note = (f"\n*(Only one target for this cantrip; ignoring: {', '.join(extras)})*"
                      if extras else "")







        t_cfg = read_cfg(path)
        sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="death", penalty=0)
        pen_txt = f" - {sv_pen}" if sv_pen else ""
        save_line = f"{pretty}: Save vs Death {sv_roll}{pen_txt} vs {sv_target}"


        if sv_ok:
            result = f"{save_line} â†’ **RESISTED**"
            return head + "\n" + result + extra_note


        dice_sum, rolls, flat = roll_dice(dmg_spec)
        raw = dice_sum + flat
        final, note = _apply_mitigation(raw, weapon_name="Arcane Blast", weapon_type="force", t_cfg=t_cfg)


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        dmg_line = f"{save_line} â†’ **FAIL** â†’ {dmg_spec} {rolls_txt} = **{raw}**"
        if note:
            dmg_line += f"\nâ†’ **{note}** â†’ **{final}**"


        if _is_monster_file(path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_tail = f"\n{before} â†’ {after}{dead_note}"
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_tail = f"\n{old_hp} â†’ **{new_hp}**{dead_note}"

        out = head + "\n" + dmg_line + hp_tail + extra_note


        if new_hp <= 0 and _is_monster_file(path):
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        slot = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(path))
            except Exception:
                pass


        try:
            bcfg2 = _load_battles()
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return out

    async def _effect_web(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        WEB:
          â€¢ Each target: Save vs Death Ray.
            â€“ Success â†’ ENTANGLED (Â½ move; cannot cast or make normal attacks).
            â€“ Fail    â†’ TRAPPED (no movement/attacks/spells).
          â€¢ Fully TRAPPED with STR â‰¥13 OR HD â‰¥4: new save each round to downgrade to ENTANGLED.
          â€¢ Duration: 2 turns/level = 120 * level rounds (we store rounds).
          â€¢ We store on initiative entry:
              <slot>.web        = rounds remaining (int)
              <slot>.web_state  = "E" or "T"
              <slot>.web_canbrk = "1"/"0" (eligible for re-save each round)
          â€¢ Igniting handled by !ignite (below).
        """
        

        chan_id = str(ctx.channel.id)
        rounds_total = max(1, 120 * max(1, int(caster_level)))


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        head = f"ðŸ•¸ï¸ **Web** â€” area filled; duration **{rounds_total} rounds** (2T/level)"
        if not targets:
            return head + "\n*(Add targets: `!cast web go1 go2 ...`)*"

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = []
        for raw in targets:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="death", penalty=0)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            save_txt = f"{sv_roll}{pen_txt} vs {sv_target}"


            STR = getint_compat(t_cfg, "stats", "str", fallback=10)
            hd  = getint_compat(t_cfg, "cur", "level", fallback=1)
            can_break = (STR >= 13) or (hd >= 4)


            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                ci_key = _find_ci_name(names, pretty) or pretty
                try:
                    slot = _choose_slot_for_effects(bcfg, chan_id, ci_key)
                except Exception:
                    try:
                        slot = _slot(ci_key)
                    except Exception:
                        slot = ci_key.replace(" ", "_")


                bcfg.set(chan_id, f"{slot}.web", str(rounds_total))
                bcfg.set(chan_id, f"{slot}.web_state", ("E" if ok else "T"))
                bcfg.set(chan_id, f"{slot}.web_canbrk", ("1" if can_break else "0"))
                _save_battles(bcfg)


            if ok:
                lines.append(f"{pretty}: Save vs Death {save_txt} â†’ **ENTANGLED** (Â½ move; no spells/attacks)")
            else:
                tail = " (STRâ‰¥13/HDâ‰¥4: new save each round)" if can_break else ""
                lines.append(f"{pretty}: Save vs Death {save_txt} â†’ **TRAPPED**{tail}")


        try:
            b2 = _load_battles()
            if b2.has_section(chan_id):
                msg_id = b2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(b2, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return head + "\n" + "\n".join(lines)

    async def _effect_arcane_dagger(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Arcane Dagger (Cantrip)
          â€¢ Attack vs AC (normal missile attack): d20 + AB + INT mod + range adj
          â€¢ Range adj: short:+1, medium:0, long:â€“2  (you can pass 'short'/'medium'/'long' as tokens)
          â€¢ Damage: 1d4 on hit
          â€¢ Counts as ordinary at L1â€“3; as SILVER at L4+; as MAGIC at L8+
          â€¢ Affects inanimate objects (unlike many spells)
          â€¢ Respects Shield status (+6 AC vs missile)
        """
        
        chan_id = str(ctx.channel.id)


        rng_mod = 0
        raw_targets: list[str] = []
        for t in tokens or []:
            k = str(t).lower()
            if k in ("short", "s"):
                rng_mod = 1
            elif k in ("medium", "med", "m"):
                rng_mod = 0
            elif k in ("long", "l"):
                rng_mod = -2
            else:
                raw_targets.append(t)

        head = "ðŸ—¡ï¸ **Arcane Dagger** â€” attack vs AC; dmg **1d4** (short:+1 / medium:0 / long:â€“2)"
        if not raw_targets:
            return head + "\n*(Add a target, e.g., `!cast arcanedagger go1 short`.)*"


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        resolved = [(_resolve_char_ci(raw)[0] or raw, _resolve_char_ci(raw)[1]) for raw in raw_targets]
        first_valid = next(((d, p) for d, p in resolved if p), None)
        if not first_valid:
            lines = [f"{d}: *(not found)*" for d, p in resolved]
            return head + "\n" + "\n".join(lines)

        tgt_disp, tgt_path = first_valid



        char_class = (get_compat(caster_cfg, "info", "class", fallback="Fighter") or "Fighter").strip()
        level      = getint_compat(caster_cfg, "cur", "level", fallback=max(1, caster_level or 1))
        INT = getint_compat(caster_cfg, "stats", "int", fallback=10)


        try:
            int_mod = getint_compat(caster_cfg, "stats", "int_modifier", fallback=None)
        except Exception:
            int_mod = None
        if int_mod is None:
            int_mod = _bfrpg_mod(INT)


        classes_tbl = getattr(self, "classes", {})
        ab_list = (classes_tbl.get(char_class.lower(), {}) or {}).get("ab", [])
        ab = ab_list[min(level - 1, len(ab_list) - 1)] if ab_list else 0

        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + int_mod + rng_mod


        t_cfg = read_cfg(tgt_path)
        target_ac = self._get_effective_ac(t_cfg)


        try:
            bcfg = _load_battles()
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                name_key = _find_ci_name(names, tgt_disp) or tgt_disp
                s = _slot(name_key)
                if bcfg.getint(chan_id, f"{s}.shield", fallback=0) > 0:
                    target_ac += 6
        except Exception:
            pass

        is_crit = (d20 == 20)
        hit = is_crit or (total_to_hit >= target_ac)


        d20_face = "**20** ðŸŽ‰" if d20 == 20 else ("**1** ðŸ’€" if d20 == 1 else str(d20))
        ab_str   = f"+ {ab}" if ab >= 0 else f"{ab}"
        int_str  = f"+ {int_mod}" if int_mod >= 0 else f"{int_mod}"
        rng_str  = (" + 1" if rng_mod == 1 else (" - 2" if rng_mod == -2 else ""))
        attack_line = f"{d20_face} {ab_str} {int_str}{rng_str} = ``{total_to_hit}``"


        if not hit:
            return (
                head + f"\n**{caster_name}** hurls an arcane dagger at **{tgt_disp}**!\n"
                f"Attack roll: {attack_line}\nResult: âŒ **MISS**"
            )


        dmg_sum, rolls, flat = roll_dice("1d4")
        raw_dmg = dmg_sum + flat

        tags = ["missile"]
        if level >= 8:
            tags.append("magic")
        elif level >= 4:
            tags.append("silver")
        weapon_type = " ".join(tags)

        final, note = _apply_mitigation(raw_dmg, weapon_name="Arcane Dagger", weapon_type=weapon_type, t_cfg=t_cfg, is_magical=True)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        dmg_line = f"Damage: 1d4 {rolls_txt} = **{raw_dmg}**"
        if note:
            dmg_line += f"\nâ†’ **{note}** â†’ **{final}**"


        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_tail = f"{before} â†’ {after}"
        else:
            hp_tail = f"{old_hp} â†’ **{new_hp}**"

        out = (
            head
            + f"\n**{caster_name}** hurls an arcane dagger at **{tgt_disp}**!\n"
            + f"Attack roll: {attack_line}\nResult: âœ… **HIT!**\n"
            + dmg_line + "\n" + hp_tail + (" â˜ ï¸ **DEAD!**" if new_hp <= 0 else "")
        )


        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass


        try:
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return out

    async def _effect_spiritual_hammer(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Spiritual Hammer (Cleric 2)
          â€¢ Creates a force hammer that attacks 1/round at up to 30 ft (not range-penalized; not a missile).
          â€¢ Uses caster's normal AB; strikes as MAGICAL weapon.
          â€¢ Damage: 1d6 + âŒŠlevel/3âŒ‹ (max +5)
          â€¢ Duration: 1 round/level (tracked on the caster).
          â€¢ Initiative storage (on caster's slot):
              <slot>.sph        = rounds remaining (int)
              <slot>.sph_bonus  = fixed damage bonus for this cast
        """
        

        chan_id = str(ctx.channel.id)
        rounds_total = max(1, int(caster_level))
        dmg_bonus = min(5, int(caster_level) // 3)


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, caster_name) or caster_name
            s = _slot(key)
            bcfg.set(chan_id, f"{s}.sph", str(rounds_total))
            bcfg.set(chan_id, f"{s}.sph_bonus", str(dmg_bonus))
            _save_battles(bcfg)

        head = (
            f"ðŸ”¨ **Spiritual Hammer** conjured â€” duration **{rounds_total} rounds**, "
            f"dmg **1d6{'+'+str(dmg_bonus) if dmg_bonus else ''}** (magical). "
            "Use `!a spiritualhammer <target>` once each round."
        )


        if not tokens:

            try:
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
            return head + "\n*(Tip: `!a spiritualhammer go1`)*"


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            return head + f"\n{tokens[0]}: *(not found)*\n*(Use `!a spiritualhammer <target>` while it lasts.)*"


        bon = dmg_bonus
        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, caster_name) or caster_name
                s = _slot(key)
                bon = bcfg.getint(chan_id, f"{s}.sph_bonus", fallback=dmg_bonus)
        except Exception:
            pass

        text = await self._attack_spiritual_hammer(ctx, caster_cfg, caster_name, caster_level, [tgt_disp], force_bonus=bon)
        return head + "\n" + text

    async def _effect_arcane_dart(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Arcane Dart (Cantrip)
          â€¢ Ability check: 1d20 + INT modifier vs DC by level (table below)
          â€¢ On success: 1d4 damage; counts as MAGIC (affects creatures only hit by magic weapons)
          â€¢ Range: 30 ft (60 ft at 9th+)
          â€¢ Blocked entirely by Shield; does not affect inanimate objects
          â€¢ Single target; if multiple names are given, uses the first valid
        """
       

        chan_id = str(ctx.channel.id)


        raw_targets = [t for t in (tokens or []) if str(t).strip()]
        range_txt = "30 ft" if (caster_level or 1) < 9 else "60 ft"
        head = f"ðŸŽ¯ **Arcane Dart** â€” INT check vs DC; dmg **1d4** â€¢ Range {range_txt}"

        if not raw_targets:
            return head + "\n*(Add a target, e.g., `!cast arcanedart go1`.)*"


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        resolved = [(_resolve_char_ci(raw)[0] or raw, _resolve_char_ci(raw)[1]) for raw in raw_targets]
        first_valid = next(((d, p) for d, p in resolved if p), None)
        extras = [d for (d, p) in resolved[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        if not first_valid:
            lines = [f"{d}: *(not found)*" for d, p in resolved]
            return head + "\n" + "\n".join(lines)

        tgt_disp, tgt_path = first_valid
        t_cfg = read_cfg(tgt_path)


        ty = str(get_compat(t_cfg, "stats", "type", fallback="") or "").lower()
        if any(tok in ty for tok in ("object","inanimate","door","wall","statue","barrier","terrain","trap")):
            return head + f"\n{tgt_disp}: inanimate object â€” no effect." + extra_note


        try:
            bcfg = _load_battles()
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                s = _slot(key)
                if bcfg.getint(chan_id, f"{s}.shield", fallback=0) > 0:
                    return head + f"\n{tgt_disp}: **Shield** is active â€” the dart is negated." + extra_note
        except Exception:
            pass


        try:
            int_mod = getint_compat(caster_cfg, "stats", "int_modifier", fallback=None)
        except Exception:
            int_mod = None
        if int_mod is None:
            INT = getint_compat(caster_cfg, "stats", "int", fallback=10)
            int_mod = _bfrpg_mod(INT)


        def _dart_dc(lv: int) -> int:
            lv = max(1, lv)
            if lv == 1: return 17
            if 2 <= lv <= 3: return 16
            if 4 <= lv <= 5: return 15
            if 6 <= lv <= 7: return 14
            if 8 <= lv <= 9: return 13
            if 10 <= lv <= 11: return 12
            if 12 <= lv <= 13: return 11
            if 14 <= lv <= 15: return 10
            if 16 <= lv <= 17: return 9
            if 18 <= lv <= 19: return 8
            return 7

        DC = _dart_dc(int(caster_level or 1))
        d20 = random.randint(1, 20)
        total = d20 + int_mod
        d20_face = "**20** ðŸŽ‰" if d20 == 20 else ("**1** ðŸ’€" if d20 == 1 else str(d20))
        roll_line = f"{d20_face} {'+' if int_mod >= 0 else ''}{int_mod} = ``{total}`` vs **DC {DC}**"

        if total < DC:
            return (
                head
                + f"\n**{caster_name}** launches an arcane dart at **{tgt_disp}**!"
                + f"\nCheck: {roll_line} â†’ âŒ **FAIL**"
                + extra_note
            )


        dmg_sum, dmg_rolls, flat = roll_dice("1d4")
        raw = dmg_sum + flat
        final, note = _apply_mitigation(raw, weapon_name="Arcane Dart", weapon_type="force", t_cfg=t_cfg)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        rolls_txt = "[" + ", ".join(str(r) for r in dmg_rolls) + "]"
        dmg_line = f"Damage: 1d4 {rolls_txt} = **{raw}**"
        if note:
            dmg_line += f"\nâ†’ **{note}** â†’ **{final}**"


        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_tail = f"{before} â†’ {after}"
        else:
            hp_tail = f"{old_hp} â†’ **{new_hp}**"
        dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""

        out = (
            head
            + f"\n**{caster_name}** launches an arcane dart at **{tgt_disp}**!"
            + f"\nCheck: {roll_line} â†’ âœ… **HIT!**"
            + f"\n{dmg_line}\n{hp_tail}{dead_note}"
            + extra_note
        )


        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass


        try:
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return out

    async def _effect_cure_minor_wounds(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Cure Minor Wounds (Cleric/Druid Cantrip)
          â€¢ Living target: heal exactly 1 HP (first target only; defaults to caster).
          â€¢ Undead target: attack roll (d20 + AB + WIS mod) vs AC; on hit deal 1 holy damage.
          â€¢ Lifebars for monsters; numeric for PCs.
          â€¢ Removes slain undead monsters from initiative and deletes their files.
        """
        


        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **Cure Minor Wounds**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)
        amount = 1


        if _is_undead_cfg(t_cfg, pretty):

            wis_mod = self._abil_mod(caster_cfg, "wis")
            ab = self._get_attack_bonus(caster_cfg)


            try:
                target_ac = self._get_effective_ac(t_cfg)
            except Exception:
                target_ac = 10


            d20 = random.randint(1, 20)
            total_to_hit = d20 + (ab or 0) + (wis_mod or 0)
            hit = (d20 == 20) or (total_to_hit >= target_ac)

            head = f"âœ¨ **Cure Minor Wounds** â€” heals **1 HP** (harms undead on hit)"
            atk_line = f"Attack roll: {d20} + {ab or 0} + {wis_mod or 0} = ``{total_to_hit}`` vs AC {target_ac} â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")

            if not hit:
                return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"


            final, note = _apply_mitigation(amount, weapon_name="Cure Minor Wounds (reversed)", weapon_type="holy", t_cfg=t_cfg)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            line = f"{pretty}: {atk_line}\n**Holy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"


            if new_hp <= 0 and _is_monster_file(path):
                try:
                    self._kill_remove_from_initiative(ctx, pretty, path)
                except Exception:
                    pass


            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

            return head + "\n" + line


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

        head = f"âœ¨ **Cure Minor Wounds** â€” heals **1 HP**"

        if old_hp <= 0:
            return head + "\n" + f"{pretty}: already **DEAD** â€” cannot be healed by this spell."


        if _has_mummy_rot(t_cfg):
            head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
            line = f"{pretty}: âŒ **No effect** â€” afflicted with **Mummy Rot**. Magical healing fails until **Cure Disease**."
            return head + "\n" + line

        new_hp = min(max_hp, old_hp + amount)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, width=10)
            after  = _life_bar(new_hp, max_hp, width=10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        line = f"{pretty}: **+{amount} HP** â€¢ {hp_txt}"
        return head + "\n" + line

    async def _effect_lightning_bolt(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Lightning Bolt (MU 3)
          â€¢ 1d6 electric per caster level, Save vs Spells for half
          â€¢ One roll shared by all targets
          â€¢ Uses mitigation with weapon_type="electric"
          â€¢ Removes slain monsters from initiative and deletes their files
          â€¢ Refreshes pinned tracker
        """
        

        chan_id = str(ctx.channel.id)


        dice_spec = f"{max(1, caster_level)}d6"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in targets:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            cleared = self._mi_clear_all_if_present(ctx, pretty)
            if cleared:

                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")

            absorbs_electric = ("electric" in _collect_absorb_types(t_cfg))

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None: ok = False

            pfl_bonus = self._pf_other_save_bonus(chan_id, pretty, "electric")
            if absorbs_electric:
                ok = False
            else:
                eff = sv_roll - (sv_pen or 0)
                if sv_dc is not None and not ok and (eff + pfl_bonus) >= sv_dc:
                    ok = True

            override = self._pf_other_damage_override(base_dmg, ok, chan_id, pretty, "electric")
            pre_mit  = override if override is not None else (base_dmg // 2 if ok else base_dmg)

            final, note = _apply_mitigation(pre_mit, weapon_name="Lightning Bolt", weapon_type="electric",
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=pretty, is_magical=True)


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))

            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"


            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            res_txt  = "**RESIST**" if ok else "**FAIL**"
            amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"
            auto_txt = " (auto-fail: absorbs electric)" if absorbs_electric else ""
            line = f"{pretty}: Save vs. Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt}{auto_txt} â†’ {amt_txt}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)


            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)

                    for pretty, _path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)

                    _write_combatants(bcfg, chan_id, names, scores)


                    current_turn = bcfg.get(chan_id, "turn", fallback="")
                    if current_turn and current_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")

                    _save_battles(bcfg)
            except Exception:
                pass


            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        head = f"âš¡ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}**"
        return head + "\n" + "\n".join(lines)

    async def _effect_causelightwounds(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Cause Light Wounds (reverse of CLW)
          â€¢ LIVING: touch attack (d20 + AB + WIS) vs AC. On hit: 1d6+1 unholy/negative dmg. On miss: no effect.
          â€¢ UNDEAD: no attack roll; heals 1d6+1 HP (to max).
          â€¢ Applies mitigation (weapon_type="unholy" â€” switch to "negative"/"necrotic" if thatâ€™s what your sheets use)
          â€¢ Removes slain monsters from initiative and deletes their files
          â€¢ Refreshes pinned tracker
        """
        


        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"ðŸ‘» **Cause Light Wounds**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        dice_spec = "1d6+1"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)


        if _is_undead_cfg(t_cfg, pretty):
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

            head = f"ðŸ‘» **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"

            if old_hp <= 0:
                return head + f"\n{pretty}: already **DEAD** â€” cannot be healed."

            new_hp = min(max_hp, old_hp + amount)
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


            if _is_monster_file(path):
                before = _life_bar(old_hp, max_hp, width=10)
                after  = _life_bar(new_hp, max_hp, width=10)
                hp_txt = f"{before} â†’ {after}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"

            return head + f"\n{pretty}: **+{amount} HP** â€¢ {hp_txt}"



        wis_mod = self._abil_mod(caster_cfg, "wis")
        ab = self._get_attack_bonus(caster_cfg)


        try:
            target_ac = self._get_effective_ac(t_cfg)
        except Exception:
            target_ac = 10


        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + (wis_mod or 0)
        hit = (d20 == 20) or (total_to_hit >= target_ac)

        head = f"ðŸ‘» **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
        atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")

        if not hit:
            return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"


        final, note = _apply_mitigation(amount, weapon_name="Cause Light Wounds", weapon_type="unholy", t_cfg=t_cfg)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        if _is_monster_file(path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{before} â†’ {after}{dead_note}"
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

        line = f"{pretty}: {atk_line}\n**Unholy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"


        if new_hp <= 0 and _is_monster_file(path):
            try:
                self._kill_remove_from_initiative(ctx, pretty, path)
            except Exception:
                pass


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return head + "\n" + line

    async def _effect_decayflesh(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Decay Flesh (copy of CauseLightWounds for necromancer)
          â€¢ LIVING: touch attack (d20 + AB + WIS) vs AC. On hit: 1d6+1 unholy/negative dmg. On miss: no effect.
          â€¢ UNDEAD: no attack roll; heals 1d6+1 HP (to max).
          â€¢ Applies mitigation (weapon_type="unholy" â€” switch to "negative"/"necrotic" if thatâ€™s what your sheets use)
          â€¢ Removes slain monsters from initiative and deletes their files
          â€¢ Refreshes pinned tracker
        """
        


        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"ðŸ§Ÿ **Decay Flesh**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        dice_spec = "1d6+1"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)


        if _is_undead_cfg(t_cfg, pretty):
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

            head = f"ðŸ§Ÿ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"

            if old_hp <= 0:
                return head + f"\n{pretty}: already **DEAD** â€” cannot be healed."

            new_hp = min(max_hp, old_hp + amount)
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


            if _is_monster_file(path):
                before = _life_bar(old_hp, max_hp, width=10)
                after  = _life_bar(new_hp, max_hp, width=10)
                hp_txt = f"{before} â†’ {after}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"

            return head + f"\n{pretty}: **+{amount} HP** â€¢ {hp_txt}"



        wis_mod = self._abil_mod(caster_cfg, "wis")
        ab = self._get_attack_bonus(caster_cfg)


        try:
            target_ac = self._get_effective_ac(t_cfg)
        except Exception:
            target_ac = 10


        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + (wis_mod or 0)
        hit = (d20 == 20) or (total_to_hit >= target_ac)

        head = f"ðŸ§Ÿ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
        atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")

        if not hit:
            return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"


        final, note = _apply_mitigation(amount, weapon_name="Decay Flesh", weapon_type="unholy", t_cfg=t_cfg)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        if _is_monster_file(path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{before} â†’ {after}{dead_note}"
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

        line = f"{pretty}: {atk_line}\n**Unholy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"


        if new_hp <= 0 and _is_monster_file(path):
            try:
                self._kill_remove_from_initiative(ctx, pretty, path)
            except Exception:
                pass


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return head + "\n" + line

    async def _effect_rotflesh(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Rot Flesh (copy of CauseSeriousWounds for necromancer)
          â€¢ LIVING: touch attack (d20 + AB + WIS) vs AC. On hit: 2d6+L unholy/negative dmg. On miss: no effect.
          â€¢ UNDEAD: no attack roll; heals 2d6+L HP (to max).
          â€¢ Applies mitigation (weapon_type="unholy" â€” switch to "negative"/"necrotic" if thatâ€™s what your sheets use)
          â€¢ Removes slain monsters from initiative and deletes their files
          â€¢ Refreshes pinned tracker
        """
        


        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"ðŸ§Ÿâ€â™‚ï¸ **Rot Flesh**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)

        dice_spec = "2d6"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat + max(0, int(caster_level or 0)))
        head = f"ðŸ§Ÿâ€â™‚ï¸ **{dice_spec} + Lvl** [{', '.join(str(r) for r in rolls)}] + {caster_level} = **{amount}**"


        if _is_undead_cfg(t_cfg, pretty):
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

            if old_hp <= 0:
                return head + f"\n{pretty}: already **DEAD** â€” cannot be healed."

            new_hp = min(max_hp, old_hp + amount)
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


            if _is_monster_file(path):
                before = _life_bar(old_hp, max_hp, width=10)
                after  = _life_bar(new_hp, max_hp, width=10)
                hp_txt = f"{before} â†’ {after}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"

            return head + f"\n{pretty}: **+{amount} HP** â€¢ {hp_txt}"



        wis_mod = self._abil_mod(caster_cfg, "wis")
        ab = self._get_attack_bonus(caster_cfg)


        try:
            target_ac = self._get_effective_ac(t_cfg)
        except Exception:
            target_ac = 10


        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + (wis_mod or 0)
        hit = (d20 == 20) or (total_to_hit >= target_ac)

        atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")

        if not hit:
            return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"


        final, note = _apply_mitigation(amount, weapon_name="Decay Flesh", weapon_type="unholy", t_cfg=t_cfg)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        if _is_monster_file(path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{before} â†’ {after}{dead_note}"
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

        line = f"{pretty}: {atk_line}\n**Unholy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"


        if new_hp <= 0 and _is_monster_file(path):
            try:
                self._kill_remove_from_initiative(ctx, pretty, path)
            except Exception:
                pass


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return head + "\n" + line

    async def _effect_coneofcold(self, ctx, caster_cfg, caster_name, caster_level: int, targets: list[str],
                                 dice_override: str = "6d8", save_vs: str = "wand"):
        """
        Cone of Cold (item version): one roll for all, cold type damage.
        - dice_override: "6d8" for wand; "6d6" for staff of power
        - save_vs: "wand" by default; can be "spell" if you want
        """


        
        chan_id = str(ctx.channel.id)


        total, rolls, flat = roll_dice(dice_override)
        base_dmg = max(0, total + flat)
        lines, dead_monsters, any_hp_changes = [], [], False

        def _resolve_char_ci(name: str):
            try: return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in (targets or []):
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            vs_key = "wand" if save_vs == "wand" else "spell"
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)

            dmg = base_dmg // 2 if ok else base_dmg
            final, note = _apply_mitigation(dmg, weapon_name="Cone of Cold", weapon_type="cold", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            pen_txt = f" - {sv_pen}" if sv_pen else ""
            res_txt = "**RESIST**" if ok else "**FAIL**"
            line = f"{pretty}: Save vs. {('Magic Wands' if vs_key=='wand' else 'Spells')} {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt} â†’ **{final}**\n{hp_txt}"
            if note: line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass

        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2 and bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        head = f"â„ï¸ **{dice_override}** â†’ **{base_dmg}**"
        return head + "\n" + "\n".join(lines)

    async def _effect_icestorm(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Ice Storm: 5d6 cold per caster level, save vs Spells for half.
        - One roll for all targets (classic)
        - Lifebars for monsters, numeric for PCs
        - Removes dead monsters from initiative and deletes their files
        - Refreshes pinned tracker
        """
        chan_id = str(ctx.channel.id)


        dice_spec = f"{max(1, 5)}d6"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in targets:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            cleared = self._mi_clear_all_if_present(ctx, pretty)
            if cleared:

                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")


            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            dmg = base_dmg // 2 if ok else base_dmg


            final, note = _apply_mitigation(dmg, weapon_name="Ice Storm", weapon_type="cold", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty, is_magical=True)


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"


            pen_txt = f" - {sv_pen}" if sv_pen else ""
            res_txt = "**RESIST**" if ok else "**FAIL**"
            line = f"{pretty}: Save vs. Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt} â†’ **{final}**\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)


            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)

                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:

                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)

                            slot = _slot(key)
                            for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)

                    _write_combatants(bcfg, chan_id, names, scores)


                    current_turn = bcfg.get(chan_id, "turn", fallback="")
                    if current_turn and current_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")

                    _save_battles(bcfg)
            except Exception:
                pass


            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        head = f"â„ï¸ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}**"
        return head + "\n" + "\n".join(lines)


    def _mi_keys(self, cfg_b, chan_id: str, name_key: str):
        try:
            slot = _slot(name_key)
        except Exception:
            slot = name_key.replace(" ", "_")
        return f"{slot}.mi", f"{slot}.mi_images"

    def _mi_consume_if_present(self, ctx, target_display: str) -> tuple[bool, int]:
        """
        If target has 1+ images, consume exactly one and return (True, remaining).
        If no images or not in battle, return (False, 0).
        """
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if not bcfg.has_section(chan_id):
                return (False, 0)
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, target_display) or target_display
            if key not in names:
                return (False, 0)
            mi_key, imgs_key = self._mi_keys(bcfg, chan_id, key)
            imgs = bcfg.getint(chan_id, imgs_key, fallback=0)
            if imgs <= 0:
                return (False, 0)
            imgs -= 1
            bcfg.set(chan_id, imgs_key, str(imgs))
            _save_battles(bcfg)
            return (True, imgs)
        except Exception:
            return (False, 0)

    def _mi_clear_all_if_present(self, ctx, target_display: str) -> int:
        """
        For AoE: set images to 0 if present. Returns number cleared.
        """
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if not bcfg.has_section(chan_id):
                return 0
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, target_display) or target_display
            if key not in names:
                return 0
            _, imgs_key = self._mi_keys(bcfg, chan_id, key)
            imgs = bcfg.getint(chan_id, imgs_key, fallback=0)
            if imgs > 0:
                bcfg.set(chan_id, imgs_key, "0")
                _save_battles(bcfg)
            return imgs
        except Exception:
            return 0


    async def _effect_mirrorimage(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Mirror Image
          â€¢ Creates 1d4 + (level//3) images (max 8), duration 60 rounds/level.
          â€¢ Targeted attacks/spells always pop a figment instead of affecting caster.
          â€¢ Area effects (e.g., Fireball) destroy all figments but still affect caster.
        """
        


        d = random.randint(1, 4)
        extra = max(0, caster_level // 3)
        images = min(8, d + extra)


        rounds = max(1, 60 * max(1, caster_level))


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg.has_section(chan_id):
            return "âŒ No battle running here."

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, caster_name) or caster_name
        if key not in names:
            return f"âŒ **{caster_name}** is not in initiative."

        mi_key, imgs_key = self._mi_keys(bcfg, chan_id, key)
        bcfg.set(chan_id, mi_key, str(rounds))
        bcfg.set(chan_id, imgs_key, str(images))

        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")
        bcfg.set(chan_id, f"{slot}.mi_by", caster_name)
        _save_battles(bcfg)


        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content=content)
        except Exception:
            pass

        return (f"ðŸªž **Mirror Image** conjured!\n"
                f"Images: **{images}** (cap 8)\n"
                f"Duration: **{rounds} rounds** (1 turn/level)")

    async def _attack_spiritual_hammer(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str], force_bonus: int | None = None) -> str:
        

        chan_id = str(ctx.channel.id)


        if not tokens:
            return "*(Add a target: `!a spiritualhammer <target>`)*"


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            return f"{tokens[0]}: *(not found)*"


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        active, bonus = True, 0
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            ci = _find_ci_name(names, caster_name) or caster_name
            s = _slot(ci)
            rounds = bcfg.getint(chan_id, f"{s}.sph", fallback=0)
            bonus  = bcfg.getint(chan_id, f"{s}.sph_bonus", fallback=0)
            active = rounds > 0

        if force_bonus is not None:
            bonus = int(force_bonus)

        if not active:
            return f"**{caster_name}** has no active Spiritual Hammer."


        classes_tbl = getattr(self, "classes", {})
        char_class = (get_compat(caster_cfg, "info", "class", fallback="Cleric") or "Cleric").strip()
        level = getint_compat(caster_cfg, "cur", "level", fallback=max(1, caster_level or 1))
        ab_list = (classes_tbl.get(char_class.lower(), {}) or {}).get("ab", [])
        ab = ab_list[min(level - 1, len(ab_list) - 1)] if ab_list else 0

        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab


        t_cfg = read_cfg(tgt_path)
        try:
            target_ac = self._get_effective_ac(t_cfg)
        except Exception:
            target_ac = 10

        is_crit = (d20 == 20)
        hit = is_crit or (total_to_hit >= target_ac)

        d20_face = "**20** ðŸŽ‰" if d20 == 20 else ("**1** ðŸ’€" if d20 == 1 else str(d20))
        ab_str = f"+ {ab}" if ab >= 0 else f"{ab}"
        attack_line = f"{d20_face} {ab_str} = ``{total_to_hit}``"

        head = f"**{caster_name}** directs the Spiritual Hammer at **{tgt_disp}**!"
        if not hit:
            return head + f"\nAttack roll: {attack_line}\nResult: âŒ **MISS**"


        dmg_sum, rolls, flat = roll_dice("1d6")
        raw_dmg = dmg_sum + flat + max(0, int(bonus))
        final, note = _apply_mitigation(
            raw_dmg,
            weapon_name="Spiritual Hammer",
            weapon_type="magic melee force",
            t_cfg=t_cfg,
        )

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        dmg_line = f"Damage: 1d6 {rolls_txt} + {bonus} = **{raw_dmg}**"
        if note:
            dmg_line += f"\nâ†’ **{note}** â†’ **{final}**"


        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_tail = f"{before} â†’ {after}"
        else:
            hp_tail = f"{old_hp} â†’ **{new_hp}**"

        out = head + f"\nAttack roll: {attack_line}\nResult: âœ… **HIT!**\n" + dmg_line + "\n" + hp_tail + (" â˜ ï¸ **DEAD!**" if new_hp <= 0 else "")

        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return out

    async def _effect_ghoulish_hands(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Ghoulish Hands (Necromancer 2)
          â€¢ Touch a *living* creature (self or ally).
          â€¢ Duration: 1 round/level; tracked on the **recipient**.
          â€¢ While active, recipient may use: !a ghoulishhands <target>
            â†’ two claw attacks, 1d4 each; on each hit target must save vs Paralyze or be paralyzed for 2d8 turns (elves immune).
          â€¢ Initiative storage (on recipient's slot):
              <slot>.ghh   = rounds remaining (int)
              <slot>.ghf   = 1 if ghoul fever was contracted on cast (1% chance)  [optional tag]
        """
        

        chan_id = str(ctx.channel.id)


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        rec_token = (tokens[0] if tokens else "").strip().lower()
        if not rec_token or rec_token in {"self", "me"}:
            rec_disp, rec_path = _resolve_char_ci(caster_name)
            rec_disp = rec_disp or caster_name
        else:
            rec_disp, rec_path = _resolve_char_ci(tokens[0])

        if not rec_path:
            return f"**Ghoulish Hands**: {tokens[0] if tokens else '(self)'} *(not found)*"


        rcfg = read_cfg(rec_path)

        def _is_undead_cfg(cfg, pretty=""):
            try:
                cls = (get_compat(cfg, "info", "class", fallback="") or "").strip().lower()
                if cls == "monster":
                    t = (get_compat(cfg, "monster", "type", fallback="") or "").strip().lower()
                    if "undead" in t:
                        return True
                race = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()
                if "undead" in race:
                    return True
            except Exception:
                pass
            return False

        def _is_construct_or_elemental(cfg):
            try:
                t = (get_compat(cfg, "monster", "type", fallback="") or "").strip().lower()
                nm = (get_compat(cfg, "info", "name", fallback="") or "").strip().lower()
                blob = " ".join([t, nm])
                return any(k in blob for k in ["construct","golem","elemental"])
            except Exception:
                return False

        if _is_undead_cfg(rcfg) or _is_construct_or_elemental(rcfg):
            return f"**Ghoulish Hands**: no effect on **{rec_disp}** (not a living creature)."

        rounds_total = max(1, int(caster_level))


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            rec_key = _find_ci_name(names, rec_disp) or rec_disp
            s = _slot(rec_key)
            bcfg.set(chan_id, f"{s}.ghh", str(rounds_total))


            if random.randint(1, 100) == 1:
                bcfg.set(chan_id, f"{s}.ghf", "1")

            _save_battles(bcfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return (f"ðŸ§Ÿâ€â™‚ï¸ **Ghoulish Hands** on **{rec_disp}** â€” duration **{rounds_total} rounds**.\n"
                "Use `!a ghoulishhands <target>` to make **two claw attacks** (1d4 each). "
                "Creatures struck must save vs **Paralyze** or be paralyzed for **2d8 turns** (elves are immune).")

    async def _effect_mage_armor(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Mage Armor (MU/SC 1): Self. Duration 1 turn (60 rounds).
        +2 AC vs melee & hand-thrown missiles, +4 AC vs normal-size projectiles (arrows/bolts/sling).
        """
        duration_rds = 60


        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
        except Exception:
            _load_battles = _save_battles = _parse_combatants = _write_combatants = _sorted_entries = _find_ci_name = _slot = _format_tracker_block = None

        try:
            if _load_battles:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, caster_name) or caster_name
                    slot = _slot(key) if _slot else key.replace(" ", "_")
                    bcfg.set(chan_id, f"{slot}.magearmor", str(duration_rds))
                    bcfg.set(chan_id, f"{slot}.magearmor_by", caster_name)
                    _save_battles(bcfg)


                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass

        return ("ðŸ§± **Mage Armor** active.\n"
                "AC **+2** vs melee & **hand-thrown** missiles; **+4** vs **projectiles** (arrows/bolts/sling).\n"
                f"Duration: **{duration_rds} rounds**")

    async def _effect_boneskin(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Boneskin (Necromancer 2): Self. Duration 1 turn/level (60 * level rounds).
        Flat +4 AC (doesn't hinder casting).
        """
        duration_rds = max(1, int(caster_level)) * 60

        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
        except Exception:
            _load_battles = _save_battles = _parse_combatants = _write_combatants = _sorted_entries = _find_ci_name = _slot = _format_tracker_block = None

        try:
            if _load_battles:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, caster_name) or caster_name
                    slot = _slot(key) if _slot else key.replace(" ", "_")
                    bcfg.set(chan_id, f"{slot}.boneskin", str(duration_rds))
                    bcfg.set(chan_id, f"{slot}.boneskin_by", caster_name)
                    _save_battles(bcfg)


                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass

        return (f"ðŸ¦´ **Boneskin** active. AC **+4** to all attacks.\n"
                f"Duration: **{duration_rds} rounds**")

    async def _effect_cureseriouswounds(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Cure Serious Wounds
        - Heals living target (first only; defaults to caster): 2d6 + 1/level.
        - If the target is UNDEAD: make an attack roll (d20 + AB + WIS) vs AC.
          On HIT, deal holy damage equal to the rolled amount; on MISS, no effect.
        - Lifebars for monsters; numeric for PCs. Removes slain undead monsters.
        """
        


        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **Cure Serious Wounds**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        dice_spec = "2d6"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat + max(0, int(caster_level or 0)))


        if _is_undead_cfg(t_cfg, pretty):
            wis_mod = self._abil_mod(caster_cfg, "wis")
            ab = self._get_attack_bonus(caster_cfg)
            try:
                target_ac = self._get_effective_ac(t_cfg)
            except Exception:
                target_ac = 10

            d20 = random.randint(1, 20)
            total_to_hit = d20 + ab + (wis_mod or 0)
            hit = (d20 == 20) or (total_to_hit >= target_ac)

            head = f"âœ¨ **{dice_spec} + Lvl** [{', '.join(str(r) for r in rolls)}] + {caster_level} = **{amount}**"
            atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")
            if not hit:
                return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"

            final, note = _apply_mitigation(amount, weapon_name="Cure Serious Wounds (reversed)", weapon_type="holy", t_cfg=t_cfg)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)

            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, 10); after = _life_bar(new_hp, mhp, 10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            line = f"{pretty}: {atk_line}\n**Holy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"

            if new_hp <= 0 and _is_monster_file(path):
                try: self._kill_remove_from_initiative(ctx, pretty, path)
                except Exception: pass


            try:
                bcfg = _load_battles(); chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception: pass

            return head + "\n" + line


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

        head = f"âœ¨ **{dice_spec} + Lvl** [{', '.join(str(r) for r in rolls)}] + {caster_level} = **{amount}**"
        if old_hp <= 0:
            return head + "\n" + f"{pretty}: already **DEAD** â€” cannot be healed by this spell."


        if _has_mummy_rot(t_cfg):
            head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
            line = f"{pretty}: âŒ **No effect** â€” afflicted with **Mummy Rot**. Magical healing fails until **Cure Disease**."
            return head + "\n" + line

        new_hp = min(max_hp, old_hp + amount)
        t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)

        try:
            bcfg = _load_battles(); chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception: pass

        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, 10); after = _life_bar(new_hp, max_hp, 10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        return head + "\n" + f"{pretty}: **+{amount} HP** â€¢ {hp_txt}"

    async def _effect_causeseriouswounds(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Cause Serious Wounds (reverse)
          â€¢ LIVING: touch attack (d20 + AB + WIS) vs AC. On hit: (2d6 + 1/level) unholy/negative dmg. On miss: no effect.
          â€¢ UNDEAD: no attack roll; heals (2d6 + 1/level) HP (to max).
          â€¢ Applies mitigation (weapon_type="unholy"), removes slain monsters, refreshes tracker.
        """

        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"ðŸ‘» **Cause Serious Wounds**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)

        dice_spec = "2d6"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat + max(0, int(caster_level or 0)))
        head = f"ðŸ‘» **{dice_spec} + Lvl** [{', '.join(str(r) for r in rolls)}] + {caster_level} = **{amount}**"


        if _is_undead_cfg(t_cfg, pretty):
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            if old_hp <= 0:
                return head + f"\n{pretty}: already **DEAD** â€” cannot be healed."

            new_hp = min(max_hp, old_hp + amount)
            if not t_cfg.has_section("cur"): t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)

            try:
                bcfg = _load_battles(); chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception: pass

            if _is_monster_file(path):
                before = _life_bar(old_hp, max_hp, 10); after = _life_bar(new_hp, max_hp, 10)
                hp_txt = f"{before} â†’ {after}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"

            return head + f"\n{pretty}: **+{amount} HP** â€¢ {hp_txt}"


        wis_mod = self._abil_mod(caster_cfg, "wis")
        ab = self._get_attack_bonus(caster_cfg)
        try:
            target_ac = self._get_effective_ac(t_cfg)
        except Exception:
            target_ac = 10

        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + (wis_mod or 0)
        hit = (d20 == 20) or (total_to_hit >= target_ac)
        atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")

        if not hit:
            return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"

        final, note = _apply_mitigation(amount, weapon_name="Cause Serious Wounds", weapon_type="unholy", t_cfg=t_cfg)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        if not t_cfg.has_section("cur"): t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)

        if _is_monster_file(path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, 10); after = _life_bar(new_hp, mhp, 10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{before} â†’ {after}{dead_note}"
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

        line = f"{pretty}: {atk_line}\n**Unholy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"

        if new_hp <= 0 and _is_monster_file(path):
            try: self._kill_remove_from_initiative(ctx, pretty, path)
            except Exception: pass

        try:
            bcfg = _load_battles(); chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception: pass

        return head + "\n" + line

    async def _effect_shillelagh(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Shillelagh (Druid 1)
          â€¢ Buffs a club/staff the caster is holding.
          â€¢ +1 to hit, +1 damage; damage die becomes 1d8; strikes as MAGICAL melee bludgeoning.
          â€¢ Duration: 1 minute/level = 6 rounds/level (tracked on caster's slot).
          â€¢ Initiative storage (on caster's slot):
              <slot>.shl          = rounds remaining (int)
              <slot>.shl_hit      = fixed to-hit bonus (1)
              <slot>.shl_dmg      = fixed damage bonus (1)
              <slot>.shl_die      = "1d8" (so we can change dice cleanly if needed)
        """
        

        chan_id = str(ctx.channel.id)
        rounds_total = max(1, 6 * int(max(1, caster_level or 1)))
        hit_bonus = 1
        dmg_bonus = 1
        die_code  = "1d8"


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, caster_name) or caster_name
            s = _slot(key)
            bcfg.set(chan_id, f"{s}.shl",      str(rounds_total))
            bcfg.set(chan_id, f"{s}.shl_hit",  str(hit_bonus))
            bcfg.set(chan_id, f"{s}.shl_dmg",  str(dmg_bonus))
            bcfg.set(chan_id, f"{s}.shl_die",  die_code)
            _save_battles(bcfg)

        head = (
            f"ðŸªµ **Shillelagh** cast â€” duration **{rounds_total} rounds**. "
            f"Weapon becomes **magical**, to-hit **+{hit_bonus}**, damage **{die_code}+{dmg_bonus}**.\n"
            "Use `!a shillelagh <target>` while it lasts."
        )


        if not tokens:

            try:
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
            return head + "\n*(Tip: `!a shillelagh go1`)*"


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_char_ci(tokens[0])
        if not tgt_path:
            return head + f"\n{tokens[0]}: *(not found)*\n*(Use `!a shillelagh <target>` while it lasts.)*"


        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, caster_name) or caster_name
                s = _slot(key)
                hit_bonus = bcfg.getint(chan_id, f"{s}.shl_hit", fallback=hit_bonus)
                dmg_bonus = bcfg.getint(chan_id, f"{s}.shl_dmg", fallback=dmg_bonus)
                die_code  = bcfg.get(chan_id,     f"{s}.shl_die", fallback=die_code)
        except Exception:
            pass

        await self._attack_shillelagh(
            ctx, caster_cfg, caster_name, caster_level,
            [tgt_disp],
            force_hit_bonus=hit_bonus,
            force_dmg_bonus=dmg_bonus,
            force_die=die_code,
        )
        return head

    def _cast_light_or_darkness(
        self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str], spell_name: str
    ):
        

        chan_id   = str(ctx.channel.id)
        is_dark   = (spell_name or "").strip().lower().startswith("dark")
        src_word  = "Darkness" if is_dark else "Light"
        src_emoji = "ðŸŒ‘" if is_dark else "ðŸŒŸ"


        key     = "darkness" if is_dark else "light"
        opp_key = "light"    if is_dark else "darkness"


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        turns  = 6 + max(0, int(caster_level))
        rounds = turns * 60


        if not tokens:
            lines = []
            if bcfg and bcfg.has_section(chan_id):

                names = _parse_combatants(bcfg, chan_id)[0]
                self_key = _find_ci_name(names, caster_name) or caster_name
                try:
                    s_self = _slot(self_key)
                except Exception:
                    s_self = self_key.replace(" ", "_")


                for k in (f"{s_self}.{opp_key}",
                          f"{s_self}.{opp_key}_by",
                          f"{s_self}.{opp_key}_level",
                          f"{s_self}.{opp_key}_perm"):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k)


                bcfg.set(chan_id, f"{s_self}.{key}",        str(rounds))
                bcfg.set(chan_id, f"{s_self}.{key}_by",     caster_name)
                bcfg.set(chan_id, f"{s_self}.{key}_level",  str(int(caster_level)))
                _save_battles(bcfg)

                lines.append(f"{src_emoji} **{src_word}** aura persists on **{caster_name}** for **{turns} turns** ({rounds} rounds).")
                lines.append("(Area effect only; no blindness applied.)")
                return lines
            else:

                return [
                    f"{src_word} aura created on **{caster_name}** for **{turns} turns** ({rounds} rounds).",
                    "No active battle here â€” effect wonâ€™t auto-tick automatically."
                ]



        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tokens[0])
        except Exception:
            tgt_disp, tgt_path = tokens[0], None
            base = tgt_disp.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path:
            return [f"âŒ Target **{tokens[0]}** not found."]

        t_cfg = read_cfg(tgt_path)
        lines = [f"{src_emoji} **{caster_name}** targets **{tgt_disp}**â€™s eyes!"]

        if bcfg and bcfg.has_section(chan_id):
            names = _parse_combatants(bcfg, chan_id)[0]
            key_ci = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                s_tgt = _slot(key_ci)
            except Exception:
                s_tgt = key_ci.replace(" ", "_")


            left  = bcfg.getint(chan_id, f"{s_tgt}.blind",       fallback=0)
            src   = bcfg.get    (chan_id, f"{s_tgt}.blind_src",  fallback="")
            o_lvl = bcfg.getint(chan_id, f"{s_tgt}.blind_level", fallback=0)


            if left > 0 and src in ("light", "darkness") and src != ("darkness" if is_dark else "light"):
                if int(caster_level) >= int(o_lvl):
                    for k in (f"{s_tgt}.blind", f"{s_tgt}.blind_src", f"{s_tgt}.blind_by", f"{s_tgt}.blind_level"):
                        if bcfg.has_option(chan_id, k):
                            bcfg.remove_option(chan_id, k)
                    _save_battles(bcfg)
                    lines.append(f"Opposed **{src.title()}** blindness dispelled (level {o_lvl} â‰¤ {caster_level}).")
                    return lines
                else:
                    lines.append(f"No effect â€” existing **{src.title()}** blindness is from a higher-level caster (level {o_lvl} > {caster_level}).")
                    return lines


        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            lines.append(f"Mirror Image: a figment is struck and shatters. Images remaining: **{left_imgs}**.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
        lines.append(f"Save vs Death/Poison: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
        if sv_ok:
            lines.append("No effect on a successful save.")
            return lines


        if bcfg and bcfg.has_section(chan_id):
            names = _parse_combatants(bcfg, chan_id)[0]
            key_ci = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                s_tgt = _slot(key_ci)
            except Exception:
                s_tgt = key_ci.replace(" ", "_")

            bcfg.set(chan_id, f"{s_tgt}.blind",       str(rounds))
            bcfg.set(chan_id, f"{s_tgt}.blind_src",   ("darkness" if is_dark else "light"))
            bcfg.set(chan_id, f"{s_tgt}.blind_by",    caster_name)
            bcfg.set(chan_id, f"{s_tgt}.blind_level", str(int(caster_level)))
            _save_battles(bcfg)

            lines.append(f"**BLINDED** by **{src_word}** for **{turns} turns** ({rounds} rounds).")
            lines.append("Attack rolls **âˆ’4**; AC **âˆ’4**.")
            return lines
        else:
            return [
                f"**BLINDED** by **{src_word}** for **{turns} turns** ({rounds} rounds).",
                "Attack rolls **âˆ’4**; AC **âˆ’4**.",
                "No active battle here â€” effect wonâ€™t auto-tick automatically."
            ]

    def _effect__continual_lod(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
        is_dark: bool,
    ):
        """
        Continual Light / Continual Darkness (shared core)
        Range 360'; Duration: 1 year/level â†’ treated as indefinite in combat.
        No-target: create an indefinite aura on the caster (Light or Darkness).
        Targeted: save vs Death Ray (poi) or be BLINDED indefinitely (â€“4 to hit; â€“4 AC).
                  On a successful save, the globe flashes behind the target (message only).
        Opposed effects: dispel opposite blindness/aura if caster level >= source level.
        """
        

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        PERM_ROUNDS = 10_000_000

        src_word  = "Continual Darkness" if is_dark else "Continual Light"
        src_emoji = "ðŸŒ‘" if is_dark else "ðŸ’¡"
        aura_key  = "darkness" if is_dark else "light"
        opp_key   = "light" if is_dark else "darkness"
        blind_src = "cdarkness" if is_dark else "clight"


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None


        if not tokens:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                self_key = _find_ci_name(names, caster_name) or caster_name
                try:
                    s_self = _slot(self_key)
                except Exception:
                    s_self = self_key.replace(" ", "_")


                opp_left = bcfg.getint(chan_id, f"{s_self}.{opp_key}", fallback=0)
                opp_lvl  = bcfg.getint(chan_id, f"{s_self}.{opp_key}_level", fallback=0)
                if opp_left > 0 and int(caster_level) >= int(opp_lvl):
                    for k in (f"{s_self}.{opp_key}",
                              f"{s_self}.{opp_key}_by",
                              f"{s_self}.{opp_key}_level",
                              f"{s_self}.{opp_key}_perm"):
                        if bcfg.has_option(chan_id, k):
                            bcfg.remove_option(chan_id, k)


                bcfg.set(chan_id, f"{s_self}.{aura_key}", str(PERM_ROUNDS))
                bcfg.set(chan_id, f"{s_self}.{aura_key}_perm", "1")
                bcfg.set(chan_id, f"{s_self}.{aura_key}_by", caster_name)
                bcfg.set(chan_id, f"{s_self}.{aura_key}_level", str(int(caster_level)))
                _save_battles(bcfg)

                return [f"{src_emoji} **{src_word}** radiates from **{caster_name}** indefinitely (in-combat).",
                        "(Area effect only; no blindness applied.)"]
            else:
                return [f"{src_word} created on **{caster_name}** (treated as indefinite; no active battle to tick)."]


        tgt_disp, tgt_path = _resolve_char_ci_local(tokens[0])
        if not tgt_path:
            return [f"âŒ Target **{tokens[0]}** not found."]
        t_cfg = read_cfg(tgt_path)

        lines = [f"{src_emoji} **{caster_name}** flares **{src_word}** at **{tgt_disp}**â€™s eyes!"]


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                s_tgt = _slot(key)
            except Exception:
                s_tgt = key.replace(" ", "_")

            left  = bcfg.getint(chan_id, f"{s_tgt}.blind",      fallback=0)
            src   = (bcfg.get(chan_id, f"{s_tgt}.blind_src",     fallback="") or "").lower()
            o_lvl = bcfg.getint(chan_id, f"{s_tgt}.blind_level", fallback=0)

            opp_sources = ("light", "clight") if is_dark else ("darkness", "cdarkness")
            if left > 0 and src in opp_sources and int(caster_level) >= int(o_lvl):
                for k in (f"{s_tgt}.blind",
                          f"{s_tgt}.blind_src",
                          f"{s_tgt}.blind_by",
                          f"{s_tgt}.blind_level",
                          f"{s_tgt}.blind_perm"):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k)
                _save_battles(bcfg)
                lines.append(f"Opposed **{('Light' if is_dark else 'Darkness')}** blindness dispelled (level {o_lvl} â‰¤ {caster_level}).")
                return lines


        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            lines.append(f"Mirror Image: a figment is struck and shatters. Images remaining: **{left_imgs}**.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
        lines.append(f"Save vs Death Ray: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
        if sv_ok:
            lines.append("They turn away in time; the globe flashes **in the air just behind them**.")
            return lines


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                s_tgt = _slot(key)
            except Exception:
                s_tgt = key.replace(" ", "_")

            bcfg.set(chan_id, f"{s_tgt}.blind",       str(PERM_ROUNDS))
            bcfg.set(chan_id, f"{s_tgt}.blind_perm",  "1")
            bcfg.set(chan_id, f"{s_tgt}.blind_src",   blind_src)
            bcfg.set(chan_id, f"{s_tgt}.blind_by",    caster_name)
            bcfg.set(chan_id, f"{s_tgt}.blind_level", str(int(caster_level)))
            _save_battles(bcfg)

            lines.append(f"**BLINDED** by **{src_word}** **indefinitely** (â€“4 to hit; AC **â€“4**).")
            return lines
        else:
            lines += ["**BLINDED** indefinitely (â€“4 to hit; AC â€“4).",
                      "No active battle here â€” effect wonâ€™t auto-tick automatically."]
            return lines

    def _effect_continuallight(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        return self._effect__continual_lod(ctx, caster_cfg, caster_name, caster_level, tokens, is_dark=False)

    def _effect_continualdarkness(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        return self._effect__continual_lod(ctx, caster_cfg, caster_name, caster_level, tokens, is_dark=True)

    def _effect_colorspray(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Color Spray (Illusionist 1) â€” cone AoE: supply any number of targets
        Usage: !cast colorspray go1 go2 go3 ...
        Rules implemented:
          - 2 HD or less: Unconscious 2d4 rounds, then Blind 1d4 rounds
          - 3â€“4 HD: Blind 1d4 rounds
          - 5+ HD: Blind 1 round
          - If target has MORE HD/levels than caster OR has 6+ HD/levels â†’ Save vs Spells negates
          - Undead / already sightless: no effect
        """
        

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass

            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        def _hd_or_level(t_cfg, t_path) -> int:
            


            try:

                hd_val = getint_compat(t_cfg, "base", "hd", fallback=None)
                if isinstance(hd_val, int) and hd_val is not None and hd_val > 0:
                    return hd_val
            except Exception:
                pass


            try:
                raw_hd = (get_compat(t_cfg, "base", "hd", fallback="") or "").strip()
                if raw_hd:
                    m = re.match(r"\s*(\d+)", raw_hd)
                    if m:
                        return int(m.group(1))
            except Exception:
                pass


            try:
                lvl = getint_compat(t_cfg, "cur", "level", fallback=None)
                if isinstance(lvl, int) and lvl is not None and lvl > 0:
                    return lvl
            except Exception:
                pass


            return 1


        def _save_vs_spells(t_cfg):
            for tag in ("spl", "spell", "spells"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)

        lines = ["ðŸŒˆ **Color Spray** bursts forth!"]
        if not tokens:
            lines.append("*(Add targets: `!cast colorspray goblin orc ...`)*")
            return lines

        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass


            blind_left = 0
            slot = None
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")
                try:
                    blind_left = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                except Exception:
                    blind_left = 0
            if blind_left > 0:
                lines.append(f"â€¢ **{tgt_disp}**: ðŸ™ˆ Already sightless â€” **no effect**.")
                continue

            hd = _hd_or_level(t_cfg, tgt_path)


            needs_save = (hd > int(caster_level)) or (hd >= 6)
            if needs_save:
                sv_ok, sv_roll, sv_dc, _ = _save_vs_spells(t_cfg)
                if sv_dc is not None:
                    if sv_ok:
                        lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **RESISTED**")
                        continue
                    else:
                        lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **FAIL**")
                else:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): *(no save table â€” treating as failed)*")


            if hd <= 2:

                u_s, u_rolls, _ = roll_dice("2d4")
                b_s, b_rolls, _ = roll_dice("1d4")
                u_rounds = max(0, u_s)
                b_rounds = max(0, b_s)

                if bcfg and bcfg.has_section(chan_id):

                    prev_par = bcfg.getint(chan_id, f"{slot}.paralyzed", fallback=0)
                    new_par = max(prev_par, u_rounds)
                    if new_par > 0:
                        bcfg.set(chan_id, f"{slot}.paralyzed", str(new_par))
                    if b_rounds > 0:
                        bcfg.set(chan_id, f"{slot}.cs_blind_pending", str(b_rounds))
                        bcfg.set(chan_id, f"{slot}.cs_blind_by", caster_name)
                    _save_battles(bcfg)

                    lines.append(
                        f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ˜´ **UNCONSCIOUS** for **{u_rounds} rounds** "
                        f"({', '.join(str(r) for r in u_rolls)}) â†’ then ðŸ™ˆ **BLIND** for **{b_rounds} rounds** "
                        f"({', '.join(str(r) for r in b_rolls)})."
                    )
                else:
                    lines.append(
                        f"â€¢ **{tgt_disp}** (HD {hd}): would be **Unconscious {u_rounds} rounds**, then **Blind {b_rounds} rounds** "
                        "(no active battle â€” not applied)."
                    )

            elif 3 <= hd <= 4:

                b_s, b_rolls, _ = roll_dice("1d4")
                b_rounds = max(0, b_s)
                if bcfg and bcfg.has_section(chan_id):
                    prev_bl = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                    new_bl = max(prev_bl, b_rounds)
                    if new_bl > 0:
                        bcfg.set(chan_id, f"{slot}.blind", str(new_bl))
                        bcfg.set(chan_id, f"{slot}.blind_src", "colorspray")
                        bcfg.set(chan_id, f"{slot}.blind_by", caster_name)
                    _save_battles(bcfg)

                    lines.append(
                        f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ™ˆ **BLIND** for **{b_rounds} rounds** "
                        f"({', '.join(str(r) for r in b_rolls)})."
                    )
                else:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): would be **Blind {b_rounds} rounds** (not applied).")

            else:

                if bcfg and bcfg.has_section(chan_id):
                    prev_bl = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                    new_bl = max(prev_bl, 1)
                    bcfg.set(chan_id, f"{slot}.blind", str(new_bl))
                    bcfg.set(chan_id, f"{slot}.blind_src", "colorspray")
                    bcfg.set(chan_id, f"{slot}.blind_by", caster_name)
                    _save_battles(bcfg)
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ™ˆ **BLIND** for **1 round**.")
                else:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): would be **Blind 1 round** (not applied).")

        return lines

    def _effect_sleep(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Sleep (Magic-User 1)
        Range 90'; AoE 30' radius (not spatially enforcedâ€”supply targets)
        Duration: 5 rounds/level
        Rules implemented:
          â€¢ Affects any number of targets with 3 HD or less (each gets a Save vs Spells).
          â€¢ At most ONE 4 HD creature (if it fails its save).
          â€¢ 5+ HD: unaffected.
          â€¢ Undead / Constructs / already Unconscious: unaffected.
          â€¢ Marked as 'sleep' (and paralyzed for the same duration so your engine gates actions).
        Special hooks (below): attacks auto-hit sleepers; damage wakes them for next round.
        """
        

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None


        def _hd_or_level(t_cfg, t_path) -> int:
            
            try:
                hd_val = getint_compat(t_cfg, "base", "hd", fallback=None)
                if isinstance(hd_val, int) and hd_val and hd_val > 0:
                    return hd_val
            except Exception:
                pass
            try:
                raw_hd = (get_compat(t_cfg, "base", "hd", fallback="") or "").strip()
                if raw_hd:
                    m = re.match(r"\s*(\d+)", raw_hd)
                    if m:
                        return int(m.group(1))
            except Exception:
                pass
            try:
                lvl = getint_compat(t_cfg, "cur", "level", fallback=None)
                if isinstance(lvl, int) and lvl and lvl > 0:
                    return lvl
            except Exception:
                pass
            return 1


        def _save_vs_spells(t_cfg):
            for tag in ("spl", "spell", "spells"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)


        def _is_constructish_cfg(t_cfg, disp: str) -> bool:
            try:
                blob = " ".join(
                    [
                        (get_compat(t_cfg, "base", "type", fallback="") or ""),
                        (get_compat(t_cfg, "info", "race", fallback="") or ""),
                        (disp or ""),
                    ]
                ).lower()
                for kw in ("construct", "golem", "animated object", "statue"):
                    if kw in blob:
                        return True
            except Exception:
                pass
            return False

        lines = [f"ðŸ’¤ **Sleep** settles over the area! *(Duration: {max(1, int(caster_level) * 5)} rounds)*"]
        if not tokens:
            lines.append("*(Add targets: `!cast sleep goblin goblin orc ...`)*")
            return lines

        rounds_total = max(1, int(caster_level) * 5)
        four_hd_used = False

        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass
            if _is_constructish_cfg(t_cfg, tgt_disp):
                lines.append(f"â€¢ **{tgt_disp}**: ðŸ—¿ Construct â€” **no effect**.")
                continue


            already_uncon = 0
            slot = None
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")
                already_uncon = bcfg.getint(chan_id, f"{slot}.paralyzed", fallback=0)
            if already_uncon > 0:
                lines.append(f"â€¢ **{tgt_disp}**: already **unconscious** â€” **no effect**.")
                continue


            hd = _hd_or_level(t_cfg, tgt_path)
            if hd >= 5:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): 5+ HD â€” **unaffected**.")
                continue
            if hd == 4 and four_hd_used:
                lines.append(f"â€¢ **{tgt_disp}** (HD 4): only one 4 HD target per casting â€” **no effect**.")
                continue


            sv_ok, sv_roll, sv_dc, _ = _save_vs_spells(t_cfg)
            if sv_dc is not None:
                if sv_ok:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **RESISTED**")
                    continue
                else:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **FAIL**")
            else:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): *(no save table â€” treating as failed)*")


            if bcfg and bcfg.has_section(chan_id):
                prev_sleep = bcfg.getint(chan_id, f"{slot}.sleep", fallback=0)
                prev_par   = bcfg.getint(chan_id, f"{slot}.paralyzed", fallback=0)
                new_val = max(prev_sleep, rounds_total)
                bcfg.set(chan_id, f"{slot}.sleep", str(new_val))
                bcfg.set(chan_id, f"{slot}.paralyzed", str(max(prev_par, new_val)))
                bcfg.set(chan_id, f"{slot}.sleep_by", caster_name)
                _save_battles(bcfg)
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ˜´ **ASLEEP** for **{rounds_total} rounds**.")
            else:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): would be **Asleep {rounds_total} rounds** (no active battle).")

            if hd == 4:
                four_hd_used = True

        return lines

    def _effect_colorcloud(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        cloud_rounds = max(1, int(caster_level))
        lines = ["ðŸŒ«ï¸ **Color Cloud** billows out!"]

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

            bcfg.set(chan_id, f"{s_me}.cc",       str(cloud_rounds))
            bcfg.set(chan_id, f"{s_me}.cc_by",    caster_name)
            bcfg.set(chan_id, f"{s_me}.cc_level", str(int(caster_level)))
            _save_battles(bcfg)

            lines.append(
                f"Cloud persists on **{caster_name}** for **{cloud_rounds} rounds**. "
                "*(Use `!a colorcloud ...` while it lasts â€” even out of turn.)*"
            )
        else:
            lines.append(f"Cloud would persist for **{cloud_rounds} rounds** (no active battle here, not auto-ticking).")

        if tokens:
            lines.extend(self._apply_colorcloud_to_targets(chan_id, bcfg, caster_name, caster_level, tokens))

        return lines

    def _apply_colorcloud_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        
        lines = []

        def _save_vs_spells(t_cfg):
            for tag in ("spl","spell","spells"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass


            s_tgt = None
            blind_left = 0
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key   = _find_ci_name(names, tgt_disp) or tgt_disp
                s_tgt = self._effect_slot_for(bcfg, chan_id, key)
                try:
                    blind_left = bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0)
                except Exception:
                    blind_left = 0

            if blind_left > 0:
                lines.append(f"â€¢ **{tgt_disp}**: ðŸ™ˆ Already sightless â€” **no effect**.")
                continue

            hd = self._hd_or_level_from_cfg(t_cfg)
            try:
                caster_lvl = int(caster_level)
            except Exception:
                caster_lvl = 0

            needs_save = (hd > caster_lvl) or (hd >= 10)
            if needs_save:
                sv_ok, sv_roll, sv_dc, _ = _save_vs_spells(t_cfg)
                if sv_dc is not None:
                    if sv_ok:
                        lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **RESISTED**")
                        continue
                    else:
                        lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **FAIL**.")
                else:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): *(no save table â€” treating as failed)*")


            if hd <= 4:
                u_s, u_rolls, _ = roll_dice("2d4")
                b_s, b_rolls, _ = roll_dice("1d4")
                u_rounds = max(0, u_s)
                b_rounds = max(0, b_s)

                if bcfg and bcfg.has_section(chan_id) and s_tgt:
                    prev = bcfg.getint(chan_id, f"{s_tgt}.paralyzed", fallback=0)
                    newv = max(prev, u_rounds)
                    if newv > 0:
                        bcfg.set(chan_id, f"{s_tgt}.paralyzed", str(newv))
                        bcfg.set(chan_id, f"{s_tgt}.paralyzed_by", "colorcloud")
                    if b_rounds > 0:
                        bcfg.set(chan_id, f"{s_tgt}.cc_blind_pending", str(b_rounds))
                        bcfg.set(chan_id, f"{s_tgt}.cc_blind_by", caster_name)
                    _save_battles(bcfg)

                lines.append(
                    f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ˜´ **UNCONSCIOUS** for **{u_rounds} rounds** "
                    f"({', '.join(str(r) for r in u_rolls)}) â†’ then ðŸ™ˆ **BLIND** for **{b_rounds} rounds** "
                    f"({', '.join(str(r) for r in b_rolls)})."
                )

            elif 5 <= hd <= 8:
                b_s, b_rolls, _ = roll_dice("1d4")
                b_rounds = max(0, b_s)
                if bcfg and bcfg.has_section(chan_id) and s_tgt and b_rounds > 0:
                    prev_bl = bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0)
                    new_bl  = max(prev_bl, b_rounds)
                    bcfg.set(chan_id, f"{s_tgt}.blind", str(new_bl))
                    bcfg.set(chan_id, f"{s_tgt}.blind_src", "colorcloud")
                    bcfg.set(chan_id, f"{s_tgt}.blind_by", caster_name)
                    _save_battles(bcfg)

                lines.append(
                    f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ™ˆ **BLIND** for **{b_rounds} rounds** "
                    f"({', '.join(str(r) for r in b_rolls)})."
                )

            else:
                if bcfg and bcfg.has_section(chan_id) and s_tgt:
                    prev_bl = bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0)
                    new_bl  = max(prev_bl, 1)
                    bcfg.set(chan_id, f"{s_tgt}.blind", str(new_bl))
                    bcfg.set(chan_id, f"{s_tgt}.blind_src", "colorcloud")
                    bcfg.set(chan_id, f"{s_tgt}.blind_by", caster_name)
                    _save_battles(bcfg)
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): ðŸ™ˆ **BLIND** for **1 round**.")

        return lines

    def _resolve_char_ci_local(self, name: str):
        """
        Case-insensitive resolver: try normal resolver; then look for <name>.coe or <name>.ini.
        Returns (display_name, path) or (name, None).
        """
        
        try:
            return self._resolve_char_ci(name)
        except Exception:
            pass

        base = (name or "").replace(" ", "_")
        want = {f"{base}.coe".lower(), f"{base}.ini".lower()}
        for fn in os.listdir("."):
            if fn.lower() in want:
                path = fn
                try:
                    cfg = read_cfg(path)
                    real = get_compat(cfg, "info", "name", fallback=None)
                    disp = (real or fn[:-4].replace("_", " "))
                    return disp, path
                except Exception:
                    return fn[:-4].replace("_", " "), path
        return name, None

    def _effect_slot_for(self, cfg, chan_id: str, display_or_key: str) -> str:
        """
        Pick the slot string for an actor, preferring whichever candidate already
        has timers/queues (PAR/BL/cc/cs queues, etc.).
        """

        cands = []
        try:
            cands.append(_slot(display_or_key))
        except Exception:
            pass
        cands.append((display_or_key or "").replace(" ", "_"))

        prefer = (
            "paralyzed","blind","cc_blind_pending","cs_blind_pending","cc",
            "magwep","ghh","magearmor","boneskin","sph","shl","light","darkness"
        )
        for s in cands:
            if any(cfg.has_option(chan_id, f"{s}.{k}") for k in prefer):
                return s
        return cands[0]

    def _effect_cloudkill(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        cloud_rounds = max(1, int(caster_level) * 6)
        lines = ["â˜£ï¸ **Cloudkill** rolls forth!"]

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


            bcfg.set(chan_id, f"{s_me}.ck",       str(cloud_rounds))
            bcfg.set(chan_id, f"{s_me}.ck_by",    caster_name)
            bcfg.set(chan_id, f"{s_me}.ck_level", str(int(caster_level)))
            _save_battles(bcfg)

            lines.append(
                f"Cloud persists on **{caster_name}** for **{cloud_rounds} rounds**. "
                "*(Use `!a cloudkill ...` while it lasts â€” even out of turn.)*"
            )
        else:
            lines.append(f"Cloud would persist for **{cloud_rounds} rounds** (no active battle here, not auto-ticking).")


        if tokens:
            lines.extend(self._apply_cloudkill_to_targets(chan_id, bcfg, caster_name, caster_level, tokens))

        return lines

    def _poison_immune(self, t_cfg) -> bool:
        """True if target has 'immune: poison' in [stats] or [base]."""
        
        def _split(v):
            return {t for t in re.split(r"[,\s]+", str(v or "").lower().strip()) if t}
        im_stats = _split(get_compat(t_cfg, "stats", "immune",  fallback=""))
        im_base  = _split(get_compat(t_cfg, "base",  "immune",  fallback=""))
        return "poison" in (im_stats | im_base)

    def _apply_cloudkill_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        
        lines = []

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass
            try:
                if self._poison_immune(t_cfg):
                    lines.append(f"â€¢ **{tgt_disp}**: ðŸ§ª Poison-immune â€” **no effect**.")
                    continue
            except Exception:
                pass


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
            if old_hp is None:
                lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
                continue
            if old_hp <= 0:
                lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
                continue


            hd = self._hd_or_level_from_cfg(t_cfg)


            died = False
            note = ""
            if hd <= 3:
                died = True
                note = "HD â‰¤ 3 â€” no save."
            else:

                sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
                if sv_dc is not None:
                    if sv_ok:
                        lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Poison {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED**")
                        continue
                    else:
                        note = f"Save vs Poison {sv_roll} vs {sv_dc} â†’ **FAIL**"
                        died = True
                else:
                    note = "*(no save table â€” treating as failed)*"
                    died = True


            if died:
                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)


                try:
                    is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
                except Exception:
                    is_mon = False

                if is_mon and bcfg and bcfg.has_section(chan_id):
                    try:
                        names, scores = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, tgt_disp) or tgt_disp
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            s = _slot(key)

                            for suf in (
                                ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                ".paralyzed",".blind",".blind_src",".blind_by",
                                ".cc_blind_pending",".cs_blind_pending",
                                ".cc",".cc_by",".cc_level",
                                ".ck",".ck_by",".ck_level",
                                ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                            ):
                                opt = f"{s}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names, scores)


                            cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                            if cur_turn == key:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                    except Exception:
                        pass


                    try:
                        
                        os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass


                try:

                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    before = _life_bar(old_hp, mhp, width=10)
                    after  = _life_bar(0, mhp, width=10)
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note}\n{before} â†’ **{after}** â˜ ï¸ **DEAD!**")
                except Exception:

                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note}\nHP {old_hp} â†’ **0** â˜ ï¸ **DEAD!**")

        return lines

    def _effect_hypnoticpattern(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Hypnotic Pattern
        - Affects total HD = 2d6 + caster_level
        - Apply to the lowest HD first; ties by the order the user typed targets
        - No save (per the provided text)
        - Sightless / blind-immune: no effect
        - While concentrating: HYP has no round counter (we store .hyp = 0)
        - On !conc drop: every .hyp_by == caster becomes .hyp = 2
        """
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŒ€ **Hypnotic Pattern** shimmers and dances!"]


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            bcfg.set(chan_id, f"{s_me}.hyp_conc", "1")
            bcfg.set(chan_id, f"{s_me}.hyp_conc_by", caster_name)
            bcfg.set(chan_id, f"{s_me}.hyp_conc_src", "Hypnotic Pattern")
            _save_battles(bcfg)
            lines.append("Concentration is **active**. *(Use `!conc drop` to end it â€” affected creatures will remain **HYP** for **2 rounds**.)*")
        else:
            lines.append("Concentration would persist (no active battle here, not auto-ticking).")


        def _resolve_any_ci(name: str):

            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass

            gfn = globals().get("_resolve_char_ci")
            if callable(gfn):
                try:
                    return gfn(name)
                except Exception:
                    pass

            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None


        cands = []
        idx = 0
        for raw in tokens or []:
            tgt_disp, tgt_path = _resolve_any_ci(raw)
            pretty = tgt_disp or raw
            if not tgt_path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
            hd = self._hd_or_level_from_cfg(t_cfg)

            s_tgt = None
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty) or pretty
                try:
                    s_tgt = _slot(key)
                except Exception:
                    s_tgt = key.replace(" ", "_")

            cands.append((hd, idx, pretty, tgt_path, s_tgt))
            idx += 1


        cands.sort(key=lambda x: (x[0], x[1]))


        d_sum, d_rolls, d_flat = roll_dice("2d6")
        pool = max(0, d_sum + int(caster_level))
        lines.append(f"HD pool: 2d6 [{', '.join(str(r) for r in d_rolls)}] + {int(caster_level)} â†’ **{pool} HD**")

        if not cands:
            return lines

        def _sightless_or_blindimmune(t_cfg, s_tgt):

            try:
                if bcfg and bcfg.has_section(chan_id) and s_tgt:
                    if bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0) > 0:
                        return True
            except Exception:
                pass

            txt = " ".join([
                str(get_compat(t_cfg, "info", "immune", fallback="")),
                str(get_compat(t_cfg, "info", "immunity", fallback="")),
                str(get_compat(t_cfg, "stats", "immune", fallback="")),
                str(get_compat(t_cfg, "stats", "immunity", fallback="")),
                str(get_compat(t_cfg, "traits", "immune", fallback="")),
                str(get_compat(t_cfg, "traits", "immunity", fallback="")),
            ]).lower()
            if any(k in txt for k in ("blind", "blindness", "sightless", "gaze immune", "immune: blind", "immuneblind")):
                return True
            if str(get_compat(t_cfg, "info", "sightless", fallback="")).strip().lower() in {"1","true","yes","y"}:
                return True
            return False


        for (hd, _i, pretty, tgt_path, s_tgt) in cands:
            t_cfg = read_cfg(tgt_path)

            if _sightless_or_blindimmune(t_cfg, s_tgt):
                lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ‘ï¸â€ðŸ—¨ï¸ **sightless/immune** â€” no effect.")
                continue

            if pool < hd:
                lines.append(f"â€¢ **{pretty}** (HD {hd}): not enough HD left (**{pool}** remain) â€” **skipped**.")
                continue

            pool -= hd

            if bcfg and bcfg.has_section(chan_id) and s_tgt:

                bcfg.set(chan_id, f"{s_tgt}.hyp", "0")
                bcfg.set(chan_id, f"{s_tgt}.hyp_by", caster_name)
                _save_battles(bcfg)

            lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ˜µ **MESMERIZED**")

        if pool > 0:
            lines.append(f"Unused HD remaining: **{pool}**")

        return lines

    @commands.group(name="conc", invoke_without_command=True)
    async def conc(self, ctx, action: str = None):
        """Concentration controls. Use: !conc (status) or !conc drop (stop)"""
        if not action:
            await self._conc_status(ctx)
            return
        if action.lower() in {"drop","end","stop","release","break"}:
            await self._conc_drop(ctx)
        else:
            await ctx.send("Unknown action. Try `!conc drop`.")

    
    async def _conc_status(self, ctx):
        """
        Show what the active PC is currently concentrating on in this channel.
        Looks for:
          â€¢ Hypnotic/Rainbow Pattern (hyp_conc + hyp_by targets)
          â€¢ Illusion figments that persist while concentrating (x_* with 0 rounds for PF/PI/SF)
          â€¢ Mislead's double (msl_conc on caster)
          â€¢ Conjure Elemental control (elem_conc on caster and elem_by on the elemental)
        """

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        caster_name = get_active(ctx.author.id)
        if not caster_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("âš ï¸ Not in an initiative tracker here.")
            return

        
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []
        me_key = _find_ci_name(names, caster_name) or caster_name
        try:
            s_me = _slot(me_key)
        except Exception:
            s_me = me_key.replace(" ", "_")

        lines = []

        
        try:
            hyp_left = bcfg.getint(chan_id, f"{s_me}.hyp_conc", fallback=0)
        except Exception:
            hyp_left = 0
        if hyp_left > 0:
            src_label = bcfg.get(chan_id, f"{s_me}.hyp_conc_src", fallback="Hypnotic Pattern") or "Hypnotic Pattern"
            affected = []
            for nm in (names or []):
                try:
                    s = _slot(nm)
                except Exception:
                    s = nm.replace(" ", "_")
                by = bcfg.get(chan_id, f"{s}.hyp_by", fallback="")
                if by and by.lower() == caster_name.lower():
                    disp = bcfg.get(chan_id, f"{s}.disp", fallback=nm)
                    affected.append(disp)
            who = ", ".join(f"**{x}**" for x in affected) if affected else "(no current targets recorded)"
            lines.append(f"ðŸŒ€ **{src_label}** â€” mesmerized targets: {who} (will **linger 2 rounds** if you drop).")

        
        try:
            msl_left = bcfg.getint(chan_id, f"{s_me}.msl_conc", fallback=0)
        except Exception:
            msl_left = 0
        if msl_left > 0:
            lab = bcfg.get(chan_id, f"{s_me}.x_mislead_label", fallback="Mislead (Double)")
            lines.append(f"ðŸªž **{lab}** â€” figment persists while you concentrate (**drops to 3 rounds** if you stop).")

        
        def _norm_spell_label(s: str) -> str:
            return "".join(ch.lower() for ch in (s or "") if ch.isalnum())

        CONC_SPELLS = {"hypnoticpattern", "rainbowpattern", "phantasmalimage", "phantasmalforce", "spectralforce", "mislead"}

        try:
            opts = dict(bcfg.items(chan_id))
        except Exception:
            opts = {}

        for k, v in list(opts.items()):
            
            if not k.startswith(f"{s_me}.x_") or k.endswith(("_label","_emoji","_code","_by")):
                continue
            
            try:
                if int(v) != 0:
                    continue
            except Exception:
                continue
            base = k.split(".")[-1]               
            by   = bcfg.get(chan_id, f"{s_me}.{base}_by",    fallback="")
            lab  = bcfg.get(chan_id, f"{s_me}.{base}_label", fallback="")
            if not by or by.lower() != caster_name.lower():
                continue
            if _norm_spell_label(lab) not in CONC_SPELLS:
                continue
            emoji = bcfg.get(chan_id, f"{s_me}.{base}_emoji", fallback="ðŸŽ­")
            pretty = lab or base.replace("x_", "").title()
            lines.append(f"{emoji} **{pretty}** â€” active while concentrating.")

        
        try:
            elem_on = bcfg.getint(chan_id, f"{s_me}.elem_conc", fallback=0)
        except Exception:
            elem_on = 0

        controlled = []
        etypes = []
        if elem_on > 0:
            for nm in (names or []):
                try:
                    s = _slot(nm)
                except Exception:
                    s = nm.replace(" ", "_")

                
                if bcfg.getint(chan_id, f"{s}.hostile", fallback=0) > 0:
                    continue

                by = (bcfg.get(chan_id, f"{s}.elem_by", fallback="") or "").lower()
                if by != caster_name.lower():
                    continue

                disp = bcfg.get(chan_id, f"{s}.disp", fallback=nm)
                ety  = bcfg.get(chan_id, f"{s}.elem_type", fallback="elemental").title()
                controlled.append(disp)
                etypes.append(ety)

        if controlled:
            combos = ", ".join(f"**{n}** ({t})" for n, t in zip(controlled, etypes))
            lines.append(f"ðŸŒªï¸ **Elemental control** â€” {combos}. Use `!conc drop` to release (turns **hostile**).")



        if not lines:
            await ctx.send("ðŸ§  Nothing you're currently concentrating on.")
            return

        embed = nextcord.Embed(title="ðŸ§  Concentration", color=random.randint(0, 0xFFFFFF))
        for ln in lines:
            embed.add_field(name="â€”", value=ln, inline=False)
        await ctx.send(embed=embed)

    async def _conc_drop(self, ctx):
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        caster_name = get_active(ctx.author.id)
        if not caster_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return
        if not (bcfg and bcfg.has_section(chan_id)):
            await ctx.send("Thereâ€™s no active battle here.")
            return

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        try:
            s_me = _slot(me_key)
        except Exception:
            s_me = me_key.replace(" ", "_")


        def _norm_spell_label(s):
            return "".join(ch.lower() for ch in str(s) if ch.isalnum())


        CONC_SPELLS = {
            "hypnoticpattern", "rainbowpattern",
            "phantasmalimage", "phantasmalforce", "spectralforce",
        }


        affected_hyp = []
        src = bcfg.get(chan_id, f"{s_me}.hyp_conc_src", fallback="Hypnotic Pattern")
        if bcfg.getint(chan_id, f"{s_me}.hyp_conc", fallback=0) > 0:
            for nm in names:
                try:
                    s = _slot(nm)
                except Exception:
                    s = nm.replace(" ", "_")
                by = bcfg.get(chan_id, f"{s}.hyp_by", fallback="")
                if by and by.lower() == caster_name.lower():
                    cur = bcfg.getint(chan_id, f"{s}.hyp", fallback=0)
                    newv = max(2, cur if cur > 0 else 2)
                    bcfg.set(chan_id, f"{s}.hyp", str(newv))
                    affected_hyp.append(nm)

            for opt in (f"{s_me}.hyp_conc", f"{s_me}.hyp_conc_by", f"{s_me}.hyp_conc_src"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
                
                _save_battles(bcfg)



        ended_msl = []
        if bcfg.getint(chan_id, f"{s_me}.msl_conc", fallback=0) > 0:
            cur = bcfg.getint(chan_id, f"{s_me}.x_mislead", fallback=-1)
            by  = bcfg.get(chan_id,   f"{s_me}.x_mislead_by", fallback="")
            if cur >= 0 and by and by.lower() == caster_name.lower():
                bcfg.set(chan_id, f"{s_me}.x_mislead", "3")
                pretty_me = bcfg.get(chan_id, f"{s_me}.disp", fallback=caster_name)
                ended_msl.append(pretty_me)

            for opt in (f"{s_me}.msl_conc", f"{s_me}.msl_conc_by"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)


        ended_x = []

        for opt_key, _val in list(bcfg.items(chan_id)):
            if ".x_" not in opt_key:
                continue
            slot, base_key = opt_key.split(".", 1)
            if not base_key.startswith("x_"):
                continue

            lab = bcfg.get(chan_id, f"{slot}.{base_key}_label", fallback="")
            by  = bcfg.get(chan_id, f"{slot}.{base_key}_by",    fallback="")
            if not lab or not by:
                continue
            if by.lower() != caster_name.lower():
                continue
            if _norm_spell_label(lab) not in CONC_SPELLS:
                continue


            try:
                if bcfg.has_option(chan_id, f"{slot}.{base_key}"):
                    bcfg.remove_option(chan_id, f"{slot}.{base_key}")
                for suf in ("_label", "_emoji", "_code", "_by"):
                    mkey = f"{slot}.{base_key}{suf}"
                    if bcfg.has_option(chan_id, mkey):
                        bcfg.remove_option(chan_id, mkey)
                pretty_slot = bcfg.get(chan_id, f"{slot}.disp", fallback=slot.replace("_", " "))
                ended_x.append((pretty_slot, lab))
            except Exception:
                pass
        ended_gas = []
        for nm in names:
            try:
                s = _slot(nm)
            except Exception:
                s = nm.replace(" ", "_")

            gas_left = bcfg.getint(chan_id, f"{s}.gas", fallback=0)
            by_gas   = bcfg.get(chan_id, f"{s}.gas_by", fallback="")

            if gas_left > 0 and by_gas and by_gas.lower() == caster_name.lower():

                for opt in (f"{s}.gas", f"{s}.gas_by", f"{s}.gas_ac_hint"):
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)


                inw_left = bcfg.getint(chan_id, f"{s}.inw", fallback=0)
                inw_src  = (bcfg.get(chan_id, f"{s}.inw_by", fallback="") or "").lower()
                if inw_left > 0 and (
                    inw_src in {"gaseousform", "windwalk"} or
                    bcfg.getint(chan_id, f"{s}.windwalk", fallback=0) > 0
                ):
                    for opt in (f"{s}.inw", f"{s}.inw_by", f"{s}.windwalk"):
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)




        ended_elem = []
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            dm_id = bcfg.get(chan_id, "DM", fallback="")
            for nm in names:
                try:
                    s = _slot(nm)
                except Exception:
                    s = nm.replace(" ", "_")

                by = bcfg.get(chan_id, f"{s}.elem_by", fallback="")
                if not by or by.lower() != caster_name.lower():
                    continue


                bcfg.set(chan_id, f"{s}.hostile", "1")

                bcfg.remove_option(chan_id, f"{s}.elem_by") if bcfg.has_option(chan_id, f"{s}.elem_by") else None


                try:

                    path = f"{nm}.coe"
                    if os.path.exists(path):
                        ecfg = read_cfg(path)
                    else:

                        disp, pth = self._resolve_char_ci(nm)
                        path = pth
                        ecfg = read_cfg(path) if pth and os.path.exists(pth) else None
                    if ecfg:
                        if not ecfg.has_section("info"):
                            ecfg.add_section("info")
                        
                        if dm_id:
                            ecfg.set("info", "owner_id", str(dm_id))
                        
                        if ecfg.has_option("info", "controller"):
                            ecfg.remove_option("info", "controller")
                        
                        write_cfg(path, ecfg)

                except Exception:
                    pass

                pretty = bcfg.get(chan_id, f"{s}.disp", fallback=nm)
                ended_elem.append(pretty)


            for opt in (f"{s_me}.elem_conc", f"{s_me}.elem_conc_by"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
        except Exception:
            pass



        ended_aaf = []
        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                me_key = _find_ci_name(names, caster_name) or caster_name
                try:
                    s_me = _slot(me_key)
                except Exception:
                    s_me = me_key.replace(" ", "_")
                if bcfg.getint(chan_id, f"{s_me}.aaf", fallback=0) > 0:
                    await self._aaf_end(ctx, bcfg, chan_id, caster_name, reason="ended early")
                    ended_aaf.append(caster_name)
        except Exception:
            pass

        ended_tree = []
        try:

            left = bcfg.getint(chan_id, f"{s_me}.tree",    fallback=0)
            by   = (bcfg.get(chan_id, f"{s_me}.tree_by",   fallback="") or "")
            if left > 0 and (not by or by.lower() == caster_name.lower()):
                for suf in ("tree", "tree_by", "tree_code", "tree_label"):
                    opt = f"{s_me}.{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                pretty_me = bcfg.get(chan_id, f"{s_me}.disp", fallback=caster_name)
                ended_tree.append(pretty_me)
        except Exception:
            pass

        _save_battles(bcfg)


        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        emb = nextcord.Embed(title="ðŸ§  Concentration dropped", color=0xCC66FF)
        parts = []
        if affected_hyp:
            parts.append(f"**{caster_name}** ends **{src}**. `HYP 2` applied to: " +
                         ", ".join(f"**{n}**" for n in affected_hyp))

        if ended_msl:
            parts.append("Mislead released â€” doubles will persist **3 rounds**:\n" +
                         "\n".join(f"â€¢ **{n}**â€™s double â†’ `MSLD 3`" for n in ended_msl))

        if ended_x:
            lines = []
            for who, lab in ended_x:
                lines.append(f"â€¢ **{lab}** on **{who}** â€” ended")
            parts.append("Illusions ended:\n" + "\n".join(lines))
        if ended_gas:
            parts.append("Gaseous Form ended:\n" + "\n".join(f"â€¢ **{n}** â€” ended" for n in ended_gas))
        if ended_tree:
            parts.append("Tree Form ended:\n" + "\n".join(f"â€¢ **{n}** â€” back to normal" for n in ended_tree))
        if ended_aaf:
            parts.append("Animal Form ended early.")

        if ended_elem:
            parts.append("Elemental control released â€” they turn **hostile** (owner â†’ GM):\n" +
                         "\n".join(f"â€¢ **{n}**" for n in ended_elem))

        if not parts:
            parts.append(f"**{caster_name}** ends concentration. *(No active concentration effects found.)*")

        emb.description = "\n\n".join(parts)
        await ctx.send(embed=emb)



    def _effect_charmperson(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Charm Person
          â€¢ Targets a humanoid (monsters up to 4 HD; PCs/NPCs regardless of level)
          â€¢ Save vs Spells negates (target gets +5 if hostile/threatened)
          â€¢ No initiative tracker status (duration is long; GM adjudicates behavior)
        Flags:
          -h / -hostile      â†’ apply +5 to the save
          -nh / -nonhostile  â†’ do NOT apply the +5 bonus
        """
        

        chan_id = str(ctx.channel.id)
        head = "ðŸ’˜ **Charm Person** â€” a beguiling glamour ripples outwardâ€¦"


        raw_names: list[str] = []
        force_hostile = None
        for t in (tokens or []):
            t = str(t).strip()
            if not t:
                continue
            tl = t.lower()
            if tl in ("-h","-hostile","+5","hostile"):
                force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"):
                force_hostile = False
            else:
                raw_names.append(t)

        if not raw_names:
            return head + "\n*(Add a humanoid target, e.g., `!cast charmperson goblin`.)*"


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(raw_names[0])
        extras = [n for n in raw_names[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        if not tgt_path:
            return head + f"\n**{raw_names[0]}**: âŒ *(not found)*" + extra_note

        t_cfg = read_cfg(tgt_path)


        hostile_bonus = False
        if force_hostile is not None:
            hostile_bonus = bool(force_hostile)
        else:

            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    if bcfg.getint(chan_id, "round", fallback=0) >= 1:
                        hostile_bonus = True
            except Exception:
                pass


        ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or str(get_compat(t_cfg, "info", "type", fallback=""))).lower()
        non_humanoid = any(k in ty for k in (
            "undead","construct","golem","elemental","ooze","slime","plant",
            "vermin","beast","animal","dragon","demon","devil","fiend","ooze"
        ))


        if non_humanoid and "hum" not in ty:
            return head + f"\n**{tgt_disp}**: not a humanoid â€” no effect." + extra_note


        is_monster = _is_monster_file(tgt_path)
        hd_or_lv = self._hd_or_level_from_cfg(t_cfg)
        if is_monster and hd_or_lv > 4:
            return head + f"\n**{tgt_disp}** (HD {hd_or_lv}): too powerful (monsters over **4 HD** are unaffected)." + extra_note




        used_vs = "Spells"
        sv_roll = None; sv_dc = None
        for vs_key in ("spell","sp","spells"):
            try:
                ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                if dc is not None:
                    sv_roll, sv_dc = r, dc
                    used_vs = "Spells"
                    break
            except Exception:
                pass
        if sv_dc is None:
            sv_dc = 15
            sv_roll = sv_roll if sv_roll is not None else 10

        bonus = 5 if hostile_bonus else 0
        adj_roll = (sv_roll or 0) + bonus
        d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
        bonus_txt = f" + {bonus}" if bonus else ""
        passed = adj_roll >= sv_dc

        line = f"**{tgt_disp}** â€” Save vs {used_vs}: {d20_face}{bonus_txt} = ``{adj_roll}`` vs **{sv_dc}** â†’ "
        if passed:
            return head + "\n" + line + "âŒ **RESISTS**" + extra_note



        charm_note = (
            "ðŸ’— **CHARMED** â€” The target now regards the caster as a trusted ally. "
            "Orders must be communicated (language/gestures), and self-harm/ally-harming orders grant a new save at **+5** (GM adjudicates)."
        )
        return head + "\n" + line + charm_note + extra_note

    def _effect_calllightning(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Call Lightning
          â€¢ On cast: start a 'cl' status on the caster (rounds = level).
          â€¢ Bolts = floor(level/3). Damage 3d6 (or 3d8 with 'storm' flag).
          â€¢ If targets provided now, immediately call one bolt (counts this round).
        """
        
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lv = max(1, int(caster_level or 1))
        rounds = lv
        bolts  = max(0, lv // 3)

        tok_lc = [str(t).strip().lower() for t in (tokens or [])]
        stormy = any(t in {"storm", "-storm", "stormy"} for t in tok_lc)
        die_spec = "3d8" if stormy else "3d6"


        target_tokens = [t for t in (tokens or []) if str(t).strip().lower() not in {"storm", "-storm", "stormy"}]

        lines = [("â›ˆï¸" if stormy else "âš¡") + " **Call Lightning** â€” the air crackles with power!"]
        if stormy:
            lines.append("Storm signs detected â†’ bolts deal **3d8** instead of 3d6.")

        if bcfg and bcfg.has_section(chan_id):

            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

            bcfg.set(chan_id, f"{s_me}.cl",            str(rounds))
            bcfg.set(chan_id, f"{s_me}.cl_bolts",      str(bolts))
            bcfg.set(chan_id, f"{s_me}.cl_die",        die_spec)
            bcfg.set(chan_id, f"{s_me}.cl_by",         caster_name)
            bcfg.set(chan_id, f"{s_me}.cl_last_round", "0")
            _save_battles(bcfg)

            lines.append(
                f"Charge persists on **{caster_name}** for **{rounds} rounds**; "
                f"bolts available: **{bolts}** (max **1/round**). "
                "Use `!a calllightning <targets>` on your turn."
            )
        else:
            lines.append(f"Would persist for **{rounds} rounds** with **{bolts}** bolts (no active battle).")


        if target_tokens and bcfg and bcfg.has_section(chan_id) and bolts > 0:

            try:
                self._hyp_break_if_targeted(chan_id, list(target_tokens))
            except Exception:
                pass


            cur_round = bcfg.getint(chan_id, "round", fallback=1)
            fire_lines = self._apply_calllightning_to_targets(chan_id, bcfg, caster_name, die_spec, target_tokens)
            lines.append("**Immediate bolt on cast:**")
            lines.extend(fire_lines)



            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
            left   = bcfg.getint(chan_id, f"{s_me}.cl_bolts", fallback=bolts)
            if left > 0:
                bcfg.set(chan_id, f"{s_me}.cl_bolts", str(left - 1))
            bcfg.set(chan_id, f"{s_me}.cl_last_round", str(cur_round))
            _save_battles(bcfg)

        return lines

    def _apply_calllightning_to_targets(self, chan_id: str, bcfg, caster_name: str, die_spec: str, tokens: list[str]) -> list[str]:
        lines = []

        try:
            if bcfg and bcfg.has_section(chan_id) and tokens:
                self._hyp_break_if_targeted(chan_id, list(tokens))
        except Exception:
            pass

        dmg_sum, dmg_rolls, flat = roll_dice(die_spec)
        base = dmg_sum + flat
        lines.append(f"âš¡ Bolt damage: **{die_spec}** [{', '.join(str(r) for r in dmg_rolls)}] â†’ **{base}**")

        def _save_vs_spells(t_cfg):
            for tag in ("spl","spell","spells"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
            absorbs_electric = ("electric" in _collect_absorb_types(t_cfg))

            sv_ok, sv_roll, sv_dc, sv_pen = _save_vs_spells(t_cfg)
            if sv_dc is None:
                sv_ok = False

            pfl_bonus = self._pf_other_save_bonus(chan_id, tgt_disp, "electric")
            if absorbs_electric:
                sv_ok = False
            else:
                eff = sv_roll - (sv_pen or 0)
                if sv_dc is not None and not sv_ok and (eff + pfl_bonus) >= sv_dc:
                    sv_ok = True

            override = self._pf_other_damage_override(base, sv_ok, chan_id, tgt_disp, "electric")
            pre_mit  = override if override is not None else (base // 2 if sv_ok else base)

            final, note = _apply_mitigation(pre_mit, weapon_name="Call Lightning", weapon_type="electric",
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=tgt_disp, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(tgt_path, t_cfg)

            if _is_monster_file(tgt_path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10); after = _life_bar(new_hp, mhp2, width=10)
                hp_tail = f"{before} â†’ {after}"
            else:
                hp_tail = f"{old_hp} â†’ **{new_hp}**"

            bonus_txt = f" + {pfl_bonus}" if pfl_bonus else ""
            auto_txt  = " (auto-fail: absorbs electric)" if absorbs_electric else ""
            amt_txt   = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"
            dup_heal  = (final < 0) and note and ("heals" in note.lower())
            note_txt  = (f" ({note})" if note else "")
            amt_part  = ("" if dup_heal else f" â†’ {amt_txt}")
            res_txt   = " **HALF**" if override is None and sv_ok else ""  

            lines.append(
                f"â€¢ **{tgt_disp}**: Save vs Spells {sv_roll}{(f' - {sv_pen}' if sv_pen else '')}{bonus_txt} vs {sv_dc}"
                f"{auto_txt}{amt_part}{note_txt}{res_txt}\n"
                f"    {hp_tail}{' â˜ ï¸ **DEAD!**' if new_hp <= 0 else ''}"
            )

        return lines

    def _effect_charmmonster(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Charm Monster
          â€¢ Works on any living, thinking creature (not undead, constructs/golems, or mindless oozes/jellies/slimes).
          â€¢ If any named target has HD > 3 â†’ single-target mode (only that one).
          â€¢ Else â†’ group mode: 3d6 HD pool; only creatures of â‰¤ 3 HD are eligible.
          â€¢ Save vs Spells negates; +5 bonus if hostile/threatened (same as Charm Person).
          â€¢ No initiative tracker status (long duration; GM adjudicates).
        Flags:
          -h / -hostile      â†’ apply +5 to the save
          -nh / -nonhostile  â†’ do NOT apply the +5 bonus
        """

        chan_id = str(ctx.channel.id)
        head = "ðŸª„ðŸ **Charm Monster** â€” eldritch allure coils through the airâ€¦"


        raw_names: list[str] = []
        force_hostile = None
        for t in (tokens or []):
            t = str(t).strip()
            if not t:
                continue
            tl = t.lower()
            if tl in ("-h","-hostile","+5","hostile"):
                force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"):
                force_hostile = False
            else:
                raw_names.append(t)

        if not raw_names:
            return head + "\n*(Add targets, e.g., `!cast charmmonster ogre` or `!cast charmmonster gob1 gob2 gob3`.)*"


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg2 = read_cfg(path)
                            real = get_compat(cfg2, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None


        resolved = []
        for nm in raw_names:
            disp, pth = _resolve_any_ci(nm)
            if not pth:
                resolved.append({"raw": nm, "disp": nm, "path": None, "hd": None, "immune": "not found"})
                continue

            cfg_t = read_cfg(pth)
            hd = self._hd_or_level_from_cfg(cfg_t)



            try:
                if _is_undead_cfg(cfg_t, disp or nm):
                    resolved.append({"raw": nm, "disp": disp or nm, "path": pth, "hd": hd, "immune": "undead"})
                    continue
            except Exception:
                pass

            ty = (str(get_compat(cfg_t, "stats", "type", fallback="")) or str(get_compat(cfg_t, "info", "type", fallback=""))).lower()
            if any(k in ty for k in ("construct","golem","ooze","slime","jelly","mindless")):
                resolved.append({"raw": nm, "disp": disp or nm, "path": pth, "hd": hd, "immune": "construct/mindless"})
                continue

            resolved.append({"raw": nm, "disp": disp or nm, "path": pth, "hd": hd, "immune": None})


        hostile_bonus = False
        if force_hostile is not None:
            hostile_bonus = bool(force_hostile)
        else:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    if bcfg.getint(chan_id, "round", fallback=0) >= 1:
                        hostile_bonus = True
            except Exception:
                pass
        bonus = 5 if hostile_bonus else 0


        high = next((r for r in resolved if r["path"] and not r["immune"] and (r["hd"] or 0) > 3), None)
        lines = []


        def _save_vs_spells_line(t_cfg):
            used_vs = "Spells"
            sv_ok = False; sv_roll = 10; sv_dc = 15; sv_pen = 0
            for vs_key in ("spell","sp","spells"):
                try:
                    ok0, r, dc, pen = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                    if dc is not None:
                        sv_ok, sv_roll, sv_dc, sv_pen = ok0, r, dc, pen
                        break
                except Exception:
                    pass
            adj = (sv_roll or 0) + bonus
            passed = adj >= (sv_dc or 0)
            d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
            btxt = f" + {bonus}" if bonus else ""
            line = f"Save vs {used_vs}: {d20_face}{btxt} = ``{adj}`` vs **{sv_dc}** â†’ "
            return passed, line

        if high:

            tgt = high
            extras = [r["disp"] for r in resolved if r is not tgt and r["path"]]
            extra_note = (f"\n*(Single-target due to HD > 3; ignoring: {', '.join(extras)})*" if extras else "")

            if tgt["immune"]:
                reason = "undead" if tgt["immune"] == "undead" else "not a valid mind/construct"
                lines.append(f"**{tgt['disp']}**: {reason} â€” **no effect**.")
                return head + "\n" + "\n".join(lines) + extra_note

            t_cfg = read_cfg(tgt["path"])
            passed, sv_line = _save_vs_spells_line(t_cfg)
            if passed:
                lines.append(f"**{tgt['disp']}** â€” {sv_line}âŒ **RESISTS**")
            else:
                lines.append(
                    f"**{tgt['disp']}** â€” {sv_line}ðŸ’— **CHARMED** â€” The creature now regards the caster as a trusted ally. "
                    "Orders must be communicated (language/gestures); self-harm/ally-harming orders grant a new save at **+5** (GM adjudicates)."
                )
            return head + "\n" + "\n".join(lines) + extra_note



        elig = [r for r in resolved if r["path"] and not r["immune"] and (r["hd"] or 0) <= 3]
        if not elig:

            for r in resolved:
                if not r["path"]:
                    lines.append(f"**{r['disp']}**: âŒ *(not found)*")
                elif r["immune"]:
                    reason = "undead" if r["immune"] == "undead" else "construct/mindless â€” no effect"
                    lines.append(f"**{r['disp']}**: {reason}.")
                else:
                    lines.append(f"**{r['disp']}** (HD {r['hd'] or '?'}): too powerful for group charm (only â‰¤ 3 HD).")
            return head + "\n" + "\n".join(lines)

        d_sum, d_rolls, d_flat = roll_dice("3d6")
        pool = max(0, d_sum + d_flat)
        lines.append(f"Group charm: **3d6** [{', '.join(str(r) for r in d_rolls)}] â†’ **{pool} HD**")

        for r in elig:
            hd = int(r["hd"] or 0)

            if pool < hd:
                lines.append(f"â€¢ **{r['disp']}** (HD {hd}): not enough HD remaining (**{pool}** left) â€” **skipped**.")
                continue

            t_cfg = read_cfg(r["path"])
            passed, sv_line = _save_vs_spells_line(t_cfg)
            if passed:
                lines.append(f"â€¢ **{r['disp']}** (HD {hd}) â€” {sv_line}âŒ **RESISTS**.")

            else:
                pool -= hd
                lines.append(
                    f"â€¢ **{r['disp']}** (HD {hd}) â€” {sv_line}ðŸ’— **CHARMED** "
                    "(regards the caster as an ally; self-harm/ally-harming orders grant a new save at **+5**)."
                )
                if pool <= 0:
                    break

        if pool > 0:
            lines.append(f"Unused HD remaining: **{pool}**")

        return head + "\n" + "\n".join(lines)

    def _effect_confusion(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Confusion
          â€¢ Up to 3d6 living creatures (count, not HD) within 30' (caller supplies targets).
          â€¢ Save vs Spells to resist; on fail â†’ apply [CN N] where N = 2 + caster_level.
          â€¢ Undead/constructs/mindless (golem, ooze/jelly/slime, 'mindless') are unaffected.
          â€¢ No automation of movement/attacks; we announce behavior each turn.
        Usage examples:
          !cast confusion orc1 orc2 orc3 ...
        """

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        head = "ðŸª **Confusion**"


        def _res(name: str):
            return self._resolve_char_ci_local(name)


        k_sum, k_rolls, k_flat = roll_dice("3d6")
        cap = max(0, k_sum + k_flat)
        dur_rounds = max(0, 2 + int(caster_level or 0))

        if not tokens:
            return [f"{head}\nTargets: *(none)*\nCreatures affected this casting: **{cap}** â€¢ Duration on fail: **{dur_rounds} rds**"]

        lines = [f"{head}", f"Creatures affected (max): **3d6** [{', '.join(str(r) for r in k_rolls)}] â†’ **{cap}**",
                 f"Duration on failed save: **{dur_rounds} rounds**"]


        resolved = []
        for raw in tokens:
            disp, path = _res(raw)
            if not path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue
            t_cfg = read_cfg(path)


            try:
                if _is_undead_cfg(t_cfg, disp):
                    lines.append(f"â€¢ **{disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass
            ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
                  str(get_compat(t_cfg, "info", "type",  fallback=""))).lower()
            if any(k in ty for k in ("construct","golem","ooze","slime","jelly","mindless")):
                lines.append(f"â€¢ **{disp}**: construct/mindless â€” **no effect**.")
                continue

            resolved.append((disp, path))

        if not resolved:
            return lines


        chosen = resolved[:cap]
        overflow = resolved[cap:]
        for disp, path in chosen:
            t_cfg = read_cfg(path)


            sv_ok = None; sv_roll = 10; sv_dc = 15; sv_pen = 0
            for tag in ("spl","spell","spells"):
                ok, r, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    sv_ok, sv_roll, sv_dc, sv_pen = ok, r, dc, pen
                    break
            if sv_ok is None:
                sv_ok = False

            d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            if sv_ok:
                lines.append(f"â€¢ **{disp}** â€” Save vs Spells {d20_face}{pen_txt} vs {sv_dc} â†’ âŒ **RESISTED**")
            else:
                lines.append(f"â€¢ **{disp}** â€” Save vs Spells {d20_face}{pen_txt} vs {sv_dc} â†’ ðŸ˜µâ€ðŸ’« **CONFUSED**")

                if bcfg and bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, disp) or disp
                    s   = self._effect_slot_for(bcfg, chan_id, key)
                    try:
                        prev = bcfg.getint(chan_id, f"{s}.cn", fallback=0)
                    except Exception:
                        prev = 0
                    bcfg.set(chan_id, f"{s}.cn", str(max(prev, dur_rounds)))
                    bcfg.set(chan_id, f"{s}.cn_by", caster_name)
                    _save_battles(bcfg)

        for disp, _ in overflow:
            lines.append(f"â€¢ **{disp}**: exceeds target cap **({cap})** â€” not affected.")

        return lines

        def _conf_mark_if_targeted(self, chan_id: str, raw_names, by: str | None) -> None:
            """If a confused creature is targeted, mark it to RETALIATE vs the attacker next turn."""
            try:
                cfg = _load_battles()
                if not cfg.has_section(chan_id):
                    return

                names, _ = _parse_combatants(cfg, chan_id)
                attacker = (by or "").strip()

                for nm in (raw_names or []):
                    key = _find_ci_name(names, nm) or nm
                    try:
                        s = _slot(key)
                    except Exception:
                        s = str(key).replace(" ", "_")


                    if cfg.getint(chan_id, f"{s}.cn", fallback=0) > 0:
                        if attacker:
                            cfg.set(chan_id, f"{s}.cn_retaliate_by", attacker)

                            cfg.set(chan_id, f"{s}.cn_retaliate_round", cfg.get(chan_id, "round", fallback="0"))

                _save_battles(cfg)
            except Exception:
                pass

    def _effect_drainblade(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Drainblade (Touch) â€” 1 round/level
        Cast on a creature (self if no name). While active, their melee *slashing* hits vs living targets
        deal +1 extra damage; the wielder heals 1 HP (not beyond max) if that +1 applied.
        No effect vs nonliving (undead, constructs, oozes, elementals, plants, etc.).
        """
        lines = ["ðŸ©¸ **Drainblade**"]

        ch = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        target_raw = (tokens[0] if tokens else caster_name)


        def _resolve_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None

        tgt_disp, tgt_path = _resolve_ci(target_raw)
        pretty = tgt_disp or target_raw
        if not tgt_path:
            lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
            return lines

        rounds = max(1, int(caster_level))
        if bcfg and bcfg.has_section(ch):

            names, _ = _parse_combatants(bcfg, ch)
            key = _find_ci_name(names, pretty) or pretty
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")
            cur = bcfg.getint(ch, f"{slot}.db", fallback=0)
            bcfg.set(ch, f"{slot}.db", str(max(cur, rounds)))
            bcfg.set(ch, f"{slot}.db_by", caster_name)
            _save_battles(bcfg)
            lines.append(f"â€¢ **{pretty}** is now under **Drainblade** for **{rounds} rounds**.")
            lines.append("*(While active: melee **slashing** hits vs living targets deal **+1**; wielder heals **1 HP**.)*")
        else:
            lines.append(f"â€¢ Would persist for **{rounds} rounds** â€” no active battle here (not auto-ticking).")

        return lines

    async def _effect_inw(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Immunity to Normal Weapons (MU/Necro/Spellcrafter 3)
          â€¢ Touch range; target is immune to **non-magical weapons**.
          â€¢ Target also counts as **enchanted** for items that are â€œvs enchanted creaturesâ€.
          â€¢ Duration: 5 rounds + 1/level (tracked on **target's** slot).
          â€¢ Initiative storage (on target's slot):
              <slot>.inw        = rounds remaining (int)
              <slot>.inw_ench   = 1 (treat as enchanted creature)
        """

        chan_id = str(ctx.channel.id)
        rounds_total = max(1, 5 + int(max(1, caster_level or 1)))


        target_name_tok = (tokens[0] if tokens else caster_name)

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_ci(target_name_tok)
        if not tgt_path:
            return f"ðŸ’Ž **Immunity to Normal Weapons**: {target_name_tok}: *(not found)*"


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp or target_name_tok) or (tgt_disp or target_name_tok)
            s = _slot(key)
            bcfg.set(chan_id, f"{s}.inw", str(rounds_total))
            bcfg.set(chan_id, f"{s}.inw_ench", "1")
            _save_battles(bcfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return (f"ðŸ’Ž **Immunity to Normal Weapons** cast on **{tgt_disp or target_name_tok}** â€” "
                f"duration **{rounds_total} rounds**.\n"
                f"Immune to *non-magical weapons*; counts as **enchanted** for item effects.\n"
                f"*(Magical weapons, Oil, and Holy Water still work.)*")


    async def _effect_protectionnormalmissiles(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Protection from Normal Missiles (MU/Spellcrafter 3)
          â€¢ Self only. The caster is completely protected from *small, non-magical* missiles:
            arrows, sling bullets, crossbow bolts, thrown daggers, darts, etc.
          â€¢ Does NOT stop magical missiles, missiles fired from **magic** bows, or large hurled objects
            (e.g., hurled boulders; GM may also treat spears/javelins/axes as 'not small').
          â€¢ Duration: 1 turn/level = 60 * level rounds (tracked on caster's slot).
          â€¢ Initiative storage (on caster's slot):
              <slot>.pnm = rounds remaining (int)
        """

        chan_id = str(ctx.channel.id)
        lvl = max(1, int(caster_level or 1))
        rounds_total = 60 * lvl


        target_name = caster_name


        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_disp, tgt_path = _resolve_ci(target_name)
        if not tgt_path:
            return f"ðŸš€ **Protection from Normal Missiles**: {target_name}: *(not found)*"


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp or target_name) or (tgt_disp or target_name)
            s = _slot(key)
            bcfg.set(chan_id, f"{s}.pnm", str(rounds_total))
            _save_battles(bcfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        note = (
            "Blocks *normal* arrows/bolts/sling bullets/thrown daggers, etc. "
            "Does **not** stop magical missiles, shots from **magic bows**, or large hurled objects."
        )
        return (f"ðŸš€ **Protection from Normal Missiles** active on **{tgt_disp or target_name}** â€” "
                f"duration **{rounds_total} rounds**.\n{note}")




    def _con_mod(self, v: int) -> int:
        if v <= 3:  return -3
        if v <= 5:  return -2
        if v <= 8:  return -1
        if v <= 12: return 0
        if v <= 15: return +1
        if v <= 17: return +2
        return +3


    def _levels_count_for_hp(self, cfg) -> int:
        """How many HD-levels to apply CON bonus per die to.
           If you have a more precise table (e.g., stops at 9th), replace here."""
        return max(1, getint_compat(cfg, "cur", "level", fallback=1))

    def _get_con_state(self, cfg):
        """Return (cur_con, temp_loss, perm_loss, peak_loss, base_con)."""
        cur_con = getint_compat(cfg, "stats", "con", fallback=10)
        temp    = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
        perm    = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)
        peak    = getint_compat(cfg, "cur", "con_loss_peak", fallback=temp)
        base    = cur_con + temp + perm
        return cur_con, temp, perm, peak, base

    def _set_con_state(self, cfg, *, cur_con=None, temp=None, perm=None, peak=None):
        """Write back any provided pieces + section safety."""
        if not cfg.has_section("cur"):   cfg.add_section("cur")
        if not cfg.has_section("stats"): cfg.add_section("stats")
        if cur_con is not None:
            cfg["stats"]["con"] = str(max(1, int(cur_con)))
        if temp is not None:
            cfg["cur"]["con_loss_temp"] = str(max(0, int(temp)))
        if perm is not None:
            cfg["cur"]["con_loss_perm"] = str(max(0, int(perm)))
        if peak is not None:
            cfg["cur"]["con_loss_peak"] = str(max(0, int(peak)))

    def _apply_con_change_adjust_hp(self, cfg, old_con: int, new_con: int):
        """Adjust max/current HP when CON modifier crosses a boundary."""
        old_mod = self._con_mod(old_con)
        new_mod = self._con_mod(new_con)
        if old_mod == new_mod:
            return 0
        hd_levels = self._levels_count_for_hp(cfg)
        delta_hp = (new_mod - old_mod) * hd_levels

        cur_hp = getint_compat(cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(cfg, "max", "hp", fallback=cur_hp)
        max_hp = max(1, max_hp + delta_hp)
        cur_hp = min(cur_hp, max_hp)

        if not cfg.has_section("cur"): cfg.add_section("cur")
        if not cfg.has_section("max"): cfg.add_section("max")
        cfg["cur"]["hp"] = str(cur_hp)
        cfg["max"]["hp"] = str(max_hp)
        return delta_hp

    def _apply_conloss_points(self, cfg, points: int, permanent: bool = False) -> int:
        """
        Apply Constitution loss to a character and return the NET Max-HP delta
        caused by CON-mod boundary shifts.

        - If permanent=False (default), increases TEMPORARY loss (cur.con_loss_temp).
          Also updates 'con_loss_peak' to the highest temp loss reached in this episode.
        - If permanent=True, increases PERMANENT loss (cur.con_loss_perm).
        - In both cases, 'stats.con' (the current, effective CON) is decreased.
        - HP max is adjusted via _apply_con_change_adjust_hp(...) whenever the CON mod changes.

        Returns:
            int: total change to Max HP (can be negative, zero, or positive if somehow raising/lowering around a boundary)
        """

        n = max(0, int(points or 0))
        if n == 0:
            return 0

        hp_delta_total = 0


        cur_con, temp, perm, peak, base = self._get_con_state(cfg)


        for _ in range(n):

            if permanent:
                new_temp = temp
                new_perm = perm + 1
            else:
                new_temp = temp + 1
                new_perm = perm

                peak = max(peak, new_temp)


            new_con = max(1, base - new_temp - new_perm)


            try:

                hp_delta_total += self._apply_con_change_adjust_hp(cfg, cur_con, new_con)
            except TypeError:

                hp_delta_total += self._apply_con_change_adjust_hp(cfg, new_con - cur_con)


            cur_con, temp, perm = new_con, new_temp, new_perm


        self._set_con_state(cfg, cur_con=cur_con, temp=temp, perm=perm, peak=peak)

        return hp_delta_total

    def _restore_one_con_point(self, cfg, require_save_for_final=True, owner_for_save_cfg=None):
        """
        Restore exactly 1 point of TEMPORARY CON loss, adjusting Max/Current HP if the CON mod changes.
        If this would be the final point of a multi-point episode, optionally require a Save vs Death.
        Returns: (message:str|None, hp_delta:int)
        """

        cur_con, temp, perm, peak, base = self._get_con_state(cfg)


        if temp <= 0:
            return None, 0


        is_final_point = bool(require_save_for_final and temp == 1 and max(peak, temp) >= 2)

        if is_final_point:
            ok, roll, dc, _ = self._roll_save(owner_for_save_cfg or cfg, vs="poi", penalty=0)
            if ok:

                old_con = cur_con

                new_con = min(base - (temp - 1) - perm, base - perm)
                hp_delta = self._apply_con_change_adjust_hp(cfg, old_con, new_con)

                self._set_con_state(cfg, cur_con=new_con, temp=0, perm=perm, peak=0)
                return f"Final CON point recovered. Save vs Death: {roll} vs {dc} â†’ **SUCCESS**.", hp_delta
            else:

                self._set_con_state(cfg, cur_con=cur_con, temp=0, perm=perm + 1, peak=0)
                return f"Final CON point recovery â€” Save vs Death: {roll} vs {dc} â†’ **FAIL**. That point is **permanently lost**.", 0


        old_con = cur_con
        new_con = min(base - (temp - 1) - perm, base - perm)
        hp_delta = self._apply_con_change_adjust_hp(cfg, old_con, new_con)


        new_temp = temp - 1
        new_peak = 0 if new_temp <= 0 else peak
        self._set_con_state(cfg, cur_con=new_con, temp=new_temp, perm=perm, peak=new_peak)

        return "CON +1 restored.", hp_delta

    def _is_elf_or_dwarf(self, cfg) -> bool:
        race = (get_compat(cfg, "info", "race", fallback="") or "").strip().lower()
        return race.startswith("elf") or race.startswith("dwarf")



    def _parse_monster_attack_spec(self, spec: str):
        """
        Returns (dice_expr:str, effects: dict). Supports tokens:
            â€¢ <NdM[+K]>   (the roll)
            â€¢ conloss[=N|:N] or just conloss  (default 1)
            â€¢ heal (leech equal to applied damage)
        Unknown tokens are ignored.
        """
        spec = (spec or "").strip()
        if not spec:
            return "1d6", {}

        dice = None
        eff = {"conloss": 0, "heal": False}
        for tok in re.split(r"\s+", spec):
            t = tok.strip().lower()
            if not t:
                continue
            if re.fullmatch(r"\d+d\d+([+-]\d+)?", t):
                dice = t
            elif t.startswith("conloss"):
                m = re.match(r"conloss(?::|=)?(\d+)?", t)
                n = int(m.group(1)) if (m and m.group(1)) else 1
                eff["conloss"] += max(1, n)
            elif t in {"heal", "leech", "regenerate"}:
                eff["heal"] = True
        return (dice or spec, eff)

    @staticmethod
    def _hd_or_level(cfg) -> int:
        """Return a creature's HD/level as an int for immunity checks."""


        try:
            lv = getint_compat(cfg, "cur", "level", fallback=None)
            if lv is not None:
                return int(lv)
        except Exception:
            pass
        try:

            return int(getint_compat(cfg, "base", "hd", fallback=0))
        except Exception:
            return 0

    async def _cast_cause_fear(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)


        target_name = None
        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            target_name = targets.strip() or None

        if not target_name:
            return ["Usage: `!cast causefear <target>`"]


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]

        t_cfg = read_cfg(tgt_path)
        lines = [f"ðŸŒ€ **{caster_name}** intones **Cause Fear** at **{tgt_disp}**."]


        hd = self._hd_or_level(t_cfg)
        if hd >= 6:
            lines.append(f"Unaffected â€” **{tgt_disp}** is **{hd} HD** (6+ HD immunity).")
            return lines

        s_tgt = None
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                s_tgt = _slot(key)
            except Exception:
                s_tgt = (key or tgt_disp).replace(" ", "_")

        fear_mod = self._fear_save_mod_for_slot(bcfg, chan_id, s_tgt) if s_tgt else 0
        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=(-fear_mod))
        lines.append(f"Save vs Spells: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
        if sv_ok:
            return lines


        rounds = 120
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.fear", str(rounds))
            bcfg.set(chan_id, f"{slot}.fear_src", "causefear")
            bcfg.set(chan_id, f"{slot}.fear_by", caster_name)
            _save_battles(bcfg)

            lines.append(f"**Frightened** for **{rounds} rounds**.")
            return lines

        lines.append(f"**Frightened** for **{rounds} rounds**. *(No active battle here â€” it won't auto-tick.)*")
        return lines

    async def _cast_invisibility(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Invisibility (Touch): apply [INV 8640] to the touched target (or self if no target).
        Ends on any attack or when the target casts any spell. Other actions don't break it.
        """


        target_name = None
        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            target_name = targets.strip() or None
        if not target_name:
            target_name = caster_name


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]

        t_cfg = read_cfg(tgt_path)


        ROUNDS = 8640

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        lines = []


        if tgt_disp == caster_name:
            lines.append(f"ðŸ«¥ **{caster_name}** vanishes from sight.")
        else:
            lines.append(f"ðŸ«¥ **{caster_name}** touches **{tgt_disp}** â†’ **Invisible**")


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.inv", str(ROUNDS))
            bcfg.set(chan_id, f"{slot}.inv_by", caster_name)
            _save_battles(bcfg)

            lines.append(f"**Invisible** for **{ROUNDS} rounds** (up to 24 hours). "
                         f"*Attacking or casting a spell ends it.*")
        else:
            lines.append(f"**Invisible** for **{ROUNDS} rounds** (up to 24 hours). "
                         f"*No active battle here â€” it wonâ€™t auto-tick.*")


        try:
            if bcfg and bcfg.has_section(chan_id):

                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                s = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                if bcfg.getint(chan_id, f"{s}.light", fallback=0) > 0 or bcfg.getint(chan_id, f"{s}.light_perm", fallback=0) > 0:
                    lines.append("ðŸ”Ž *Light sources stay visible even if the holder is invisible.*")
        except Exception:
            pass

        return lines



    def _norm_tag(self, s: str) -> str:
        return re.sub(r"[^a-z0-9]+", "", (s or "").lower())

    def _default_code(self, label: str) -> str:
        words = [w for w in re.findall(r"[A-Za-z]+", label)]
        if len(words) >= 2:
            code = "".join(w[0] for w in words[:3]).upper()
        else:
            code = (re.sub(r"[^A-Za-z]", "", label).upper()[:3] or "FX")
        return code

    def _apply_custom_timer(self, chan_id: str, slot: str, tag: str, label: str,
                            rounds: int, by: str, emoji: str | None = None) -> str:
        """
        Write x_* timer keys into battles.cfg and return the compact code (e.g., 'DI', 'HP', etc).
        """
        cfg = _load_battles()
        code = self._default_code(label)
        cfg.set(chan_id, f"{slot}.x_{tag}", str(int(rounds)))
        cfg.set(chan_id, f"{slot}.x_{tag}_label", label)
        cfg.set(chan_id, f"{slot}.x_{tag}_code", code)
        if emoji:
            cfg.set(chan_id, f"{slot}.x_{tag}_emoji", emoji)
        cfg.set(chan_id, f"{slot}.x_{tag}_by", by)
        _save_battles(cfg)
        return code

    def _parse_duration_to_rounds(self, txt: str, caster_level: int) -> int | None:
        if not txt: return None
        s = (txt or "").strip().lower()
        m = re.match(r"^\s*(\d+)\s*(rounds?|turns?|hours?)\s*(?:/(?:lvl|level)|\s*per\s*(?:lvl|level))?\s*$", s)
        if not m:
            return None
        n = int(m.group(1))
        unit = m.group(2)
        per_lvl = bool(re.search(r"(?:/|per)\s*(?:lvl|level)", s))
        if unit.startswith("round"):
            base = n
        elif unit.startswith("turn"):
            base = n * 60
        else:
            base = n * 360
        return base * (caster_level if per_lvl else 1)

    async def _apply_custom_timer(self, ctx, chan_id: str, slot: str, tag: str, label: str, rounds: int, by: str, emoji: str = "â±ï¸"):
        cfg = _load_battles()
        cfg.set(chan_id, f"{slot}.x_{tag}", str(rounds))
        cfg.set(chan_id, f"{slot}.x_{tag}_label", label)

        code = "".join(w[0] for w in label.split())[:3].upper() or tag[:3].upper()
        cfg.set(chan_id, f"{slot}.x_{tag}_code", code)
        cfg.set(chan_id, f"{slot}.x_{tag}_emoji", emoji)
        cfg.set(chan_id, f"{slot}.x_{tag}_by", by)
        _save_battles(cfg)
        try:
            await self._update_tracker_message(ctx, cfg, chan_id)
        except Exception:
            pass
        return code

    def _duration_to_rounds(self, code: str, level: int) -> int:
        """
        Convert your duration codes to rounds (initiative rounds).
        Returns 0 when the duration is not timer-friendly (instant, permanent,
        concentration, â€œ2d8tâ€, etc.).
          r = rounds
          t = turns (10 minutes = 60 rounds)
          m = minutes (1 minute = 6 rounds)
          h = hours   (1 hour   = 360 rounds)
          d = days    (1 day    = 8640 rounds)
          y = years   (â€¦ huge; we return 0)
        Supports:
          N<unit>, N<unit>lvl (/level), N<unit>plus1lvl, N<unit>Kvl (every K levels),
          two-part composites (e.g., 1h30m).
        """
        if not code:
            return 0
        c = code.strip().lower().replace(" ", "")

        if c in {"instant", "instantaneous", "inst", "perm", "permanent", "conc", "concentration"}:
            return 0

        mult = {"r": 1, "t": 60, "m": 6, "h": 360, "d": 8640, "y": 0}

        def unit_to_rounds(n: int, u: str) -> int:
            return n * mult.get(u, 0)


        m = re.fullmatch(r'(\d+)([rtmhyd])(\d+)([rtmhyd])', c)
        if m:
            n1, u1, n2, u2 = int(m.group(1)), m.group(2), int(m.group(3)), m.group(4)
            return unit_to_rounds(n1, u1) + unit_to_rounds(n2, u2)


        if re.fullmatch(r'\d+d\d+t', c):
            return 0


        m = re.fullmatch(r'(\d+)([rtmhd])plus1lvl', c)
        if m:
            base = unit_to_rounds(int(m.group(1)), m.group(2))
            return base + max(1, int(level))


        m = re.fullmatch(r'(\d+)([rtmhyd])lvl', c)
        if m:
            return unit_to_rounds(int(m.group(1)), m.group(2)) * max(1, int(level))


        m = re.fullmatch(r'(\d+)([rtmhd])(\d+)lvl', c)
        if m:
            n, u, k = int(m.group(1)), m.group(2), int(m.group(3))
            uses = max(1, (max(1, int(level)) + k - 1) // k)
            return unit_to_rounds(n, u) * uses


        m = re.fullmatch(r'(\d+)([rtmhyd])', c)
        if m:
            return unit_to_rounds(int(m.group(1)), m.group(2))


        if re.fullmatch(r'\d+u\d+lvl', c):
            return 0

        return 0

    def _effect_rainbowpattern(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Rainbow Pattern
        - Works like Hypnotic Pattern.
        - Fixed pool: up to 24 HD of creatures (lowest HD first; ties by input order).
        - No save (per your HP text).
        - While concentrating: store .hyp = 0 on targets (doesn't tick); .hyp_by = caster.
        - On !conc drop: all those become HYP 2 (your existing _conc_drop already does this).
        - Extra rider: may move 30'/round; followers re-save if led into obvious danger; out of sight ends effect.
          (We surface this as text/RP notes; adjudication stays with DM.)
        """

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŒˆ **Rainbow Pattern** ripples and flows!"]


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")
            bcfg.set(chan_id, f"{s_me}.hyp_conc", "1")
            bcfg.set(chan_id, f"{s_me}.hyp_conc_by", caster_name)

            bcfg.set(chan_id, f"{s_me}.hyp_conc_src", "Rainbow Pattern")
            _save_battles(bcfg)
            lines.append("Concentration is **active**. *(Use `!conc drop` to end it â€” affected creatures will remain **HYP** for **2 rounds**.)*")
            lines.append("You may move the pattern up to **30â€²/round**. Mesmerized creatures follow; "
                         "moving them toward obvious danger grants a **new save**; moving it out of their sight **ends the effect** for them.")
        else:
            lines.append("Concentration would persist (no active battle here, not auto-ticking).")


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            gfn = globals().get("_resolve_char_ci")
            if callable(gfn):
                try:
                    return gfn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None


        cands = []
        idx = 0
        for raw in (tokens or []):
            tgt_disp, tgt_path = _resolve_any_ci(raw)
            pretty = tgt_disp or raw
            if not tgt_path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue
            t_cfg = read_cfg(tgt_path)
            hd = self._hd_or_level_from_cfg(t_cfg)

            s_tgt = None
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty) or pretty
                try:
                    s_tgt = _slot(key)
                except Exception:
                    s_tgt = key.replace(" ", "_")

            cands.append((hd, idx, pretty, tgt_path, s_tgt))
            idx += 1

        cands.sort(key=lambda x: (x[0], x[1]))


        pool = 24
        lines.append(f"HD pool: up to **{pool} HD**")

        if not cands:
            return lines

        def _sightless_or_blindimmune(t_cfg, s_tgt):

            try:
                if bcfg and bcfg.has_section(chan_id) and s_tgt:
                    if bcfg.getint(chan_id, f"{s_tgt}.blind", fallback=0) > 0:
                        return True
            except Exception:
                pass

            txt = " ".join([
                str(get_compat(t_cfg, "info", "immune", fallback="")),
                str(get_compat(t_cfg, "info", "immunity", fallback="")),
                str(get_compat(t_cfg, "stats", "immune", fallback="")),
                str(get_compat(t_cfg, "stats", "immunity", fallback="")),
                str(get_compat(t_cfg, "traits", "immune", fallback="")),
                str(get_compat(t_cfg, "traits", "immunity", fallback="")),
            ]).lower()
            if any(k in txt for k in ("blind", "blindness", "sightless", "gaze immune", "immune: blind", "immuneblind")):
                return True
            if str(get_compat(t_cfg, "info", "sightless", fallback="")).strip().lower() in {"1","true","yes","y"}:
                return True
            return False

        for (hd, _i, pretty, tgt_path, s_tgt) in cands:
            t_cfg = read_cfg(tgt_path)

            if _sightless_or_blindimmune(t_cfg, s_tgt):
                lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ‘ï¸â€ðŸ—¨ï¸ **sightless/immune** â€” no effect.")
                continue

            if pool < hd:
                lines.append(f"â€¢ **{pretty}** (HD {hd}): not enough HD left (**{pool}** remain) â€” **skipped**.")
                continue

            pool -= hd

            if bcfg and bcfg.has_section(chan_id) and s_tgt:

                bcfg.set(chan_id, f"{s_tgt}.hyp", "0")
                bcfg.set(chan_id, f"{s_tgt}.hyp_by", caster_name)
                _save_battles(bcfg)

            lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ˜µ **MESMERIZED**")

        if pool > 0:
            lines.append(f"Unused HD remaining: **{pool}**")

        return lines

    async def _effect_gaseous_form(self, ctx, cfg, caster_name, level, targets):
        """
        Applies Gaseous Form: adds GAS and INW timers, shows effect text.
        GAS also blocks !a and !cast while active.
        Duration: 1 minute/level -> 10 rounds/level.
        """
        rounds = max(1, int(level or 1)) * 10

        bcfg = _load_battles()
        chan  = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan)):
            return "âš ï¸ No battle running here."


        tlist = list(targets) if targets else [caster_name]


        try:
            names, _ = _parse_combatants(bcfg, chan)
        except Exception:
            names = []

        def _ci(nm: str) -> str:
            try:
                return _find_ci_name(names, nm) or nm
            except Exception:
                return nm

        seen, final_targets = set(), []
        for t in tlist:
            k = _ci(str(t).strip())
            if not k: continue
            lk = k.lower()
            if lk in seen: continue
            seen.add(lk)
            final_targets.append(k)


        applied_to = []
        for tgt in final_targets:
            slot = _resolve_effect_slot(bcfg, chan, tgt)


            bcfg.set(chan, f"{slot}.gas",    str(rounds))
            bcfg.set(chan, f"{slot}.gas_by", caster_name)


            bcfg.set(chan, f"{slot}.inw",    str(rounds))
            bcfg.set(chan, f"{slot}.inw_by", "GaseousForm")


            bcfg.set(chan, f"{slot}.gas_ac_hint", "22 (vs magical weapons)")

            applied_to.append(bcfg.get(chan, f"{slot}.disp", fallback=tgt))

        _save_battles(bcfg)


        summary = f"â˜ï¸ Gaseous Form: **AC 22 vs magical weapons**, **immune to nonmagical**; cannot attack or cast; fly 10 ft; can seep through cracks; ends if you resume material form."
        who_txt = ", ".join(applied_to)
        return [
            f"Applied **Gaseous Form** ({rounds} rds) to **{who_txt}**.",
            summary,
            {"suppress_timer": True},
        ]


    def _poly_clear(path):
        cfg = read_cfg(path)
        if cfg.has_section("poly"):
            cfg.remove_section("poly")
        write_cfg(path, cfg)



    def _cast_polymorph(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str], spell_name: str):
        """
        PolymorphSelf:  !cast PolymorphSelf <Form>
        PolymorphOther: !cast PolymorphOther <Target> <Form> [-willing]
        Returns a list of display lines; caller sends them.
        """

        chan_id = str(ctx.channel.id)
        sname = (spell_name or "").strip().lower()
        is_self  = "self"  in sname
        is_other = "other" in sname

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        if is_self:
            if not tokens:
                return ["âŒ Usage: `!cast PolymorphSelf <Form>`"]

            form_arg = tokens[0]
            form_pretty, mcfg = _load_monster_form(form_arg)
            if not mcfg:
                return [f"âŒ Form **{form_arg}** not found in /monsters."]


            m_hd = getint_compat(mcfg, "base", "hd", fallback=0)
            if int(m_hd) > int(caster_level):
                return [f"âŒ {form_pretty} has {m_hd} HD, which exceeds your level {caster_level}."]


            cas_disp, cas_path = self._resolve_char_ci(caster_name)
            if not cas_path:
                return [f"âŒ Caster file for **{caster_name}** not found."]

            tcfg = read_cfg(cas_path)
            _poly_apply_overlay(tcfg, mcfg, form_pretty, kind="self")
            write_cfg(cas_path, tcfg)


            rounds = max(0, int(caster_level)) * 360

            lines = [
                f"âœ¨ **Polymorph Self**: {caster_name} assumes the form of a **{form_pretty}**.",
                f"Duration: **{caster_level} hour(s)** ({rounds} rounds).",
                "You gain AC and natural attacks of the form; **no** special/supernatural/spell-like abilities.",
                "Your gear doesnâ€™t function unless it fits this body (use natural attacks like `claw`, `bite`).",
            ]


            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                self_key = _find_ci_name(names, caster_name) or caster_name
                try:
                    s_self = _slot(self_key)
                except Exception:
                    s_self = self_key.replace(" ", "_")


                for k in (
                    f"{s_self}.polyself", f"{s_self}.polyself_by", f"{s_self}.polyform",
                    f"{s_self}.ps", f"{s_self}.ps_by", f"{s_self}.ps_form"
                ):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k)

                bcfg.set(chan_id, f"{s_self}.ps", str(rounds))
                bcfg.set(chan_id, f"{s_self}.ps_by", caster_name)
                bcfg.set(chan_id, f"{s_self}.ps_form", form_pretty)
                bcfg.set(chan_id, f"{s_self}.poly", form_pretty)
                _save_battles(bcfg)


                try:
                    loop = getattr(self.bot, "loop", None)
                    updater = getattr(self, "_refresh_tracker_message", None) or getattr(self, "_update_tracker_message", None)
                    if updater:
                        if loop and not loop.is_closed():
                            loop.create_task(updater(ctx, bcfg, chan_id))
                        else:
                            asyncio.create_task(updater(ctx, bcfg, chan_id))
                except Exception:
                    pass

            return lines


        if is_other:
            if not tokens:
                return ["âŒ Usage: `!cast PolymorphOther <Target> <Form> [-willing]`"]

            willing = any(t.lower() in {"-w", "-willing", "willing"} for t in tokens)
            pos = [t for t in tokens if not t.startswith("-")]
            if len(pos) < 2:
                return ["âŒ Usage: `!cast PolymorphOther <Target> <Form> [-willing]`"]

            tgt_arg, form_arg = pos[0], pos[1]
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_arg)
            if not tgt_path:
                return [f"âŒ Target **{tgt_arg}** not found."]

            form_pretty, mcfg = _load_monster_form(form_arg)
            if not mcfg:
                return [f"âŒ Form **{form_arg}** not found in /monsters."]


            m_hd = getint_compat(mcfg, "base", "hd", fallback=0)
            if int(m_hd) > int(caster_level):
                return [f"âŒ {form_pretty} has {m_hd} HD, which exceeds caster level {caster_level}."]

            tcfg = read_cfg(tgt_path)
            lines = [f"âœ¨ **Polymorph Other**: {caster_name} targets **{tgt_disp}** to become a **{form_pretty}**."]

            if not willing:
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(tcfg, vs="para", penalty=0)
                lines.append(f"Save vs Paralysis: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
                if sv_ok:
                    lines.append("No effect on a successful save.")
                    return lines
            else:
                lines.append("(Save bypassed: willing target.)")

            _poly_apply_overlay(tcfg, mcfg, form_pretty, kind="other")
            write_cfg(tgt_path, tcfg)

            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    s_tgt = _slot(key)
                except Exception:
                    s_tgt = key.replace(" ", "_")
                bcfg.set(chan_id, f"{s_tgt}.poly", form_pretty)
                _save_battles(bcfg)


                try:
                    loop = getattr(self.bot, "loop", None)
                    if loop and not loop.is_closed():
                        loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                    else:
                        asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                except Exception:
                    pass

            lines.append("Effect is **permanent** until dispelled or the creature is slain.")
            lines.append("Target keeps current HP; gains AC/natural attacks of the new form. Gear that doesnâ€™t fit is dropped/ineffective.")
            return lines

        return ["âŒ Unknown polymorph variant. Use PolymorphSelf or PolymorphOther."]

    def _effect_bestowcurse(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        """
        BestowCurse
        Range 30'; Duration: Permanent until RemoveCurse. DispelMagic does NOT remove.
        Options (2nd arg): ability | rolls | 50 | rp

        ability: -4 to one ability (min 1) â€” GM selects which ability
        rolls:   -4 penalty on attack rolls and saves
        50:      each combat round, 50% to act normally; otherwise, no action
        rp:      GM-defined custom curse (no stronger than above)

        We record a permanent tracker tag + metadata. No auto-math is imposed here.
        """


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None


        def _bc_normalize_choice(raw) -> str | None:
            s = str(raw or "").strip().lower().replace("%", "")

            if s in {"ability", "abil", "stat", "score", "abilityscore"}:
                return "ability"
            if s in {"rolls", "roll", "atk", "attack", "attacks", "save", "saves"}:
                return "rolls"
            if s in {"50", "fifty", "half"}:
                return "50"
            if s in {"rp", "custom", "freeform", "dm"}:
                return "rp"
            return None

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None



        pos = [t for t in tokens if not t.startswith("-")]


        if len(pos) < 2:
            return [
                "âŒ Usage: `!cast BestowCurse <Target> <ability|rolls|50|rp>`",
                "Options:",
                "â€¢ `ability` â€” â€“4 to one ability (minimum 1).",
                "â€¢ `rolls` â€” â€“4 to attack rolls and saving throws.",
                "â€¢ `50` â€” each round: 50% act / 50% no action.",
                "â€¢ `rp` â€” GM-defined (no stronger than the above).",
                "See `!info bestowcurse` for full details.",
            ]

        tgt_arg, choice_raw = pos[0], pos[1]
        kind = _bc_normalize_choice(choice_raw)
        if not kind:
            return [
                "âŒ Unknown option.",
                "Use: `!cast BestowCurse <Target> <ability|rolls|50|rp>`",
                "Options:",
                "â€¢ `ability` â€” â€“4 to one ability (minimum 1).",
                "â€¢ `rolls` â€” â€“4 to attack rolls and saving throws.",
                "â€¢ `50` â€” each round: 50% act / 50% no action.",
                "â€¢ `rp` â€” GM-defined (no stronger than the above).",
                "See `!info bestowcurse` for full details.",
            ]

        tgt_disp, tgt_path = _resolve_char_ci_local(tgt_arg)
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]

        tcfg = read_cfg(tgt_path)
        lines = [f"ðŸ§¿ **Bestow Curse**: {caster_name} curses **{tgt_disp}** ({kind})."]


        
        try:
            
            if _pfed_try_absorb_sp(self, tcfg, tgt_path, "curse", embed=None):
                return lines + ["â†’ The curse is **negated** by Protection from Energy Drain."]
        except Exception:
            pass

        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            lines.append(f"Mirror Image: a figment staggers under the malediction and crumbles. Images left: **{left_imgs}**.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_save(tcfg, vs="spell", penalty=0)
        lines.append(f"Save vs Spells: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
        if sv_ok:
            lines.append("The curse fails to take hold.")
            return lines


        PERM_ROUNDS = 10_000_000
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                s_tgt = _slot(key)
            except Exception:
                s_tgt = key.replace(" ", "_")


            for k in (f"{s_tgt}.curse", f"{s_tgt}.curse_perm", f"{s_tgt}.curse_kind",
                      f"{s_tgt}.curse_by", f"{s_tgt}.cur", f"{s_tgt}.curse50"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)



            short = {"ability": "ABL", "rolls": "â€“4", "50": "50", "rp": "RP"}[kind]

            bcfg.set(chan_id, f"{s_tgt}.curse",      str(PERM_ROUNDS))
            bcfg.set(chan_id, f"{s_tgt}.curse_perm", "1")
            bcfg.set(chan_id, f"{s_tgt}.curse_kind", kind)
            bcfg.set(chan_id, f"{s_tgt}.curse_by",   caster_name)
            bcfg.set(chan_id, f"{s_tgt}.cur",        f"{short}")
            if kind == "50":
                bcfg.set(chan_id, f"{s_tgt}.curse50", "1")

            _save_battles(bcfg)


            try:
                loop = getattr(self.bot, "loop", None)
                if loop and not loop.is_closed():
                    loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                else:
                    asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
            except Exception:
                pass


            if kind == "ability":
                lines.append("Effect: **â€“4 to one ability score (minimum 1)**.")
            elif kind == "rolls":
                lines.append("Effect: **â€“4 penalty to attack rolls and saving throws**.")
            elif kind == "50":
                lines.append("Effect: **Each combat round, 50% chance to act normally; otherwise, takes no action**.")
            else:
                lines.append("Effect: **Custom curse**; adjudicated by the GM (no stronger than the listed options).")

            lines.append("This curse is **permanent** until removed via **Remove Curse** (Dispel Magic does not end it).")
            return lines


        lines.append("Applied (treated as permanent); no active battle here to display an ongoing tag.")
        lines.append("Use **Remove Curse** to end it; Dispel Magic has no effect.")
        return lines

    def _effect_removecurse(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        """
        RemoveCurse
        Range 30'; Duration: Instantaneous.
        Removes ordinary curses (including BestowCurse) affecting a creature.
        Special/deity-level curses may be beyond this spell (DMâ€™s call).
        """

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None

        if not tokens:
            return ["âŒ Usage: `!cast RemoveCurse <Target>`"]

        tgt_arg = tokens[0]
        tgt_disp, tgt_path = _resolve_char_ci_local(tgt_arg)
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = [f"ðŸª¬ **Remove Curse**: {caster_name} attempts to cleanse **{tgt_disp}**."]


        removed_any = False
        if bcfg:
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    s_tgt = _slot(key)
                except Exception:
                    s_tgt = key.replace(" ", "_")

                for k in (f"{s_tgt}.curse",
                          f"{s_tgt}.curse_perm",
                          f"{s_tgt}.curse_kind",
                          f"{s_tgt}.curse_by",
                          f"{s_tgt}.cur",
                          f"{s_tgt}.curse50"):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k)
                        removed_any = True

                if removed_any:
                    _save_battles(bcfg)

                    try:
                        loop = getattr(self.bot, "loop", None)
                        if loop and not loop.is_closed():
                            loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                        else:
                            asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                    except Exception:
                        pass

        if removed_any:
            lines.append("Ordinary curses are **removed**. (Artifact/special curses may remain at the DMâ€™s discretion.)")
        else:
            lines.append("No tracked ordinary curses found to remove here. (If a special curse persists, GM adjudicates.)")

        return lines

    async def _curse50_turn_gate(self, ctx, cfg, chan_id: str, slot_id: str) -> bool:
        """
        If slot_id is under BestowCurse kind '50', roll 50% at the *start* of their turn.
        Returns True if the creature takes NO action (i.e., you should auto-advance turn).
        Returns False if they act normally.
        """

        if not cfg or not cfg.has_section(chan_id):
            return False


        left = cfg.getint(chan_id, f"{slot_id}.curse", fallback=0)
        if left <= 0:
            return False

        kind = (cfg.get(chan_id, f"{slot_id}.curse_kind", fallback="") or "").lower()
        if kind != "50":
            return False


        acts = bool(random.getrandbits(1))

        disp = cfg.get(chan_id, f"{slot_id}.disp", fallback=slot_id.replace("_", " "))
        if acts:
            await ctx.send(f"ðŸ§¿ **Curse (50%)**: **{disp}** shakes off the malaise and may act this round.")
            return False
        else:
            await ctx.send(f"ðŸ§¿ **Curse (50%)**: **{disp}** falters and takes **no action** this round.")
            return True

    async def _cast_invisible10(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Invisible10 (Touch): like Invisibility, but the primary target (leader) and
        the other names provided become a *group* of invisibles.
        Group semantics:
          â€¢ Everyone can see the others in the group (flavor).
          â€¢ If the *leader* attacks or casts â†’ invis ends for the *entire group*.
          â€¢ If a *member* (non-leader) attacks or casts â†’ ends only for that member.
          â€¢ RAW says >10' from leader ends memberâ€™s invis; call `_invis10_break_member(...)`
            from your movement code if you want to enforce that.
        Duration: 1 turn/level â†’ 60 rounds/level (your engine uses 10s rounds).
        """


        leader_in = None
        if isinstance(targets, (list, tuple, set)):
            leader_in = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            leader_in = targets.strip() or None
        if not leader_in:
            leader_in = caster_name


        try:
            lead_disp, lead_path = self._resolve_char_ci(leader_in)
        except Exception:
            lead_disp, lead_path = str(leader_in), None
            base = f"{str(leader_in).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    lead_path = fn
                    break
        if not lead_path or not os.path.exists(lead_path):
            return [f"âŒ Target **{leader_in}** not found."]


        others_raw = []
        if isinstance(targets, (list, tuple, set)):
            for t in targets:
                if isinstance(t, str) and t.strip():
                    if t.strip().lower() != lead_disp.strip().lower():
                        others_raw.append(t)


        ROUNDS = max(0, 60 * max(1, int(caster_level or 1)))

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        lines = []

        lines.append(f"ðŸ«¥ **{caster_name}** casts **Invisible10**.")
        if not bcfg or not bcfg.has_section(chan_id):
            lines.append(f"**Invisible** for **{ROUNDS} rounds** (1 turn/level). "
                         f"*No active battle here â€” it wonâ€™t auto-tick.*")
            return lines


        names, _ = _parse_combatants(bcfg, chan_id)

        def _slot_ci(name: str) -> str:
            k = _find_ci_name(names, name) or name
            try:
                return _slot(k)
            except Exception:
                return k.replace(" ", "_")


        leader_key = _find_ci_name(names, lead_disp) or lead_disp
        s_lead = _slot_ci(leader_key)
        bcfg.set(chan_id, f"{s_lead}.inv", str(ROUNDS))
        bcfg.set(chan_id, f"{s_lead}.inv_by", caster_name)
        bcfg.set(chan_id, f"{s_lead}.inv_type", "group")
        bcfg.set(chan_id, f"{s_lead}.inv_gid", leader_key)
        bcfg.set(chan_id, f"{s_lead}.inv_leader", "1")

        applied = [leader_key]
        missed = []


        for raw in others_raw:
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = str(raw), None
                base = f"{str(raw).replace(' ', '_')}.coe"
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        path = fn
                        break
            if not path or not os.path.exists(path):
                missed.append(str(raw))
                continue

            s = _slot_ci(disp)
            bcfg.set(chan_id, f"{s}.inv", str(ROUNDS))
            bcfg.set(chan_id, f"{s}.inv_by", caster_name)
            bcfg.set(chan_id, f"{s}.inv_type", "group")
            bcfg.set(chan_id, f"{s}.inv_gid", leader_key)

            applied.append(_find_ci_name(names, disp) or disp)

        _save_battles(bcfg)


        group_txt = ", ".join(applied)
        lines.append(f"**Group Invisible** for **{ROUNDS} rounds** (1 turn/level).")
        lines.append(f"Group: {group_txt}")
        if missed:
            lines.append("*(Not found: " + ", ".join(missed) + ")*")
        lines.append("ðŸ” *Group members can see each other. If the leader attacks/casts, "
                     "the **entire group** becomes visible; if a member attacks/casts, only **they** do.*")


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return lines

    async def _cast_improvedinvisibility(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Improved Invisibility (Touch): like Invisibility, but it does NOT end if the subject
        attacks or casts a spell. Duration 1 round/level.
        """


        target_name = None
        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            target_name = targets.strip() or None
        if not target_name:
            target_name = caster_name


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]


        ROUNDS = max(1, int(caster_level or 1))

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        lines = []

        if tgt_disp == caster_name:
            lines.append(f"ðŸ«¥ **{caster_name}** fades into **Improved Invisibility**.")
        else:
            lines.append(f"ðŸ«¥ **{caster_name}** touches **{tgt_disp}** â†’ **Improved Invisible**")

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.inv", str(ROUNDS))
            bcfg.set(chan_id, f"{slot}.inv_by", caster_name)
            bcfg.set(chan_id, f"{slot}.inv_type", "imp")
            _save_battles(bcfg)

            lines.append(f"**Improved Invisible** for **{ROUNDS} rounds**. "
                         f"*Attacking/casting **does not** end it.*")
        else:
            lines.append(f"**Improved Invisible** for **{ROUNDS} rounds**. "
                         f"*No active battle here â€” it wonâ€™t auto-tick.*")

        return lines

    async def _cast_massinvisibility(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Mass Invisibility: Bestows Invisibility on all named targets.
        Duration: Permanent until the subject attacks or casts a spell.
        Usage example: !cast massinvisibility wizard holyman testman
        If no targets are given, defaults to self.
        """


        raw_list = []
        if isinstance(targets, (list, tuple, set)):
            raw_list = [t for t in targets if isinstance(t, str) and t.strip()]
        elif isinstance(targets, str) and targets.strip():
            raw_list = [targets.strip()]
        if not raw_list:
            raw_list = [caster_name]


        ok_targets = []
        missed = []
        for name in raw_list:
            try:
                disp, path = self._resolve_char_ci(name)
            except Exception:
                disp, path = str(name), None
                base = f"{str(name).replace(' ', '_')}.coe"
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        path = fn
                        break
            if not path or not os.path.exists(path):
                missed.append(str(name))
            else:
                ok_targets.append(disp)

        lines = []
        lines.append(f"ðŸ«¥ **{caster_name}** casts **Mass Invisibility**.")

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):

            if ok_targets:
                lines.append(f"**Invisible (permanent)** on: {', '.join(ok_targets)}")
            if missed:
                lines.append("*(Not found: " + ", ".join(missed) + ")*")
            lines.append("ðŸ”Ž *Each subject remains invisible until they attack or cast a spell.*")
            lines.append("ðŸ“Œ *No active battle here â€” it wonâ€™t auto-track.*")
            return lines

        names, _ = _parse_combatants(bcfg, chan_id)

        def _slot_ci(name: str) -> str:
            k = _find_ci_name(names, name) or name
            try:
                return _slot(k)
            except Exception:
                return k.replace(" ", "_")

        applied = []
        for disp in ok_targets:
            s = _slot_ci(disp)

            bcfg.set(chan_id, f"{s}.inv", "0")
            bcfg.set(chan_id, f"{s}.inv_perm", "1")
            bcfg.set(chan_id, f"{s}.inv_by", caster_name)
            bcfg.set(chan_id, f"{s}.inv_type", "mass")
            applied.append(_find_ci_name(names, disp) or disp)

        _save_battles(bcfg)

        if applied:
            lines.append("**Invisible (permanent)** on: " + ", ".join(applied))
        if missed:
            lines.append("*(Not found: " + ", ".join(missed) + ")*")
        lines.append("ðŸ”Ž *Each subject remains invisible until they attack or cast a spell.*")


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return lines

    async def _cast_animatedead(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Animate Dead (30 ft): spawn Skeletons (1 HD each) and Zombies (2 HD by default).
        Caps: per cast â‰¤ 2Ã—level HD; controlled total â‰¤ 4Ã—level HD (in this initiative).
        Usage:
          !cast animatedead -sk 5 -zo 3
          !cast animatedead sk5 zo3
        Tip: Use !hd ZO# N to set a zombieâ€™s HD after creation (owner allowed).
        """

        
        _cl = max(1, int(caster_level or 1))
        _default_per_cast_cap = 2 * _cl
        _default_control_cap  = 4 * _cl

        per_cast_hd_cap = _kw.get("per_cast_hd_cap", _default_per_cast_cap)
        try:
            per_cast_hd_cap = int(per_cast_hd_cap) if per_cast_hd_cap is not None else _default_per_cast_cap
        except Exception:
            per_cast_hd_cap = _default_per_cast_cap

        control_cap = _kw.get("control_cap", _default_control_cap)
        try:
            control_cap = int(control_cap) if control_cap is not None else _default_control_cap
        except Exception:
            control_cap = _default_control_cap
        


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        sk = 0
        zo = 0

        def _take_int_after(flag):
            nonlocal toks
            for i in range(len(toks) - 1):
                if toks[i] in flag and re.fullmatch(r"\d+", toks[i+1] or ""):
                    v = int(toks[i+1]); toks[i] = ""; toks[i+1] = ""
                    return v
            return 0


        sk += _take_int_after({"-sk", "-sk", "-skeleton"})
        zo += _take_int_after({"-zo", "-zo", "-zombie"})


        for t in list(toks):
            m = re.fullmatch(r"(sk|skeleton)(\d+)", t)
            if m: sk += int(m.group(2)); toks.remove(t); continue
            m = re.fullmatch(r"(zo|zombie)(\d+)", t)
            if m: zo += int(m.group(2)); toks.remove(t); continue

        if sk <= 0 and zo <= 0:
            return [
                "âŒ **Animate Dead**: invalid usage.",
                "Try: `!cast animatedead -sk 5 -zo 3`  or  `!cast animatedead sk5 zo3`",
                "Skeletons are **1 HD** each; Zombies default to **2 HD** (adjust with `!hd ZO# N`).",
                "Limits: per cast â‰¤ **2Ã—level HD**; controlled total â‰¤ **4Ã—level HD**."
            ]


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        tpl_sk = _load_monster_template("skeleton")
        tpl_zo = _load_monster_template("zombie")
        if not tpl_sk or not tpl_zo:
            return ["âŒ Missing monster templates in `/monsters/`: need `skeleton.ini` and `zombie.ini`."]

        sk_hd = int(str(tpl_sk.get("hd", 1)) or "1")
        zo_hd = int(str(tpl_zo.get("hd", 2)) or "2")


        per_cast_cap = 2 * max(1, int(caster_level or 1))
        want_hd = sk * sk_hd + zo * zo_hd
        if want_hd <= 0:
            return ["âŒ Nothing to animate (zero HD)."]

        if want_hd > per_cast_cap:
            return [f"âŒ Per-cast limit exceeded: you can animate at most **{per_cast_cap} HD** right now (you asked for **{want_hd} HD**)."]


        def _sum_controlled(owner_id: str, controller_name: str) -> int:
            names, _ = _parse_combatants(bcfg, chan_id)
            total = 0
            for n in names:
                fn = f"{n}.coe"
                if not os.path.exists(fn):
                    continue
                rc = read_cfg(fn)
                if str(get_compat(rc, "info", "owner_id", fallback="")) != str(owner_id):
                    continue
                if str(get_compat(rc, "info", "controller", fallback="")).strip().lower() != caster_name.strip().lower():
                    continue
                if str(get_compat(rc, "stats", "type", fallback="")).strip().lower() != "undead":
                    continue
                hd_now = getint_compat(rc, "cur", "level", fallback=1)
                total += max(1, int(hd_now))
            return total

        already = _sum_controlled(caster_owner_id, caster_name)
        control_cap = 4 * max(1, int(caster_level or 1))
        if already + want_hd > control_cap:
            return [f"âŒ Control cap exceeded: you control **{already} HD**; cap is **{control_cap} HD**; "
                    f"this cast adds **{want_hd} HD** (over by **{already + want_hd - control_cap} HD**)."]


        def _spawn_batch(mon_name: str, tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 1))
            hpmod  = int(tpl.get("hpmod", 0))
            damage = str(tpl.get("damage", "1d6"))
            move   = int(tpl.get("move", 30))
            saveas = str(tpl.get("saveas", "Fighter 1"))
            resist  = str(tpl.get("resist",  "")).strip()
            reduce1 = str(tpl.get("reduce1", "")).strip()
            immune  = str(tpl.get("immune",  "")).strip()

            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", hd

            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = re.sub(r"[^A-Za-z]", "", mon_name).upper()[:2] or "MO"
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            created = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)

                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": mon_name, "battle_chan": chan_id,

                    "controller": caster_name,
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


                stats = {"ac": str(ac), "ab": "", "move": str(move),
                         "type": str(tpl.get("type", "")).strip(),
                         "resist": resist, "reduce1": reduce1, "immune": immune}
                attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
                atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
                attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or damage or "1d6"
                else:
                    stats["damage"] = damage or "1d6"

                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)

                s = _slot(mon)

                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s}."):
                        bcfg.remove_option(chan_id, opt_key)
                    if bcfg.has_option(chan_id, mon):
                        bcfg.remove_option(chan_id, mon)

                bcfg.set(chan_id, f"{s}.dex", "0")
                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s}.join", str(join_seq))
                bcfg.set(chan_id, f"{s}.disp", mon)

                created.append((mon, d6, hp, hd))

            _save_battles(bcfg)
            return created


        lines = [f"ðŸ§Ÿ **{caster_name}** casts **Animate Dead**."]
        created = []
        if sk > 0:
            created += _spawn_batch("skeleton", tpl_sk, sk)
        if zo > 0:
            created += _spawn_batch("zombie",   tpl_zo, zo)

        if not created:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        sk_names = [n for (n, _i, _hp, _hd) in created if n.upper().startswith("SK")]
        zo_names = [n for (n, _i, _hp, _hd) in created if n.upper().startswith("ZO")]
        made_hd  = sum(hd for (_n, _i, _hp, hd) in created)
        lines.append(f"Raised: "
                     + (f"**{len(sk_names)}** Skeleton(s) " if sk_names else "")
                     + ("and " if sk_names and zo_names else "")
                     + (f"**{len(zo_names)}** Zombie(s) " if zo_names else "")
                     + f"(**{made_hd} HD**).")
        lines.append(f"Control: **{already} â†’ {already + made_hd} / {control_cap} HD**.")
        if zo_names:
            lines.append("â„¹ï¸ Use `!hd ZO# N` to set a **zombieâ€™s HD** after creation (owner allowed).")

        return lines

    async def _cast_reanimation(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Animate Dead (30 ft): spawn Skeletons (1 HD each) and Zombies (2 HD by default).
        Caps: per cast â‰¤ 2Ã—level HD; controlled total â‰¤ 4Ã—level HD (in this initiative).
        Usage:
          !cast re-nimation -sk 5 -zo 3
          !cast reanimation sk5 zo3
        Tip: Use !hd ZO# N to set a zombieâ€™s HD after creation (owner allowed).
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        sk = 0
        zo = 0

        def _take_int_after(flag):
            nonlocal toks
            for i in range(len(toks) - 1):
                if toks[i] in flag and re.fullmatch(r"\d+", toks[i+1] or ""):
                    v = int(toks[i+1]); toks[i] = ""; toks[i+1] = ""
                    return v
            return 0


        sk += _take_int_after({"-sk", "-sk", "-skeleton"})
        zo += _take_int_after({"-zo", "-zo", "-zombie"})


        for t in list(toks):
            m = re.fullmatch(r"(sk|skeleton)(\d+)", t)
            if m: sk += int(m.group(2)); toks.remove(t); continue
            m = re.fullmatch(r"(zo|zombie)(\d+)", t)
            if m: zo += int(m.group(2)); toks.remove(t); continue

        if sk <= 0 and zo <= 0:
            return [
                "âŒ **Reanimation**: invalid usage.",
                "Try: `!cast reanimation -sk 5 -zo 3`  or  `!cast reanimation sk5 zo3`",
                "Skeletons default to **1 HD** each; Zombies default to **2 HD** (adjust with `!hd ZO# N`).",
                "Limits: per cast â‰¤ **3Ã—level HD**; controlled total â‰¤ **6Ã—level HD**."
            ]


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        tpl_sk = _load_monster_template("skeleton")
        tpl_zo = _load_monster_template("zombie")
        if not tpl_sk or not tpl_zo:
            return ["âŒ Missing monster templates in `/monsters/`: need `skeleton.ini` and `zombie.ini`."]

        sk_hd = int(str(tpl_sk.get("hd", 1)) or "1")
        zo_hd = int(str(tpl_zo.get("hd", 2)) or "2")


        per_cast_cap = 3 * max(1, int(caster_level or 1))
        want_hd = sk * sk_hd + zo * zo_hd
        if want_hd <= 0:
            return ["âŒ Nothing to animate (zero HD)."]

        if want_hd > per_cast_cap:
            return [f"âŒ Per-cast limit exceeded: you can animate at most **{per_cast_cap} HD** right now (you asked for **{want_hd} HD**)."]


        def _sum_controlled(owner_id: str, controller_name: str) -> int:
            names, _ = _parse_combatants(bcfg, chan_id)
            total = 0
            for n in names:
                fn = f"{n}.coe"
                if not os.path.exists(fn):
                    continue
                rc = read_cfg(fn)
                if str(get_compat(rc, "info", "owner_id", fallback="")) != str(owner_id):
                    continue
                if str(get_compat(rc, "info", "controller", fallback="")).strip().lower() != caster_name.strip().lower():
                    continue
                if str(get_compat(rc, "stats", "type", fallback="")).strip().lower() != "undead":
                    continue
                hd_now = getint_compat(rc, "cur", "level", fallback=1)
                total += max(1, int(hd_now))
            return total

        already = _sum_controlled(caster_owner_id, caster_name)
        control_cap = 6 * max(1, int(caster_level or 1))
        if already + want_hd > control_cap:
            return [f"âŒ Control cap exceeded: you control **{already} HD**; cap is **{control_cap} HD**; "
                    f"this cast adds **{want_hd} HD** (over by **{already + want_hd - control_cap} HD**)."]


        def _spawn_batch(mon_name: str, tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 1))
            hpmod  = int(tpl.get("hpmod", 0))
            damage = str(tpl.get("damage", "1d6"))
            move   = int(tpl.get("move", 30))
            saveas = str(tpl.get("saveas", "Fighter 1"))
            resist  = str(tpl.get("resist",  "")).strip()
            reduce1 = str(tpl.get("reduce1", "")).strip()
            immune  = str(tpl.get("immune",  "")).strip()

            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", hd

            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = re.sub(r"[^A-Za-z]", "", mon_name).upper()[:2] or "MO"
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            created = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)

                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": mon_name, "battle_chan": chan_id,

                    "controller": caster_name,
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


                stats = {"ac": str(ac), "ab": "", "move": str(move),
                         "type": str(tpl.get("type", "")).strip(),
                         "resist": resist, "reduce1": reduce1, "immune": immune}
                attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
                atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
                attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or damage or "1d6"
                else:
                    stats["damage"] = damage or "1d6"

                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)

                s = _slot(mon)

                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s}."):
                        bcfg.remove_option(chan_id, opt_key)
                    if bcfg.has_option(chan_id, mon):
                        bcfg.remove_option(chan_id, mon)

                bcfg.set(chan_id, f"{s}.dex", "0")
                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s}.join", str(join_seq))
                bcfg.set(chan_id, f"{s}.disp", mon)

                created.append((mon, d6, hp, hd))

            _save_battles(bcfg)
            return created


        lines = [f"ðŸ’€ **{caster_name}** casts **Reanimation**."]
        created = []
        if sk > 0:
            created += _spawn_batch("skeleton", tpl_sk, sk)
        if zo > 0:
            created += _spawn_batch("zombie",   tpl_zo, zo)

        if not created:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        sk_names = [n for (n, _i, _hp, _hd) in created if n.upper().startswith("SK")]
        zo_names = [n for (n, _i, _hp, _hd) in created if n.upper().startswith("ZO")]
        made_hd  = sum(hd for (_n, _i, _hp, hd) in created)
        lines.append(f"Raised: "
                     + (f"**{len(sk_names)}** Skeleton(s) " if sk_names else "")
                     + ("and " if sk_names and zo_names else "")
                     + (f"**{len(zo_names)}** Zombie(s) " if zo_names else "")
                     + f"(**{made_hd} HD**).")
        lines.append(f"Control: **{already} â†’ {already + made_hd} / {control_cap} HD**.")
        if zo_names:
            lines.append("â„¹ï¸ Use `!hd ZO# N` to set a **zombieâ€™s HD** after creation (owner allowed).")
        if sk_names:
            lines.append("â„¹ï¸ Use `!hd SK# N` to set a **skeletonâ€™s HD** after creation (owner allowed).")
        return lines

    @commands.command(name="hd")
    async def set_monster_hd(self, ctx, name: str, new_hd: int):
        """
        Set a monster's HD; adjusts HP by Â±(Î”Ã—d8 + Î”Ã—hpmod).
        GM-only, except: Zombies (names starting with ZO) can be changed by their owner.
        Enforces controller's 4Ã—level undead control cap on increases.
        Usage: !hd ZO1 5
        """

        try:
            new_hd = int(new_hd)
        except Exception:
            await ctx.send("âŒ Usage: `!hd <name> <new_hd>` (e.g., `!hd ZO1 5`).")
            return
        if new_hd < 1 or new_hd > 20:
            await ctx.send("âŒ HD must be between 1 and 20.")
            return


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            await ctx.send("âŒ No initiative running here.")
            return
        dm_id = bcfg.get(chan_id, "DM", fallback="")


        def _resolve_file_ci(nm: str):
            base = f"{nm}.coe"
            if os.path.exists(base): return nm, base
            want = nm.lower() + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == want:
                    return fn[:-4], fn
            return nm, None

        mon_name, path = _resolve_file_ci(name)
        if not path or not os.path.exists(path):
            await ctx.send(f"âŒ Monster **{name}** not found.")
            return

        rc = read_cfg(path)
        owner = str(get_compat(rc, "info", "owner_id", fallback=""))
        mtype = str(get_compat(rc, "info", "monster_type", fallback="")).strip().lower()
        is_zombie = mon_name.upper().startswith("ZO") or mtype == "zombie"
        is_skeleton = mon_name.upper().startswith("SK") or mtype == "skeleton"

        if str(ctx.author.id) != str(dm_id):
            if not (is_zombie or is_skeleton and owner == str(ctx.author.id)):
                await ctx.send("âŒ Only the GM can change HD for that creature. (Zombie/Skeleton exception: owner may adjust.)")
                return

        old_hd = getint_compat(rc, "cur", "level", fallback=1)
        if old_hd == new_hd:
            await ctx.send(f"â„¹ï¸ {mon_name} already has **{new_hd} HD**.")
            return


        tpl = _load_monster_template(mtype or "zombie") or {}
        hpmod = int(str(tpl.get("hpmod", 0)) or "0")

        delta = new_hd - old_hd

        if delta > 0:
            controller = str(get_compat(rc, "info", "controller", fallback="")).strip()

            ctrl_level = None
            if controller:
                try:
                    ctrl_disp, ctrl_path = self._resolve_char_ci(controller)
                    if ctrl_path and os.path.exists(ctrl_path):
                        ctrl_cfg = read_cfg(ctrl_path)
                        ctrl_level = getint_compat(ctrl_cfg, "cur", "level", fallback=None)
                except Exception:
                    pass
            if ctrl_level is None:

                active = get_active(ctx.author.id)
                if active:
                    apath = f"{active.replace(' ', '_')}.coe"
                    if os.path.exists(apath):
                        acfg = read_cfg(apath)
                        ctrl_level = getint_compat(acfg, "cur", "level", fallback=None)
            if ctrl_level is None:
                ctrl_level = 1


            def _sum_controlled(owner_id: str, controller_name: str) -> int:
                names, _ = _parse_combatants(bcfg, chan_id)
                total = 0
                for n in names:
                    fn = f"{n}.coe"
                    if not os.path.exists(fn):
                        continue
                    xc = read_cfg(fn)
                    if str(get_compat(xc, "info", "owner_id", fallback="")) != str(owner_id): continue
                    if str(get_compat(xc, "info", "controller", fallback="")).strip().lower() != controller_name.strip().lower(): continue
                    if str(get_compat(xc, "stats", "type", fallback="")).strip().lower() != "undead": continue
                    total += max(1, getint_compat(xc, "cur", "level", fallback=1))
                return total

            already = _sum_controlled(owner, controller or "")
            cap = 4 * max(1, ctrl_level)
            if already + delta > cap:
                await ctx.send(f"âŒ Control cap would be exceeded for **{controller or 'controller'}**: "
                               f"{already} + {delta} > {cap} HD.")
                return


        def _roll_d8s(n):
            s = 0; rolls = []
            for _ in range(n):
                r = random.randint(1, 8); s += r; rolls.append(r)
            return s, rolls

        max_hp = getint_compat(rc, "max", "hp", fallback=1)
        cur_hp = getint_compat(rc, "cur", "hp", fallback=max_hp)

        if delta > 0:
            add_sum, rolls = _roll_d8s(delta)
            add = add_sum + delta * hpmod
            new_max = max_hp + add
            new_cur = cur_hp + add
            rc["max"]["hp"] = str(new_max)
            rc["cur"]["hp"] = str(new_cur)
            rc["cur"]["level"] = str(new_hd)
            hp_note = f"+{add} HP (d8s {rolls} + {delta}Ã—hpmod {hpmod})"
        else:
            dec = -delta
            sub_sum, rolls = _roll_d8s(dec)
            sub = sub_sum + dec * hpmod
            new_max = max(1, max_hp - sub)

            new_cur = min(cur_hp, new_max)
            if new_cur < 1:
                new_cur = 1
            rc["max"]["hp"] = str(new_max)
            rc["cur"]["hp"] = str(new_cur)
            rc["cur"]["level"] = str(new_hd)
            hp_note = f"âˆ’{sub} HP (d8s {rolls} + {dec}Ã—hpmod {hpmod}); floors at 1 HP / 1 max"


        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

        for k, v in saves_out.items():
            rc["saves"][k] = v

        write_cfg(path, rc)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        await ctx.send(f"ðŸ› ï¸ **{mon_name}** HD: **{old_hd} â†’ {new_hd}** ({hp_note}).")

    async def _cast_conjureelemental(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):




        src = str(_kw.get("source") or _kw.get("variant") or "spell").lower()
        use_staff = src in {"staff", "wizardry", "staff_of_wizardry"}


        def _pick_type(argset):
            if isinstance(argset, (list, tuple, set)):
                for t in argset:
                    s = str(t or "").strip().lower()
                    if s in {"air","fire","earth","water","wood","metal","ice","lightning"}:
                        return s
            elif isinstance(argset, str):
                for tok in re.split(r"\s+", argset.strip().lower()):
                    if tok in {"air","fire","earth","water","wood","metal","ice","lightning"}:
                        return tok
            return None

        want = _pick_type(targets)
        if not want:
            return ["âŒ Usage: `!cast conjureelemental <air|fire|earth|water|wood|metal|ice|lightning>`"]


        preferred = f"{want}elementalstaff"
        fallback  = f"{want}elementalspell"
        name_candidates = [preferred, fallback] if use_staff else [fallback, preferred]

        tpl = None
        mon_type_name = None
        for cand in name_candidates:
            t = _load_monster_template(cand)
            if t:
                tpl = t
                mon_type_name = cand
                break
        if not tpl:
            return [f"âŒ Monster template not found for **{preferred}.ini** or **{fallback}.ini** in `/monsters`."]


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]



        ac     = int(tpl.get("ac", 10))
        hd     = int(tpl.get("hd", 8))
        hpmod  = int(tpl.get("hpmod", 0))
        damage = str(tpl.get("damage", "2d8"))
        move   = int(tpl.get("move", 60))
        saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
        resist  = str(tpl.get("resist",  "")).strip()
        reduce1 = str(tpl.get("reduce1", "")).strip()
        immune  = str(tpl.get("immune",  "")).strip()
        weak    = str(tpl.get("weak",    "")).strip()
        special = str(tpl.get("special", "")).strip()


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1)
            save_level = max(1, min(20, int(m.group(2))))
        else:
            save_class, save_level = "Fighter", max(1, hd)
        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


        prefix_map = {"air":"AI","fire":"FI","earth":"EA","water":"WA","wood":"WO","metal":"ME","ice":"IC","lightning":"LI"}
        prefix = prefix_map.get(want, "EL")
        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        i = 1
        while f"{prefix}{i}" in existing:
            i += 1
        mon = f"{prefix}{i}"


        hp = sum(random.randint(1, 8) for _ in range(hd)) + hpmod
        hp = max(1, hp)


        coe = configparser.ConfigParser()
        coe.optionxform = str
        coe["version"] = {"current": "08082018"}
        owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)
        coe["info"] = {
            "race": "Monster", "class": "Monster", "sex": "",
            "name": mon, "owner_id": owner_id,
            "monster_type": mon_type_name,
            "battle_chan": chan_id,
            "controller": caster_name,
            "summoned": "elemental",
            "elemental_type": want,
        }
        coe["max"] = {"hp": str(hp)}
        coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}

        stats = {
            "ac": str(ac), "ab": "", "move": str(move),
            "type": str(tpl.get("type", "")).strip(),
            "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
            "special": special,
        }

        attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
        atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
        attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
        if attack_list:
            stats["attacknames"] = " ".join(attack_list)
            first_spec = None
            for an in attack_list:
                spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                if spec:
                    stats[f"atk_{an}"] = spec
                    if first_spec is None:
                        first_spec = spec
            stats["damage"] = first_spec or damage or "1d6"
        else:
            stats["damage"] = damage or "1d6"

        coe["stats"] = stats
        coe["base"]  = dict(stats)
        coe["saves"] = saves_out
        coe["thief_mods"] = {}
        coe["banned_weapons"] = {"list": ""}
        coe["skills"] = {"list": ""}

        with open(f"{mon}.coe", "w", encoding="utf-8") as f:
            coe.write(f)


        names, scores = _parse_combatants(bcfg, chan_id)
        d6 = random.randint(1, 6)
        if mon not in names:
            names.append(mon)
        scores[mon] = d6
        _write_combatants(bcfg, chan_id, names, scores)


        try:
            s_me = _slot(_find_ci_name(names, caster_name) or caster_name)
        except Exception:
            s_me = (caster_name or "").replace(" ", "_")
        try:
            s_el = _slot(mon)
        except Exception:
            s_el = mon.replace(" ", "_")

        bcfg.set(chan_id, f"{s_me}.elem_conc", "1")
        bcfg.set(chan_id, f"{s_me}.elem_conc_by", caster_name)
        bcfg.set(chan_id, f"{s_el}.elem_by", caster_name)
        bcfg.set(chan_id, f"{s_el}.elem_type", want)
        bcfg.set(chan_id, f"{s_el}.hostile", "0")
        bcfg.set(chan_id, f"{s_el}.disp", mon)


        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
        bcfg.set(chan_id, "join_seq", str(join_seq))
        bcfg.set(chan_id, f"{s_el}.join", str(join_seq))

        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        pretty = want.title()
        return [
            f"ðŸŒªï¸ **{caster_name}** conjures one **{pretty} Elemental**!",
            f"â€¢ **{mon}** joins initiative (1d6 â†’ **{d6}**).",
            "ðŸ§  You must **concentrate** to control it. Use `!conc drop` to release control (it becomes **hostile**)."
        ]

    def _effect_feeblemind(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        """
        Feeblemind
        Range 180'; Duration: Permanent.
        Save vs Spells (target gets -4 if they are a spellcaster). On fail:
          - RP: victim cannot cast, speak/understand language, or communicate
          - Marks a permanent Feeblemind tag in the tracker ([FB â€“])
        Optional: pass -w to *write* INT/CHA=1 into [stats] (originals saved for restore)
        """


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None

        def _is_spellcaster(cfg) -> bool:
            raw = (get_compat(cfg, "info", "class", fallback="") or "").lower()

            parts = re.split(r"[^\w]+", raw)
            canon = {re.sub(r"[^a-z]", "", p) for p in parts if p}

            caster_set = {
                "cleric", "druid", "magicuser", "illusionist",
                "necromancer", "spellcrafter", "wizard", "mage"
            }
            return any(p in caster_set for p in canon)


        if not tokens:
            return [
                "âŒ Usage: `!cast Feeblemind <Target> [-w]`",
                "Add `-w` to actually set **INT**/**CHA** to 1 in the sheet (defaults to RP-only tag).",
            ]
        opts = {t.lower() for t in tokens if t.startswith("-")}
        pos  = [t for t in tokens if not t.startswith("-")]
        tgt_arg = pos[0]
        do_write = ("-w" in opts) or ("-write" in opts) or ("-mutate" in opts)

        tgt_disp, tgt_path = _resolve_char_ci_local(tgt_arg)
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]
        tcfg = read_cfg(tgt_path)

        lines = [f"ðŸ§  **Feeblemind**: {caster_name} assaults the mind of **{tgt_disp}**."]


        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            lines.append(f"Mirror Image: a figment is struck and collapses. Images left: **{left_imgs}**.")
            return lines


        penalty = -4 if _is_spellcaster(tcfg) else 0
        ok, roll, dc, _pen = self._roll_save(tcfg, vs="spell", penalty=penalty)
        pen_note = " (â€“4 spellcaster)" if penalty else ""
        lines.append(f"Save vs Spells{pen_note}: {roll} vs {dc} â†’ **{'RESISTED' if ok else 'FAIL'}**")
        if ok:
            lines.append("The victim shrugs off the assault.")
            return lines


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        chan_id = _section_id(ctx.channel) if "_section_id" in globals() else str(ctx.channel.id)
        PERM_ROUNDS = 10_000_000

        if bcfg and bcfg.has_section(chan_id):

            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try: s_tgt = _slot(key)
            except Exception: s_tgt = key.replace(" ", "_")


            for k in (f"{s_tgt}.feeble", f"{s_tgt}.feeble_perm", f"{s_tgt}.feeble_by", f"{s_tgt}.feeble_note"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)

            bcfg.set(chan_id, f"{s_tgt}.feeble",      str(PERM_ROUNDS))
            bcfg.set(chan_id, f"{s_tgt}.feeble_perm", "1")
            bcfg.set(chan_id, f"{s_tgt}.feeble_by",   caster_name)
            bcfg.set(chan_id, f"{s_tgt}.feeble_note", "INT/CHA=1; cannot cast/speak")
            _save_battles(bcfg)


            try:
                loop = getattr(self.bot, "loop", None)
                if loop and not loop.is_closed():
                    loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                else:
                    asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
            except Exception:
                pass


        if do_write:
            try:

                if not tcfg.has_section("feeblemind"):
                    tcfg.add_section("feeblemind")
                if not tcfg.has_option("feeblemind", "prev_int"):
                    prev_int = getint_compat(tcfg, "stats", "int",
                                 fallback=getint_compat(tcfg, "base", "int", fallback=1))
                    tcfg.set("feeblemind", "prev_int", str(prev_int))
                if not tcfg.has_option("feeblemind", "prev_cha"):
                    prev_cha = getint_compat(tcfg, "stats", "cha",
                                 fallback=getint_compat(tcfg, "base", "cha", fallback=1))
                    tcfg.set("feeblemind", "prev_cha", str(prev_cha))


                if not tcfg.has_section("stats"):
                    tcfg.add_section("stats")
                tcfg.set("stats", "int", "1")
                tcfg.set("stats", "cha", "1")

                write_cfg(tgt_path, tcfg)
                lines.append("Effect applied: **INT**/**CHA** set to **1** on the sheet (stored prior values).")
            except Exception:
                lines.append("Effect applied (RP), but failed to write INT/CHA=1 to the sheet.")


        lines.append("Victim cannot cast spells, speak, or understand language; they still recognize allies and try to help.")
        lines.append("This effect is **permanent** until removed by **Heal** or **Restoremind**.")
        return lines

    def _effect_restoremind(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        """
        Restoremind
        Range 180'; Duration: Permanent.
        Removes Feeblemind from the target. If the sheet was mutated by Feeblemind (-w),
        restores INT/CHA from stored values (or from [base] as a fallback).
        """

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None

        if not tokens:
            return ["âŒ Usage: `!cast Restoremind <Target>`"]

        tgt_arg = tokens[0]
        tgt_disp, tgt_path = _resolve_char_ci_local(tgt_arg)
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]
        tcfg = read_cfg(tgt_path)

        lines = [f"ðŸ•Šï¸ **Restoremind**: {caster_name} attempts to restore **{tgt_disp}**."]


        removed_any = False
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        chan_id = _section_id(ctx.channel) if "_section_id" in globals() else str(ctx.channel.id)
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try: s_tgt = _slot(key)
            except Exception: s_tgt = key.replace(" ", "_")

            for k in (f"{s_tgt}.feeble", f"{s_tgt}.feeble_perm", f"{s_tgt}.feeble_by", f"{s_tgt}.feeble_note"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)
                    removed_any = True
            if removed_any:
                _save_battles(bcfg)
                try:
                    loop = getattr(self.bot, "loop", None)
                    if loop and not loop.is_closed():
                        loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                    else:
                        asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                except Exception:
                    pass


        restored = False
        try:
            if tcfg.has_section("feeblemind"):
                p_int = getint_compat(tcfg, "feeblemind", "prev_int", fallback=None)
                p_cha = getint_compat(tcfg, "feeblemind", "prev_cha", fallback=None)
            else:
                p_int = p_cha = None

            if not tcfg.has_section("stats"):
                tcfg.add_section("stats")

            if p_int is not None or p_cha is not None:
                if p_int is not None: tcfg.set("stats", "int", str(p_int))
                if p_cha is not None: tcfg.set("stats", "cha", str(p_cha))
                restored = True
            else:

                b_int = getint_compat(tcfg, "base", "int", fallback=None)
                b_cha = getint_compat(tcfg, "base", "cha", fallback=None)
                if b_int is not None: tcfg.set("stats", "int", str(b_int)); restored = True
                if b_cha is not None: tcfg.set("stats", "cha", str(b_cha)); restored = True


            if tcfg.has_section("feeblemind"):
                try:
                    tcfg.remove_section("feeblemind")
                except Exception:
                    pass

            if restored:
                write_cfg(tgt_path, tcfg)
        except Exception:
            pass

        if removed_any or restored:
            lines.append("Feeblemind effects are **removed**.")
            if restored:
                lines.append("INT/CHA restored on the sheet.")
        else:
            lines.append("No tracked Feeblemind found here (or sheet changes not detected).")

        return lines

    def _effect_stoneskin(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        """
        Stoneskin
        Range: Touch; Duration: 1 turn/level.
        Soaks the first 10 damage per caster level from **attacks** (not spells). Discharges when pool is used.
        Classes: Druid 5, Magic-User 5, Spellcrafter 5.
        Usage: !cast Stoneskin [Target]   (defaults to self)
        """


        tgt_arg = (tokens[0] if tokens else caster_name)
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_arg)
        except Exception:
            tgt_disp, tgt_path = tgt_arg, None
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]


        pool = max(0, int(caster_level) * 10)
        turns = max(1, int(caster_level))
        rounds = turns * TURN_ROUNDS

        lines = [f"ðŸª¨ **Stoneskin**: {caster_name} hardens **{tgt_disp}**â€™s skin."]
        lines.append(f"Buffer: **{pool}** damage â€¢ Duration: **{turns} turn(s)** ({rounds} rounds).")


        bcfg = None
        try:
            bcfg = _load_battles()
        except Exception:
            pass


        try:
            chan_id = self._section_id(ctx.channel)
        except Exception:
            try:
                chan_id = _section_id(ctx.channel)
            except Exception:
                chan_id = str(ctx.channel.id)

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            rounds_key, pool_key, by_key = _stone_keys(slot)


            if (bcfg.has_option(chan_id, pool_key) or
                bcfg.has_option(chan_id, rounds_key)):
                lines.append("Previous Stoneskin **replaced**.")


            bcfg.set(chan_id, rounds_key, str(rounds))
            bcfg.set(chan_id, pool_key,   str(pool))
            bcfg.set(chan_id, by_key,     caster_name)


            aliases = [
                f"{slot}.ss_pool",
                f"{slot}.sspool",
                f"{slot}.ssbuf",
                f"{slot}.stoneskin",
                f"{slot}.ss",
            ]
            for alias in aliases:
                try:
                    bcfg.set(chan_id, alias, str(pool))
                except Exception:
                    pass


            try:
                bcfg.set(chan_id, f"{slot}.disp", tgt_disp)
            except Exception:
                pass

            _save_battles(bcfg)


            try:
                loop = getattr(self.bot, "loop", None)
                if loop and not loop.is_closed():
                    loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                else:
                    asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
            except Exception:
                pass

            lines.append(f"Tracker tag: **[SS {pool}]**")
        else:
            lines.append("Applied (no active battle to show countdown/tag).")

        return lines

    def _not_truly_alive(self, t_cfg, tgt_disp: str):
        """Return (is_immune, reason) for undead/construct/golem/ooze."""
        try:

            if _is_undead_cfg(t_cfg, tgt_disp):
                return True, "Undead â€” no effect"
        except Exception:
            pass


        hay = " ".join([
            get_compat(t_cfg, "info", "class", fallback=""),
            get_compat(t_cfg, "info", "race",  fallback=""),
            get_compat(t_cfg, "base", "type",  fallback=""),
            get_compat(t_cfg, "base", "tags",  fallback=""),
            get_compat(t_cfg, "stats","type",  fallback=""),
        ]).lower()


        for kw in ("construct", "golem", "animated"):
            if kw in hay:
                return True, "Construct/Golem â€” no effect"


        for kw in ("ooze", "slime", "jelly", "pudding"):
            if kw in hay:
                return True, "Ooze â€” no effect"

        return False, ""

    def _roll_death_save(self, t_cfg):
        """Try a few common codes for 'Save vs Death Ray'."""
        for code in ("poi", "death", "deathray", "poison"):
            sv_ok, sv_roll, sv_dc, note = self._roll_save(t_cfg, vs=code, penalty=0)
            if sv_dc is not None:
                return sv_ok, sv_roll, sv_dc, note

        return False, None, None, None

    def _effect_deathspell(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Death Spell
          â€¢ Kills up to 3d12 HD of creatures (in listed order).
          â€¢ Immune: undead, constructs/golems, oozes; HD â‰¥ 8.
          â€¢ Each affected creature gets Save vs Death; fail â†’ die (unless PFED).
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        rolls = [random.randint(1, 12) for _ in range(3)]
        pool  = sum(rolls)
        lines = [
            "ðŸ’€ **Death Spell**",
            f"Kill capacity: 3d12 â†’ {rolls} = **{pool} HD**.",
            "*(Targets are checked in the order listed.)*",
        ]

        if not tokens:
            lines.append("â€¢ *(No targets provided.)*")
            return lines

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
            if old_hp is None:
                lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
                continue
            if old_hp <= 0:
                lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
                continue

            immune, why = self._not_truly_alive(t_cfg, tgt_disp)
            if immune:
                lines.append(f"â€¢ **{tgt_disp}**: {why}.")
                continue

            hd = max(1, int(self._hd_or_level_from_cfg(t_cfg)))
            if hd >= 8:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): HD â‰¥ 8 â€” **immune**.")
                continue

            if pool < hd:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Remaining pool **{pool}** < **{hd}** â€” **unaffected**.")
                continue
            pool -= hd

            sv_ok, sv_roll, sv_dc, _ = self._roll_death_save(t_cfg)
            if sv_dc is not None and sv_ok:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Death {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** (pool left: {pool})")
                continue
            note = f"Save vs Death {sv_roll} vs {sv_dc} â†’ **FAIL**" if sv_dc is not None else "*(no death save table â€” treating as failed)*"

            
            used, pfed_note = _pfed_try_absorb_sp(t_cfg, tgt_path, tag="death")
            if used:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note} â†’ {pfed_note} (pool left: {pool})")
                continue

            
            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = "0"
            write_cfg(tgt_path, t_cfg)

            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                    ".paralyzed",".blind",".blind_src",".blind_by",
                                    ".cc_blind_pending",".cs_blind_pending",
                                    ".cc",".cc_by",".cc_level",
                                    ".ck",".ck_by",".ck_level",
                                    ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                    ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass

            try:
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(0,    mhp, width=10)
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note}\n{before} â†’ **{after}** â˜ ï¸ **DEAD!** (pool left: {pool})")
            except Exception:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note}\nHP {old_hp} â†’ **0** â˜ ï¸ **DEAD!** (pool left: {pool})")

        if pool > 0:
            lines.append(f"Excess effectiveness is lost: **{pool} HD** unused.")
        return lines

    def _roll_spell_save(self, t_cfg):
        """Try common codes for 'Save vs Spells / RSW'."""
        for code in ("spell", "spells", "spl", "magic", "rsw", "wand", "staff", "rod"):
            sv_ok, sv_roll, sv_dc, note = self._roll_save(t_cfg, vs=code, penalty=0)
            if sv_dc is not None:
                return sv_ok, sv_roll, sv_dc, note

        return False, None, None, None

    def _effect_disintegrate(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Disintegrate
        â€¢ Any single creature or object is disintegrated (save vs Spells negates).
        â€¢ If the target saves, the spell is wasted.
        â€¢ Equipment worn/carried is not affected (flavor note).
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŸ¢ **Disintegrate**"]

        if not tokens:
            lines.append("â€¢ *(No target provided.)*")
            return lines


        raw0 = tokens[0]
        if len(tokens) > 1:
            others = ", ".join(tokens[1:])
            lines.append(f"*(Single-target spell â€” only **{raw0}** is affected; ignoring: {others})*")


        tgt_disp, tgt_path = self._resolve_char_ci_local(raw0)


        if not tgt_path:
            lines.append(f"â€¢ **{raw0}**: âœ¨ The object is **DISINTEGRATED** (â‰¤10Ã—10Ã—10 ft cube).")
            return lines


        t_cfg = read_cfg(tgt_path)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
            return lines
        if old_hp <= 0:
            lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_spell_save(t_cfg)
        if sv_dc is not None:
            if sv_ok:
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** (spell wasted).")
                return lines
            note = f"Save vs Spells {sv_roll} vs {sv_dc} â†’ **FAIL**"
        else:
            note = "*(no spells save table â€” treating as failed)*"


        t_cfg.setdefault("cur", {})
        t_cfg["cur"]["hp"] = "0"
        write_cfg(tgt_path, t_cfg)


        try:
            is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
        except Exception:
            is_mon = False

        if is_mon and bcfg and bcfg.has_section(chan_id):
            try:
                names, scores = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                if key in names:
                    names = [n for n in names if n != key]
                    if bcfg.has_option(chan_id, key):
                        bcfg.remove_option(chan_id, key)
                    s = _slot(key)
                    for suf in (
                        ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                        ".paralyzed",".blind",".blind_src",".blind_by",
                        ".cc_blind_pending",".cs_blind_pending",
                        ".cc",".cc_by",".cc_level",
                        ".ck",".ck_by",".ck_level",
                        ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                        ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                    ):
                        opt = f"{s}{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)

                    cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                    if cur_turn == key:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass


            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass


        try:
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(0,    mhp, width=10)
            lines.append(
                f"â€¢ **{tgt_disp}**: {note}\n"
                f"{before} â†’ **{after}** ðŸ’¨ **DISINTEGRATED**\n"
                f"_Equipment worn or carried falls to the ground._"
            )
        except Exception:
            lines.append(
                f"â€¢ **{tgt_disp}**: {note}\n"
                f"HP {old_hp} â†’ **0** ðŸ’¨ **DISINTEGRATED**\n"
                f"_Equipment worn or carried falls to the ground._"
            )

        return lines

    def _is_construct_cfg(self, t_cfg, pretty_name: str = "") -> bool:
        """
        True if the creature is a construct. Primary gate: [info] monster_type == construct.
        Also accepts common fallbacks in case some sheets use stats.type or synonyms.
        """
        mt = str(get_compat(t_cfg, "info", "monster_type", fallback="")).strip().lower()
        if mt == "construct":
            return True

        txt = " ".join(filter(None, [
            mt,
            str(get_compat(t_cfg, "stats", "type", fallback="")).lower(),
            pretty_name.lower()
        ]))

        SYN = {"construct", "golem", "automaton", "clockwork", "animated object", "robot"}
        return any(s in txt for s in SYN)

    async def _effect_repair(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Repair (Spellcrafter 1)
        - Heals only constructs by touch.
        - Does nothing to non-constructs (no harm, no heal).
        - Uses dice from spell list if present; fallback 1d6+1.
        """

        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **Repair**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        if not self._is_construct_cfg(t_cfg, pretty):
            return f"âœ¨ **Repair**: {pretty}: not a **construct** â€” *(no effect)*"


        dice_spec = "1d6+1"
        try:
            sec = None
            for s in self._spell_cp.sections():
                if "".join(ch.lower() for ch in s if ch.isalnum()) == "repair":
                    sec = s; break
            if sec:
                raw_desc = self._spell_cp.get(sec, "desc", fallback="") if self._spell_cp.has_option(sec, "desc") else ""
                m = re.search(r"\b\d+d\d+(?:\s*[+\-]\s*\d+)?\b", (raw_desc or ""), flags=re.I)
                if m:
                    dice_spec = m.group(0).replace(" ", "")
        except Exception:
            pass

        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

        if old_hp <= 0:
            head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
            return head + "\n" + f"{pretty}: already **DESTROYED** â€” cannot be repaired by this spell."

        new_hp = min(max_hp, old_hp + amount)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, width=10)
            after  = _life_bar(new_hp, max_hp, width=10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"
        line = f"{pretty}: **+{amount} HP** â€¢ {hp_txt}"
        return head + "\n" + line

    async def _effect_fleshtostone(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Flesh to Stone (MU 6 / Spellcrafter 6)
        Target: 1 living creature
        Duration: Permanent (until restored)
        Rules implemented:
          â€¢ Target gets a Save vs. Petrification/Paralysis (your 'para').
          â€¢ On a failed save, target is Petrified: tracker tag [PET â€“] (permanent).
          â€¢ Undead / obvious Constructs are unaffected.
          â€¢ Already-petrified creatures are unaffected.
        Notes:
          â€¢ We record <slot>.pet_perm = 1 and <slot>.pet_by = <caster_name>.
          â€¢ Your !ds handler should clear: pet, pet_perm, pet_by.
        """

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None


        def _save_vs_para(t_cfg):
            for tag in ("para", "parapet", "petrify", "petrification", "paralysis"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen, tag

            ok, roll, dc, pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            return ok, roll, dc, pen, "para?"


        def _is_constructish_cfg(t_cfg, disp: str) -> bool:
            try:
                blob = " ".join([
                    (get_compat(t_cfg, "base", "type", fallback="") or ""),
                    (get_compat(t_cfg, "info", "race", fallback="") or ""),
                    (disp or ""),
                ]).lower()
                for kw in ("construct", "golem", "animated object", "statue"):
                    if kw in blob:
                        return True
            except Exception:
                pass
            return False

        lines = ["ðŸ—¿ **Flesh to Stone** takes hold! *(Duration: Permanent)*"]
        if not tokens:
            lines.append("*(Add a target: `!cast fleshtostone <name>`)*")
            return lines

        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **unaffected**.")
                    continue
            except Exception:
                pass
            if _is_constructish_cfg(t_cfg, tgt_disp):
                lines.append(f"â€¢ **{tgt_disp}**: ðŸ› ï¸ Construct â€” **unaffected**.")
                continue


            slot = None
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")

                already = (
                    bcfg.getint(chan_id, f"{slot}.pet_perm", fallback=0) > 0
                    or bcfg.getint(chan_id, f"{slot}.pet", fallback=0) > 0
                )
                if already:
                    lines.append(f"â€¢ **{tgt_disp}**: already **Petrified** â€” **no effect**.")
                    continue


            sv_ok, sv_roll, sv_dc, _pen, tag_used = _save_vs_para(t_cfg)

            if sv_dc is None:
                save_txt = f"(rolled **{sv_roll}** vs **PARA**; target number unknown)"
                failed = True
            else:
                save_txt = f"(d20 **{sv_roll}** vs **{sv_dc}**)"

                failed = not sv_ok

            if not failed:
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Petrification {save_txt} â†’ **RESISTED**")
                continue


            if bcfg and bcfg.has_section(chan_id) and slot:
                bcfg.set(chan_id, f"{slot}.pet_perm", "1")
                bcfg.set(chan_id, f"{slot}.pet_by", caster_name)
                _save_battles(bcfg)


                try:
                    if bcfg and bcfg.has_section(chan_id):
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

                lines.append(f"â€¢ **{tgt_disp}**: Save vs Petrification {save_txt} â†’ **FAIL** â€” **PETRIFIED** `[PET â€“]`.")
            else:
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Petrification {save_txt} â†’ **FAIL** â€” would be **Petrified** (no active battle).")

        return lines

    def _effect_stonetoflesh(self, ctx, caster_cfg, caster_name, caster_level, tokens):
        """
        Stone to Flesh (MU 6 / Spellcrafter 6)
        Range 180'; Duration: Permanent.
        Reverses Flesh to Stone (and similar) on the target: removes PET status.
        Does nothing to ordinary stone or if no petrification is tracked.
        """

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        if not tokens:
            return ["âŒ Usage: `!cast StoneToFlesh <Target>`"]

        lines = [f"ðŸ—¿âž¡ï¸ **Stone to Flesh**: {caster_name} attempts restoration."]


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = _section_id(ctx.channel) if "_section_id" in globals() else str(ctx.channel.id)

        for tgt_arg in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(tgt_arg)
            if not tgt_path:
                lines.append(f"â€¢ **{tgt_arg}**: âŒ not found.")
                continue


            removed_any = False
            found_any = False

            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")


                keys = [
                    f"{slot}.pet",
                    f"{slot}.pet_perm",
                    f"{slot}.pet_by",
                    f"{slot}.pet_note",
                ]

                keys_alt = [
                    f"{slot}.petrified",
                    f"{slot}.petrify",
                    f"{slot}.petrif",
                ]

                if bcfg.has_option(chan_id, f"{slot}.pet"):
                    try:
                        if bcfg.getint(chan_id, f"{slot}.pet", fallback=0) > 0:
                            found_any = True
                    except Exception:
                        found_any = True
                if bcfg.has_option(chan_id, f"{slot}.pet_perm"):
                    try:
                        if bcfg.getint(chan_id, f"{slot}.pet_perm", fallback=0) > 0:
                            found_any = True
                    except Exception:
                        found_any = True

                for k in keys_alt:
                    if bcfg.has_option(chan_id, k):
                        found_any = True
                        break


                for k in (keys + keys_alt):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k)
                        removed_any = True

                if removed_any:
                    _save_battles(bcfg)

                    try:
                        loop = getattr(self.bot, "loop", None)
                        if loop and not loop.is_closed():
                            loop.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                        else:
                            asyncio.create_task(self._refresh_tracker_message(ctx, bcfg, chan_id))
                    except Exception:
                        pass

                if found_any:
                    lines.append(f"â€¢ **{tgt_disp}**: Petrification **removed** â€” flesh restored.")
                else:
                    lines.append(f"â€¢ **{tgt_disp}**: no tracked Petrification â€” **no effect** (ordinary stone or different source).")
            else:

                lines.append(f"â€¢ **{tgt_disp}**: would remove Petrification (no active battle).")

        return lines

    async def _cast_invisiblestalker(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Invisible Stalker: summons one invisible stalker that obeys the caster until slain,
        DispelEvil, or the task is fulfilled. No concentration required.
        Usage: !cast invisiblestalker
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        tpl = (_load_monster_template("invisiblestalker")
               or _load_monster_template("invisible_stalker")
               or _load_monster_template("invisible-stalker"))
        if not tpl:
            return ["âŒ Monster template not found for **invisiblestalker** (try `invisiblestalker.ini`)."]


        ac     = int(tpl.get("ac", 10))
        hd     = int(tpl.get("hd", 8))
        hpmod  = int(tpl.get("hpmod", 0))
        damage = str(tpl.get("damage", "2d6"))
        move   = int(tpl.get("move", 120))
        saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
        resist  = str(tpl.get("resist",  "")).strip()
        reduce1 = str(tpl.get("reduce1", "")).strip()
        immune  = str(tpl.get("immune",  "")).strip()
        weak    = str(tpl.get("weak",    "")).strip()


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
        else:
            save_class, save_level = "Fighter", max(1, hd)
        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        i = 1
        while f"IN{i}" in existing:
            i += 1
        mon = f"IN{i}"


        hp = sum(random.randint(1, 8) for _ in range(hd)) + hpmod
        hp = max(1, hp)


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        coe = configparser.ConfigParser()
        coe.optionxform = str
        coe["version"] = {"current": "08082018"}
        coe["info"] = {
            "race": "Monster", "class": "Monster", "sex": "",
            "name": mon, "owner_id": str(caster_owner_id),
            "monster_type": "invisiblestalker",
            "battle_chan": chan_id,
            "controller": caster_name,
            "summoned": "invisiblestalker",
        }
        coe["max"] = {"hp": str(hp)}
        coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


        stats = {
            "ac": str(ac), "ab": "", "move": str(move),
            "type": str(tpl.get("type", "")).strip(),
            "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
        }
        attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
        atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
        attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
        if attack_list:
            stats["attacknames"] = " ".join(attack_list)
            first_spec = None
            for an in attack_list:
                spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                            tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                if spec:
                    stats[f"atk_{an}"] = spec
                    if first_spec is None:
                        first_spec = spec
            stats["damage"] = first_spec or damage or "1d6"
        else:
            stats["damage"] = damage or "1d6"

        coe["stats"] = stats
        coe["base"]  = dict(stats)
        coe["saves"] = saves_out
        coe["thief_mods"] = {}
        coe["banned_weapons"] = {"list": ""}
        coe["skills"] = {"list": ""}

        with open(f"{mon}.coe", "w", encoding="utf-8") as f:
            coe.write(f)


        names, scores = _parse_combatants(bcfg, chan_id)
        d6 = random.randint(1, 6)
        if mon not in names:
            names.append(mon)
        scores[mon] = d6
        _write_combatants(bcfg, chan_id, names, scores)


        try:
            s_el = _slot(mon)
        except Exception:
            s_el = mon.replace(" ", "_")
        bcfg.set(chan_id, f"{s_el}.disp", mon)
        bcfg.set(chan_id, f"{s_el}.hostile", "0")

        bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
        bcfg.set(chan_id, f"{s_el}.minion_type", "invisiblestalker")


        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
        bcfg.set(chan_id, "join_seq", str(join_seq))
        bcfg.set(chan_id, f"{s_el}.join", str(join_seq))

        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return [
            f"ðŸ«¥ **{caster_name}** summons an **Invisible Stalker**!",
            f"â€¢ **{mon}** joins initiative (1d6 â†’ **{d6}**).",
            "It obeys your commands without concentration, until **DispelEvil**, it is **slain**, or the **task is complete**."
        ]

    async def _cast_shades(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Invisible Stalker: summons one invisible stalker that obeys the caster until slain,
        DispelEvil, or the task is fulfilled. No concentration required.
        Usage: !cast invisiblestalker
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        tpl = (_load_monster_template("shade")
               or _load_monster_template("shade")
               or _load_monster_template("shade"))
        if not tpl:
            return ["âŒ Monster template not found for **shade** (try `shade.ini`)."]


        ac     = int(tpl.get("ac", 10))
        hd     = int(tpl.get("hd", 8))
        hpmod  = int(tpl.get("hpmod", 0))
        damage = str(tpl.get("damage", "2d6"))
        move   = int(tpl.get("move", 120))
        saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
        resist  = str(tpl.get("resist",  "")).strip()
        reduce1 = str(tpl.get("reduce1", "")).strip()
        immune  = str(tpl.get("immune",  "")).strip()
        weak    = str(tpl.get("weak",    "")).strip()


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
        else:
            save_class, save_level = "Fighter", max(1, hd)
        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        i = 1
        while f"SH{i}" in existing:
            i += 1
        mon = f"SH{i}"


        hp = sum(random.randint(1, 8) for _ in range(hd)) + hpmod
        hp = max(1, hp)


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        coe = configparser.ConfigParser()
        coe.optionxform = str
        coe["version"] = {"current": "08082018"}
        coe["info"] = {
            "race": "Monster", "class": "Monster", "sex": "",
            "name": mon, "owner_id": str(caster_owner_id),
            "monster_type": "shade",
            "battle_chan": chan_id,
            "controller": caster_name,
            "summoned": "shade",
        }
        coe["max"] = {"hp": str(hp)}
        coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


        stats = {
            "ac": str(ac), "ab": "", "move": str(move),
            "type": str(tpl.get("type", "")).strip(),
            "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
        }
        attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
        atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
        attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
        if attack_list:
            stats["attacknames"] = " ".join(attack_list)
            first_spec = None
            for an in attack_list:
                spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                            tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                if spec:
                    stats[f"atk_{an}"] = spec
                    if first_spec is None:
                        first_spec = spec
            stats["damage"] = first_spec or damage or "1d6"
        else:
            stats["damage"] = damage or "1d6"

        coe["stats"] = stats
        coe["base"]  = dict(stats)
        coe["saves"] = saves_out
        coe["thief_mods"] = {}
        coe["banned_weapons"] = {"list": ""}
        coe["skills"] = {"list": ""}

        with open(f"{mon}.coe", "w", encoding="utf-8") as f:
            coe.write(f)


        names, scores = _parse_combatants(bcfg, chan_id)
        d6 = random.randint(1, 6)
        if mon not in names:
            names.append(mon)
        scores[mon] = d6
        _write_combatants(bcfg, chan_id, names, scores)


        try:
            s_el = _slot(mon)
        except Exception:
            s_el = mon.replace(" ", "_")
        bcfg.set(chan_id, f"{s_el}.disp", mon)
        bcfg.set(chan_id, f"{s_el}.hostile", "0")

        bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
        bcfg.set(chan_id, f"{s_el}.minion_type", "invisiblestalker")


        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
        bcfg.set(chan_id, "join_seq", str(join_seq))
        bcfg.set(chan_id, f"{s_el}.join", str(join_seq))

        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return [
            f"ðŸ•¶ï¸ **{caster_name}** summons a **Shade**!",
            f"â€¢ **{mon}** joins initiative (1d6 â†’ **{d6}**).",
        ]

    async def _cast_reincarnate(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Reincarnate (touch): Brings a dead (0 HP) PC back in a new young-adult body.
        Usage:
          !cast reincarnate <target>
          !cast reincarnate <target> <race>   # optional GM override or for 'Choice' result
        Notes:
          â€¢ Works only if target is at 0 HP.
          â€¢ Refuses on monsters/undead (monsters are removed on 0 anyway).
          â€¢ Keeps INT/WIS/CHA; re-rolls STR/DEX/CON (3d6).
          â€¢ Loses 1 level/HD; HP fully re-rolled.
        """


        def _norm(s: str) -> str:
            return re.sub(r"[^\w]+", "", (s or "").lower())

        def _resolve_char_ci(name: str):
                    try:
                        return self._resolve_char_ci(name)
                    except Exception:
                        base = name.replace(" ", "_").lower() + ".coe"
                        for fn in os.listdir("."):
                            if fn.lower() == base:
                                path = fn
                                try:
                                    cfg = read_cfg(path)
                                    real = get_compat(cfg, "info", "name", fallback=None)
                                    return (real or fn[:-4].replace("_", " ")), path
                                except Exception:
                                    return fn[:-4].replace("_", " "), path
                        return None, None

        race_alias = {
            "bugbear": "Bugbear",
            "dwarf": "Dwarf",
            "elf": "Elf",
            "gnoll": "Gnoll",
            "gnome": "Gnome",
            "goblin": "Goblin",
            "halfling": "Halfling",
            "human": "Human",
            "kobold": "Kobold",
            "lizardman": "Lizard Man",
            "lizard-man": "Lizard Man",
            "lizard": "Lizard Man",
            "orc": "Orc",
            "choice": "Choice",
        }

        want_name = None
        want_force_race = None
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t) for t in targets if str(t).strip()]
        else:
            toks = [t for t in re.split(r"\s+", str(targets or "").strip()) if t]
        if toks:
            want_name = toks[0]
        if len(toks) >= 2:
            rkey = _norm(toks[1])
            want_force_race = race_alias.get(rkey)

        if not want_name:
            return ["âŒ Usage: `!cast reincarnate <target> [race]`"]


        tgt_name, tgt_path = _resolve_char_ci(want_name)
        if not tgt_path:
            return [f"âŒ Target '{want_name}' not found."]
        if _is_monster_file(tgt_path):
            return [f"âŒ **{tgt_name}** is a monster/NPC record. Reincarnate is intended for PCs here."]

        tcfg = read_cfg(tgt_path)
        old_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_hp != 0:
            return [f"âŒ **{tgt_name}** is not at 0 HP. Reincarnate requires a deceased target (0 HP)."]


        race_now = (get_compat(tcfg, "info", "race", fallback="") or "").strip()
        if "undead" in race_now.lower():
            return [f"âŒ Undead are not affected by Reincarnate. (**{tgt_name}** is {race_now})."]


        d100 = random.randint(1, 100)

        def _race_from_roll(n: int) -> str:
            if n == 1: return "Bugbear"
            if 2 <= n <= 15: return "Dwarf"
            if 16 <= n <= 29: return "Elf"
            if n == 30: return "Gnoll"
            if 31 <= n <= 39: return "Gnome"
            if 40 <= n <= 46: return "Goblin"
            if 47 <= n <= 60: return "Halfling"
            if 61 <= n <= 88: return "Human"
            if 89 <= n <= 91: return "Kobold"
            if 92 <= n <= 93: return "Lizard Man"
            if 94 <= n <= 98: return "Orc"
            return "Choice"

        rolled_race = _race_from_roll(d100)

        final_race = want_force_race or (rolled_race if rolled_race != "Choice" else "Human")


        def _abil_mod(score: int) -> int:
            if score <= 3: return -3
            if score <= 5: return -2
            if score <= 8: return -1
            if score <= 12: return 0
            if score <= 15: return 1
            if score <= 17: return 2
            return 3

        def _roll_3d6():
            rolls = [random.randint(1,6) for _ in range(3)]
            return sum(rolls), rolls


        old_stats = {
            "str": getint_compat(tcfg, "stats", "str", fallback=10),
            "dex": getint_compat(tcfg, "stats", "dex", fallback=10),
            "con": getint_compat(tcfg, "stats", "con", fallback=10),
            "int": getint_compat(tcfg, "stats", "int", fallback=10),
            "wis": getint_compat(tcfg, "stats", "wis", fallback=10),
            "cha": getint_compat(tcfg, "stats", "cha", fallback=10),
        }

        new_str, str_rolls = _roll_3d6()
        new_dex, dex_rolls = _roll_3d6()
        new_con, con_rolls = _roll_3d6()

        new_mods = {
            "str_modifier": _abil_mod(new_str),
            "dex_modifier": _abil_mod(new_dex),
            "con_modifier": _abil_mod(new_con),
            "int_modifier": _abil_mod(old_stats["int"]),
            "wis_modifier": _abil_mod(old_stats["wis"]),
            "cha_modifier": _abil_mod(old_stats["cha"]),
        }


        lvl_before = max(1, getint_compat(tcfg, "cur", "level", fallback=1))
        lvl_after = max(1, lvl_before - 1)

        cls = (get_compat(tcfg, "info", "class", fallback="") or "").strip().lower()

        hd_map = {
            "magic-user": 4, "illusionist": 4, "thief": 4, "assassin": 4,
            "cleric": 6, "druid": 6, "scout": 6,
            "necromancer": 4, "spellcrafter": 4,
            "fightermage": 6, "magethief": 4,
            "fighter": 8, "paladin": 8, "ranger": 8, "barbarian": 10,
        }
        hd_die = hd_map.get(cls, 6)


        def _roll_hp_levels(n_levels: int, die: int, con_mod: int):
            rolls = [random.randint(1, die) for _ in range(max(0, n_levels))]
            total = sum(rolls) + con_mod * max(0, n_levels)
            return max(1, total), rolls

        new_max_hp, hp_rolls = _roll_hp_levels(lvl_after, hd_die, new_mods["con_modifier"])
        new_cur_hp = new_max_hp



        tcfg["info"]["race"] = final_race


        if not tcfg.has_section("stats"): tcfg.add_section("stats")
        tcfg["stats"]["str"] = str(new_str)
        tcfg["stats"]["dex"] = str(new_dex)
        tcfg["stats"]["con"] = str(new_con)

        tcfg["stats"]["int"] = str(old_stats["int"])
        tcfg["stats"]["wis"] = str(old_stats["wis"])
        tcfg["stats"]["cha"] = str(old_stats["cha"])

        for k, v in new_mods.items():
            tcfg["stats"][k] = str(v)


        if not tcfg.has_section("base"): tcfg.add_section("base")
        tcfg["base"]["str"] = str(new_str)
        tcfg["base"]["dex"] = str(new_dex)
        tcfg["base"]["con"] = str(new_con)

        tcfg["base"]["str_modifier"] = str(new_mods["str_modifier"])
        tcfg["base"]["dex_modifier"] = str(new_mods["dex_modifier"])
        tcfg["base"]["con_modifier"] = str(new_mods["con_modifier"])


        if not tcfg.has_section("max"): tcfg.add_section("max")
        if not tcfg.has_section("cur"): tcfg.add_section("cur")
        tcfg["cur"]["level"] = str(lvl_after)
        tcfg["max"]["hp"] = str(new_max_hp)
        tcfg["cur"]["hp"] = str(new_cur_hp)

        tcfg["cur"]["neg_levels"] = "0"
        tcfg["cur"]["neg_hp_loss_total"] = "0"

        write_cfg(tgt_path, tcfg)


        try:
            bcfg = _load_battles()
            chan_id = _section_id(ctx.channel)
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_name) or tgt_name
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")

                for suf in (".paralyzed",".blind",".oil",".acpen",".holds",".heldby",
                            ".inv",".inv_by",".inv_type",".inv_gid",".inv_leader",".inv_perm",
                            ".gas",".stoneskin",".disease"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)
        except Exception:
            pass


        try:
            bcfg = _load_battles()
            if bcfg and bcfg.has_section(_section_id(ctx.channel)):
                msg_id = bcfg.getint(_section_id(ctx.channel), "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, _section_id(ctx.channel))
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass


        rolls_txt = lambda rs: "[" + ", ".join(str(r) for r in rs) + "]"
        pretty_roll = f"d100 â†’ **{d100}** â†’ **{rolled_race}**"
        if rolled_race == "Choice" and not want_force_race:
            pretty_roll += " â†’ defaulted to **Human** (pass a race next time to choose)."
        elif want_force_race and rolled_race == "Choice":
            pretty_roll += f" â†’ player/GM choice: **{final_race}**"

        return [
            f"ðŸŒ± **Reincarnate!** {tgt_name} returns in a **{final_race}** body.",
            f"â€¢ {pretty_roll}",
            (f"â€¢ STR {old_stats['str']} â†’ **{new_str}** {rolls_txt(str_rolls)} "
             f"(mod **{new_mods['str_modifier']}**); "
             f"DEX {old_stats['dex']} â†’ **{new_dex}** {rolls_txt(dex_rolls)} "
             f"(mod **{new_mods['dex_modifier']}**); "
             f"CON {old_stats['con']} â†’ **{new_con}** {rolls_txt(con_rolls)} "
             f"(mod **{new_mods['con_modifier']}**)."),
            f"â€¢ INT/WIS/CHA **unchanged** ({old_stats['int']}/{old_stats['wis']}/{old_stats['cha']}).",
            f"â€¢ Level {lvl_before} â†’ **{lvl_after}**; HP re-rolled: **{new_max_hp}** {rolls_txt(hp_rolls)} (now fully healed).",
            "â³ A misty outline forms and solidifies over **1 hour**â€¦ then the new body takes its first breath.",
        ]

    async def conloss(self, ctx, who: str = None, points: int = 0, *, opts: str = ""):
        """
        Apply Constitution loss to a character.
        Usage:
          !conloss <name> <points>            # temp CON loss
          !conloss <name> <points> -perm     # permanent CON loss
        If <name> is omitted, uses your active character.
        """


        if points is None or int(points) <= 0:
            await ctx.send("âŒ Provide a positive number of CON points to lose, e.g. `!conloss holyman2 2`.")
            return
        points = int(points)

        want_perm = False
        if opts:
            tokens = [t.strip().lower() for t in re.split(r"\s+", opts) if t.strip()]
            want_perm = ("-perm" in tokens) or ("-p" in tokens) or ("perm" in tokens)


        if not who:
            who = get_active(ctx.author.id)
            if not who:
                await ctx.send("âŒ No active character. Use `!char <name>` first or pass a name: `!conloss <name> <n>`.")
                return

        disp_name, file_path = _resolve_char_ci(who)
        if not file_path:
            await ctx.send(f"âŒ Character '{who}' does not exist.")
            return

        cfg = read_cfg(file_path)


        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        allowed = (not owner_id) or (owner_id == str(ctx.author.id))
        if not allowed:

            try:
                bcfg = _load_battles()
                chan_id = _section_id(ctx.channel)
                if bcfg.has_section(chan_id):
                    dm_id = bcfg.get(chan_id, "DM", fallback="")
                    allowed = (str(ctx.author.id) == str(dm_id))
            except Exception:
                pass
        if not allowed:
            await ctx.send(f"âŒ You do not own '{disp_name}'.")
            return


        old_hp   = getint_compat(cfg, "cur", "hp",  fallback=0)
        old_max  = getint_compat(cfg, "max", "hp",  fallback=old_hp)
        cur_con  = getint_compat(cfg, "stats", "con", fallback=0)
        temp     = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
        perm     = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)
        peak     = getint_compat(cfg, "cur", "con_loss_peak", fallback=0)
        base_con = max(1, cur_con + temp + perm)


        if want_perm:

            hp_delta = self._apply_conloss_points(cfg, points, permanent=True)
        else:
            hp_delta = self._apply_conloss_points(cfg, points, permanent=False)


        write_cfg(file_path, cfg)
        cfg = read_cfg(file_path)

        new_hp  = getint_compat(cfg, "cur", "hp",  fallback=0)
        new_max = getint_compat(cfg, "max", "hp",  fallback=new_hp)
        cur_con = getint_compat(cfg, "stats", "con", fallback=0)
        temp    = getint_compat(cfg, "cur", "con_loss_temp", fallback=0)
        perm    = getint_compat(cfg, "cur", "con_loss_perm", fallback=0)


        clamped = False
        if new_hp > new_max:
            cfg["cur"]["hp"] = str(new_max)
            write_cfg(file_path, cfg)
            new_hp = new_max
            clamped = True


        title = f"ðŸ©¸ Constitution Loss afflicts {disp_name}"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))


        loss_kind = "permanent" if want_perm else "temp"
        embed.add_field(name="Loss Applied", value=f"**âˆ’{points} CON** ({loss_kind})", inline=False)


        con_line = f"**{base_con} â†’ {cur_con}** â€¢ temp **-{temp}**, perm **-{perm}**"
        embed.add_field(name="Constitution", value=con_line, inline=False)


        if old_max != new_max:
            delta = new_max - old_max
            sign  = "+" if delta > 0 else ""
            embed.add_field(name="Max HP", value=f"{old_max} â†’ **{new_max}**  ({sign}{delta} from CON)", inline=False)


        if clamped or old_hp != new_hp:
            tail = " *(clamped to new max)*" if clamped else ""
            embed.add_field(name="HP", value=f"{old_hp} â†’ **{new_hp}** / {new_max}{tail}", inline=False)


        embed.add_field(name="Effect", value="Victim appears aged. Long rest (`!lr`) restores 1 CON per day; "
                                             "if total loss exceeded 1, the **final** point requires a Save vs Death.", inline=False)

        await ctx.send(embed=embed)

    async def _effect_permanency(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Permanency (MU/Necro/Spellcrafter 6)
        Usage: !cast permanency <target> <spell>
        Allowed creature spells: DetectMagic, ProtectionFromEvil, ReadLanguages, ReadMagic, DetectInvisible, Fly
        Rules implemented:
          â€¢ Only those six (arcane) spells can be made permanent here.
          â€¢ No more than TWO permanency effects on a single creature (the 3rd fails).
          â€¢ If it would fail, there is NO CON COST. Otherwise, caster loses 1 CON permanently.
          â€¢ Target gets [CODE â€“] tag on tracker; any active [CODE N] timer is removed.
          â€¢ Dispel should clear the *_perm flag (snippet below).
        """


        def _norm(s: str) -> str:
            return re.sub(r"[^\w]+", "", (s or "").lower())


        PERM_SPELLS = {

            "detectmagic":         ("detectmagic",       "DM", "DetectMagic"),
            "protectionfromevil":  ("protectionfromevil","PF", "ProtectionFromEvil"),
            "readlanguages":       ("readlanguages",     "RL", "ReadLanguages"),
            "readmagic":           ("readmagic",         "RM", "ReadMagic"),
            "detectinvisible":     ("detectinvisible",   "DI", "DetectInvisible"),
            "fly":                 ("fly",               "FL", "Fly"),
        }


        def _abil_mod(score: int) -> int:
            if score <= 3: return -3
            if score <= 5: return -2
            if score <= 8: return -1
            if score <= 12: return 0
            if score <= 15: return 1
            if score <= 17: return 2
            return 3


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None


        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        if not tokens or len(tokens) < 2:
            return ["âŒ Usage: `!cast permanency <target> <spell>`",
                    "Spells: DetectMagic, ProtectionFromEvil, ReadLanguages, ReadMagic, DetectInvisible, Fly"]

        raw_tgt, raw_spell = tokens[0], tokens[1]
        tgt_disp, tgt_path = _resolve_char_ci_local(raw_tgt)
        if not tgt_path:
            return [f"âŒ Target '{raw_tgt}' not found."]


        key = _norm(raw_spell)
        if key not in PERM_SPELLS:
            return [f"âŒ `{raw_spell}` cannot be made permanent here.",
                    "Allowed: DetectMagic, ProtectionFromEvil, ReadLanguages, ReadMagic, DetectInvisible, Fly"]

        alias_key, CODE, label = PERM_SPELLS[key]


        slot_tgt = None
        base_slot = None
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            k = _find_ci_name(names, tgt_disp) or tgt_disp
            try:

                slot_tgt = _resolve_effect_slot(bcfg, chan_id, k) if '_resolve_effect_slot' in globals() else _slot(k)
            except Exception:
                slot_tgt = k.replace(" ", "_")

            try:
                base_slot = _slot(k)
            except Exception:
                base_slot = k.replace(" ", "_")


        def _count_target_perms() -> int:
            if not (bcfg and bcfg.has_section(chan_id) and slot_tgt):
                return 0
            count = 0
            for ak, _code, _lbl in [PERM_SPELLS[k] for k in PERM_SPELLS]:
                if bcfg.getint(chan_id, f"{slot_tgt}.x_{ak}_perm", fallback=0) > 0:
                    count += 1
            return count


        if bcfg and bcfg.has_section(chan_id) and slot_tgt:
            if bcfg.getint(chan_id, f"{slot_tgt}.x_{alias_key}_perm", fallback=0) > 0:
                return [f"âœ¨ **{tgt_disp}** already has **{label}** made permanent `[{CODE} â€“]` â€” **no effect**."]

            if _count_target_perms() >= 2:
                return [f"âŒ **{tgt_disp}** already has two permanent arcane effects from *Permanency* â€” this spell **fails**."]


        name_key = None
        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            name_key = (_find_ci_name(names, tgt_disp) or tgt_disp)
        except Exception:
            name_key = tgt_disp
        all_slots = _all_slots_for_display(bcfg, chan_id, tgt_disp, key_guess=name_key)


        for s in all_slots:
            _scrub_all_timers_for_code(bcfg, chan_id, s, code=CODE, label=label, alias_key=alias_key)


        slot_tgt = None
        if all_slots:

            try:
                slot_tgt = _resolve_effect_slot(bcfg, chan_id, name_key)
            except Exception:
                pass
            if not slot_tgt:
                slot_tgt = next(iter(all_slots))
            bcfg.set(chan_id, f"{slot_tgt}.x_{alias_key}_perm", "1")
            bcfg.set(chan_id, f"{slot_tgt}.x_{alias_key}_perm_by", caster_name)

        _save_battles(bcfg)


        caster_disp, caster_path = _resolve_char_ci_local(caster_name)
        if caster_path:
            ccfg = read_cfg(caster_path)


            old_hp   = getint_compat(ccfg, "cur", "hp",  fallback=0)
            old_max  = getint_compat(ccfg, "max", "hp",  fallback=old_hp)
            old_con  = getint_compat(ccfg, "stats", "con", fallback=0)


            hp_delta = self._apply_conloss_points(ccfg, 1, permanent=True)
            write_cfg(caster_path, ccfg)
            ccfg = read_cfg(caster_path)


            new_hp  = getint_compat(ccfg, "cur", "hp",  fallback=0)
            new_max = getint_compat(ccfg, "max", "hp",  fallback=new_hp)
            new_con = getint_compat(ccfg, "stats", "con", fallback=0)

            clamped = False
            if new_hp > new_max:
                ccfg["cur"]["hp"] = str(new_max)
                write_cfg(caster_path, ccfg)
                new_hp = new_max
                clamped = True


            if old_max != new_max:
                caster_con_note = (f"**{caster_disp}** suffers **â€“1 CON** "
                                   f"({old_con}â†’{new_con}); Max HP {old_max}â†’{new_max}.")
            else:
                caster_con_note = f"**{caster_disp}** suffers **â€“1 CON** ({old_con}â†’{new_con})."
        else:
            caster_con_note = f"**{caster_name}** suffers **â€“1 CON**."


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        return [
            f"ðŸ”— **Permanency!** {label} is now **permanent** on **{tgt_disp}** `[{CODE} â€“]`.",
            f"â€¢ {caster_con_note}",
            "â€¢ Lasts until **dispelled**; dispelling removes the effect immediately.",
            "â€¢ A creature can have **at most two** *Permanency* effects at a time.",
            {"suppress_timer": True}
        ]

    async def _effect_delayedblastfireball(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Delayed Blast Fireball
          â€¢ With targets: explode immediately â†’ (Lv)d6 + Lv fire to each (save vs Spells half)
          â€¢ Without targets: arm a DBF on the caster and show [DBF â€“] until thrown with !a delayedblastfireball ...
        """
        chan_id = str(ctx.channel.id)
        lv = max(1, int(caster_level or 1))
        dice_spec = f"{lv}d6"

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        if targets:

            total, rolls, flat = roll_dice(dice_spec)
            base_dmg = max(0, total + flat + lv)

            lines = []
            any_hp_changes = False
            dead_monsters = []

            for raw in targets:
                disp, path = _resolve_char_ci(raw)
                pretty = disp or raw
                if not path:
                    lines.append(f"{pretty}: *(not found)*")
                    continue

                t_cfg = read_cfg(path)


                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")


            absorbs_fire = ("fire" in _collect_absorb_types(t_cfg))

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                ok = False

            rf_bonus = self._rc_rf_save_bonus(t_cfg, chan_id, pretty, "fire")
            pff_bonus = self._pf_other_save_bonus(chan_id, pretty, "fire")
            total_bonus = rf_bonus + pff_bonus

            if absorbs_fire:
                ok = False
            else:
                try:
                    eff_roll = sv_roll - (sv_pen or 0)
                    if sv_dc is not None and not ok and (eff_roll + total_bonus) >= sv_dc:
                        ok = True
                except Exception:
                    pass

            override = self._pf_other_damage_override(base_dmg, ok, chan_id, pretty, "fire")
            pre_mit = (override if override is not None else (base_dmg // 2 if ok else base_dmg))

            final, note = _apply_mitigation(pre_mit, weapon_name="Delayed Blast Fireball", weapon_type="fire",
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            res_txt  = "**RESIST**" if ok else "**FAIL**"
            auto_txt = " (auto-fail: absorbs fire)" if absorbs_fire else ""
            amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"

            dup_heal = (final < 0) and note and ("heals" in note.lower())
            amt_part = "" if dup_heal else f" â†’ {amt_txt}"

            line = f"{pretty}: Save vs. Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


            if dead_monsters:
                try:
                    bcfg = _load_battles()
                    if bcfg.has_section(chan_id):
                        names, scores = _parse_combatants(bcfg, chan_id)
                        for pretty, path in dead_monsters:
                            key = _find_ci_name(names, pretty) or pretty
                            if key in names:
                                names = [n for n in names if n != key]
                                if bcfg.has_option(chan_id, key):
                                    bcfg.remove_option(chan_id, key)
                                s = _slot(key)

                                for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                    opt = f"{s}{suf}"
                                    if bcfg.has_option(chan_id, opt):
                                        bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)

                        current_turn = bcfg.get(chan_id, "turn", fallback="")
                        if current_turn and current_turn not in names:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass

                for _, p in dead_monsters:
                    try:
                        os.remove(os.path.abspath(p))
                    except Exception:
                        pass


            if any_hp_changes:
                try:
                    bcfg2 = _load_battles()
                    if bcfg2.has_section(chan_id):
                        msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg2, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                except Exception:
                    pass

            head = f"ðŸ’¥ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] + **{lv}** = **{base_dmg}**"
            return head + "\n" + "\n".join(lines)


        lines = []
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


            bcfg.set(chan_id, f"{s_me}.x_dbf", "-1")
            bcfg.set(chan_id, f"{s_me}.x_dbf_label", "DBF")
            bcfg.set(chan_id, f"{s_me}.x_dbf_emoji", "ðŸ’£")
            bcfg.set(chan_id, f"{s_me}.x_dbf_code",  "perm")

            bcfg.set(chan_id, f"{s_me}.dbf_die", dice_spec)
            bcfg.set(chan_id, f"{s_me}.dbf_flat", str(lv))
            bcfg.set(chan_id, f"{s_me}.dbf_by", caster_name)
            _save_battles(bcfg)

            lines.append("ðŸ’£ **Delayed Blast Fireball** is armed on you.")
            lines.append("Status: **[DBF â€“]** (throw it with `!a delayedblastfireball <targets>` on your turn).")


            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass
        else:
            lines.append("ðŸ’£ **Delayed Blast Fireball** would be armed, but no battle is active.")
            lines.append("When a battle is active, it shows as **[DBF â€“]** and you can throw it with `!a delayedblastfireball ...`.")

        return "\n".join(lines)

    async def _effect_powerwordstun(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Power Word Stun
          â€¢ One creature only; no save.
          â€¢ If HP >= 71 â†’ no effect.
          â€¢ If 36â€“70 HP â†’ stunned (paralyzed) 1d6 rounds.
          â€¢ If <=35 HP â†’ stunned (paralyzed) 2d6 turns (turn=60 rounds).
          â€¢ Uses the existing 'paralyzed' timer/status.
        """


        chosen_disp, chosen_path = None, None
        for raw in (targets or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            if path:
                chosen_disp, chosen_path = (disp or raw), path
                break

        if not chosen_path:
            return "ðŸ”Š **Power Word Stun** â€” _(no valid target found)_"


        t_cfg = read_cfg(chosen_path)
        cur_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        if cur_hp is None:

            cur_hp = getint_compat(t_cfg, "max", "hp", fallback=0)

        pretty = (chosen_disp or "").upper()


        try:
            bcfg = _load_battles()
            if bcfg and bcfg.has_section(str(ctx.channel.id)):
                self._hyp_break_if_targeted(str(ctx.channel.id), [chosen_disp])
        except Exception:
            pass


        if cur_hp >= 71:
            result = f"{pretty}: **unaffected** (current HP {cur_hp} â‰¥ 71)."
            head = "ðŸ”Š **Power Word Stun**"
            return f"{head}\n{result}"

        from cogs.combat import roll_dice
        if 36 <= cur_hp <= 70:
            rsum, rolls, flat = roll_dice("1d6")
            rounds = max(0, rsum + flat)
            try:
                self._set_status_rounds(ctx, chosen_disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass

            try:
                if bcfg and bcfg.has_section(str(ctx.channel.id)):
                    await self._update_tracker_message(ctx, bcfg, str(ctx.channel.id))
            except Exception:
                pass
            line = f"{pretty}: **STUNNED** *(paralyzed)* for **{rounds}** rounds (1d6 = {', '.join(map(str, rolls))})."
        else:
            rsum, rolls, flat = roll_dice("2d6")
            turns = max(0, rsum + flat)
            rounds = turns * 60
            try:
                self._set_status_rounds(ctx, chosen_disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            try:
                if bcfg and bcfg.has_section(str(ctx.channel.id)):
                    await self._update_tracker_message(ctx, bcfg, str(ctx.channel.id))
            except Exception:
                pass
            line = (f"{pretty}: **STUNNED** *(paralyzed)* for **{turns}** turns "
                    f"(2d6 = {', '.join(map(str, rolls))}) â€” **{rounds} rounds**.")

        head = "ðŸ”Š **Power Word Stun**"
        return f"{head}\n{line}"

    async def _effect_sword(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Sword (MU 7 / Spellcrafter 7)
          â€¢ Duration: 1 round/level (tracked on caster).
          â€¢ Attacks 1/round on casterâ€™s initiative turn.
          â€¢ To-hit: Fighter AB at caster level + caster INT mod.
          â€¢ Damage: 3d4; crits on 19â€“20 (double damage).
          â€¢ Hits as *magical force*.
          â€¢ Initiative keys used on caster's slot:
              <slot>.swd            = rounds remaining (int)
              <slot>.swd_last_round = last round the sword attacked (int; once/round gate)
        """

        chan_id = str(ctx.channel.id)
        rounds_total = max(1, int(caster_level or 1))


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            ci = _find_ci_name(names, caster_name) or caster_name
            s  = self._effect_slot_for(bcfg, chan_id, ci)
            bcfg.set(chan_id, f"{s}.swd", str(rounds_total))
            bcfg.set(chan_id, f"{s}.swd_last_round", "0")
            bcfg.set(chan_id, f"{s}.swd_by", caster_name)
            _save_battles(bcfg)

        head = (
            f"ðŸ—¡ï¸ **Sword** shimmers into being â€” duration **{rounds_total} rounds**. "
            "Use `!a sword <target>` once each round *on your turn*. "

        )


        if not tokens:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
            return head + "\n*(Tip: `!a sword go1`)*"

        await self._attack_sword(ctx, caster_cfg, caster_name, caster_level, [tokens[0]])
        return head


        tgt_disp, tgt_path = None, None
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tokens[0])
        except Exception:

            base = tokens[0].replace(" ", "_").lower() + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base:
                    tgt_path = fn
                    try:
                        cfg = read_cfg(fn)
                        tgt_disp = get_compat(cfg, "info", "name", fallback=fn[:-4].replace("_", " "))
                    except Exception:
                        tgt_disp = fn[:-4].replace("_", " ")

        text = await self._attack_sword(ctx, caster_cfg, caster_name, caster_level, [tgt_disp or tokens[0]])
        return head + "\n" + text

    async def _effect_gazereflection(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Gaze Reflection (Illusionist 1)
        Range: 0 (self) â€¢ Duration: 1 round/level
        Effect: While active, any gaze attack that targets you is reflected back to the attacker.
        Implementation:
          â€¢ Sets <slot>.x_gazereflection = rounds
          â€¢ Plus metadata so tracker shows [GR N]: code/label/_by
        """

        rounds = max(1, int(caster_level))
        lines = [f"ðŸªž **Gaze Reflection** surrounds {caster_name}'s eyes in a mirrored sheen.",
                 f"Duration: **{rounds} rounds** (1/level)."]

        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)

            if bcfg and bcfg.has_section(chan_id):

                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, caster_name) or caster_name
                except Exception:
                    key = caster_name
                try:
                    slot = _choose_slot_for_effects(bcfg, chan_id, key) if '_choose_slot_for_effects' in globals() else _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")


                bcfg.set(chan_id, f"{slot}.x_gazereflection", str(rounds))
                bcfg.set(chan_id, f"{slot}.x_gazereflection_code", "GR")
                bcfg.set(chan_id, f"{slot}.x_gazereflection_label", "Gaze Reflection")
                bcfg.set(chan_id, f"{slot}.x_gazereflection_by", caster_name)
                _save_battles(bcfg)


                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception:
                    pass

                lines.append("â†’ While **[GR]** is active, gaze attacks are *reflected back* at the attacker.")
            else:
                lines.append("â†’ *(No active battle â€” status will not be tracked here.)*")

        except Exception as e:
            lines.append(f"âš ï¸ Couldnâ€™t apply tracker status: `{type(e).__name__}`.")

        return lines

    async def _effect_removefear(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Remove Fear (Cleric/Illusionist/Necromancer 1)
        Range: Touch â€¢ Duration: Instantaneous
        If the target is currently under magical fear, they immediately get a new
        Save vs Spells with a +1/level bonus. On success, fear ends.
        Tracker:
          â€¢ Clears <slot>.fear and metadata on success.
        """

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        lines = [f"ðŸ˜Œ **Remove Fear**: {caster_name} extends a calming touch."]
        if not tokens:
            lines.append("*(Usage: `!cast removefear <target>`)*")
            return lines


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)


        bonus = max(0, int(caster_level))

        penalty = -bonus

        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ not found.")
                continue


            slot = None
            fear_found = False
            fear_rounds = None
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    slot = (_choose_slot_for_effects(bcfg, chan_id, key)
                            if '_choose_slot_for_effects' in globals() else _slot(key))
                except Exception:
                    slot = (tgt_disp or raw).replace(" ", "_")

                try:

                    fear_rounds = bcfg.getint(chan_id, f"{slot}.fear", fallback=0)
                    if fear_rounds and fear_rounds > 0:
                        fear_found = True

                    if not fear_found and bcfg.has_option(chan_id, f"{slot}.fear_perm"):
                        if bcfg.getint(chan_id, f"{slot}.fear_perm", fallback=0) > 0:
                            fear_found = True
                except Exception:
                    pass

            if not fear_found:
                lines.append(f"â€¢ **{tgt_disp}**: no tracked **Fear** â€” **no effect**.")
                continue


            t_cfg = read_cfg(tgt_path)
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=penalty)
            btxt = f" (+{bonus} bonus)" if bonus else ""
            stxt = f"(d20 **{sv_roll}** vs **{sv_dc}**{btxt})"

            if sv_dc is None:

                lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {stxt} â†’ **table missing** â€” cannot adjudicate.")
                continue

            if sv_ok:

                if bcfg and bcfg.has_section(chan_id) and slot:
                    for k in (f"{slot}.fear", f"{slot}.fear_src", f"{slot}.fear_by"):
                        if bcfg.has_option(chan_id, k):
                            bcfg.remove_option(chan_id, k)

                    if bcfg.has_option(chan_id, f"{slot}.fear_perm"):
                        bcfg.remove_option(chan_id, f"{slot}.fear_perm")
                    _save_battles(bcfg)


                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                    except Exception:
                        pass

                rem_txt = f" (was **{fear_rounds} rounds** left)" if (fear_rounds and fear_rounds > 0) else ""
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {stxt} â†’ **SUCCESS** â€” **Fear removed**{rem_txt}.")
            else:

                rem_txt = f" (**{fear_rounds} rounds** remaining)" if (fear_rounds and fear_rounds > 0) else ""
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {stxt} â†’ **FAIL** â€” remains **Frightened**{rem_txt}.")

        return lines

    def _is_humanoidish_form(self, mcfg, form_name: str) -> bool:
        """
        Loosely decide if a monster form is 'humanoid' by checking base.type / info.race / name.
        Extend the lists if you use different naming.
        """
        try:
            blob = " ".join([
                (get_compat(mcfg, "base", "type", fallback="") or ""),
                (get_compat(mcfg, "info", "race", fallback="") or ""),
                (form_name or ""),
            ]).lower()
        except Exception:
            blob = (form_name or "").lower()


        if "humanoid" in blob:
            return True


        HUMANOID_TOKENS = {
            "human","elf","dwarf","halfling","gnome","half-elf","halfelf","half-orc","halforc",
            "orc","goblin","hobgoblin","bugbear","kobold","gnoll","lizardman","lizardfolk","troglodyte",
            "yuan-ti","yak-man","yakman","tasloi","norker","grimlock","bullywug"
        }
        return any(tok in blob for tok in HUMANOID_TOKENS)

    def _extract_natural_attacks(self, mcfg) -> list[tuple[str,str]]:
        """
        From a monster .ini, return only 'natural' attacks as (name, dmg) pairs.
        We exclude anything that your item DB recognizes as a weapon (Battleaxe, Spear, etc).
        Also allow a keyword allowlist (claw, bite, etc) if the item DB is inconclusive.
        """
        out = []
        try:
            names_str = (get_compat(mcfg, "base", "attacknames", fallback="") or "").strip()
            if not names_str:
                return out
            cand_names = [s.strip() for s in names_str.split() if s.strip()]
        except Exception:
            return out

        NATURAL_HINTS = {"claw","bite","gore","hoof","hooves","slam","tail","tailslap","pincer",
                         "sting","tentacle","beak","wing","wingslam","fist","kick","headbutt"}


        def _get_dmg_ci(k: str) -> str | None:
            try:
                for opt, val in mcfg.items("base"):
                    if str(opt).strip().lower() == k.strip().lower():
                        return str(val).strip()
            except Exception:
                pass

            try:
                atk_key = f"atk_{k}".lower()
                for opt, val in mcfg.items("base"):
                    if str(opt).strip().lower() == atk_key:
                        return str(val).strip()
            except Exception:
                pass
            return None

        for nm in cand_names:

            try:
                canon, _item = self.find_item(nm)
                if canon is not None:
                    continue
            except Exception:
                pass


            low = nm.lower()
            looks_natural = (low in NATURAL_HINTS) or any(h in low for h in NATURAL_HINTS)
            if not looks_natural:

                continue

            dmg = _get_dmg_ci(nm)
            if dmg:
                out.append((nm, dmg))
        return out

    async def _effect_alterself(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Alter Self (Illusionist 2) â€“ Self only
        Duration: 10 minutes/level (60 rounds/level)
        Limits: target form must be humanoid; HD â‰¤ caster level and â‰¤ 5; no weapon attacks imported.
        You keep your own stats/AB/saves; you gain the form's AC/movement/natural attacks only.
        No special/supernatural/spell-like abilities and no extra attacks beyond normal.
        Gear continues to function (same general body plan/size).
        """

        if not tokens:
            return ["âŒ Usage: `!cast AlterSelf <Humanoid Form>`"]

        form_arg = tokens[0]


        form_pretty, mcfg = _load_monster_form(form_arg)
        if not mcfg:
            return [f"âŒ Form **{form_arg}** not found in /monsters."]


        m_hd = getint_compat(mcfg, "base", "hd", fallback=0)
        max_hd = min(int(caster_level), 5)
        if int(m_hd) > max_hd:
            return [f"âŒ {form_pretty} has {m_hd} HD; Alter Self limit is **â‰¤ {max_hd} HD**."]


        if not self._is_humanoidish_form(mcfg, form_pretty):
            return [f"âŒ {form_pretty} is not a recognized **humanoid** form for Alter Self."]


        cas_disp, cas_path = self._resolve_char_ci(caster_name)
        if not cas_path:
            return [f"âŒ Caster file for **{caster_name}** not found."]
        tcfg = read_cfg(cas_path)



        _poly_apply_overlay(tcfg, mcfg, form_pretty, kind="alter")


        naturals = self._extract_natural_attacks(mcfg)

        try:
            if not tcfg.has_section("poly"):
                tcfg.add_section("poly")




            if naturals:
                tcfg.set("poly", "attacks", " | ".join(f"{n}: {d}" for n, d in naturals))
            else:
                tcfg.set("poly", "attacks", "")

            tcfg.set("poly", "kind", "alter")
            tcfg.set("poly", "nogear", "0")

            tcfg.set("poly", "no_extra_attacks", "1")
        except Exception:
            pass

        write_cfg(cas_path, tcfg)


        rounds = max(0, int(caster_level)) * 60

        lines = [
            f"âœ¨ **Alter Self**: {caster_name} assumes the form of a **{form_pretty}**.",
            f"Duration: **{caster_level}Ã—10 minutes** (**{rounds} rounds**).",
            "You keep your own STR/DEX/etc., AB, HP, and saving throws.",
            "You gain the formâ€™s **AC**, movement (non-magical only), **natural attacks** (weapons excluded), racial traits, and gross physical qualities.",
            "No extra attacks beyond your normal routine; no special/supernatural/spell-like abilities.",
            "Gear continues to function (similar body plan/size).",
        ]



        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            self_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_self = _slot(self_key)
            except Exception:
                s_self = self_key.replace(" ", "_")


            for k in (f"{s_self}.ps", f"{s_self}.ps_by", f"{s_self}.ps_form"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)


            bcfg.set(chan_id, f"{s_self}.ps", str(rounds))
            bcfg.set(chan_id, f"{s_self}.ps_by", caster_name)
            bcfg.set(chan_id, f"{s_self}.ps_form", form_pretty)
            bcfg.set(chan_id, f"{s_self}.poly", form_pretty)
            bcfg.set(chan_id, f"{s_self}.ps_src", "alterself")
            _save_battles(bcfg)


            try:
                loop = getattr(self.bot, "loop", None)
                updater = getattr(self, "_refresh_tracker_message", None) or getattr(self, "_update_tracker_message", None)
                if updater:
                    if loop and not loop.is_closed():
                        loop.create_task(updater(ctx, bcfg, chan_id))
                    else:
                        asyncio.create_task(updater(ctx, bcfg, chan_id))
            except Exception:
                pass

        return lines

    async def _cast_blur(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Blur (Illusionist 2, Touch): targetâ€™s outline wavers.
        Attacks vs target: â€“4 on the first attempt from an attacker that turn, â€“2 on their successive attempts that turn.
        Saves: (optional) +1 vs direct magical attacks â€” not auto-wired globally here.
        Duration: 1 minute/level (6 rounds/level).
        """


        target_name = None
        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            target_name = targets.strip() or None
        if not target_name:
            target_name = caster_name


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]


        rounds = max(0, int(caster_level)) * 6

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        lines = []

        if tgt_disp == caster_name:
            lines.append(f"ðŸŒ€ **{caster_name}** becomes **Blurred**.")
        else:
            lines.append(f"ðŸŒ€ **{caster_name}** touches **{tgt_disp}** â†’ **Blurred**.")

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")


            bcfg.set(chan_id, f"{slot}.x_blur", str(rounds))
            bcfg.set(chan_id, f"{slot}.x_blur_code", "BL")
            bcfg.set(chan_id, f"{slot}.x_blur_label", "Blur")
            bcfg.set(chan_id, f"{slot}.x_blur_by", caster_name)
            _save_battles(bcfg)

            lines.append(f"**Blur** for **{rounds} rounds** ({caster_level} minute(s)).")
            lines.append("Attacks against target: âˆ’4 first attempt per attacker/turn; âˆ’2 on that attackerâ€™s additional attempts this turn.")
            lines.append("Detect Invisible does **not** negate. **True Seeing** cancels.")
        else:
            lines.append(f"**Blur** for **{rounds} rounds**. *(No active battle here â€” it wonâ€™t auto-tick.)*")

        return lines

    async def _cast_displacement(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Displacement (Illusionist 3, Touch)
        Target appears offset; all melee/missile attacks vs target suffer âˆ’4 to hit.
        Detect Invisible does NOT counter; True Seeing does. Ignored if attacker cannot see target (e.g., Invisible target).
        Duration: 2 rounds/level.
        """


        target_name = None
        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            target_name = targets.strip() or None
        if not target_name:
            target_name = caster_name


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]


        rounds = max(0, int(caster_level)) * 2

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        lines = []

        if tgt_disp == caster_name:
            lines.append(f"ðŸŽ­ **{caster_name}** becomes **Displaced**.")
        else:
            lines.append(f"ðŸŽ­ **{caster_name}** touches **{tgt_disp}** â†’ **Displaced**.")

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")


            bcfg.set(chan_id, f"{slot}.x_displacement", str(rounds))
            bcfg.set(chan_id, f"{slot}.x_displacement_code", "DP")
            bcfg.set(chan_id, f"{slot}.x_displacement_label", "Displacement")
            bcfg.set(chan_id, f"{slot}.x_displacement_by", caster_name)


            for suf in ("", "_code", "_label", "_by"):
                opt = f"{slot}.x_blur{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)

            _save_battles(bcfg)

            lines.append(f"**Displacement** for **{rounds} rounds**.")
            lines.append("All attacks vs target: **âˆ’4 to hit**. Detect Invisible does **not** negate; **True Seeing** cancels.")
        else:
            lines.append(f"**Displacement** for **{rounds} rounds**. *(No active battle here â€” it wonâ€™t auto-tick.)*")

        return lines

    def _effect_stinkingcloud(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        sc_rounds = max(1, int(caster_level) * 10)
        lines = ["ðŸ’¨ **Stinking Cloud** billows out!"]

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


            bcfg.set(chan_id, f"{s_me}.sc",       str(sc_rounds))
            bcfg.set(chan_id, f"{s_me}.sc_by",    caster_name)
            bcfg.set(chan_id, f"{s_me}.sc_level", str(int(caster_level)))
            _save_battles(bcfg)

            lines.append(
                f"Cloud persists on **{caster_name}** for **{sc_rounds} rounds**. "
                "*(Use `!a stinkingcloud ...` while it lasts â€” even out of turn.)*"
            )
        else:
            lines.append(f"Cloud would persist for **{sc_rounds} rounds** (no active battle here, not auto-ticking).")


        if tokens:
            lines.extend(self._apply_stinkingcloud_to_targets(chan_id, bcfg, caster_name, caster_level, tokens))

        return lines

    def _apply_stinkingcloud_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        lines = []
        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass
            try:
                if self._poison_immune(t_cfg):
                    lines.append(f"â€¢ **{tgt_disp}**: ðŸ§ª Poison-immune â€” **no effect**.")
                    continue
            except Exception:
                pass


            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is not None and sv_ok:
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED**")
                continue

            dur = random.randint(1, 4) + 1

            slot = _choose_slot_for_effects(bcfg, chan_id, tgt_disp)
            base = f"{slot}.x_nausea"

            cur = bcfg.getint(chan_id, base, fallback=0)
            newv = max(cur, dur)
            bcfg.set(chan_id, base, str(newv))
            bcfg.set(chan_id, f"{base}_label", "Nauseated")
            bcfg.set(chan_id, f"{base}_code",  "NA")
            bcfg.set(chan_id, f"{base}_by",    caster_name)
            _save_battles(bcfg)

            lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {sv_roll} vs {sv_dc} â†’ ðŸ¤¢ **NAUSEATED** for **{dur}** rounds" + (f" *(now {newv})*" if newv != dur else ""))

        return lines

    def _effect_phantasmal_killer(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Phantasmal Killer (Illusionist 4)
        â€¢ Target first makes Save vs Spells to disbelieve (success = no effect).
        â€¢ If failed, target then saves vs Petrify:
            - Fail: instant death (fear).
            - Success: takes 3d6 damage.
        â€¢ Range/Duration are rules text only here (no placement state).
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸ’€ **Phantasmal Killer**"]

        if not tokens:
            lines.append("â€¢ *(No target provided.)*")
            return lines


        raw0 = tokens[0]
        if len(tokens) > 1:
            others = ", ".join(tokens[1:])
            lines.append(f"*(Single-target spell â€” only **{raw0}** is affected; ignoring: {others})*")


        tgt_disp, tgt_path = self._resolve_char_ci_local(raw0)
        if not tgt_path:
            lines.append(f"â€¢ **{raw0}**: âš ï¸ *(creature not found â€” no effect)*")
            return lines

        t_cfg = read_cfg(tgt_path)

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
            return lines
        if old_hp <= 0:
            lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
            return lines


        sv1_ok, sv1_roll, sv1_dc, _ = self._roll_spell_save(t_cfg)
        if sv1_dc is not None and sv1_ok:
            lines.append(f"â€¢ **{tgt_disp}**: Save vs Spells {sv1_roll} vs {sv1_dc} â†’ âœ… **DISBELIEVED** (no effect).")
            return lines
        if sv1_dc is None:
            sv1_note = "*(no Spells save table â€” treating as failed)*"
        else:
            sv1_note = f"Save vs Spells {sv1_roll} vs {sv1_dc} â†’ **FAIL**"




        sv2_ok, sv2_roll, sv2_dc, _ = self._roll_save(t_cfg, vs="para", penalty=0)

        if sv2_dc is not None and not sv2_ok:

            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = "0"
            write_cfg(tgt_path, t_cfg)


            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False

            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (
                            ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                            ".paralyzed",".blind",".blind_src",".blind_by",
                            ".cc_blind_pending",".cs_blind_pending",
                            ".cc",".cc_by",".cc_level",
                            ".ck",".ck_by",".ck_level",
                            ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                            ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                        ):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)

                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass


                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass


            try:
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(0,    mhp, width=10)
                lines.append(
                    f"â€¢ **{tgt_disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ **FAIL**\n"
                    f"{before} â†’ **{after}**  â˜ ï¸ **DEAD!**"
                )
            except Exception:
                lines.append(
                    f"â€¢ **{tgt_disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ **FAIL**\n"
                    f"HP {old_hp} â†’ **0**  â˜ ï¸ **DEAD!**"
                )
            return lines



        d = [random.randint(1, 6) for _ in range(3)]
        dmg = sum(d)

        new_hp = max(0, old_hp - dmg)
        t_cfg.setdefault("cur", {})
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        died = (new_hp <= 0)


        if died and bcfg and bcfg.has_section(chan_id):
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if is_mon:
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (
                            ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                            ".paralyzed",".blind",".blind_src",".blind_by",
                            ".cc_blind_pending",".cs_blind_pending",
                            ".cc",".cc_by",".cc_level",
                            ".ck",".ck_by",".ck_level",
                            ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                            ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                        ):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)

                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass


        try:
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            tail = "  â˜ ï¸ **DEAD!**" if died else ""
            lines.append(
                f"â€¢ **{tgt_disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ âœ… **RESISTED TERROR**\n"
                f"3d6 = {d[0]}+{d[1]}+{d[2]} â†’ **{dmg}**\n"
                f"{before} â†’ **{after}**{tail}"
            )
        except Exception:
            tail = "  â˜ ï¸ **DEAD!**" if died else ""
            lines.append(
                f"â€¢ **{tgt_disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ âœ… **RESISTED TERROR**\n"
                f"3d6 â†’ **{dmg}**\n"
                f"HP {old_hp} â†’ **{new_hp}**{tail}"
            )

        return lines

    def _effect_suggestion(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Suggestion (Illusionist 4)
        â€¢ Target understands the language (GM adjudicates; we note but don't enforce here).
        â€¢ Undead are immune.
        â€¢ Target saves vs Spells (optional penalty like -1/-2 can be passed after the target).
          - Success: no effect.
          - Failure: apply a Suggestion status for 1 hr/level (as x_* timer, code 'SU').
        """
        chan_id = str(ctx.channel.id)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŸ¦ **Suggestion**"]

        if not tokens:
            lines.append("â€¢ *(No target provided.)*")
            return lines


        raw_target = None
        penalty = 0
        for tok in tokens:
            s = str(tok).strip()
            if re.fullmatch(r"[+-]?\d+", s):
                try:
                    penalty = int(s)
                except Exception:
                    penalty = 0
            elif raw_target is None:
                raw_target = s

        if raw_target is None:
            lines.append("â€¢ *(No valid target provided.)*")
            return lines

        if penalty:

            penalty = max(-5, min(5, penalty))


        extras = [t for t in tokens if str(t).strip() != raw_target]
        if len(extras) > 0:

            others = ", ".join(extras)
            lines.append(f"*(Single-target spell â€” only **{raw_target}** is affected; args: {others})*")


        tgt_disp, tgt_path = self._resolve_char_ci_local(raw_target)
        if not tgt_path:
            lines.append(f"â€¢ **{raw_target}**: âš ï¸ *(creature not found â€” no effect)*")
            return lines

        t_cfg = read_cfg(tgt_path)


        try:
            t_type = (get_compat(t_cfg, "stats", "type", fallback="") or
                      get_compat(t_cfg, "base",  "type", fallback="") or "").strip().lower()
        except Exception:
            t_type = ""
        if "undead" in t_type:
            lines.append(f"â€¢ **{tgt_disp}**: ðŸ›¡ï¸ Undead â€” **immune** to Suggestion.")
            return lines


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        if old_hp is None:
            lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
            return lines
        if old_hp <= 0:
            lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_spell_save(t_cfg)
        if sv_dc is None:

            lines.append(f"â€¢ **{tgt_disp}**: *(no Spells save table â€” treating as failed)*")
            sv_effective_ok = False
            sv_note = None
        else:
            eff_roll = sv_roll + penalty
            sv_effective_ok = (eff_roll >= sv_dc)
            pen_note = f" ({sv_roll}{' ' if penalty>=0 else ''}{penalty:+d} â†’ {eff_roll})" if penalty else f" ({sv_roll})"
            sv_note = f"Save vs Spells{pen_note} vs {sv_dc} â†’ " + ("âœ… **RESISTED**" if sv_effective_ok else "**FAIL**")

        if sv_note:
            lines.append(f"â€¢ **{tgt_disp}**: {sv_note}")

        if sv_effective_ok:

            lines.append("_Must be spoken in a language the target understands; obviously harmful suggestions auto-fail (GM call)._")
            return lines


        if not (bcfg and bcfg.has_section(chan_id)):
            lines.append("âš ï¸ *(No active battle section; applying status was skipped â€” save result stands.)*")
            return lines


        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []
        key = _find_ci_name(names, tgt_disp) or tgt_disp
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")


        dur_rounds = max(1, int(caster_level)) * 360

        bcfg.set(chan_id, f"{slot}.x_suggestion", str(dur_rounds))
        bcfg.set(chan_id, f"{slot}.x_suggestion_code", "SU")
        bcfg.set(chan_id, f"{slot}.x_suggestion_label", "Suggestion")
        bcfg.set(chan_id, f"{slot}.x_suggestion_by", caster_name)
        _save_battles(bcfg)


        hrs = max(1, int(caster_level))
        lines.append(f"â†’ **Applied** [SU {dur_rounds}] to **{tgt_disp}** (_Suggestion_; lasts ~{hrs} hour{'s' if hrs!=1 else ''}).")
        lines.append("_GM note: Must sound reasonable; explicitly harmful suggestions auto-negate. Target must understand the language._")

        return lines

    def _effect_mislead(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Mislead (Illusionist 5)
        â€¢ Caster: Improved Invisibility for 1 round/level (attacking/casting does NOT end it).
        â€¢ Illusory Double: figment like Spectral Force, lasts while caster concentrates + 3 rounds afterward.
          - While concentrating, we store [MSLD 0] on the CASTER (non-ticking).
          - On !conc drop: [MSLD 3] (keeps doing the last â€œscriptedâ€ activity).
        â€¢ The double can talk/gesture/move at casterâ€™s speed; cannot attack/cast (can pretend).
        â€¢ Place within 100 ft (GM adjudicates; we just note it).
        """
        chan_id = str(ctx.channel.id)

        lines = ["ðŸªž **Mislead**"]



        label = None
        overlap = False
        if tokens:

            toks = [t for t in tokens if isinstance(t, str) and t.strip()]
            keyset = {"overlap", "over", "superimpose", "superimposed"}
            overlap = any(t.lower() in keyset for t in toks)
            other = [t for t in toks if t.lower() not in keyset]
            if other:
                label = " ".join(other).strip()


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if not bcfg or not bcfg.has_section(chan_id):

            rounds_inv = max(1, int(caster_level or 1))
            lines.append(f"ðŸ«¥ **{caster_name}** becomes **Improved Invisible** for **{rounds_inv} rounds**.")
            lines.append("ðŸŽ­ An **illusory double** appears "
                         + ("perfectly superimposed over the caster" if overlap else "within 100 ft")
                         + (f" (\"{label}\")" if label else "") + ".")
            lines.append("_No active battle here â€” durations wonâ€™t auto-tick. Use GM adjudication._")
            return lines


        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        try:
            s_me = _slot(me_key)
        except Exception:
            s_me = me_key.replace(" ", "_")


        ROUNDS = max(1, int(caster_level or 1))
        bcfg.set(chan_id, f"{s_me}.inv", str(ROUNDS))
        bcfg.set(chan_id, f"{s_me}.inv_by", caster_name)
        bcfg.set(chan_id, f"{s_me}.inv_type", "imp")

        lines.append(f"ðŸ«¥ **{caster_name}** becomes **Improved Invisible** for **{ROUNDS} rounds** "
                     f"(attacking/casting **does not** end it).")


        bcfg.set(chan_id, f"{s_me}.x_mislead", "0")
        bcfg.set(chan_id, f"{s_me}.x_mislead_code", "MSLD")
        bcfg.set(chan_id, f"{s_me}.x_mislead_label", "Mislead (Double)")
        bcfg.set(chan_id, f"{s_me}.x_mislead_by", caster_name)


        bcfg.set(chan_id, f"{s_me}.msl_conc", "1")
        bcfg.set(chan_id, f"{s_me}.msl_conc_by", caster_name)
        _save_battles(bcfg)


        appear_txt = "perfectly superimposed over the caster" if overlap else "within 100 ft"
        lines.append("ðŸŽ­ An **illusory double** appears " + appear_txt +
                     (f' (disguised as: "{label}")' if label else "") + ".")
        lines.append("â€¢ Moves at your speed; can **talk/gesture**; **canâ€™t attack or cast** (may pretend).")
        lines.append("â€¢ You control it as long as you can **see** it. Use `!conc drop` when you stop concentrating â€” "
                     "**[MSLD 3]** will be applied automatically and the image keeps acting for those 3 rounds.")

        return lines

    async def _cast_greaterfear(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Greater Fear
          â€¢ Each named target: Save vs Spells.
              - FAIL: PANICKED â€” drop held, flee/cower. â€“2 to saves while it lasts.
                      Apply FR for 1 round/level. Also show [PANIC N] as an x_* tag.
              - SUCCESS: Shaken 1 round (â€“2 atk & saves). Show [SHAKEN 1] as an x_* tag.
          â€¢ Range/area is adjudicated by the DM; you name whoâ€™s in the 30 ft wave.
        """
        chan_id = str(ctx.channel.id)
        rounds = max(1, int(caster_level or 1))


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rcfg = read_cfg(path)
                            real = get_compat(rcfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        names = []
        if isinstance(targets, (list, tuple, set)):
            names = [t for t in targets if isinstance(t, str) and t.strip()]
        elif isinstance(targets, str):
            names = [t.strip() for t in targets.split() if t.strip()]

        if not names:
            return ["Usage: `!cast greaterfear <t1> <t2> ...`"]

        lines = [f"ðŸ˜± **{caster_name}** unleashes **Greater Fear**!"]
        any_changes = False

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        for raw in names:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path or not os.path.exists(path):
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(path)

            slot = None
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = (key or tgt_disp).replace(" ", "_")

            fear_mod = self._fear_save_mod_for_slot(bcfg, chan_id, slot) if slot else 0

            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=(-fear_mod))

            if sv_ok:

                if bcfg and bcfg.has_section(chan_id):
                    slot = self._effect_slot_for(bcfg, chan_id, pretty)
                    bcfg.set(chan_id, f"{slot}.x_shk", "1")
                    bcfg.set(chan_id, f"{slot}.x_shk_label", "Shaken")
                    bcfg.set(chan_id, f"{slot}.x_shk_code",  "SHK")
                    bcfg.set(chan_id, f"{slot}.x_shk_by",    caster_name)
                    _save_battles(bcfg)
                    any_changes = True
                    lines.append(f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** â†’ **SHAKEN 1 round** *(â€“2 atk & saves)*")
                else:
                    lines.append(f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** â†’ **Shaken 1 round** *(â€“2 atk & saves; no active battle, wonâ€™t auto-tick)*")
                continue


            if bcfg and bcfg.has_section(chan_id):
                slot = self._effect_slot_for(bcfg, chan_id, pretty)


                bcfg.set(chan_id, f"{slot}.fear",     str(rounds))
                bcfg.set(chan_id, f"{slot}.fear_src", "greaterfear")
                bcfg.set(chan_id, f"{slot}.fear_by",  caster_name)







                _save_battles(bcfg)
                try:
                    await self._refresh_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass

                any_changes = True

                lines.append(
                    f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ **FAIL** â†’ ðŸ˜µ **PANICKED** for **{rounds} rounds** â€” "
                    f"drops held, flees (cowers if cornered). *Remember: â€“2 to all saving throws while panicked.*"
                )
            else:
                lines.append(
                    f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ **FAIL** â†’ **PANICKED** for **{rounds} rounds** "
                    f"(â€“2 saves; no active battle, wonâ€™t auto-tick)."
                )


        if any_changes:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        return lines

    async def _effect_masssuggestion(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Mass Suggestion (Illusionist 6)
        â€¢ Applies Suggestion to multiple named creatures (GM chooses whoâ€™s in the 30Ã—30 area).
        â€¢ One optional numeric penalty (e.g. -1 / -2) applied to ALL saves.
        â€¢ Each target: save vs Spells; success = no effect; failure = [SU N] (1 hr/level).
        â€¢ Undead are immune. Target must understand the language; harmful suggestions auto-negate (GM call).
        """
        chan_id = str(ctx.channel.id)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŸ¦ **Mass Suggestion**", "*(Single suggestion applies to all named targets; GM adjudicates whoâ€™s in the 30-ft square.)*"]

        if not tokens:
            lines.append("â€¢ *(No targets provided.)*")
            return lines


        penalty = None
        targets = []
        for tok in tokens:
            s = str(tok).strip()
            if re.fullmatch(r"[+-]?\d+", s):
                penalty = int(s)
            else:
                targets.append(s)

        if penalty is None:
            penalty = 0
        else:
            penalty = max(-5, min(5, penalty))

        if not targets:
            lines.append("â€¢ *(No valid targets provided.)*")
            return lines


        dur_rounds = max(1, int(caster_level or 1)) * 360
        hrs = max(1, int(caster_level or 1))

        any_applied = False

        for raw_target in targets:

            tgt_disp, tgt_path = self._resolve_char_ci_local(raw_target)
            pretty = tgt_disp or raw_target
            if not tgt_path or not os.path.exists(tgt_path):
                lines.append(f"â€¢ **{pretty}**: âš ï¸ *(creature not found â€” no effect)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                t_type = (get_compat(t_cfg, "stats", "type", fallback="") or
                          get_compat(t_cfg, "base",  "type", fallback="") or "").strip().lower()
            except Exception:
                t_type = ""
            if "undead" in t_type:
                lines.append(f"â€¢ **{pretty}**: ðŸ›¡ï¸ Undead â€” **immune** to Suggestion.")
                continue


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            if old_hp is None:
                lines.append(f"â€¢ **{pretty}**: âš ï¸ No HP field â€” cannot resolve.")
                continue
            if old_hp <= 0:
                lines.append(f"â€¢ **{pretty}**: already â˜ ï¸ **dead**.")
                continue


            sv_ok, sv_roll, sv_dc, _ = self._roll_spell_save(t_cfg)
            if sv_dc is None:

                eff_ok = False
                pen_note = None
            else:
                eff_roll = sv_roll + penalty
                eff_ok = (eff_roll >= sv_dc)
                pen_note = f" ({sv_roll}{' ' if penalty>=0 else ''}{penalty:+d} â†’ {eff_roll})" if penalty else f" ({sv_roll})"

            if pen_note:
                lines.append(f"â€¢ **{pretty}**: Save vs Spells{pen_note} vs {sv_dc} â†’ " + ("âœ… **RESISTED**" if eff_ok else "**FAIL**"))

            if eff_ok:

                lines.append("_Must sound reasonable; harmful suggestions auto-fail. Target must understand the language._")
                continue


            if not (bcfg and bcfg.has_section(chan_id)):
                lines.append(f"â†’ Would apply [SU {dur_rounds}] to **{pretty}** "
                             f"(~{hrs} hour{'s' if hrs!=1 else ''}), but no active battle here.")
                continue

            slot = self._effect_slot_for(bcfg, chan_id, pretty)
            bcfg.set(chan_id, f"{slot}.x_suggestion",        str(dur_rounds))
            bcfg.set(chan_id, f"{slot}.x_suggestion_code",   "SU")
            bcfg.set(chan_id, f"{slot}.x_suggestion_label",  "Mass Suggestion")
            bcfg.set(chan_id, f"{slot}.x_suggestion_by",     caster_name)
            _save_battles(bcfg)
            any_applied = True

            lines.append(f"â†’ **Applied** [SU {dur_rounds}] to **{pretty}** "
                         f"(~{hrs} hour{'s' if hrs!=1 else ''}).")


        if any_applied:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


        lines.append("_GM note: One sentence or two, same suggestion to all; must sound reasonable; harmful asks auto-negate; each gets its own save; language must be understood._")

        return lines

    async def _effect_trueseeing(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        True Seeing (Clr 5 / Ill 6 / Spellcrafter 6)
        Range: Touch â€¢ Duration: 1 round/level â€¢ Sight range: ~120 ft (GM adjudicates; not enforced)
        Effect: Target sees through darkness/illusions; ignores Blur/Displacement; sees invisibility; does not beat fog/concealment/solid objects.
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)


        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        else:
            target_name = (targets or "").strip() or None
        if not target_name:
            return ["Usage: `!cast trueseeing <ally>`"]


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]


        rounds = max(1, int(caster_level))

        lines = [f"ðŸ‘ï¸ **{caster_name}** bestows **True Seeing** upon **{tgt_disp}** for **{rounds} round{'s' if rounds!=1 else ''}**."]
        if not (bcfg and bcfg.has_section(chan_id)):
            lines.append("_No active battle here â€” the timer wonâ€™t auto-tick, but the effect applies narratively._")
            return lines


        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.x_truesight",        str(rounds))
            bcfg.set(chan_id, f"{slot}.x_truesight_code",   "TS")
            bcfg.set(chan_id, f"{slot}.x_truesight_label",  "True Seeing")
            bcfg.set(chan_id, f"{slot}.x_truesight_by",     caster_name)
            _save_battles(bcfg)


            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass
        except Exception:
            lines.append("âš ï¸ Failed to set initiative status; GM track manually.")
        return lines

    def _maze_is_active(self, cfg, chan_id: str, name_key: str) -> tuple[bool, str, int]:
        """Returns (active, slot, until_round)."""
        try:
            slot = _slot(name_key)
        except Exception:
            slot = name_key.replace(" ", "_")
        cur_rd = cfg.getint(chan_id, "round", fallback=0)
        until = cfg.getint(chan_id, f"{slot}.maze_until", fallback=0)
        return (until > 0 and cur_rd < until, slot, until)

    def _clear_maze(self, cfg, chan_id: str, slot: str):

        for key in (f"{slot}.maze_until", f"{slot}.maze_by"):
            if cfg.has_option(chan_id, key):
                cfg.remove_option(chan_id, key)



        try:
            if '_clear_x_effect' in globals():
                _clear_x_effect(cfg, chan_id, slot, "x_maze")
            else:

                for suf in ("", "_code", "_label", "_emoji", "_by"):
                    opt = f"{slot}.x_maze{suf}"
                    if cfg.has_option(chan_id, opt):
                        cfg.remove_option(chan_id, opt)
        except Exception:

            for suf in ("", "_code", "_label", "_emoji", "_by"):
                opt = f"{slot}.x_maze{suf}"
                if cfg.has_option(chan_id, opt):
                    cfg.remove_option(chan_id, opt)

        _save_battles(cfg)

    def _is_minotaur(self, tgt_cfg) -> bool:

        for sec in ("info", "base", "monster", "stats"):
            try:
                v = (tgt_cfg.get(sec, "type", fallback="") or "").strip().lower()
                if v == "minotaur":
                    return True
            except Exception:
                pass
        return False

    def _tick_maze_on_turn(self, cfg, chan_id: str, name_key: str) -> tuple[bool, str | None]:
        """
        Start-of-turn Maze logic for 'name_key'.
        Returns (still_in_maze, note_for_channel_or_None).
        If they escape or duration expires, returns False.
        """
        active, slot, until = self._maze_is_active(cfg, chan_id, name_key)
        cur_rd = cfg.getint(chan_id, "round", fallback=0)


        if not active and until > 0 and cur_rd >= until:
            self._clear_maze(cfg, chan_id, slot)
            return (False, f"ðŸŒ€ **{name_key}** returns as **Maze** ends.")

        if not active:
            return (False, None)


        disp, path = _resolve_char_ci(name_key)
        if not path:

            return (True, None)

        def_cfg = read_cfg(path)
        ok, roll, dc, _pen = self._roll_save(def_cfg, vs="spl", penalty=0)

        if ok:
            self._clear_maze(cfg, chan_id, slot)
            return (False, f"ðŸŒ€ **Maze**: {name_key} rolls **{roll}** vs **{dc}** â†’ **ESCAPES** and reappears.")
        else:
            return (True, f"ðŸŒ€ **Maze**: {name_key} rolls **{roll}** vs **{dc}** â†’ **still lost** (turn skipped).")

    async def _effect_maze(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets, *_a, **_kw):
        """
        Maze (Ill 6): no save on cast; target attempts Save vs Spells at the start of *its* turn;
        ends automatically after 10 minutes (your code uses 60 rounds).
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan_id)):
            return "âŒ No battle running here."


        if isinstance(targets, (list, tuple, set)):
            target = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        else:
            target = (targets or "").strip() or None
        if not target:
            return "Usage: `!cast maze <target>`"

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        tgt_name, tgt_path = _resolve_char_ci(target)
        if not tgt_path or not os.path.exists(tgt_path):
            return f"âŒ Target '{target}' not found."
        tgt_cfg = read_cfg(tgt_path)


        if _is_monster_file(tgt_path) and self._is_minotaur(tgt_cfg):
            return f"ðŸŒ€ **Maze** has no effect: **{tgt_name}** is a **Minotaur** (immune)."


        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            slot_tgt = _slot(key)
        except Exception:
            slot_tgt = key.replace(" ", "_")


        cur_rd = bcfg.getint(chan_id, "round", fallback=0)
        active_until = bcfg.getint(chan_id, f"{slot_tgt}.maze_until", fallback=0)
        if active_until and cur_rd < active_until:
            return f"ðŸŒ€ **{tgt_name}** is already lost in a **Maze**."


        MAZE_DURATION_ROUNDS = 60
        bcfg.set(chan_id, f"{slot_tgt}.maze_until", str(cur_rd + MAZE_DURATION_ROUNDS))
        bcfg.set(chan_id, f"{slot_tgt}.maze_by",     caster_name or "Unknown")
        _save_battles(bcfg)


        return (f"ðŸŒ€ **{tgt_name}** vanishes into a labyrinth. "
                f"At the start of each of their turns: **Save vs Spells** to escape. "
                f"Ends automatically after **10 minutes** (60 rounds).")

    async def _effect_demand(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Demand (Illusionist 7)
        â€¢ Single target; Undead are immune.
        â€¢ Target must understand the language (GM adjudicates).
        â€¢ Save vs Spells; apply one numeric mod in [-4, +4]:
            negative = sounds reasonable (penalty to the save),
            positive = dangerous/hopeless (bonus to the save).
        â€¢ On failure (or willing acceptance), apply [SU N] as x_demand for 1 day/level.
        """
        chan_id = str(ctx.channel.id)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŸ¨ **Demand**"]

        if not tokens:
            lines.append("â€¢ *(No target provided.)*")
            return lines


        raw_target = None
        mod = 0
        willing = False
        for tok in tokens:
            s = str(tok).strip().lower()
            if re.fullmatch(r"[+-]?\d+", s):
                try:
                    mod = int(s)
                except Exception:
                    mod = 0
            elif s in {"-accept", "accept", "willing"}:
                willing = True
            elif raw_target is None:
                raw_target = str(tok)

        if raw_target is None:
            lines.append("â€¢ *(No valid target provided.)*")
            return lines

        mod = max(-4, min(4, mod))


        try:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw_target)
        except Exception:
            tgt_disp, tgt_path = self._resolve_char_ci(raw_target)
        if not tgt_path or not os.path.exists(tgt_path):
            lines.append(f"â€¢ **{raw_target}**: âš ï¸ *(creature not found â€” no effect)*")
            return lines
        t_cfg = read_cfg(tgt_path)


        try:
            t_type = (get_compat(t_cfg, "stats", "type", fallback="") or
                      get_compat(t_cfg, "base",  "type", fallback="") or "").strip().lower()
        except Exception:
            t_type = ""
        if "undead" in t_type:
            lines.append(f"â€¢ **{tgt_disp}**: ðŸ›¡ï¸ Undead â€” **immune** to Demand.")
            return lines


        hp_now = getint_compat(t_cfg, "cur", "hp", fallback=None)
        if hp_now is None:
            lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
            return lines
        if hp_now <= 0:
            lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
            return lines


        lines.append("_Must be spoken in a language the target understands; "
                     "obviously self-destructive demands auto-negate (GM adjudicates)._")


        sv_effective_ok = False
        sv_note = None
        if willing:
            lines.append(f"â€¢ **{tgt_disp}**: *(willingly accepts the Demand â€” no save)*")
        else:
            sv_ok, sv_roll, sv_dc, _ = self._roll_spell_save(t_cfg)
            if sv_dc is None:
                sv_effective_ok = False
                sv_note = f"â€¢ **{tgt_disp}**: *(no Spells save table â€” treating as failed)*"
            else:
                eff_roll = sv_roll + mod
                sv_effective_ok = (eff_roll >= sv_dc)
                adj = f" ({sv_roll}{' ' if mod>=0 else ''}{mod:+d} â†’ {eff_roll})" if mod else f" ({sv_roll})"
                sv_note = f"â€¢ **{tgt_disp}**: Save vs Spells{adj} vs {sv_dc} â†’ " + ("âœ… **RESISTED**" if sv_effective_ok else "**FAIL**")
            if sv_note:
                lines.append(sv_note)

        if sv_effective_ok:
            return lines


        if not (bcfg and bcfg.has_section(chan_id)):
            lines.append("âš ï¸ *(No active battle here; status not applied â€” adjudicate manually.)*")
            return lines


        try:
            names, _ = _parse_combatants(bcfg, chan_id)
        except Exception:
            names = []
        key = _find_ci_name(names, tgt_disp) or tgt_disp
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")


        dur_rounds = max(1, int(caster_level)) * 8640
        days = max(1, int(caster_level))

        bcfg.set(chan_id, f"{slot}.x_demand",        str(dur_rounds))
        bcfg.set(chan_id, f"{slot}.x_demand_code",   "SU")
        bcfg.set(chan_id, f"{slot}.x_demand_label",  "Demand")
        bcfg.set(chan_id, f"{slot}.x_demand_by",     caster_name)
        _save_battles(bcfg)


        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        lines.append(f"â†’ **Applied** [SU {dur_rounds}] to **{tgt_disp}** (_Demand_; lasts ~{days} day{'s' if days!=1 else ''}).")
        lines.append("_GM note: You may phrase a delayed trigger; if it never triggers, the effect expires at duration end. "
                     "Extremely dangerous/hopeless demands warrant a save **bonus**; very reasonable phrasing warrants a **penalty**._")

        return lines

    async def _effect_insanity(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Insanity (Illusionist 7)
        Range: 100 ft (+10/level). Target saves vs Spells.
          â€¢ On FAIL: permanent Confusion (only Heal/Restoration/Wish removes).
          â€¢ On SUCCESS: Confusion for 2 + level rounds.
        Undead/constructs/mindless are unaffected (mirrors Confusion).
        """
        chan_id = str(ctx.channel.id)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸŒš **Insanity**"]

        if not tokens:
            lines.append("â€¢ *(No target provided.)*")
            return lines

        raw_target = str(tokens[0]).strip()


        try:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw_target)
        except Exception:
            tgt_disp, tgt_path = self._resolve_char_ci(raw_target)
        if not tgt_path or not os.path.exists(tgt_path):
            lines.append(f"â€¢ **{raw_target}**: âš ï¸ *(creature not found â€” no effect)*")
            return lines

        t_cfg = read_cfg(tgt_path)


        try:
            if _is_undead_cfg(t_cfg, tgt_disp):
                lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                return lines
        except Exception:
            pass
        ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
              str(get_compat(t_cfg, "info",  "type", fallback=""))).lower()
        if any(k in ty for k in ("construct","golem","ooze","slime","jelly","mindless")):
            lines.append(f"â€¢ **{tgt_disp}**: construct/mindless â€” **no effect**.")
            return lines


        hp_now = getint_compat(t_cfg, "cur", "hp", fallback=None)
        if hp_now is None:
            lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
            return lines
        if hp_now <= 0:
            lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
            return lines


        sv_ok, sv_roll, sv_dc, sv_pen = self._roll_spell_save(t_cfg)
        if sv_dc is None:

            sv_effective_ok = False
            pen_txt = ""
        else:
            sv_effective_ok = (sv_roll + 0 >= sv_dc)
            pen_txt = f" - {sv_pen}" if sv_pen else ""

        d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
        if sv_effective_ok:
            lines.append(f"â€¢ **{tgt_disp}** â€” Save vs Spells {d20_face}{pen_txt} vs {sv_dc} â†’ âœ… **RESISTED**")

            dur_rounds = max(0, 2 + int(caster_level or 0))
            if bcfg and bcfg.has_section(chan_id) and dur_rounds > 0:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                s = self._effect_slot_for(bcfg, chan_id, key)
                prev = bcfg.getint(chan_id, f"{s}.cn", fallback=0)
                bcfg.set(chan_id, f"{s}.cn", str(max(prev, dur_rounds)))
                bcfg.set(chan_id, f"{s}.cn_by", caster_name)
                _save_battles(bcfg)
                lines.append(f"â†’ **Confused** for **{dur_rounds} rounds**.")
            return lines


        lines.append(f"â€¢ **{tgt_disp}** â€” Save vs Spells {d20_face}{pen_txt} vs {sv_dc} â†’ ðŸ˜µâ€ðŸ’« **MADNESS (permanent Confusion)**")

        if not (bcfg and bcfg.has_section(chan_id)):
            lines.append("âš ï¸ *(No active battle; mark Confusion manually.)*")
            return lines

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_disp) or tgt_disp
        s = self._effect_slot_for(bcfg, chan_id, key)


        bcfg.set(chan_id, f"{s}.cn_perm", "1")
        if bcfg.getint(chan_id, f"{s}.cn", fallback=0) <= 0:
            bcfg.set(chan_id, f"{s}.cn", "1")
        bcfg.set(chan_id, f"{s}.cn_by", caster_name)
        _save_battles(bcfg)


        lines.append("_Only **Heal**, **Restoration**, or **Wish** will remove this condition (per spell text)._")


        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return lines

    async def _effect_prismaticspray(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Prismatic Spray (Illusionist 7)
        Cone; each named target in the area is struck by 1 ray (d8) or 2 rays on an 8 (re-roll 8s).
        Targets HD â‰¤ 8 are also BLINDED 2d4 rounds (no save).
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        head = "ðŸŒˆ **Prismatic Spray**"
        if not tokens:
            return [f"{head}\nTargets: *(none)*"]

        lines = [head]
        any_hp_changes = False
        removed_from_ini = []
        dead_monsters = []

        def _res(name: str):

            try:
                return self._resolve_char_ci_local(name)
            except Exception:
                return _resolve_char_ci(name)


        def _save_mix(t_cfg, prim: str, alts=()):
            for tag in (prim, *alts):
                ok, r, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, r, dc, pen

            return False, 10, 15, 0


        def _apply_damage(t_disp: str, t_path: str, t_cfg, amount: int, dtype: str, label: str) -> tuple[str, int, int, bool]:
            nonlocal any_hp_changes
            mitig, note = _apply_mitigation(amount, weapon_name=f"Prismatic Spray ({label})", weapon_type=dtype, t_cfg=t_cfg, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - mitig) if mitig >= 0 else min(mhp, old_hp - mitig))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(t_path, t_cfg)
            any_hp_changes = True

            if _is_monster_file(t_path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10); after = _life_bar(new_hp, mhp2, width=10)
                hp_txt = f"{before} â†’ {after}{' â˜ ï¸ **DEAD!**' if new_hp <= 0 else ''}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**{' â˜ ï¸ **DEAD!**' if new_hp <= 0 else ''}"


            if mitig >= 0:
                amt_txt = f"**{mitig}**"
            else:
                if note and ("heals" in note.lower()):
                    amt_txt = ""
                else:
                    amt_txt = f"**heals {abs(mitig)}**"

            detail = (f"â†’ {amt_txt}" if amt_txt else "") + (f" ({note})" if note else "") + f"\n{hp_txt}"
            return detail, old_hp, new_hp, (_is_monster_file(t_path) and new_hp <= 0)

        for raw in tokens:
            disp, path = _res(raw)
            pretty = disp or raw
            if not path or not os.path.exists(path):
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(path)


            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"â€¢ **{pretty}**: Mirror Image **({cleared})** destroyed by area effect.")
            except Exception:
                pass


            try:
                hd = getint_compat(t_cfg, "cur", "level", fallback=1)
            except Exception:
                hd = 1
            if hd <= 8 and bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    try:
                        slot = _slot(key)
                    except Exception:
                        slot = key.replace(" ", "_")
                    s, rolls_b, flat_b = roll_dice("2d4")
                    rounds_blind = max(1, s + flat_b)
                    bcfg.set(chan_id, f"{slot}.blind",       str(rounds_blind))
                    bcfg.set(chan_id, f"{slot}.blind_src",   "prismatic")
                    bcfg.set(chan_id, f"{slot}.blind_by",    caster_name)
                    bcfg.set(chan_id, f"{slot}.blind_level", str(int(caster_level)))
                    _save_battles(bcfg)
                    lines.append(f"â€¢ **{pretty}**: **BLINDED** {rounds_blind} rounds (HD â‰¤ 8; no save).")
                except Exception:
                    pass


            def _roll_rays():
                d = random.randint(1, 8)
                if d != 8:
                    return [d]

                r1 = random.randint(1, 7)
                r2 = random.randint(1, 7)
                return [r1, r2]

            rays = _roll_rays()
            lines.append(f"â€¢ **{pretty}**: Rays â†’ {', '.join(str(r) for r in rays)}")


            slot = None
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    try:
                        slot = _slot(key)
                    except Exception:
                        slot = key.replace(" ", "_")
                except Exception:
                    pass

            target_dead = False
            removed_here = False

            for r in rays:
                if target_dead:
                    break



                if r == 1:
                    absorbs_fire = ("fire" in _collect_absorb_types(t_cfg))
                    ok, roll, dc, pen = _save_mix(t_cfg, "death", ("poi","dr"))
                    if absorbs_fire:
                        ok = False
                    dmg = 10 if ok else 20
                    detail, old_hp, new_hp, died = _apply_damage(pretty, path, t_cfg, dmg, "fire", "Red")
                    auto_txt = " (auto-fail: absorbs fire)" if absorbs_fire else ""
                    lines.append(
                        f"    ðŸ”´ Red â€” Save vs Death {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ "
                        f"{'âœ… HALF' if ok else '**FAIL**'}{auto_txt} {detail}"
                    )
                    target_dead = died


                elif r == 3:
                    absorbs_elec = ("electric" in _collect_absorb_types(t_cfg))
                    ok, roll, dc, pen = _save_mix(t_cfg, "death", ("poi","dr"))
                    if absorbs_elec:
                        ok = False
                    dmg = 40 if ok else 80
                    detail, old_hp, new_hp, died = _apply_damage(pretty, path, t_cfg, dmg, "electric", "Yellow")
                    auto_txt = " (auto-fail: absorbs electric)" if absorbs_elec else ""
                    lines.append(
                        f"    ðŸŸ¡ Yellow â€” Save vs Death {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ "
                        f"{'âœ… HALF' if ok else '**FAIL**'}{auto_txt} {detail}"
                    )
                    target_dead = died

                elif r == 2:
                    ok, roll, dc, pen = _save_mix(t_cfg, "death", ("poi","dr"))
                    dmg = 20 if ok else 40
                    detail, old_hp, new_hp, died = _apply_damage(pretty, path, t_cfg, dmg, "acid", "Orange")
                    lines.append(f"    ðŸŸ  Orange â€” Save vs Death {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ "
                                 f"{'âœ… HALF' if ok else '**FAIL**'} {detail}")
                    target_dead = died


                elif r == 4:
                    ok, roll, dc, pen = _save_mix(t_cfg, "poi", ("poison","death","dr"))
                    if ok:
                        lines.append(f"    ðŸŸ¢ Green â€” Save vs Poison {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ âœ… **RESISTED**")
                    else:

                        if _is_monster_file(path):
                            dead_monsters.append((pretty, path))
                            lines.append(f"    ðŸŸ¢ Green â€” Save vs Poison {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ â˜ ï¸ **DEAD!**")
                            target_dead = True
                        else:

                            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                            t_cfg["cur"]["hp"] = "0"; write_cfg(path, t_cfg); any_hp_changes = True
                            lines.append(f"    ðŸŸ¢ Green â€” Save vs Poison {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ â˜ ï¸ **DEAD!**")
                            target_dead = True

                elif r == 5:
                    ok, roll, dc, pen = _save_mix(t_cfg, "pet", ("petrify","petri"))
                    if ok:
                        lines.append(f"    ðŸ”µ Blue â€” Save vs Petrify {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ âœ… **RESISTED**")
                    else:
                        if bcfg and bcfg.has_section(chan_id) and slot:
                            bcfg.set(chan_id, f"{slot}.pet_perm", "1")
                            bcfg.set(chan_id, f"{slot}.pet_by", caster_name)
                            _save_battles(bcfg)
                        lines.append(f"    ðŸ”µ Blue â€” Save vs Petrify {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ ðŸ—¿ **PETRIFIED**")

                elif r == 6:
                    ok, roll, dc, pen = _save_mix(t_cfg, "spl", ("spell","spells"))
                    if ok:
                        lines.append(f"    ðŸŸ£ Indigo â€” Save vs Spells {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ âœ… **RESISTED**")
                    else:
                        if bcfg and bcfg.has_section(chan_id) and slot:
                            bcfg.set(chan_id, f"{slot}.cn_perm", "1")
                            if bcfg.getint(chan_id, f"{slot}.cn", fallback=0) <= 0:
                                bcfg.set(chan_id, f"{slot}.cn", "1")
                            bcfg.set(chan_id, f"{slot}.cn_by", caster_name)
                            _save_battles(bcfg)
                        lines.append(f"    ðŸŸ£ Indigo â€” Save vs Spells {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ ðŸ˜µâ€ðŸ’« **INSANITY** (permanent Confusion)")

                elif r == 7:
                    ok, roll, dc, pen = _save_mix(t_cfg, "spl", ("spell","spells"))
                    if ok:
                        lines.append(f"    ðŸŸª Violet â€” Save vs Spells {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ âœ… **RESISTED**")
                    else:

                        miles, rolls, flat = roll_dice("5d100")
                        dist = miles + flat
                        lines.append(f"    ðŸŸª Violet â€” Save vs Spells {roll}{f' - {pen}' if pen else ''} vs {dc} â†’ âœ¨ **TELEPORTED** ~{dist} miles away.")
                        if bcfg and bcfg.has_section(chan_id) and not removed_here:
                            try:
                                names, scores = _parse_combatants(bcfg, chan_id)
                                key = _find_ci_name(names, pretty) or pretty
                                if key in names:
                                    names = [n for n in names if n != key]
                                    if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)

                                    s = _slot(key)
                                    for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby",".cn",".cn_perm",".cn_by",".paralyzed",".blind"):
                                        opt = f"{s}{suf}"
                                        if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                                    _write_combatants(bcfg, chan_id, names, scores)

                                    cur_turn = bcfg.get(chan_id, "turn", fallback="")
                                    if cur_turn and cur_turn not in names:
                                        ents = _sorted_entries(bcfg, chan_id)
                                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                                    _save_battles(bcfg)
                                    removed_from_ini.append(pretty)
                                    removed_here = True
                            except Exception:
                                pass



            try:
                if _is_monster_file(path):
                    hp_now = getint_compat(t_cfg, "cur", "hp", fallback=1)
                    if hp_now <= 0 and (pretty, path) not in dead_monsters:
                        dead_monsters.append((pretty, path))
            except Exception:
                pass


        if dead_monsters:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, p in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby",".cn",".cn_perm",".cn_by",".paralyzed",".blind"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur_turn = bcfg.get(chan_id, "turn", fallback="")
                    if cur_turn and cur_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass

            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes or removed_from_ini or dead_monsters:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        return lines

    async def _effect_scintillatingpattern(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Scintillating Pattern (Illusionist 7)
        â€¢ 20â€² area (GM adjudicates targets). Sightless creatures are unaffected.
        â€¢ Only creatures with HD > caster level get a Save vs Spells to negate entirely.
        â€¢ Outcomes by HD:
            â‰¤6  : Unconscious 2d4 rds â†’ then Blind 1d4 â†’ then Confused 1d4
            7â€“9 : Blind 1d4 â†’ then Confused 1d4
            â‰¥10 : Blind 1 rd AND Confused 1 rd (simultaneous)
        """
        chan_id = str(ctx.channel.id)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["âœ¨ **Scintillating Pattern**"]

        if not tokens:
            lines.append("Targets: *(none)*")
            return lines

        def _roll_save_spells(t_cfg):

            for tag in ("spl", "spell", "spells"):
                ok, r, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None: return ok, r, dc, pen

            return False, 10, 15, 0

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path or not os.path.exists(tgt_path):
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            blind_now = 0
            blind_perm = 0
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    try:
                        slot = _slot(key)
                    except Exception:
                        slot = key.replace(" ", "_")
                    blind_now = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                    blind_perm = bcfg.getint(chan_id, f"{slot}.blind_perm", fallback=0)
                else:
                    slot = None
            except Exception:
                slot = None

            if blind_perm or blind_now > 0:
                lines.append(f"â€¢ **{pretty}**: ðŸ™ˆ Already sightless â€” **no effect**.")
                continue


            hd = self._hd_or_level_from_cfg(t_cfg)
            try:
                clv = int(caster_level or 0)
            except Exception:
                clv = 0

            if hd > clv:
                ok, sv_roll, sv_dc, _ = _roll_save_spells(t_cfg)
                if ok:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED**")
                    continue
                else:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): Save vs Spells {sv_roll} vs {sv_dc} â†’ **FAIL**")


            if not (bcfg and bcfg.has_section(chan_id)):
                lines.append(f"â€¢ **{pretty}**: *(no active battle â€” statuses not auto-ticked; adjudicate manually)*")
                continue


            if slot is None:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty) or pretty
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")

            def _queue_blind_after_paralysis(rounds: int):

                if rounds <= 0: return
                bcfg.set(chan_id, f"{slot}.sp_blind_pending", str(rounds))
                bcfg.set(chan_id, f"{slot}.sp_blind_by", caster_name)

            def _queue_confusion_after_blind(rounds: int):
                if rounds <= 0: return
                bcfg.set(chan_id, f"{slot}.sp_cnf_pending", str(rounds))
                bcfg.set(chan_id, f"{slot}.sp_cnf_by", caster_name)

            if hd <= 6:

                u_sum, u_rolls, _ = roll_dice("2d4")
                b_sum, b_rolls, _ = roll_dice("1d4")
                c_sum, c_rolls, _ = roll_dice("1d4")
                u_rd = max(0, u_sum); b_rd = max(0, b_sum); c_rd = max(0, c_sum)

                prev_par = bcfg.getint(chan_id, f"{slot}.paralyzed", fallback=0)
                if u_rd > 0:
                    bcfg.set(chan_id, f"{slot}.paralyzed", str(max(prev_par, u_rd)))
                    bcfg.set(chan_id, f"{slot}.paralyzed_by", "Scintillating Pattern")
                _queue_blind_after_paralysis(b_rd)
                _queue_confusion_after_blind(c_rd)
                _save_battles(bcfg)

                lines.append(
                    f"â€¢ **{pretty}** (HD {hd}): ðŸ˜´ **UNCONSCIOUS** {u_rd} rounds "
                    f"â†’ then ðŸ™ˆ **BLINDED** {b_rd} rounds â†’ then ðŸ˜µâ€ðŸ’« **CONFUSED** {c_rd} rounds."
                )

            elif 7 <= hd <= 9:

                b_sum, b_rolls, _ = roll_dice("1d4")
                c_sum, c_rolls, _ = roll_dice("1d4")
                b_rd = max(0, b_sum); c_rd = max(0, c_sum)

                prev_bl = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                if b_rd > 0:
                    bcfg.set(chan_id, f"{slot}.blind", str(max(prev_bl, b_rd)))
                    bcfg.set(chan_id, f"{slot}.blind_src", "scintillating")
                    bcfg.set(chan_id, f"{slot}.blind_by", caster_name)
                _queue_confusion_after_blind(c_rd)
                _save_battles(bcfg)

                lines.append(
                    f"â€¢ **{pretty}** (HD {hd}): ðŸ™ˆ **BLINDED** {b_rd} rounds â†’ then ðŸ˜µâ€ðŸ’« **CONFUSED** {c_rd} rounds."
                )

            else:

                prev_bl = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                bcfg.set(chan_id, f"{slot}.blind", str(max(prev_bl, 1)))
                bcfg.set(chan_id, f"{slot}.blind_src", "scintillating")
                bcfg.set(chan_id, f"{slot}.blind_by",  caster_name)

                prev_cn = bcfg.getint(chan_id, f"{slot}.cn", fallback=0)
                bcfg.set(chan_id, f"{slot}.cn", str(max(prev_cn, 1)))
                bcfg.set(chan_id, f"{slot}.cn_by", caster_name)
                _save_battles(bcfg)

                lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ™ˆ **BLINDED** 1 round **and** ðŸ˜µâ€ðŸ’« **CONFUSED** 1 round.")


        try:
            if bcfg and bcfg.has_section(chan_id):
                await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return lines

    def _effect_weird(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Weird (Illusionist 7) â€” multi-target Phantasmal Killer
          â€¢ Each target: Save vs Spells to disbelieve (success = no effect).
          â€¢ If failed: Save vs Petrify â€” fail = death; success = 3d6 damage.
        """

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸ¥ **Weird**"]

        if not tokens:
            lines.append("â€¢ *(No targets provided.)*")
            return lines

        def _slot_of(name: str) -> str:
            try:
                return _slot(name)
            except Exception:
                return name.replace(" ", "_")

        def _sweep_dead_monster(tgt_disp: str, t_cfg, tgt_path: str):
            if not (bcfg and bcfg.has_section(chan_id)):
                return
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if not is_mon:
                return
            try:
                names, scores = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                if key in names:
                    names = [n for n in names if n != key]
                    if bcfg.has_option(chan_id, key):
                        bcfg.remove_option(chan_id, key)
                    s = _slot_of(key)
                    for suf in (
                        ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                        ".paralyzed",".blind",".blind_src",".blind_by",
                        ".cc_blind_pending",".cs_blind_pending",
                        ".cc",".cc_by",".cc_level",
                        ".ck",".ck_by",".ck_level",
                        ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                        ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                    ):
                        opt = f"{s}{suf}"
                        if bcfg.has_option(chan_id, opt):
                            bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                    if cur_turn == key:
                        try:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        except Exception:
                            pass
                    _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

        def _lifebar_or(hp, mhp, width=10):
            try:
                return _life_bar(hp, mhp, width=width)
            except Exception:
                return f"{hp}/{mhp}"


        resolved = []
        not_found = []
        for raw in tokens:
            disp, path = self._resolve_char_ci_local(raw)
            if not path:
                not_found.append(raw)
            else:
                resolved.append((raw, disp or raw, path))

        if not resolved:
            lines.append("â€¢ *(No valid targets found.)*")
            return lines
        if not_found:
            lines.append("*(ignored: " + ", ".join(not_found) + " â€” not found)*")


        seen = set()
        chosen = []
        for _raw, disp, path in resolved:
            k = disp.lower()
            if k in seen:
                continue
            seen.add(k)
            chosen.append((disp, path))


        for disp, tgt_path in chosen:
            t_cfg = read_cfg(tgt_path)
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
            if old_hp is None:
                lines.append(f"â€¢ **{disp}**: âš ï¸ No HP field â€” cannot resolve.")
                continue
            if old_hp <= 0:
                lines.append(f"â€¢ **{disp}**: already â˜ ï¸ **dead**.")
                continue


            try:
                sv1_ok, sv1_roll, sv1_dc, _ = self._roll_spell_save(t_cfg)
            except Exception:
                sv1_ok, sv1_roll, sv1_dc, _ = self._roll_save(t_cfg, vs="spells", penalty=0)

            if sv1_dc is None:

                sv1_ok = False

            if sv1_ok:
                lines.append(f"â€¢ **{disp}**: Save vs Spells {sv1_roll} vs {sv1_dc} â†’ âœ… **DISBELIEVED** (no effect).")
                continue

            sv1_note = f"Save vs Spells {sv1_roll} vs {sv1_dc} â†’ **FAIL**" if sv1_dc is not None else "*(no Spells save table â€” treating as failed)*"


            sv2_ok, sv2_roll, sv2_dc, _ = self._roll_save(t_cfg, vs="para", penalty=0)

            if not sv2_ok:

                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)
                _sweep_dead_monster(disp, t_cfg, tgt_path)
                try:
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
                    before = _lifebar_or(old_hp, mhp, width=10)
                    after  = _lifebar_or(0,    mhp, width=10)
                    lines.append(
                        f"â€¢ **{disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ **FAIL**\n"
                        f"{before} â†’ **{after}**  â˜ ï¸ **DEAD!**"
                    )
                except Exception:
                    lines.append(
                        f"â€¢ **{disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ **FAIL**\n"
                        f"HP {old_hp} â†’ **0**  â˜ ï¸ **DEAD!**"
                    )
                continue


            d = [random.randint(1, 6) for _ in range(3)]
            dmg = sum(d)
            new_hp = max(0, old_hp - dmg)
            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(tgt_path, t_cfg)

            died = (new_hp <= 0)
            if died:
                _sweep_dead_monster(disp, t_cfg, tgt_path)

            try:
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
                before = _lifebar_or(old_hp, mhp, width=10)
                after  = _lifebar_or(new_hp, mhp, width=10)
                tail = "  â˜ ï¸ **DEAD!**" if died else ""
                lines.append(
                    f"â€¢ **{disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ âœ… **RESISTED TERROR**\n"
                    f"3d6 = {d[0]}+{d[1]}+{d[2]} â†’ **{dmg}**\n"
                    f"{before} â†’ **{after}**{tail}"
                )
            except Exception:
                tail = "  â˜ ï¸ **DEAD!**" if died else ""
                lines.append(
                    f"â€¢ **{disp}**: {sv1_note}; then Save vs Petrify {sv2_roll} vs {sv2_dc} â†’ âœ… **RESISTED TERROR**\n"
                    f"3d6 â†’ **{dmg}**\n"
                    f"HP {old_hp} â†’ **{new_hp}**{tail}"
                )

        return lines


    async def _effect_chill(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Chill (Necromancer 1)
          â€¢ Immediately deals 1d4 damage to one target within range (no attack roll).
          â€¢ Target then saves vs Paralysis (+2 if -heat flag present):
              - Fail: becomes "Chilled" (â€“1 melee hit & damage) for 1d6 rounds.
              - Success: no debuff.
          â€¢ Caster gets a one-time follow-up use next round via !a chill <target> (no extra slot).
          â€¢ We don't enforce range/heat positioning here; '-heat' flag is user-driven.
        """

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        out = ["ðŸ¥¶ **Chill**"]

        if not tokens:
            return {"text": "ðŸ¥¶ **Chill** â€” *(No target provided.)*", "suppress_timer": True}


        want_heat = any(t.lower() in {"-heat", "-heat"} for t in tokens)

        names = [t for t in tokens if not t.startswith("-")]
        raw = names[0] if names else None
        if not raw:
            return {"text": "ðŸ¥¶ **Chill** â€” *(No target provided.)*", "suppress_timer": True}


        try:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
        except Exception:
            tgt_disp, tgt_path = None, None

        if not tgt_path:
            return {"text": f"ðŸ¥¶ **Chill**\nâ€¢ **{raw}**: *(not found)*", "suppress_timer": True}

        t_cfg = read_cfg(tgt_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            return {"text": f"ðŸ¥¶ **Chill**\nâ€¢ **{tgt_disp}**: âš ï¸ No HP field.", "suppress_timer": True}
        if old_hp <= 0:
            return {"text": f"ðŸ¥¶ **Chill**\nâ€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.", "suppress_timer": True}


        d4 = random.randint(1, 4)
        new_hp = max(0, old_hp - d4)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)


        heat_bonus = 2 if want_heat else 0
        try:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", bonus=heat_bonus)
        except TypeError:

            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=(-heat_bonus))
        except Exception:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=0)


        try:
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_txt = f"{before} â†’ **{after}**"
        except Exception:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"


        debuff_line = ""
        if sv_dc is None:

            sv_ok = False

        if not sv_ok:
            rounds = random.randint(1, 6)
            if bcfg and bcfg.has_section(chan_id):

                try:
                    slotT = _choose_slot_for_effects(bcfg, chan_id, tgt_disp)
                except Exception:
                    slotT = tgt_disp.replace(" ", "_")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff",           str(rounds))
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_code",      "CH")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_label",     "Chilled (melee -1)")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_emoji",     "ðŸ¥¶")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_by",        caster_name)
                _save_battles(bcfg)
            debuff_line = f"\nâ€¢ **Debuff**: **Chilled** *(â€“1 melee hit & dmg)* for **{rounds}** rounds."


        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                ci = _find_ci_name(names, caster_name) or caster_name
                s = _choose_slot_for_effects(bcfg, chan_id, ci) if '_choose_slot_for_effects' in globals() else _slot(ci)

                bcfg.set(chan_id, f"{s}.chl", "2")
                bcfg.set(chan_id, f"{s}.chl_charges", "1")
                _save_battles(bcfg)
        except Exception:
            pass

        heat_txt = " (+2 from heat)" if want_heat else ""
        sv_txt = f"Save vs Paralysis {sv_roll} vs {sv_dc}{heat_txt} â†’ " + ("âœ… **RESISTED**" if sv_ok else "**FAIL**")

        text = (
            f"â€¢ **{tgt_disp}** takes **1d4 = {d4}** damage.\n"
            f"{hp_txt}\n"
            f"â€¢ {sv_txt}{debuff_line}\n"
            f"*(You may use **!a chill <target>** once **next round** without spending a slot.)*"
        )

        return {"text": text, "suppress_timer": True}


    async def _effect_chillray(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Chill Ray (Necromancer 2)
          â€¢ Conjures a ray for 1 round/level.
          â€¢ Each round (incl. now) you can fire at one target: 1d4+1 cold, then Save vs Paralysis (+2 with -heat) or Chilled (â€“1 melee hit & dmg) 1d6 rounds.
          â€¢ Use `!a chillray <target>` once per round while it lasts. We don't enforce geometry here.
        """

        chan_id = str(ctx.channel.id)
        rounds_total = max(1, int(caster_level))


        bcfg = None
        try:
            bcfg = _load_battles()
        except Exception:
            pass

        if bcfg and bcfg.has_section(chan_id):
            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                ci = _find_ci_name(names, caster_name) or caster_name
                s  = _choose_slot_for_effects(bcfg, chan_id, ci) if '_choose_slot_for_effects' in globals() else _slot(ci)
            except Exception:
                s = caster_name.replace(" ", "_")
            bcfg.set(chan_id, f"{s}.cr", str(rounds_total))
            _save_battles(bcfg)

        head = f"â„ï¸ **Chill Ray** conjured â€” duration **{rounds_total} rounds**. Use `!a chillray <target>` once each round."


        want_heat = any(t.lower() in {"-heat","-heat"} for t in tokens or [])
        tgt_tokens = [t for t in (tokens or []) if not t.startswith("-")]
        if tgt_tokens:
            shot_txt = await self._do_chillray_shot(ctx, caster_name, caster_cfg, tgt_tokens[0], want_heat)
            return {"text": head + "\n" + shot_txt, "suppress_timer": True}


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return {"text": head, "suppress_timer": True}

    async def _do_chillray_shot(self, ctx, caster_name: str, caster_cfg, raw_target: str, want_heat: bool) -> str:


        try:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw_target)
        except Exception:
            tgt_disp, tgt_path = None, None
        if not tgt_path:
            return f"â€¢ **{raw_target}**: *(not found)*"

        t_cfg = read_cfg(tgt_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            return f"â€¢ **{tgt_disp}**: âš ï¸ No HP field."
        if old_hp <= 0:
            return f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**."


        d4 = random.randint(1,4); base = d4 + 1
        new_hp = max(0, old_hp - base)
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)


        heat_bonus = 2 if want_heat else 0
        try:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", bonus=heat_bonus)
        except TypeError:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=(-heat_bonus))
        except Exception:
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="para", penalty=0)
        if sv_dc is None:
            sv_ok = False


        debuff_line = ""
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        if (not sv_ok) and bcfg:
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                rounds = random.randint(1,6)
                try:
                    slotT = _choose_slot_for_effects(bcfg, chan_id, tgt_disp) if '_choose_slot_for_effects' in globals() else _slot(tgt_disp)
                except Exception:
                    slotT = tgt_disp.replace(" ", "_")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff",       str(rounds))
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_code",  "CH")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_label", "Chilled (melee -1)")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_emoji", "ðŸ¥¶")
                bcfg.set(chan_id, f"{slotT}.x_chilldebuff_by",    caster_name)
                _save_battles(bcfg)
                debuff_line = f"\nâ€¢ **Debuff**: **Chilled** *(â€“1 melee hit & dmg)* for **{rounds}** rounds."


        try:
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            hp_txt = f"{before} â†’ **{after}**"
        except Exception:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"


        if new_hp <= 0:
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if is_mon and bcfg and bcfg.has_section(str(ctx.channel.id)):
                try:
                    names, scores = _parse_combatants(bcfg, str(ctx.channel.id))
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(str(ctx.channel.id), key):
                            bcfg.remove_option(str(ctx.channel.id), key)
                        s = key.replace(" ","_")
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(str(ctx.channel.id), opt):
                                bcfg.remove_option(str(ctx.channel.id), opt)
                        _write_combatants(bcfg, str(ctx.channel.id), names, scores)
                        if bcfg.get(str(ctx.channel.id), "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, str(ctx.channel.id))
                            bcfg.set(str(ctx.channel.id), "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass

        heat_txt = " (+2 from heat)" if want_heat else ""
        sv_txt = f"Save vs Paralysis {sv_roll} vs {sv_dc}{heat_txt} â†’ " + ("âœ… **RESISTED**" if sv_ok else "**FAIL**")
        tail = "  â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
        return (
            f"â€¢ **{tgt_disp}** is struck for **1d4+1 = {base}** cold.\n"
            f"{hp_txt}{tail}\n"
            f"â€¢ {sv_txt}{debuff_line}"
        )

    async def _effect_stench(self, ctx, cfg, caster_name: str, caster_level: int, targets):
        """
        Stench (Self): creatures you name must save vs Poison or be Sickened (âˆ’2 to hit) for 2d6 rounds.
        Save penalty: âˆ’1 per 3 levels (3rd âˆ’1, 6th âˆ’2, 9th âˆ’3â€¦).
        Duration (aura): 1 turn/level (10 rounds/level).
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan_id)):
            return "âš ï¸ No initiative running here. Use `!init` first.", {"suppress_timer": True}

        toks = []
        if isinstance(targets, (list, tuple)): toks = list(targets)
        elif isinstance(targets, str) and targets.strip():
            toks = [t for t in re.split(r"\s+", targets.strip()) if t]


        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


        for k in (f"{s_me}.stench", f"{s_me}.stench_by"):
            if bcfg.has_option(chan_id, k):
                bcfg.remove_option(chan_id, k)

        self._clear_code_badges(bcfg, chan_id, s_me, "ST")

        aura_rounds = max(1, int(caster_level) * 10)
        pen_levels  = max(0, int(caster_level // 3))


        bcfg.set(chan_id, f"{s_me}.stencha",        str(aura_rounds))
        bcfg.set(chan_id, f"{s_me}.stencha_by",     caster_name)
        bcfg.set(chan_id, f"{s_me}.stencha_level",  str(int(caster_level)))
        bcfg.set(chan_id, f"{s_me}.stencha_pen",    str(pen_levels))



        self._clear_code_badges(bcfg, chan_id, s_me, "ST")
        base = f"{s_me}.x_stench"
        bcfg.set(chan_id, base,                 str(aura_rounds))
        bcfg.set(chan_id, f"{base}_label",      "Stench")
        bcfg.set(chan_id, f"{base}_code",       "ST")
        bcfg.set(chan_id, f"{base}_by",         caster_name)
        _save_battles(bcfg)

        lines = [
            f"ðŸ¤¢ **Stench** aura clings to **{caster_name}** for **{aura_rounds} rounds** "
            f"(save penalty **âˆ’{pen_levels}** while it lasts).",
            "*(Use `!a stench ...` to force saves on creatures you choose â€” even out of turn.)*",
        ]

        if toks:
            lines.extend(self._apply_stench_to_targets(chan_id, bcfg, caster_name, caster_level, toks))


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return "\n".join(lines), {"suppress_timer": True}

    async def _effect_maggotspray(self, ctx, cfg, caster_name: str, caster_level: int, targets):
        """
        MaggotSpray (10 ft): each named target takes 1d4 damage now; save vs Poison or be
        Sickened (2d6 rounds, âˆ’2 to attack). Also suffer 1d4 damage per round for L rounds,
        unless they spend a full round â€œbrushing offâ€ (GM action).
        """
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan_id)):
            return "âš ï¸ No initiative running here. Use `!init` first.", {"suppress_timer": True}

        toks = list(targets) if isinstance(targets, (list, tuple)) else []
        if isinstance(targets, str) and targets.strip():
            toks = [t for t in re.split(r"\s+", targets.strip()) if t]
        if not toks:
            return "Usage: `!cast MaggotSpray <t1> <t2> ...`", {"suppress_timer": True}

        lines = [f"ðŸª± **{caster_name}** spews a writhing spray of filth!"]

        for raw in toks:
            disp, path = None, None
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                pass
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            s1, rolls1, flat1 = roll_dice("1d4")
            now = s1 + flat1
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - now)
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            try:
                ok, roll, dc, pen = self._roll_save(t_cfg, vs="poi", penalty=0)
            except TypeError:
                ok, roll, dc, pen = self._roll_save(t_cfg, vs="poi", bonus=0)

            if ok:
                save_line = f"Save vs Poison {roll} vs {dc} â†’ âœ… **RESISTED**"
            else:

                s2, rolls2, flat2 = roll_dice("2d6")
                sick_r = s2 + flat2
                self._apply_sickened(bcfg, chan_id, pretty, caster_name, sick_r, penalty=-2)
                save_line = f"Save vs Poison {roll} vs {dc} â†’ **FAIL** â†’ **SICKENED** for **2d6 = {sick_r}** rounds."


            if new_hp > 0 and caster_level > 0:
                self._start_maggots(bcfg, chan_id, pretty, caster_name, rounds=int(caster_level), dmg_spec="1d4")


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                hp_txt = f"{_life_bar(old_hp, mhp, 10)} â†’ **{_life_bar(new_hp, mhp, 10)}**"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"
            dead = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            lines.append(f"{pretty}: **1d4 = {now}** â†’ {hp_txt}{dead}\n{save_line}")


            if new_hp <= 0 and _is_monster_file(path):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                        s = _slot(key) if '_slot' in globals() else key.replace(" ","_")
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                    try: os.remove(os.path.abspath(path))
                    except Exception: pass
                except Exception:
                    pass

        _save_battles(bcfg)

        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        lines.append("_Creatures can spend a full round to **brush off** the maggots (stops the ongoing damage; Sickened remains)._")
        return "\n".join(lines), {"suppress_timer": True}

    def _apply_sickened(self, bcfg, chan_id, target_disp: str, by: str, rounds: int, penalty: int = -2):
        res = _resolve_effect_slot(bcfg, chan_id, target_disp)
        slotT = res[0] if isinstance(res, (tuple, list)) else res
        p = int(penalty)
        bcfg.set(chan_id, f"{slotT}.stench",       str(max(0, int(rounds))))
        bcfg.set(chan_id, f"{slotT}.stench_pen",   str(p))
        shown = abs(p) if p < 0 else p
        bcfg.set(chan_id, f"{slotT}.stench_label", f"Sickened (âˆ’{shown} to attack)")
        bcfg.set(chan_id, f"{slotT}.stench_emoji", "ðŸ¤¢")
        bcfg.set(chan_id, f"{slotT}.stench_by",    by)

    def _start_maggots(self, bcfg, chan_id, target_disp: str, by: str, rounds: int, dmg_spec: str = "1d4"):
        res = _resolve_effect_slot(bcfg, chan_id, target_disp)
        slotT = res[0] if isinstance(res, (tuple, list)) else res
        bcfg.set(chan_id, f"{slotT}.x_maggots",       str(max(0, int(rounds))))
        bcfg.set(chan_id, f"{slotT}.x_maggots_code",  "MS")
        bcfg.set(chan_id, f"{slotT}.x_maggots_label", "Maggots (1d4/rd)")
        bcfg.set(chan_id, f"{slotT}.x_maggots_emoji", "ðŸª±")
        bcfg.set(chan_id, f"{slotT}.x_maggots_dmg",   dmg_spec)
        bcfg.set(chan_id, f"{slotT}.x_maggots_by",    by)

    def _apply_stench_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        lines = []
        pen_levels = max(0, int(caster_level // 3))

        for raw in tokens:
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            try:
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass
            try:
                if self._poison_immune(t_cfg):
                    lines.append(f"â€¢ **{tgt_disp}**: ðŸ§ª Poison-immune â€” **no effect**.")
                    continue
            except Exception:
                pass


            try:
                ok, roll, dc, _ = self._roll_save(t_cfg, vs="poi", penalty=pen_levels)
            except TypeError:
                ok, roll, dc, _ = self._roll_save(t_cfg, vs="poi", bonus=(-pen_levels))

            if ok:
                lines.append(f"â€¢ **{tgt_disp}**: Save vs Poison {roll} - {pen_levels if pen_levels else 0} vs {dc} â†’ âœ… **RESISTED**")
                continue


            s2, _rolls2, flat2 = roll_dice("2d6")
            dur = s2 + flat2


            try:
                self._apply_sickened(bcfg, chan_id, tgt_disp, caster_name, dur, penalty=-2)
            except Exception:
                pass

            slot = _choose_slot_for_effects(bcfg, chan_id, tgt_disp)


            for k in (f"{slot}.stench", f"{slot}.stench_by"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)


            self._clear_code_badges(bcfg, chan_id, slot, "STN")


            base = f"{slot}.x_stenchn"
            bcfg.set(chan_id, base,                str(dur))
            bcfg.set(chan_id, f"{base}_label",     "Stench")
            bcfg.set(chan_id, f"{base}_code",      "STN")
            bcfg.set(chan_id, f"{base}_by",        caster_name)
            _save_battles(bcfg)


            slot = _choose_slot_for_effects(bcfg, chan_id, tgt_disp)
            self._clear_code_badges(bcfg, chan_id, slot, "STN")

            base = f"{slot}.x_stenchn"
            bcfg.set(chan_id, base,                str(dur))
            bcfg.set(chan_id, f"{base}_label",     "Stench")
            bcfg.set(chan_id, f"{base}_code",      "STN")
            bcfg.set(chan_id, f"{base}_by",        caster_name)
            _save_battles(bcfg)

            lines.append(
                f"â€¢ **{tgt_disp}**: Save vs Poison {roll} - {pen_levels if pen_levels else 0} vs {dc} â†’ **FAIL** â†’ "
                f"ðŸ¤¢ **SICKENED** for **2d6 = {dur}** rounds [STN {dur}]"
            )

        return lines

    def _clear_code_badges(self, bcfg, chan_id: str, slot: str, code: str) -> bool:
        """
        Remove any x_* tracker badges for this slot whose `_code` equals `code`
        (e.g., "ST" or "STN"). Returns True if anything was removed.
        """
        removed = False
        try:
            opts = list(bcfg.options(chan_id))
        except Exception:
            return False

        want = str(code).strip().upper()
        for opt in list(opts):

            if not opt.startswith(f"{slot}.x_") or not opt.endswith("_code"):
                continue
            if str(bcfg.get(chan_id, opt, fallback="")).strip().upper() != want:
                continue

            base = opt[:-5]
            for suf in ("", "_label", "_code", "_by"):
                key = base + suf
                if bcfg.has_option(chan_id, key):
                    bcfg.remove_option(chan_id, key)
                    removed = True

        if removed:
            _save_battles(bcfg)
        return removed

    async def _cast_fireskullfamiliar(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Fireskull Familiar (Necromancer 2)
        â€¢ One active at a time per caster; subsequent casts fail unless the first is dismissed/destroyed.
        â€¢ HP = 1/4 of caster's total (max) HP, min 1.
        â€¢ AC 13, dmg 1d2, move 40, saves as Fighter 1.
        â€¢ Attacks with the caster's attack bonus (copies caster's stats.ab).
        â€¢ Provides torchlight; tagged as a minion controlled by the caster.
        â€¢ Duration = 1 hour/level -> 360 * level rounds, tracked via x_* timer ([FS N]).
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        tpl = (_load_monster_template("fireskullfamiliar")
               or _load_monster_template("fire_skull_familiar")
               or _load_monster_template("fireskull_familiar")
               or _load_monster_template("fireskull-familiar"))
        if not tpl:
            return ["âŒ Monster template not found for **fireskullfamiliar** (try `fireskullfamiliar.ini`)."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)
        cname_lc = (caster_name or "").strip().lower()
        for fn in os.listdir("."):
            if not fn.lower().endswith(".coe"):
                continue
            try:
                cp = read_cfg(fn)
                if str(get_compat(cp, "info", "class", fallback="")).strip().lower() != "monster":
                    continue
                if (str(get_compat(cp, "info", "summoned",  fallback="")).strip().lower() == "fireskullfamiliar" and
                    (
                        str(get_compat(cp, "info", "controller", fallback="")).strip().lower() == cname_lc
                        or str(get_compat(cp, "info", "owner_id",  fallback="")).strip() == caster_owner_id
                    )):
                    name = get_compat(cp, "info", "name", fallback=fn[:-4])
                    return [f"âŒ You already have an active Fireskull Familiar (**{name}**). Dismiss it or wait for it to be destroyed first."]
            except Exception:
                pass


        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass

            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None


        caster_disp, caster_path = _resolve_char_ci_local(caster_name)
        caster_cfg = read_cfg(caster_path) if caster_path and os.path.exists(caster_path) else None
        caster_max_hp = getint_compat(caster_cfg, "max", "hp",
                          fallback=getint_compat(caster_cfg, "cur", "hp", fallback=1)) if caster_cfg else 1
        skull_hp = max(1, int(caster_max_hp // 4))
        caster_ab = (get_compat(caster_cfg, "stats", "ab", fallback="") or "") if caster_cfg else ""


        ac     = int(tpl.get("ac", 13))
        damage = str(tpl.get("damage", "1d2"))
        move   = int(tpl.get("move", 40))
        saveas = str(tpl.get("saveas", "Fighter 1"))
        resist  = str(tpl.get("resist",  "")).strip()
        reduce1 = str(tpl.get("reduce1", "")).strip()
        immune  = str(tpl.get("immune",  "")).strip()
        weak    = str(tpl.get("weak",    "")).strip()


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
        else:
            save_class, save_level = "Fighter", 1
        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        i = 1
        while f"FI{i}" in existing:
            i += 1
        mon = f"FI{i}"


        coe = configparser.ConfigParser()
        coe.optionxform = str
        coe["version"] = {"current": "08082018"}
        coe["info"] = {
            "race": "Monster", "class": "Monster", "sex": "",
            "name": mon, "owner_id": str(caster_owner_id),
            "monster_type": "fireskullfamiliar",
            "battle_chan": chan_id,
            "controller": caster_name,
            "summoned": "fireskullfamiliar",
        }
        coe["max"] = {"hp": str(skull_hp)}
        coe["cur"] = {"hp": str(skull_hp), "level": "0", "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}

        stats = {
            "ac": str(ac),
            "ab": str(caster_ab),
            "move": str(move),
            "type": str(tpl.get("type", "")).strip(),
            "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
            "damage": damage,
        }
        coe["stats"] = stats
        coe["base"]  = dict(stats)
        coe["saves"] = saves_out
        coe["thief_mods"] = {}
        coe["banned_weapons"] = {"list": ""}
        coe["skills"] = {"list": ""}

        with open(f"{mon}.coe", "w", encoding="utf-8") as f:
            coe.write(f)


        names, scores = _parse_combatants(bcfg, chan_id)
        d6 = random.randint(1, 6)
        if mon not in names:
            names.append(mon)
        scores[mon] = d6
        _write_combatants(bcfg, chan_id, names, scores)

        try:
            slot = _slot(mon)
        except Exception:
            slot = mon.replace(" ", "_")


        bcfg.set(chan_id, f"{slot}.disp", mon)
        bcfg.set(chan_id, f"{slot}.hostile", "0")
        bcfg.set(chan_id, f"{slot}.minion_by", caster_name)
        bcfg.set(chan_id, f"{slot}.minion_type", "fireskullfamiliar")


        bcfg.set(chan_id, f"{slot}.light_perm", "1")
        bcfg.set(chan_id, f"{slot}.light_level", "torch")


        rounds = max(1, int(caster_level)) * 360
        bcfg.set(chan_id, f"{slot}.x_fs",        str(rounds))
        bcfg.set(chan_id, f"{slot}.x_fs_label",  "Fireskull")
        bcfg.set(chan_id, f"{slot}.x_fs_code",  "FS")
        bcfg.set(chan_id, f"{slot}.x_fs_emoji",  "ðŸ’€")
        bcfg.set(chan_id, f"{slot}.x_fs_by",     caster_name)


        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
        bcfg.set(chan_id, "join_seq", str(join_seq))
        bcfg.set(chan_id, f"{slot}.join", str(join_seq))

        _save_battles(bcfg)


        try:
            if caster_cfg:
                if not caster_cfg.has_section("minions"):
                    caster_cfg.add_section("minions")
                caster_cfg.set("minions", "fireskull", mon)
                write_cfg(caster_path, caster_cfg)
        except Exception:
            pass


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return [
            f"ðŸ”¥ðŸ’€ **{caster_name}** animates a **Fireskull Familiar**!",
            f"â€¢ **{mon}** joins initiative (1d6 â†’ **{d6}**).",
            f"â€¢ Duration: **{rounds} rounds** (~{rounds//360} hour{'s' if rounds>=720 else ''})  â€” tracker tag **[FS {rounds}]**.",
            "It hovers near its master providing torchlight, can fetch/deliver, and attacks with your base to-hit."
        ]

    async def _cast_corpseservant(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Corpse Servant (touch): temporarily animate Skeletons (1 HD each) and Zombies (2 HD default).
        Caps: per cast â‰¤ level HD (does NOT count toward Animate Dead control caps).
        Only one instance per caster at a time (blocked if an active CS timer is found).
        Duration: 1 hour/level (use your normal !cast auto x_timer => code 'CS' on the caster).

        Usage:
          !cast corpseservant -sk 4 -zo 1
          !cast corpseservant sk3 zo1
        Tip: Like Animate Dead, you can adjust Zombie HD after creation with `!hd ZO# N` if needed.
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        sk = 0
        zo = 0

        def _take_int_after(flagset):
            nonlocal toks
            for i in range(len(toks) - 1):
                if toks[i] in flagset and re.fullmatch(r"\d+", toks[i+1] or ""):
                    v = int(toks[i+1]); toks[i] = ""; toks[i+1] = ""
                    return v
            return 0


        sk += _take_int_after({"-sk", "-sk", "-skeleton"})
        zo += _take_int_after({"-zo", "-zo", "-zombie"})


        for t in list(toks):
            m = re.fullmatch(r"(sk|skeleton)(\d+)", t)
            if m: sk += int(m.group(2)); toks.remove(t); continue
            m = re.fullmatch(r"(zo|zombie)(\d+)", t)
            if m: zo += int(m.group(2)); toks.remove(t); continue

        if sk <= 0 and zo <= 0:
            return [
                "âŒ **Corpse Servant**: invalid usage.",
                "Try: `!cast corpseservant -sk 4 -zo 1`  or  `!cast corpseservant sk3 zo1`",
                "Skeletons are **1 HD** each; Zombies default to **2 HD** (adjust with `!hd ZO# N`).",
                "Limit: per cast â‰¤ **your level HD**. Duration: **1 hour/level** (temporary).",
                "Only one instance per caster may be active at a time."
            ]


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        def _caster_has_active_cs_timer(caster_display_name: str) -> bool:
            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                exact = _find_ci_name(names, caster_display_name) or caster_display_name
                try:
                    slot = _slot(exact)
                except Exception:
                    slot = exact.replace(" ", "_")
                prefix = f"{slot}.x_"
                for opt in bcfg.options(chan_id):
                    if not opt.startswith(prefix): continue
                    if opt.endswith(("_code", "_label", "_emoji", "_by")): continue
                    rounds_left = bcfg.getint(chan_id, opt, fallback=0)
                    if rounds_left <= 0: continue
                    base = opt.split(".", 1)[1]
                    code  = bcfg.get(chan_id, f"{slot}.{base}_code",  fallback="").upper()
                    label = bcfg.get(chan_id, f"{slot}.{base}_label", fallback="").strip().lower().replace(" ", "")
                    if code == "CS" or label in {"corpseservant", "corpse-servant"}:
                        return True
            except Exception:
                pass
            return False





        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        tpl_sk = _load_monster_template("skeleton")
        tpl_zo = _load_monster_template("zombie")
        if not tpl_sk or not tpl_zo:
            return ["âŒ Missing monster templates in `/monsters/`: need `skeleton.ini` and `zombie.ini`."]

        sk_hd = int(str(tpl_sk.get("hd", 1)) or "1")
        zo_hd = int(str(tpl_zo.get("hd", 2)) or "2")


        per_cast_cap = max(1, int(caster_level or 1))
        want_hd = sk * sk_hd + zo * zo_hd
        if want_hd <= 0:
            return ["âŒ Nothing to animate (zero HD)."]
        if want_hd > per_cast_cap:
            return [f"âŒ Limit exceeded: **Corpse Servant** can animate at most **{per_cast_cap} HD** right now "
                    f"(you asked for **{want_hd} HD**)."]


        def _spawn_batch(mon_name: str, tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 1))
            hpmod  = int(tpl.get("hpmod", 0))
            damage = str(tpl.get("damage", "1d6"))
            move   = int(tpl.get("move", 30))
            saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
            resist  = str(tpl.get("resist",  "")).strip()
            reduce1 = str(tpl.get("reduce1", "")).strip()
            immune  = str(tpl.get("immune",  "")).strip()
            weak    = str(tpl.get("weak",    "")).strip()

            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", max(1, hd)

            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = re.sub(r"[^A-Za-z]", "", mon_name).upper()[:2] or "MO"
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            created = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)

                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": mon_name, "battle_chan": chan_id,
                    "controller": caster_name,

                    "summoned": "corpseservant",
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


                stats = {
                    "ac": str(ac), "ab": "", "move": str(move),
                    "type": str(tpl.get("type", "")).strip(),
                    "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
                }
                attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
                atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
                attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or damage or "1d6"
                else:
                    stats["damage"] = damage or "1d6"

                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)


                try:
                    s_el = _slot(mon)
                except Exception:
                    s_el = mon.replace(" ", "_")

                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s_el}."):
                        pass
                bcfg.set(chan_id, f"{s_el}.dex", "0")
                join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s_el}.join", str(join_seq))
                bcfg.set(chan_id, f"{s_el}.disp", mon)
                bcfg.set(chan_id, f"{s_el}.hostile", "0")


                bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
                bcfg.set(chan_id, f"{s_el}.minion_type", "corpseservant")

                bcfg.set(chan_id, f"{s_el}.expires_with_code", "CS")

                created.append((mon, d6, hp, hd))

            _save_battles(bcfg)
            return created


        lines = [f"ðŸ¦´ **{caster_name}** casts **Corpse Servant**."]
        created = []
        if sk > 0: created += _spawn_batch("skeleton", tpl_sk, sk)
        if zo > 0: created += _spawn_batch("zombie",   tpl_zo, zo)

        if not created:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        sk_names = [n for (n, _i, _hp, _hd) in created if n.upper().startswith("SK")]
        zo_names = [n for (n, _i, _hp, _hd) in created if n.upper().startswith("ZO")]
        made_hd  = sum(hd for (_n, _i, _hp, hd) in created)

        lines.append(
            "Raised: "
            + (f"**{len(sk_names)}** Skeleton(s) " if sk_names else "")
            + ("and " if sk_names and zo_names else "")
            + (f"**{len(zo_names)}** Zombie(s) " if zo_names else "")
            + f"(**{made_hd} HD**, temporary)."
        )
        lines.append(f"Limit: **{made_hd} / {per_cast_cap} HD** this cast. (Does **not** count toward Reanimation caps.)")
        lines.append("â±ï¸ Duration: **1 hour/level**. (Your `!cast` auto-timer will show **[CS â€¦]** on the caster.)")

        return lines

    async def _cast_commandundead(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Command Undead (30 ft)
          â€¢ Intelligent undead: as Charm Person (save vs Spells; hostile +5), up to 2 HD Ã— level affected this cast.
          â€¢ Unintelligent undead (e.g., skeletons, zombies): no save; permanent control transfer to caster.
          â€¢ Unintelligent commanded HD counts against Reanimation control cap (6Ã—level HD).
        Usage:
          !cast commandundead <target [target ...]> [-h|hostile | -nh|-nonhostile]
        Notes:
          â€¢ Hostile default: if a battle is running and round â‰¥ 1 â†’ +5 to save (overridable via flags).
          â€¢ Intelligent targets are not directly controlled (no ping), but cease hostility (GM adjudicates).
          â€¢ Unintelligent targets become controlled by the caster (pinged on their turns).
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        raw_names: list[str] = []
        force_hostile = None
        for t in toks:
            tl = t.lower()
            if tl in ("-h","-hostile","+5","hostile"):
                force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"):
                force_hostile = False
            else:
                raw_names.append(t)

        if not raw_names:
            return [
                "âŒ **Command Undead**: add at least one undead target.",
                "Example: `!cast commandundead ghoul` or `!cast commandundead zo2 sk1 -h`"
            ]


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            for fnm in os.listdir("."):
                if fnm.lower() == base:
                    path = fnm
                    try:
                        c = read_cfg(path)
                        real = get_compat(c, "info", "name", fallback=None)
                        return (real or fnm[:-4].replace("_", " ")), path
                    except Exception:
                        return fnm[:-4].replace("_", " "), path
            return None, None


        def _is_undead(rcfg) -> bool:
            ty = (str(get_compat(rcfg, "stats", "type", fallback="")) or str(get_compat(rcfg, "info", "type", fallback=""))).lower()
            return "undead" in ty

        def _is_unintelligent_undead(rcfg) -> bool:

            mt = (str(get_compat(rcfg, "info", "monster_type", fallback="")) or "").lower()
            nm = (str(get_compat(rcfg, "info", "name", fallback="")) or "").lower()
            if any(k in mt for k in ("skeleton", "zombie")):
                return True
            if re.match(r"^(sk|zo)\d+$", nm):
                return True

            return False

        def _slot_for(name: str) -> str:
            try:
                return _slot(name)
            except Exception:
                return name.replace(" ", "_")


        def _sum_controlled(owner_id: str, controller_name: str) -> int:
            names, _ = _parse_combatants(bcfg, chan_id)
            total = 0
            for n in names:
                fn = f"{n}.coe"
                if not os.path.exists(fn):
                    continue
                rc = read_cfg(fn)
                if str(get_compat(rc, "info", "owner_id", fallback="")) != str(owner_id):
                    continue
                if str(get_compat(rc, "info", "controller", fallback="")).strip().lower() != caster_name.strip().lower():
                    continue
                if str(get_compat(rc, "stats", "type", fallback="")).strip().lower() != "undead":
                    continue
                hd_now = getint_compat(rc, "cur", "level", fallback=1)
                total += max(1, int(hd_now))
            return total


        hostile_bonus_default = False
        try:
            if force_hostile is None and bcfg.getint(chan_id, "round", fallback=0) >= 1:
                hostile_bonus_default = True
        except Exception:
            pass
        hostile_bonus_flag = force_hostile if force_hostile is not None else hostile_bonus_default
        hostile_bonus_val = 5 if hostile_bonus_flag else 0


        hd_budget_total = 2 * max(1, int(caster_level or 1))
        hd_budget_used  = 0

        control_cap = 6 * max(1, int(caster_level or 1))
        control_used = _sum_controlled(caster_owner_id, caster_name)


        head = f"ðŸ•¯ï¸ **Command Undead**"
        lines: list[str] = [head]
        changed_any = False

        for raw in raw_names:
            disp, path = _resolve_any_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            tcfg = read_cfg(path)
            if not _is_undead(tcfg):
                lines.append(f"â€¢ **{pretty}**: âŒ not undead (no effect).")
                continue

            hd = self._hd_or_level_from_cfg(tcfg)
            unintelligent = _is_unintelligent_undead(tcfg)


            slot = _slot_for(pretty)

            if unintelligent:

                if control_used + hd > control_cap:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): âŒ exceeds control cap "
                                 f"(**{control_used} / {control_cap} HD**).")
                    continue


                tcfg.set("info", "owner_id", str(caster_owner_id))
                tcfg.set("info", "controller", caster_name)

                tcfg.set("info", "battle_chan", chan_id)
                with open(path, "w", encoding="utf-8") as f:
                    tcfg.write(f)


                bcfg.set(chan_id, f"{slot}.hostile", "0")
                bcfg.set(chan_id, f"{slot}.minion_by", caster_name)
                bcfg.set(chan_id, f"{slot}.minion_type", "commandundead")

                control_used += hd
                changed_any = True
                lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ§¿ **Commanded** â€” no save. "
                             f"Control: **{control_used - hd} â†’ {control_used} / {control_cap} HD**.")
            else:

                if hd_budget_used + hd > hd_budget_total:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): âŒ over budget "
                                 f"(used **{hd_budget_used} / {hd_budget_total} HD** for this cast).")
                    continue


                used_vs = "Spells"
                sv_dc = None; sv_roll = None
                for vs_key in ("spell", "sp", "spells"):
                    try:
                        ok, r, dc, pen = self._roll_save(tcfg, vs=vs_key, penalty=0)
                        if dc is not None:
                            sv_roll, sv_dc = r, dc
                            used_vs = "Spells"
                            break
                    except Exception:
                        pass
                if sv_dc is None:
                    sv_dc = 15
                    sv_roll = 10

                adj = (sv_roll or 0) + hostile_bonus_val
                d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
                pass_save = adj >= sv_dc

                if pass_save:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): Save vs {used_vs} {d20_face}"
                                 f"{' + 5' if hostile_bonus_val else ''} = ``{adj}`` vs **{sv_dc}** â†’ âŒ **RESISTS**.")
                    continue


                hd_budget_used += hd

                bcfg.set(chan_id, f"{slot}.hostile", "0")

                bcfg.set(chan_id, f"{slot}.charmed_by", caster_name)
                bcfg.set(chan_id, f"{slot}.charm_source", "commandundead")

                changed_any = True
                note = ("ðŸ’— **Charmed** â€” regards the caster as a trusted ally; "
                        "orders must be communicated. Self/ally-harming commands grant a fresh save at **+5** (GM adjudicates).")
                lines.append(f"â€¢ **{pretty}** (HD {hd}): Save vs {used_vs} {d20_face}"
                             f"{' + 5' if hostile_bonus_val else ''} = ``{adj}`` vs **{sv_dc}** â†’ **CHARMED**. {note} "
                             f"(Budget: **{hd_budget_used} / {hd_budget_total} HD**)")

        if changed_any:
            try:
                _save_battles(bcfg)
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


        lines.insert(1, "Range: **30 ft**  â€¢  Duration: **Special**")
        lines.append("â€”")
        lines.append("â€¢ Intelligent undead: like *Charm Person*; up to **2 HD/level** this cast; save vs Spells (hostile +5).")
        lines.append("â€¢ Unintelligent undead: **no save**; **permanent** control; "
                     "counts against **Reanimation** control cap (**6Ã—level HD**).")

        return lines

    async def _effect_fossilize(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ):
        """
        Fossilize (Necromancer 3) â€” Touch â€¢ Permanent
          â€¢ Target: one **skeletal undead** (e.g., Skeleton, skeletal champion)
          â€¢ Permanently: AC +4, damage +2, special resistances:
              - Slashing â†’ always takes exactly 1 damage (if >0 was dealt)
              - Immune to **normal** arrows/bolts/bullets (magic missiles still work)
              - Resists (Â½) all **other weapon** attacks
          â€¢ Drawback: cannot be repaired/healed afterwards
        Implementation:
          - Edits the targetâ€™s .coe: sets base/stats.fossilized = 1,
            bumps AC, adjusts damage, and records flags for mitigation.
        """
        if not tokens:
            return ["ðŸª¨ **Fossilize**: *(Usage: `!cast fossilize <skeletal_undead>`)*"]

        lines = [f"ðŸª¨ **Fossilize**: {caster_name} mineralizes undead bonesâ€¦"]

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return (fn[:-4].replace("_", " "), path)
            return name, None

        def _is_skeletal_undead(cfg) -> bool:
            ty = (str(get_compat(cfg, "stats", "type", fallback="")) or
                  str(get_compat(cfg, "base",  "type", fallback="")) or
                  str(get_compat(cfg, "info",  "type", fallback=""))).lower()
            mt = str(get_compat(cfg, "info", "monster_type", fallback="")).lower()
            nm = str(get_compat(cfg, "info", "name",          fallback="")).lower()
            if "undead" not in ty:
                return False
            return ("skeleton" in mt) or ("skeleton" in nm) or ("skeletal" in mt) or ("skeletal" in nm)

        def _bump_ac_str(val, plus=4):
            try:
                return str(max(0, int(val)) + int(plus))
            except Exception:
                return str(plus)

        def _add_plus2_to_dmg(s: str) -> str | None:
            """
            Tries to turn 'XdY' or 'XdY+Z' into 'XdY+(Z+2)'.
            Returns None if unparsable so caller can set a dmg_bonus flag instead.
            """
            if not s: return None
            m = re.fullmatch(r"\s*(\d+)\s*d\s*(\d+)\s*([+-]\s*\d+)?\s*", s, re.I)
            if not m:
                return None
            flat = 0
            if m.group(3):
                try:
                    flat = int(m.group(3).replace(" ", ""))
                except Exception:
                    flat = 0
            flat += 2
            sign = "+" if flat >= 0 else "-"
            return f"{int(m.group(1))}d{int(m.group(2))}{sign}{abs(flat)}"


        for raw in tokens:
            disp, path = _resolve_ci(raw)
            if not path:
                lines.append(f"â€¢ **{raw}**: âŒ not found.")
                continue

            cfg = read_cfg(path)
            if not _is_skeletal_undead(cfg):
                lines.append(f"â€¢ **{disp}**: not a **skeletal undead** â€” no effect.")
                continue


            already = getint_compat(cfg, "base", "fossilized", fallback=0) or getint_compat(cfg, "stats", "fossilized", fallback=0)
            if already:
                lines.append(f"â€¢ **{disp}**: already fossilized.")
                continue


            old_ac = (get_compat(cfg, "stats", "ac", fallback="") or get_compat(cfg, "base", "ac", fallback="") or "0")
            new_ac = _bump_ac_str(old_ac, 4)
            for sec in ("stats", "base"):
                if not cfg.has_section(sec):
                    cfg.add_section(sec)
                cfg.set(sec, "ac", new_ac)


            dmg_stats = get_compat(cfg, "stats", "damage", fallback="")
            dmg_base  = get_compat(cfg, "base",  "damage", fallback=dmg_stats)
            new_stats = _add_plus2_to_dmg(dmg_stats) or ""
            new_base  = _add_plus2_to_dmg(dmg_base)  or ""

            if new_stats:
                cfg.set("stats", "damage", new_stats)
            if new_base:
                cfg.set("base",  "damage", new_base)


            if not new_stats and not new_base:
                for sec in ("stats", "base"):
                    cfg.set(sec, "dmg_bonus", str(max(2, getint_compat(cfg, sec, "dmg_bonus", fallback=0) + 2)))


            for sec in ("stats", "base"):
                cfg.set(sec, "fossilized", "1")


                prev_reduce = str(get_compat(cfg, sec, "reduce1", fallback="")).strip()
                if "reduce1" not in prev_reduce.lower():

                    pass


            imm0 = str(get_compat(cfg, "base", "immune", fallback="")).strip()
            imm_tokens = [t for t in re.split(r"[,\s]+", imm0) if t]
            for tok in ("Longbow", "Shortbow", "Sling", "LightXbow", "HeavyXbow"):
                if tok.lower() not in {t.lower() for t in imm_tokens}:
                    imm_tokens.append(tok)
            cfg.set("base", "immune", " ".join(imm_tokens))


            for sec in ("stats", "base"):
                cfg.set(sec, "no_heal", "fossilized")

            write_cfg(path, cfg)


            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


            try:
                shown_old = int(old_ac)
                shown_new = int(new_ac)
            except Exception:
                shown_old = old_ac; shown_new = new_ac

            dmg_note = (f"{dmg_stats}â†’{new_stats}" if new_stats else (f"{dmg_base}â†’{new_base}" if new_base else "+2"))
            lines.append(
                f"â€¢ **{disp}**: **FOSSILIZED** â€” AC {shown_old}â†’**{shown_new}**, damage **+2** ({dmg_note}); "
                "slashing â†’ 1, immune to normal arrows/bolts/bullets, resists other weapons; cannot be healed."
            )

        return lines


    async def _effect_haltundead(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ) -> str:
        """
        Halt Undead â€” Necromancer 3
          â€¢ Range: 200 ft (not enforced here)
          â€¢ Duration: 1 round/level
          â€¢ Up to 3 undead targets.
          â€¢ Unintelligent undead (e.g., skeletons, zombies): no save â€” paralyzed.
          â€¢ Intelligent undead: Save vs Spells or be paralyzed.
        """

        head = "ðŸª¦ **Halt Undead**"
        if not tokens:
            return head + "\n*(Usage: `!cast haltundead <undead> [undead] [undead]` â€” up to 3 targets)*"


        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        def _is_undead_cfg_local(rcfg) -> bool:
            try:
                return _is_undead_cfg(rcfg, get_compat(rcfg, "info", "name", fallback=""))
            except Exception:
                ty = (
                    str(get_compat(rcfg, "stats", "type", fallback=""))
                    or str(get_compat(rcfg, "info", "type", fallback=""))
                ).lower()
                return "undead" in ty

        def _is_unintelligent_undead(rcfg) -> bool:
            mt = (str(get_compat(rcfg, "info", "monster_type", fallback="")) or "").lower()
            nm = (str(get_compat(rcfg, "info", "name",          fallback="")) or "").lower()
            if any(k in mt for k in ("skeleton", "zombie")):
                return True
            if re.fullmatch(r"(sk|zo)\d+", nm):
                return True

            return False


        resolved = []
        for t in tokens:
            disp, path = _resolve_ci(t)
            resolved.append((t, disp or t, path))
        extras = []
        if len(resolved) > 3:
            extras = [disp for (_r, disp, _p) in resolved[3:]]
            resolved = resolved[:3]

        rounds = max(1, int(caster_level or 1))
        changed_any = False
        lines = [f"Range: **200 ft**  â€¢  Duration: **{rounds} round{'s' if rounds!=1 else ''}**"]

        for raw, disp, path in resolved:
            pretty = disp or raw
            if not path:
                lines.append(f"â€¢ **{pretty}**: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            if not _is_undead_cfg_local(t_cfg):
                lines.append(f"â€¢ **{pretty}**: not undead â€” **no effect**")
                continue


            if _is_unintelligent_undead(t_cfg):
                try:
                    self._set_status_rounds(ctx, pretty, "paralyzed", rounds, by=caster_name)
                    changed_any = True
                except Exception:
                    pass
                lines.append(f"â€¢ **{pretty}**: mindless undead â€” ðŸ§Š **PARALYZED** *(no save)*")
                continue


            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if ok:
                lines.append(f"â€¢ **{pretty}**: Save vs Spells **{sv_roll}** vs **{sv_dc}** â†’ âŒ **RESISTS**")
                continue


            try:
                self._set_status_rounds(ctx, pretty, "paralyzed", rounds, by=caster_name)
                changed_any = True
            except Exception:
                pass
            lines.append(f"â€¢ **{pretty}**: Save vs Spells **{sv_roll}** vs **{sv_dc}** â†’ ðŸ§Š **PARALYZED**")

        if extras:
            lines.append(f"*(Up to 3 targets; ignoring: {', '.join(extras)})*")


        if changed_any:
            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        return head + "\n" + "\n".join(lines)


    async def _effect_rayofexhaustion(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        caster_level: int,
        tokens: list[str],
    ) -> str:
        """
        Ray of Exhaustion â€” Necromancer 3
          â€¢ Range: 50 ft (not enforced)
          â€¢ Duration: 6 rounds/level (timer on target: [RE â€¦])
          â€¢ Attack: ranged touch (ignores armor; keeps Dex bonus)
              to-hit = d20 + caster DEX modifier
              Touch AC = 10 + target DEX modifier
          â€¢ On hit: Save vs Spells
              â€“ Fail: STR â€“6 and DEX â€“6
              â€“ Success: STR â€“2 and DEX â€“2
          â€¢ Floor: abilities never drop below 3
          â€¢ Use `!ds <name> re` to end early and auto-restore STR/DEX.
        """

        head = "ðŸ–¤ **Ray of Exhaustion**"
        if not tokens:
            return head + "\n*(Usage: `!cast rayofexhaustion <target>`)*"


        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        def _ability_mod_from_cfg(rcfg, skey: str) -> int:

            m = getint_compat(rcfg, "stats", f"{skey}_modifier", fallback=None)
            if m is not None:
                return int(m)
            val = getint_compat(rcfg, "stats", skey, fallback=None)
            try:
                return int(_ability_mod(val)) if val is not None else 0
            except Exception:
                return 0

        def _apply_temp_ability_debuff(path: str, src_key: str, deltas: dict[str, int]) -> dict[str, int]:
            """
            Apply temporary ability penalties (positive values reduce).
            Records how much was actually applied under [effects] so we can restore.
            Returns {stat: applied_amount}.
            """
            cfg = read_cfg(path)
            applied = {}
            for skey, amt in deltas.items():
                sk = skey.lower()
                old = getint_compat(cfg, "stats", sk, fallback=None)
                if old is None:
                    continue
                target = max(3, int(old) - int(amt))
                real = int(old) - target
                if real <= 0:
                    continue
                if not cfg.has_section("stats"): cfg.add_section("stats")
                cfg["stats"][sk] = str(target)

                try:
                    new_mod = _ability_mod(target)
                except Exception:
                    new_mod = getint_compat(cfg, "stats", f"{sk}_modifier", fallback=0)
                cfg["stats"][f"{sk}_modifier"] = str(new_mod)
                applied[sk] = real

            if applied:
                if not cfg.has_section("effects"): cfg.add_section("effects")
                for sk, real in applied.items():
                    cfg["effects"][f"{src_key}_{sk}_delta"] = str(real)
                write_cfg(path, cfg)
            return applied

        def _slot_for(name: str) -> str:
            try:
                return _choose_slot_for_effects(_load_battles(), str(ctx.channel.id), name)
            except Exception:
                try:
                    return _slot(name)
                except Exception:
                    return name.replace(" ", "_")


        raw = tokens[0]
        disp, t_path = _resolve_ci(raw)
        target = disp or raw
        if not t_path:
            return head + f"\nâ€¢ **{target}**: *(not found)*"

        t_cfg = read_cfg(t_path)

        caster_dex_mod = _ability_mod_from_cfg(caster_cfg, "dex")

        target_dex_mod = _ability_mod_from_cfg(t_cfg, "dex")
        touch_ac = 10 + int(target_dex_mod)


        d20 = random.randint(1, 20)
        atk_total = d20 + int(caster_dex_mod)
        hit = (atk_total >= touch_ac)

        lines = [f"Range: **50 ft**  â€¢  Duration: **{6*max(1,int(caster_level or 1))} rounds** ( [RE] )",
                 f"ðŸŽ¯ {caster_name} targets **{target}** â€” Ranged Touch: d20 **{d20}**"
                 + (f" + DEX {caster_dex_mod:+d}" if caster_dex_mod else "")
                 + f" = **{atk_total}** vs **Touch AC {touch_ac}**"
                ]

        if not hit:
            lines.append(f"â€¢ **{target}**: **MISS** â€” the black ray hisses past.")
            return " \n".join([head] + lines)


        ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
        if sv_dc is None:

            sv_dc = 15
        passed = bool(ok)


        penal = 2 if passed else 6
        lines.append(f"â€¢ **{target}**: Save vs Spells **{sv_roll}** vs **{sv_dc}** â†’ "
                     + ("**RESISTS** (reduced effect)" if passed else "**FAILS**"))



        applied = _apply_temp_ability_debuff(t_path, "rayexhaustion", {"str": penal, "dex": penal})


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                slot = _slot_for(target)
                rounds = 6 * max(1, int(caster_level or 1))

                base_key = "x_rayexhaustion"
                bcfg.set(chan_id, f"{slot}.{base_key}",          str(int(rounds)))
                bcfg.set(chan_id, f"{slot}.{base_key}_code",     "RE")
                bcfg.set(chan_id, f"{slot}.{base_key}_label",    "Ray of Exhaustion")
                bcfg.set(chan_id, f"{slot}.{base_key}_emoji",    "ðŸ˜µâ€ðŸ’«")
                bcfg.set(chan_id, f"{slot}.{base_key}_by",       caster_name)


                if applied:
                    bcfg.set(chan_id, f"{slot}.re_str_applied", str(applied.get("str", 0)))
                    bcfg.set(chan_id, f"{slot}.re_dex_applied", str(applied.get("dex", 0)))

                _save_battles(bcfg)


                try:
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass
        except Exception:
            pass


        if applied:
            s = applied.get("str", 0); d = applied.get("dex", 0)
            lines.append(f"â†’ **{target}** suffers STR **â€“{s}** and DEX **â€“{d}** "
                         f"(min 3). **[RE {6*max(1,int(caster_level or 1))}]**")
        else:
            lines.append(f"â†’ **{target}** already at minimums â€” no ability change recorded.")


        lines.append("*(Use `!ds {name} re` to clear early and restore STR/DEX.)*".format(name=target))
        return " \n".join([head] + lines)

    async def _effect_spiritwrack(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:

        chan_id = str(ctx.channel.id)
        L = max(1, int(caster_level))


        burst = False
        if targets and str(targets[0]).lower() in {"-burst", "-b", "burst"}:
            burst = True
            targets = targets[1:]

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                name_safe = (name or "")
                base = name_safe.replace(" ", "_").lower() + (".ini" if name_safe.lower().endswith(".ini") else ".coe")
                files = os.listdir(".")
                for fn in files:
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None) or get_compat(cfg, "base", "name", fallback=None)
                            return (real or fn.rsplit(".",1)[0].replace("_", " ")), path
                        except Exception:
                            return fn.rsplit(".",1)[0].replace("_", " "), path
                want = name_safe.replace(" ", "_").lower()
                for fn in files:
                    stem = fn.rsplit(".",1)[0].lower()
                    if stem == want:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None) or get_compat(cfg, "base", "name", fallback=None)
                            return (real or fn.rsplit(".",1)[0].replace("_", " ")), path
                        except Exception:
                            return fn.rsplit(".",1)[0].replace("_", " "), path
                return None, None

        INCORP_RE = re.compile(r"\b(wraith|spectre|specter|ghost|poltergeist|banshee|spirit|phantom|apparition|shadow|shade)\b", re.I)

        def _is_incorporeal_undead(cfg, display_name: str) -> bool:
            disp = (display_name or "").lower()

            type_fields = " ".join(filter(None, [
                str(get_compat(cfg, "base",  "type", fallback="")),
                str(get_compat(cfg, "stats", "type", fallback="")),
                str(get_compat(cfg, "info",  "type", fallback="")),
            ])).lower()

            mtype_fields = " ".join(filter(None, [
                str(get_compat(cfg, "base",  "monster_type", fallback="")),
                str(get_compat(cfg, "stats", "monster_type", fallback="")),
                str(get_compat(cfg, "info",  "monster_type", fallback="")),
            ])).lower()

            traits = " ".join(filter(None, [
                str(get_compat(cfg, "base",  "traits",   fallback="")),
                str(get_compat(cfg, "base",  "keywords", fallback="")),
                str(get_compat(cfg, "base",  "special",  fallback="")),
                str(get_compat(cfg, "stats", "traits",   fallback="")),
                str(get_compat(cfg, "stats", "keywords", fallback="")),
            ])).lower()

            is_undead = ("undead" in type_fields)
            is_incorp = (
                ("incorporeal" in traits or "incorp" in traits) or
                (INCORP_RE.search(mtype_fields) is not None) or
                (INCORP_RE.search(disp) is not None)
            )
            if not is_undead and (INCORP_RE.search(mtype_fields) is not None):
                is_undead = True
            return is_undead and is_incorp


        if not targets:
            head = f"ðŸ”” **Spirit Wrack** â€” {L}d8 (single) or {L}d4 (burst), Save vs **Spells** for half"
            return (
                f"{head}\n"
                f"*Usage:* `!cast spiritwrack <one target>` (single)  â€¢  "
                f"`!cast spiritwrack <t1> <t2> ...` (auto-burst, 20 ft)\n"
                f"*Tip:* `-b` also forces burst if you want."
            )


        resolved = []
        for raw in targets:
            d, p = _resolve_char_ci(raw)
            resolved.append(((d or raw), p))


        valids = [(d, p) for d, p in resolved if p]
        extra_note = ""
        work = []

        if not burst and len(valids) > 1:
            burst = True
            work = valids
            extra_note = " *(Auto-burst: multiple targets listed.)*"
        elif burst:

            if not valids:
                lines = [f"{d}: *(not found)*" for d, p in resolved]
                head = f"ðŸ”” **Spirit Wrack** â€” {L}d8 (single) or {L}d4 (burst), Save vs **Spells** for half â€¢ **Burst 20 ft**"
                return head + "\n" + "\n".join(lines)
            work = valids
        else:

            first_valid = next(((d, p) for d, p in resolved if p), None)
            if not first_valid:
                lines = [f"{d}: *(not found)*" for d, p in resolved]
                head = f"ðŸ”” **Spirit Wrack** â€” {L}d8 (single) or {L}d4 (burst), Save vs **Spells** for half"
                return head + "\n" + "\n".join(lines)
            work = [first_valid]
            extras = [d for (d, p) in resolved[1:]]
            extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")


        head = (
            f"ðŸ”” **Spirit Wrack** â€” {L}d8 (single) or {L}d4 (burst), Save vs **Spells** for half"
            + ("" if not burst else " â€¢ **Burst 20 ft** (names treated as in range)")
        )


        dmg_spec = f"{L}d8" if not burst else f"{L}d4"


        shared_roll = None
        if burst:
            s, rolls, flat = roll_dice(dmg_spec)
            shared_roll = (s + flat, rolls, flat)

        out_lines = [head]


        for pretty, path in work:
            if not path:
                out_lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            if not _is_incorporeal_undead(t_cfg, pretty):
                out_lines.append(f"{pretty}: âŒ No effect (not a **true incorporeal undead**).")
                continue


            sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            save_line = f"{pretty}: Save vs Spells {sv_roll}{pen_txt} vs {sv_target}"


            if shared_roll:
                raw_total, rolls, flat = shared_roll
                rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "] (shared)"
            else:
                s, rolls, flat = roll_dice(dmg_spec)
                raw_total = s + flat
                rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"

            raw_after_save = raw_total if not sv_ok else int(math.floor(raw_total / 2))


            final, note = _apply_mitigation(raw_after_save, weapon_name="Spirit Wrack", weapon_type="magical", t_cfg=t_cfg)


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            base = f"{save_line} â†’ {'**SUCCESS**' if sv_ok else '**FAIL**'} â†’ {dmg_spec} {rolls_txt} = **{raw_total}**"
            if sv_ok:
                base += f" â†’ **{raw_after_save}** after save"
            if note:
                base += f"\nâ†’ **{note}** â†’ **{final}**"


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_tail = f"\n{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_tail = f"\n{old_hp} â†’ **{new_hp}**{dead_note}"

            out_lines.append(base + hp_tail)


            if new_hp <= 0 and _is_monster_file(path):
                try:
                    bcfg = _load_battles()
                    if bcfg.has_section(chan_id):
                        names, scores = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names, scores)
                            if bcfg.get(chan_id, "turn", fallback="") == key:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(path))
                except Exception:
                    pass

        if any("poltergeist" in (n or "").lower() for n, _ in work):
            out_lines.append("*GM: Minor spirits like poltergeists are often destroyed outright by this spell.*")


        try:
            bcfg2 = _load_battles()
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return "\n".join(out_lines) + (extra_note if extra_note else "")

    async def _cast_summonspirit(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Summon Spirit (Necromancer 3)
          â€¢ L1â€“9: summons **one Wraith** (no args)
          â€¢ L10â€“14: choose **1d4 Wraiths** or **1 Spectre**
          â€¢ L15+: choose **2d4 Wraiths**, **1d3 Spectres**, or **1 Ghost**
          â€¢ Duration: 1 turn/level (assumed 10 rounds/turn = 10Ã—level rounds)
          â€¢ On expiry, each spirit with â‰¥ half HP may go **rogue**:
              Wraith 5%, Spectre 10%, Ghost 20% (hostile for level rounds, then departs)
        Usage:
          !cast summonspirit                 # L1â€“9 (one wraith)
          !cast summonspirit wraiths|wraith  # L10+ option
          !cast summonspirit spectre         # L10+ option
          !cast summonspirit ghost           # L15+ option
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]

        L = max(1, int(caster_level or 1))
        rounds_total = 10 * L


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]


        choice = None
        for t in toks:
            if t in {"wraith", "wraiths"}:
                choice = "wraith"
                break
            if t in {"specter", "spectre", "spectres", "specters"}:
                choice = "spectre"
                break
            if t in {"ghost", "ghosts"}:
                choice = "ghost"
                break


        if L < 10:

            plan = ("wraith", 1, "1Ã— Wraith", 5)
        elif L < 15:

            if not choice:
                return ["âŒ Choose one: `!cast summonspirit wraiths` **or** `!cast summonspirit spectre` (L10â€“14)."]
            if choice == "wraith":
                n = random.randint(1, 4)
                plan = ("wraith", n, f"{n}Ã— Wraith{'s' if n != 1 else ''} (1d4)", 5)
            elif choice == "spectre":
                plan = ("spectre", 1, "1Ã— Spectre", 10)
            else:
                return ["âŒ At levels 10â€“14 you may choose **wraiths** or **spectre**."]
        else:

            if not choice:
                return ["âŒ Choose one: `wraiths` (2d4), `spectres` (1d3), or `ghost` (1)."]
            if choice == "wraith":
                n = random.randint(1, 4) + random.randint(1, 4)
                plan = ("wraith", n, f"{n}Ã— Wraith{'s' if n != 1 else ''} (2d4)", 5)
            elif choice == "spectre":
                n = random.randint(1, 3)
                plan = ("spectre", n, f"{n}Ã— Spectre{'s' if n != 1 else ''} (1d3)", 10)
            elif choice == "ghost":
                plan = ("ghost", 1, "1Ã— Ghost", 20)
            else:
                return ["âŒ At level 15+ you may choose **wraiths** (2d4), **spectres** (1d3), or **ghost** (1)."]

        mon_name, count, pretty_count, rogue_pct = plan


        def _tpl(kind: str):
            return (_load_monster_template(kind)
                    or _load_monster_template(kind + ".ini")
                    or None)

        tpl = _tpl(mon_name)
        if not tpl:
            return [f"âŒ Monster template not found for **{mon_name}** (e.g., `{mon_name}.ini`)."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        def _spawn_batch(mon_name: str, tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 4))
            hpmod  = int(tpl.get("hpmod", 0))
            damage = str(tpl.get("damage", "1d6"))
            move   = int(tpl.get("move", 60))
            saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
            resist  = str(tpl.get("resist",  "")).strip()
            reduce1 = str(tpl.get("reduce1", "")).strip()
            immune  = str(tpl.get("immune",  "")).strip()
            weak    = str(tpl.get("weak",    "")).strip()


            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", max(1, hd)
            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}



            prefix = {"wraith": "WR", "spectre": "SP", "ghost": "GH"}.get(mon_name, re.sub(r"[^A-Za-z]", "", mon_name).upper()[:2] or "MO")
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            made = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)


                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": mon_name, "battle_chan": chan_id,
                    "controller": caster_name,
                    "summoned": "summonspirit",
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}

                stats = {
                    "ac": str(ac), "ab": "", "move": str(move),
                    "type": str(tpl.get("type", "")).strip(),
                    "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
                }
                attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
                atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
                attack_list = [a for a in re.split(r"[,\s]+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None:
                                first_spec = spec
                    stats["damage"] = first_spec or damage or "1d6"
                else:
                    stats["damage"] = damage or "1d6"

                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)


                try:
                    s_el = _slot(mon)
                except Exception:
                    s_el = mon.replace(" ", "_")


                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s_el}."):
                        bcfg.remove_option(chan_id, opt_key)
                if bcfg.has_option(chan_id, mon):
                    bcfg.remove_option(chan_id, mon)


                bcfg.set(chan_id, f"{s_el}.disp", mon)
                bcfg.set(chan_id, f"{s_el}.hostile", "0")
                bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
                bcfg.set(chan_id, f"{s_el}.minion_type", mon_name)


                bcfg.set(chan_id, f"{s_el}.summon_left", str(rounds_total))
                bcfg.set(chan_id, f"{s_el}.summon_rogue_pct", str(rogue_pct))
                bcfg.set(chan_id, f"{s_el}.summon_rogue_linger", str(L))
                bcfg.set(chan_id, f"{s_el}.summon_src", "summonspirit")


                bcfg.set(chan_id, f"{s_el}.expire_cb", "summonspirit")

                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s_el}.join", str(join_seq))

                made.append((mon, d6, hp, hd, s_el))

            _save_battles(bcfg)
            return made

        created = _spawn_batch(mon_name, tpl, count)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        if not created:
            return [f"âš ï¸ SummonSpirit: nothing created (template/write error?)."]


        names = [n for (n, _i, _hp, _hd, _s) in created]
        lines = [
            f"ðŸ•¯ï¸ **{caster_name}** casts **Summon Spirit**.",
            f"â€¢ Summoned: **{pretty_count}** â†’ {', '.join(names)}",
            f"â€¢ Duration: **{L} turn(s)** (**{rounds_total} rounds**).",
        ]
        if mon_name == "wraith":
            lines.append("â€¢ On expiry: each Wraith (â‰¥ half HP) has **5%** chance to go **ROGUE** for **{L} rounds**, then departs.")
        elif mon_name == "spectre":
            lines.append("â€¢ On expiry: each Spectre (â‰¥ half HP) has **10%** chance to go **ROGUE** for **{L} rounds**, then departs.")
        else:
            lines.append("â€¢ On expiry: the Ghost (â‰¥ half HP) has **20%** chance to go **ROGUE** for **{L} rounds**, then departs.")

        return lines

    async def _effect_blight(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets) -> str:
        """
        Blight (Druid 5 â€¢ Necromancer 5)
          â€¢ Single target.
          â€¢ If target is a PLANT CREATURE: takes Ld6 damage (save vs **Spells** for half).
          â€¢ If target is a non-creature plant: withers & dies (no save).
          â€¢ Range: Touch. (No attack roll here â€” treat the touch as already achieved.)
          â€¢ Duration: Instantaneous.
        Usage:
          !cast blight <target-or-plant-name>
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in targets.split()]

        L = max(1, int(caster_level))
        dmg_spec = f"{L}d6"

        if not toks:
            return (f"ðŸŒ¿ **Blight** â€” If target is a *plant creature*: **{dmg_spec}** (save vs **Spells** for half). "
                    f"If itâ€™s a *non-creature* plant: it **withers instantly**.\n"
                    f"_Usage:_ `!cast blight <target>`")

        tgt_raw = toks[0]
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_raw)
        except Exception:
            tgt_disp, tgt_path = tgt_raw, None
        extras = [t for t in toks[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")


        def _is_plant_creature(cfg) -> bool:
            fields = " ".join(filter(None, [
                str(get_compat(cfg, "base",  "type",          fallback="")),
                str(get_compat(cfg, "info",  "type",          fallback="")),
                str(get_compat(cfg, "stats", "type",          fallback="")),
                str(get_compat(cfg, "base",  "monster_type",  fallback="")),
                str(get_compat(cfg, "info",  "monster_type",  fallback="")),
                str(get_compat(cfg, "stats", "monster_type",  fallback="")),
                str(get_compat(cfg, "base",  "keywords",      fallback="")),
                str(get_compat(cfg, "stats", "keywords",      fallback="")),
                str(get_compat(cfg, "base",  "traits",        fallback="")),
                str(get_compat(cfg, "stats", "traits",        fallback="")),
            ])).lower()
            return "plant" in fields


        if not tgt_path or not os.path.exists(tgt_path):

            return f"ðŸŒ¿ **Blight**\n{tgt_disp}: **Withers and dies** (non-creature plant; no save)." + extra_note


        t_cfg = read_cfg(tgt_path)
        if not _is_plant_creature(t_cfg):
            return f"ðŸŒ¿ **Blight**\n{tgt_disp}: âŒ No effect (not a **plant creature**)." + extra_note


        sv_ok, sv_roll, sv_target, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
        pen_txt = f" - {sv_pen}" if sv_pen else ""
        save_line = f"{tgt_disp}: Save vs **Spells** {sv_roll}{pen_txt} vs {sv_target} â†’ " + ("**SUCCESS**" if sv_ok else "**FAIL**")


        s, rolls, flat = roll_dice(dmg_spec)
        raw_total = s + flat
        raw_after_save = raw_total if not sv_ok else int(math.floor(raw_total / 2))
        final, note = _apply_mitigation(raw_after_save, weapon_name="Blight", weapon_type="magical", t_cfg=t_cfg)


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        new_hp = max(0, old_hp - final)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)


        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        base = f"ðŸŒ¿ **Blight**\n{save_line}\n{dmg_spec} {rolls_txt} = **{raw_total}**"
        if sv_ok:
            base += f" â†’ **{raw_after_save}** after save"
        if note:
            base += f"\nâ†’ **{note}** â†’ **{final}**"


        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            tail = f"\n{before} â†’ {after}{dead_note}"
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            tail = f"\n{old_hp} â†’ **{new_hp}**{dead_note}"

        out = base + tail + extra_note


        if new_hp <= 0 and _is_monster_file(tgt_path):
            chan_id = str(ctx.channel.id)
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        slot = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass


        try:
            bcfg2 = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg2.has_section(chan_id):
                msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg2, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return out

    async def _effect_vampirictouch(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets) -> str:
        """
        Vampiric Touch (Necromancer 3)
          â€¢ Touch attack: d20 + STR mod vs AC (nat 20 hits, nat 1 misses)
          â€¢ Damage: âŒŠlevel/2âŒ‹d6 (magical). Mitigation applies.
          â€¢ Caster gains a Stoneskin-style buffer equal to damage actually inflicted.
          â€¢ Buffer duration: 1 hour (6 turns) â€” shown as [SS N] on the caster.
          â€¢ If target dies, THP equals only the damage needed to kill it.
        Usage:
          !cast vampirictouch <target>
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in targets.split()]
        if not toks:
            return "ðŸ©¸ **Vampiric Touch** â€” touch attack; damage âŒŠlevel/2âŒ‹d6; gain temp HP = damage dealt (1 hour).\n*(Add a target, e.g., `!cast vampirictouch goblin`.)*"

        tgt_raw = toks[0]
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_raw)
        except Exception:
            tgt_disp, tgt_path = tgt_raw, None
        extras = [t for t in toks[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        if not tgt_path or not os.path.exists(tgt_path):
            return f"ðŸ©¸ **Vampiric Touch**\n{tgt_raw}: *(not found)*{extra_note}"


        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        shield_bonus_applied = ac_defense_applied = blind_def_ac_pen = ma_bonus_applied = bs_bonus_applied = 0
        target_ac = 10
        if bcfg and bcfg.has_section(chan_id):
            target_ac, shield_bonus_applied, ac_defense_applied, blind_def_ac_pen, ma_bonus_applied, bs_bonus_applied =\
                self._defender_ac_with_buffs(bcfg, chan_id, tgt_disp, want_oil=False, atk_type="touch")
        else:

            t_cfg_raw = read_cfg(tgt_path)
            target_ac = self._get_effective_ac(t_cfg_raw, fallback=10)


        STR = getint_compat(caster_cfg, "stats", "str", fallback=10)
        try:
            str_mod = osr_mod(STR)
        except Exception:
            str_mod = 0

        d20 = random.randint(1, 20)
        nat20 = (d20 == 20)
        nat1  = (d20 == 1)
        char_class = (get_compat(caster_cfg, "info", "class", fallback="Fighter") or "Fighter").strip()
        ab_list = self.classes.get(char_class.lower(), {}).get("ab", [])

        cl = max(1, int(caster_level))
        ab = ab_list[min(cl - 1, len(ab_list) - 1)] if ab_list else 0
        total_to_hit = d20 + ab + str_mod

        hit = nat20 or (not nat1 and total_to_hit >= target_ac)


        if hit and bcfg and bcfg.has_section(chan_id):
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
                if consumed:
                    line_roll = f"Attack: **{d20}** + {ab:+} + {str_mod:+} = **{total_to_hit}** â†’ âœ… **HIT**"
                    note_mi   = f"\nMirror Image: a figment is struck and shatters (images left: **{left}**)."
                    return "ðŸ©¸ **Vampiric Touch**\n" + line_roll + note_mi + "\nNo damage dealt; no temporary HP gained." + extra_note
            except Exception:
                pass


        dice_n = max(1, int(caster_level) // 2)
        dmg_spec = f"{dice_n}d6"


        t_cfg = read_cfg(tgt_path)

        lines = ["ðŸ©¸ **Vampiric Touch**"]
        lines.append(f"Attack: **{d20}** + {ab} + {str_mod} = **{total_to_hit}** â†’ " + ("âœ… **HIT**" if hit else "âŒ **MISS**"))

        if not hit:
            return "\n".join(lines) + extra_note


        s, rolls, flat = roll_dice(dmg_spec)
        raw_total = s + flat


        final, note = _apply_mitigation(raw_total, weapon_name="Vampiric Touch", weapon_type="magical", t_cfg=t_cfg)


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        inflicted = min(final, old_hp)
        new_hp = max(0, old_hp - final)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        dmg_line = f"Damage: {dmg_spec} {rolls_txt} = **{raw_total}**"
        if note:
            dmg_line += f"\nâ†’ **{note}** â†’ **{final}**"
        lines.append(dmg_line)


        if _is_monster_file(tgt_path):
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            before = _life_bar(old_hp, mhp, width=10)
            after  = _life_bar(new_hp, mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            lines.append(f"{before} â†’ {after}{dead_note}")
        else:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            lines.append(f"HP: {old_hp} â†’ **{new_hp}**{dead_note}")


        thp = max(0, int(inflicted))
        if thp > 0 and bcfg and bcfg.has_section(chan_id):

            try:
                slot_c = _slot(caster_name)
            except Exception:
                slot_c = caster_name.replace(" ", "_")


            try:
                rounds = 6 * TURN_ROUNDS
            except Exception:
                rounds = 6 * 60


            try:
                rounds_key, pool_key, by_key = _stone_keys(slot_c)
            except Exception:
                rounds_key = f"{slot_c}.ss_rounds"
                pool_key   = f"{slot_c}.ss_pool"
                by_key     = f"{slot_c}.ss_by"


            bcfg.set(chan_id, rounds_key, str(int(rounds)))
            bcfg.set(chan_id, pool_key,   str(int(thp)))
            bcfg.set(chan_id, by_key,     caster_name)


            for alias in (f"{slot_c}.sspool", f"{slot_c}.ssbuf", f"{slot_c}.stoneskin", f"{slot_c}.ss"):
                try: bcfg.set(chan_id, alias, str(int(thp)))
                except Exception: pass


            try: bcfg.set(chan_id, f"{slot_c}.disp", caster_name)
            except Exception: pass

            _save_battles(bcfg)
            lines.append(f"Gain: **{thp} temporary HP** (Stoneskin-style buffer). Duration: **1 hour**. Tracker tag: **[SS {thp}]**")


            try:
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass
        else:
            if thp > 0:
                lines.append(f"Gain: **{thp} temporary HP** (no active initiative; buffer applied without tracker tag).")


        if new_hp <= 0 and _is_monster_file(tgt_path):
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key): bcfg.remove_option(chan_id, key)
                        slot = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                            opt = f"{slot}{suf}"
                            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
            except Exception:
                pass
            try:
                os.remove(os.path.abspath(tgt_path))
            except Exception:
                pass

        return "\n".join(lines) + extra_note

    def _defender_ac_with_buffs(self, bcfg, chan_id: str, tgt_name: str, *, want_oil: bool, atk_type: str):
        """
        Return (ac, shield_bonus, ac_defense_applied, blind_def_pen, magearmor_bonus, boneskin_bonus)
        - Shield: treat OIL as missile (+6) per your rule; otherwise +6 vs missiles, +3 vs melee/thrown.
        - Mage Armor: +4 vs projectiles; +2 vs melee/thrown. Treat OIL as thrown here (so +2).
        - Boneskin: +4 always.
        - Blind on defender: âˆ’4 AC.
        - Defend/Parry: add both.
        """

        t_cfg = read_cfg(_resolve_char_ci(tgt_name)[1])
        try:
            ac = int(self._gc(t_cfg, "ac") or 11)
        except Exception:
            ac = 11


        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")


        acbuf = bcfg.getint(chan_id, f"{slot}.acbuf", fallback=0)
        parry = bcfg.getint(chan_id, f"{slot}.parry", fallback=0)
        ac_def = acbuf + parry
        ac += ac_def


        blind_def_pen = 0
        if bcfg.getint(chan_id, f"{slot}.blind", fallback=0) > 0:
            ac -= 4
            blind_def_pen = 4


        try:
            if bcfg.getint(chan_id, f"{slot}.sick", fallback=0) > 0:
                ac -= 2
        except Exception:
            pass


        shield_bonus = 0
        sh_left = bcfg.getint(chan_id, f"{slot}.shield", fallback=0)
        if sh_left > 0:
            is_missileish = (atk_type in {"missile","ranged","bow","xbow","projectile","sling","thrown"})
            if want_oil:
                shield_bonus = 6
            else:
                shield_bonus = 6 if is_missileish and atk_type not in {"melee"} else 3
            ac += shield_bonus


        ma_bonus = 0
        bs_bonus = 0
        ma_left = bcfg.getint(chan_id, f"{slot}.magearmor", fallback=0)
        bs_left = bcfg.getint(chan_id, f"{slot}.boneskin",  fallback=0)
        if ma_left > 0:
            is_projectile = atk_type in {"missile","ranged","bow","xbow","projectile","sling"}
            is_thrown     = want_oil or atk_type in {"thrown"}

            ma_bonus = 4 if is_projectile else 2 if (is_thrown or atk_type in {"melee",""}) else 2
            ac += ma_bonus
        if bs_left > 0:
            bs_bonus = 4
            ac += bs_bonus


        try:
            enh_left = max(
                bcfg.getint(chan_id, f"{slot}.enharmor",       fallback=0),
                bcfg.getint(chan_id, f"{slot}.x_enhancearmor", fallback=0),
            )
            weak_left = max(
                bcfg.getint(chan_id, f"{slot}.weakarmor",      fallback=0),
                bcfg.getint(chan_id, f"{slot}.x_weakenarmor",  fallback=0),
            )
            if enh_left > 0:
                enh_mag = max(1, bcfg.getint(chan_id, f"{slot}.enharmor_bonus", fallback=1))
                ac += enh_mag
            if weak_left > 0:
                ac -= 1
        except Exception:
            pass

        return ac, shield_bonus, ac_def, blind_def_pen, ma_bonus, bs_bonus



    async def _effect_blacktentacles(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets) -> str:
        """
        Black Tentacles (Necromancer 4)
        Range: 100 ft + 10/level â€¢ Duration: 1 rd/level
        â€¢ Spawns an area of writhing tentacles. For each named creature, make a grapple attack:
          to-hit = (caster AB at level) + STR 18 (+3) vs target AC (melee, includes Shield/MA/Boneskin, etc.).
        â€¢ On HIT: target is **HELD** and gains a per-round constrict tick: 1d6 damage at the **start of its turn**
          while held (shown as [BT N]). No immediate damage on the initial grab.
        â€¢ Creatures not held can move through the area at **half speed** (informational; not enforced by the bot).
        Usage: !cast blacktentacles go1 go2 go3
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return "âŒ **Black Tentacles**: no initiative running here. Use `!init` first."


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in targets.split()]
        if not toks:
            return ("ðŸ™ **Black Tentacles** â€” wrestles each listed target; on hit, holds and constricts for **1d6** each round "
                    "while held (duration **1 round/level**). Add targets, e.g., `!cast blacktentacles goblin orc`.")


        char_class = (get_compat(caster_cfg, "info", "class", fallback="Fighter") or "Fighter").strip()
        ab_list = self.classes.get(char_class.lower(), {}).get("ab", [])
        cl = max(1, int(caster_level or 1))
        ab = ab_list[min(cl - 1, len(ab_list) - 1)] if ab_list else 0
        str_mod = 3


        rounds_on_victim = max(1, int(caster_level or 1))

        out_lines = [f"ðŸ™ **Black Tentacles** â€” caster AB **{ab:+}**, tentacles STR **18** ({str_mod:+}); "
                     f"Duration: **{rounds_on_victim} round{'s' if rounds_on_victim!=1 else ''}**."]


        resolved = []
        for raw in toks:
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = raw, None
            resolved.append((raw, disp, path))


        any_changed = False
        for raw, pretty, path in resolved:
            name_show = pretty or raw

            if not path or not os.path.exists(path):
                out_lines.append(f"{name_show}: *(not found)*")
                continue


            try:
                ac, sh, acdef, blind_pen, ma_bonus, bs_bonus =\
                    self._defender_ac_with_buffs(bcfg, chan_id, name_show, want_oil=False, atk_type="melee")
            except Exception:
                t_cfg_fallback = read_cfg(path)
                ac = getint_compat(t_cfg_fallback, "stats", "ac", fallback=11)


            d20 = random.randint(1, 20)
            total = d20 + ab + str_mod
            hit = (d20 == 20) or (total >= ac and d20 != 1)


            try:
                if hit:
                    consumed, left = self._mi_consume_if_present(ctx, name_show)
                    if consumed:
                        out_lines.append(
                            f"{name_show}: d20 **{d20}** AB {ab:+} STR {str_mod:+} = **{total}** â†’ âœ… **HIT**, "
                            f"but a **Mirror Image** is grabbed and destroyed (images left: **{left}**)."
                            f"\nâ†’ No effect on the real target."
                        )
                        continue
            except Exception:
                pass

            line = (f"{name_show}: d20 **{d20}** AB {ab:+} STR {str_mod:+} = **{total}** â†’ " +
                    ("âœ… **GRAB!**" if hit else "âŒ **MISS**"))
            out_lines.append(line)

            if not hit:
                continue


            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                def_key = _find_ci_name(names, name_show) or name_show
                try:
                    s_def = _slot(def_key)
                except Exception:
                    s_def = def_key.replace(" ", "_")


                bcfg.set(chan_id, f"{s_def}.heldby", f"{caster_name} (Tentacles)")


                bcfg.set(chan_id, f"{s_def}.x_tentacles",        str(rounds_on_victim))
                bcfg.set(chan_id, f"{s_def}.x_tentacles_dmg",    "1d6")
                bcfg.set(chan_id, f"{s_def}.x_tentacles_label",  "Black Tentacles")
                bcfg.set(chan_id, f"{s_def}.x_tentacles_emoji",  "ðŸ™")
                bcfg.set(chan_id, f"{s_def}.x_tentacles_code",   "BT")
                bcfg.set(chan_id, f"{s_def}.x_tentacles_by",     caster_name)


                bcfg.set(chan_id, f"{s_def}.disp", def_key)

                any_changed = True

                out_lines.append(f"â†’ **HELD**. Will take **1d6** constriction damage each turn while held. "
                                 f"Tracker tag: **[BT {rounds_on_victim}]**")
            except Exception as e:
                out_lines.append(f"â†’ âš ï¸ could not set hold/timer: {type(e).__name__}: {e}")


        if any_changed:
            try:
                _save_battles(bcfg)
            except Exception:
                pass
            try:
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

            out_lines.append("_Creatures not held may move through the area at **half speed**._")

        return "\n".join(out_lines)

    async def _effect_causedisease(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets):
        """
        Cause Disease (reverse of Cure Disease)
        Touch; no save on hit. Target becomes **Sickened** for 1d10 days:
          â€¢ âˆ’2 to attack rolls, AC, and saving throws
          â€¢ No natural healing / CON recovery; cannot prepare spells; cannot run
          â€¢ End of any day with exertion â†’ Save vs Spells or take 1d6 damage
        Tracker tag: [SI <rounds>] on the target (rounds = days Ã— 8640)
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in targets.split()]
        if not toks:
            return "ðŸ§ª **Cause Disease** â€” touch a target to inflict **Sickened** for 1d10 days (no save). Usage: `!cast causedisease <target>`"

        tgt_raw = toks[0]
        extras = [t for t in toks[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_raw)
        except Exception:
            tgt_disp, tgt_path = tgt_raw, None
        if not tgt_path or not os.path.exists(tgt_path):
            return f"ðŸ§ª **Cause Disease**\n{tgt_raw}: *(not found)*{extra_note}"


        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        if not (bcfg and bcfg.has_section(chan_id)):
            return "âŒ **Cause Disease**: no initiative running here. Use `!init` first."


        try:
            ac, sh, acdef, blind_pen, ma_bonus, bs_bonus =\
                self._defender_ac_with_buffs(bcfg, chan_id, tgt_disp, want_oil=False, atk_type="melee")
        except Exception:
            t_cfg_fb = read_cfg(tgt_path)
            ac = getint_compat(t_cfg_fb, "stats", "ac", fallback=11)


        char_class = (get_compat(caster_cfg, "info", "class", fallback="Fighter") or "Fighter").strip()
        ab_list = self.classes.get(char_class.lower(), {}).get("ab", [])
        level = max(1, int(caster_level or 1))
        ab = ab_list[min(level - 1, len(ab_list) - 1)] if ab_list else 0
        STR = getint_compat(caster_cfg, "stats", "str", fallback=10)
        try:
            str_mod = osr_mod(STR)
        except Exception:
            str_mod = 0

        d20 = random.randint(1, 20)
        total = d20 + ab + str_mod
        hit = (d20 == 20) or (total >= ac and d20 != 1)


        if hit:
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
                if consumed:
                    return ("ðŸ§ª **Cause Disease**\n"
                            f"{tgt_disp}: d20 **{d20}** + AB {ab:+} + STR {str_mod:+} = **{total}** â†’ âœ… **HIT**, "
                            f"but a **Mirror Image** is touched and destroyed (images left: **{left}**).\n"
                            "â†’ No effect on the real target." + extra_note)
            except Exception:
                pass

        lines = [ "ðŸ§ª **Cause Disease**",
                  f"{tgt_disp}: d20 **{d20}** + AB {ab:+} + STR {str_mod:+} = **{total}** â†’ "
                  + ("âœ… **HIT**" if hit else "âŒ **MISS**") ]

        if not hit:
            return "\n".join(lines) + extra_note


        days = random.randint(1, 10)
        DAY_TURNS = 144
        try:
            rounds_per_turn = TURN_ROUNDS
        except Exception:
            rounds_per_turn = 60
        DAY_ROUNDS = DAY_TURNS * rounds_per_turn
        total_rounds = days * DAY_ROUNDS


        tgt_cfg = read_cfg(tgt_path)
        if not tgt_cfg.has_section("cur"):
            tgt_cfg.add_section("cur")
        tgt_cfg["cur"]["sick_days"]  = str(days)
        tgt_cfg["cur"]["sick_turns"] = str(DAY_TURNS)
        tgt_cfg["cur"]["sick_exert"] = "0"

        tgt_cfg["cur"]["sick_block_heal"]   = "1"
        tgt_cfg["cur"]["sick_block_prep"]   = "1"
        tgt_cfg["cur"]["sick_block_run"]    = "1"
        write_cfg(tgt_path, tgt_cfg)


        try:
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")


            bcfg.set(chan_id, f"{slot}.sick", "1")
            bcfg.set(chan_id, f"{slot}.sick_pen", "-2")


            bcfg.set(chan_id, f"{slot}.x_sick",         str(total_rounds))
            bcfg.set(chan_id, f"{slot}.x_sick_code",    "SI")
            bcfg.set(chan_id, f"{slot}.x_sick_label",   "Sickened (Disease)")
            bcfg.set(chan_id, f"{slot}.x_sick_emoji",   "ðŸ¤¢")
            bcfg.set(chan_id, f"{slot}.x_sick_by",      caster_name)


            bcfg.set(chan_id, f"{slot}.disp", key)

            _save_battles(bcfg)


            try:
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass
        except Exception:
            pass

        lines.append(f"â†’ **Sickened** for **{days} day{'s' if days!=1 else ''}** "
                     f"(âˆ’2 attack, AC, saves; no natural healing/CON recovery; no spell prep; no running).\n"
                     f"End of any **exerting** day: Save vs **Spells** or take **1d6** damage.\n"
                     f"Tracker tag: **[SI {total_rounds}]** on **{tgt_disp}**.")
        return "\n".join(lines) + extra_note

    async def _effect_curedisease(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets):
        """
        Cure Disease
        Cures all diseases and kills parasites (includes existing DIS and maggots; new Sickened; and **Mummy Rot**).
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in targets.split()]
        tgt_raw = toks[0] if toks else caster_name

        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_raw)
        except Exception:
            tgt_disp, tgt_path = tgt_raw, None
        if not tgt_path or not os.path.exists(tgt_path):
            return f"âœ¨ **Cure Disease**\n{tgt_raw}: *(not found)*"


        chan_id = str(ctx.channel.id)
        try: bcfg = _load_battles()
        except Exception: bcfg = None

        cfg = read_cfg(tgt_path)
        if not cfg.has_section("cur"): cfg.add_section("cur")

        cfg["cur"]["disease"] = "0"

        for k in ("sick_days","sick_turns","sick_exert","sick_block_heal","sick_block_prep","sick_block_run"):
            if cfg.has_option("cur", k): cfg.remove_option("cur", k)


        had_mrot = getint_compat(cfg, "cur", "mummyrot", fallback=0) > 0
        for k in ("mummyrot", "mrot_block_heal", "mrot_days"):
            if cfg.has_option("cur", k):
                cfg.remove_option("cur", k)
        write_cfg(tgt_path, cfg)



        try:
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_disp) or tgt_disp
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")


                for suf in (".sick",".sick_pen",
                            ".x_sick",".x_sick_code",".x_sick_label",".x_sick_emoji",".x_sick_by",
                            ".maggots",".maggots_die",
                            ".x_maggots",".x_maggots_dmg",".x_maggots_label",".x_maggots_emoji",".x_maggots_code",".x_maggots_by",

                            ".mrot",".mrot_block_heal",
                            ".x_mrot",".x_mrot_n",".x_mrot_code",".x_mrot_label",".x_mrot_emoji",".x_mrot_by"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)


                self._tracker_remove_tag(bcfg, chan_id, slot, "DIS")
                self._tracker_remove_tag(bcfg, chan_id, slot, "MROT")

                _save_battles(bcfg)

                try:
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass
        except Exception:
            pass


        mrot_note = "\nThey may **regain hit points** again (mummy rot lifted)." if had_mrot else ""

        return (f"âœ¨ **Cure Disease**\n**{tgt_disp}** is cleansed of all diseases and parasites."
                f"{mrot_note}"
                "\n_(GM may rule special/magical diseases require a higher-level caster.)_")

    async def _effect_enervation(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets) -> str:
        """
        Enervation (Necromancer 4)
          â€¢ Ranged *touch* attack: d20 + AB + DEX vs touch AC (ignore armor/shield; Dex applies).
          â€¢ On hit vs living: target suffers 1d4 negative levels (Energy Drain). No save.
          â€¢ On hit vs undead: target gains 5d4 temporary HP for 1 hour (Stoneskin-style buffer).
          â€¢ If the living target survives: NLs fade after hours equal to caster level (GM can !restore).
          â€¢ Range: 50 ft (not enforced here).
        Usage:
          !cast enervation <target>
        """

        
        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in targets.split()]
        if not toks:
            return ("â˜ ï¸ **Enervation** â€” ranged touch ray; on hit: 1d4 negative levels (living) or 5d4 temp HP (undead).\n"
                    "_Add a target: `!cast enervation goblin`_")
        tgt_raw = toks[0]
        extras = [t for t in toks[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_raw)
        except Exception:
            tgt_disp, tgt_path = tgt_raw, None
        if not tgt_path or not os.path.exists(tgt_path):
            return f"â˜ ï¸ **Enervation**\n{tgt_raw}: *(not found)*{extra_note}"

        
        def _is_undead(cfg) -> bool:
            try:
                race = (get_compat(cfg, "info", "race", fallback="") or "").lower()
                typ  = (get_compat(cfg, "info", "type", fallback="") or "").lower()
                return ("undead" in race) or ("undead" in typ)
            except Exception:
                return False

        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        
        target_ac = 10
        if bcfg and bcfg.has_section(chan_id):
            try:
                try:
                    target_ac, *rest = self._defender_ac_with_buffs(
                        bcfg, chan_id, tgt_disp, want_oil=False, atk_type="ranged_touch"
                    )
                except Exception:
                    target_ac, *rest = self._defender_ac_with_buffs(
                        bcfg, chan_id, tgt_disp, want_oil=False, atk_type="touch"
                    )
            except Exception:
                t_cfg_raw = read_cfg(tgt_path)
                DEX_t = getint_compat(t_cfg_raw, "stats", "dex", fallback=10)
                try: dex_mod_t = osr_mod(DEX_t)
                except Exception: dex_mod_t = 0
                target_ac = 10 + max(-10, dex_mod_t)
        else:
            t_cfg_raw = read_cfg(tgt_path)
            DEX_t = getint_compat(t_cfg_raw, "stats", "dex", fallback=10)
            try: dex_mod_t = osr_mod(DEX_t)
            except Exception: dex_mod_t = 0
            target_ac = 10 + max(-10, dex_mod_t)

        
        DEX = getint_compat(caster_cfg, "stats", "dex", fallback=10)
        try: dex_mod = osr_mod(DEX)
        except Exception: dex_mod = 0

        char_class = (get_compat(caster_cfg, "info", "class", fallback="Fighter") or "Fighter").strip()
        ab_list = self.classes.get(char_class.lower(), {}).get("ab", [])
        cl = max(1, int(caster_level))
        ab = ab_list[min(cl - 1, len(ab_list) - 1)] if ab_list else 0

        d20 = random.randint(1, 20)
        nat20 = (d20 == 20)
        nat1  = (d20 == 1)
        total_to_hit = d20 + ab + dex_mod
        hit = nat20 or (not nat1 and total_to_hit >= target_ac)

        t_cfg = read_cfg(tgt_path)
        undead = _is_undead(t_cfg)

        lines = [f"â˜ ï¸ **Enervation**"]
        lines.append(f"Attack: **{d20}** + AB {ab:+} + DEX {dex_mod:+} = **{total_to_hit}** â†’ "
                     + ("âœ… **HIT**" if hit else "âŒ **MISS**"))

        
        if hit and bcfg and bcfg.has_section(chan_id):
            try:
                consumed, left = self._mi_consume_if_present(ctx, tgt_disp)
                if consumed:
                    lines.append(f"Mirror Image: a figment is struck and shatters (images left: **{left}**).")
                    lines.append("No effect to the real target.")
                    return "\n".join(lines) + extra_note
            except Exception:
                pass

        if not hit:
            return "\n".join(lines) + extra_note

        
        if undead:
            s, rolls, flat = roll_dice("5d4")
            thp = max(0, s + flat)
            rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
            lines.append(f"Undead target: gains **{thp}** temporary HP (5d4 {rolls_txt}). Duration: **1 hour**.")
            if bcfg and bcfg.has_section(chan_id):
                try:
                    slot_t = _slot(tgt_disp)
                except Exception:
                    slot_t = str(tgt_disp).replace(" ", "_")
                try:
                    rounds = 6 * TURN_ROUNDS
                except Exception:
                    rounds = 6 * 60
                try:
                    rounds_key, pool_key, by_key = _stone_keys(slot_t)
                except Exception:
                    rounds_key = f"{slot_t}.ss_rounds"; pool_key = f"{slot_t}.ss_pool"; by_key = f"{slot_t}.ss_by"
                bcfg.set(chan_id, rounds_key, str(int(rounds)))
                bcfg.set(chan_id, pool_key,   str(int(thp)))
                bcfg.set(chan_id, by_key,     caster_name)
                for alias in (f"{slot_t}.sspool", f"{slot_t}.ssbuf", f"{slot_t}.stoneskin", f"{slot_t}.ss"):
                    try: bcfg.set(chan_id, alias, str(int(thp)))
                    except Exception: pass
                try: bcfg.set(chan_id, f"{slot_t}.disp", tgt_disp)
                except Exception: pass
                _save_battles(bcfg)
                lines.append(f"Tracker tag: **[SS {thp}]** (on {tgt_disp}).")
                try:
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass
            else:
                lines.append("*(No active initiative; buffer applied without tracker tag.)*")
            return "\n".join(lines) + extra_note

        
        s, rolls, flat = roll_dice("1d4")
        nl = max(1, s + flat)
        rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        lines.append(f"Living target: rolled **{nl}** negative level{'s' if nl!=1 else ''} (1d4 {rolls_txt}). No save.")

        
        try:
            drain_host = (
                self.bot.get_cog("Combat") or
                self.bot.get_cog("Attacks") or
                self
            )
            state = await drain_host._auto_apply_negative_levels(
                ctx,
                tgt_disp, t_cfg, tgt_path,
                n_levels=nl,
                source="Enervation (ray)",
                embed=None
            )

            
            t_cfg_after = read_cfg(tgt_path)

            applied = int(state.get("n_levels_added") or 0)
            absorbed = max(0, nl - applied)

            
            if absorbed > 0:
                disintegrated = False
                cur_txt = mx_txt = ""
                try:
                    found = None
                    try:
                        found = _pfed_find_equipped_in_cfg(t_cfg_after)
                    except Exception:
                        found = None

                    if found and t_cfg_after.has_section("pfed"):
                        _slot_pf, _disp_pf, core_pf = found
                        cur_txt = (t_cfg_after.get("pfed", _pfed_key(core_pf, "cur"), fallback="") or "").strip()
                        mx_txt  = (t_cfg_after.get("pfed", _pfed_key(core_pf, "max"), fallback="") or "").strip()
                    else:
                        
                        pairs = {}
                        if t_cfg_after.has_section("pfed"):
                            for opt, val in list(t_cfg_after.items("pfed")):
                                m = re.match(r"^pfed_(.+)_(cur|max)$", opt.strip().lower())
                                if not m:
                                    continue
                                core, kind = m.group(1), m.group(2)
                                try:
                                    v = int(str(val).strip())
                                except Exception:
                                    v = None
                                pairs.setdefault(core, {})[kind] = v
                        disintegrated = any(
                            (d.get("cur") == 0 and d.get("max") == 0)
                            for d in pairs.values()
                        )

                    if cur_txt or mx_txt:
                        line = f"ðŸ›¡ï¸ **Protection from Energy Drain** absorbs **{absorbed}** NL â†’ charges **{cur_txt or '?'} / {mx_txt or '?'}**."
                    else:
                        line = f"ðŸ›¡ï¸ **Protection from Energy Drain** absorbs **{absorbed}** NL."

                    if disintegrated or (cur_txt == '0' and (mx_txt == '0' or mx_txt != "")):
                        line += " âœ¨ *(device disintegrates)*"

                    lines.append(line)
                except Exception:
                    lines.append(f"ðŸ›¡ï¸ **Protection from Energy Drain** absorbs **{absorbed}** NL.")

                
            if applied <= 0:
                return "\n".join(lines) + extra_note

            
            locks_applied = state.get("locks_applied", {})
            if isinstance(locks_applied, dict) and locks_applied:
                piece = ", ".join(f"L{L}:{n}" for L, n in sorted(locks_applied.items(), reverse=True))
                lines.append(f"Slots locked now: {piece}. L0 unaffected.")

            hp_loss = state.get("hp_loss")
            if isinstance(hp_loss, int):
                if _is_monster_file(tgt_path):
                    lines.append(f"Max HP cap reduced by **{hp_loss}**.")
                else:
                    hp_after = state.get("hp_after")
                    if hp_after is not None:
                        lines.append(f"HP after drain: **{hp_after}**. (Cap âˆ’{hp_loss})")

            hp_after = state.get("hp_after")
            is_dead = isinstance(hp_after, int) and hp_after <= 0
            if is_dead:
                lines.append("â˜ ï¸ **SLAIN BY ENERGY DRAIN**")
                try:
                    if _is_monster_file(tgt_path) and bcfg and bcfg.has_section(chan_id):
                        names, scores = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, tgt_disp) or tgt_disp
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names, scores)
                            if bcfg.get(chan_id, "turn", fallback="") == key:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                    try:
                        if _is_monster_file(tgt_path):
                            os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass
                except Exception:
                    pass
                return "\n".join(lines) + extra_note

            
            hours = max(1, int(caster_level))
            lines.append(f"Fades after **{hours} hour{'s' if hours!=1 else ''}** (then remove with `!restore {tgt_disp} {applied}`).")

            if bcfg and bcfg.has_section(chan_id):
                try:
                    try:
                        rounds = hours * 6 * TURN_ROUNDS
                    except Exception:
                        rounds = hours * 6 * 60
                    try:
                        slot_t = _resolve_effect_slot(bcfg, chan_id, tgt_disp)
                    except Exception:
                        try:
                            slot_t = _slot(tgt_disp)
                        except Exception:
                            slot_t = str(tgt_disp).replace(" ", "_")
                    base_key = "x_enervfade"
                    bcfg.set(chan_id, f"{slot_t}.{base_key}",          str(int(rounds)))
                    bcfg.set(chan_id, f"{slot_t}.{base_key}_code",     "EN")
                    bcfg.set(chan_id, f"{slot_t}.{base_key}_label",    "Enervation: NL fade")
                    bcfg.set(chan_id, f"{slot_t}.{base_key}_emoji",    "ðŸ•¯ï¸")
                    bcfg.set(chan_id, f"{slot_t}.{base_key}_by",       caster_name)
                    _save_battles(bcfg)
                    lines.append(f"Tracker timer: **[EN {int(rounds)}]** on **{tgt_disp}**.")
                    try:
                        ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                        if ini and hasattr(ini, "_update_tracker_message"):
                            await ini._update_tracker_message(ctx, bcfg, chan_id)
                    except Exception:
                        pass
                except Exception:
                    pass

        except Exception as e:
            
            lines.append(f"âš ï¸ Couldnâ€™t auto-apply NLs ({type(e).__name__}). GM may run `!drain {tgt_disp} {nl}`.")

        return "\n".join(lines) + extra_note



    async def _cast_mummify(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Mummify / Summon Mummy (custom)
          â€¢ Spawns N **Mummy** minions (persistent).
          â€¢ Join initiative immediately; controlled by the caster.
          â€¢ Usage: !cast mummify mu3   (or)  !cast mummify 3   (or)  !cast mummify mummy 3
        """

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        n = 1
        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        for t in toks:
            m = re.match(r"mu(\d+)$", t)
            if m:
                n = max(1, int(m.group(1))); break
            if t.isdigit():
                n = max(1, int(t)); break


        def _tpl(kind: str):
            return (_load_monster_template(kind)
                    or _load_monster_template(kind + ".ini")
                    or None)

        tpl = _tpl("mummy")
        if not tpl:
            return [f"âŒ Monster template not found for **mummy** (e.g., `mummy.ini`)."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        def _spawn_mummies(tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 5))
            hpmod  = int(tpl.get("hpmod", 0))
            move   = int(tpl.get("move", 60))
            saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
            mtype  = str(tpl.get("type", "")).strip()


            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", max(1, hd)
            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


            attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
            atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
            attack_list = [a for a in re.split(r"[,\s]+", attacknames_raw) if a] if attacknames_raw else atk_pref_list

            prefix = "MU"
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            made = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)


                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": "mummy", "battle_chan": chan_id,
                    "controller": caster_name,
                    "summoned": "mummify",
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd)}
                stats = {
                    "ac": str(ac), "move": str(move), "type": mtype,
                    "immune": str(tpl.get("immune",  "")).strip(),
                    "resist": str(tpl.get("resist",  "")).strip(),
                    "weak":   str(tpl.get("weak",    "")).strip(),
                    "reduce1":str(tpl.get("reduce1", "")).strip(),
                }


                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None:
                                first_spec = spec
                    stats["damage"] = first_spec or str(tpl.get("damage", "1d6"))
                else:
                    stats["damage"] = str(tpl.get("damage", "1d6"))

                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)


                try:
                    s_el = _slot(mon)
                except Exception:
                    s_el = mon.replace(" ", "_")


                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s_el}."):
                        bcfg.remove_option(chan_id, opt_key)
                if bcfg.has_option(chan_id, mon):
                    bcfg.remove_option(chan_id, mon)

                bcfg.set(chan_id, f"{s_el}.disp", mon)
                bcfg.set(chan_id, f"{s_el}.hostile", "0")
                bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
                bcfg.set(chan_id, f"{s_el}.minion_type", "mummy")

                _save_battles(bcfg)

                made.append((mon, d6, hp, hd, s_el))
            return made

        created = _spawn_mummies(tpl, n)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        if not created:
            return [f"âš ï¸ Mummify: nothing created."]

        names = [n for (n, *_rest) in created]
        return [
            f"ðŸ§» **{caster_name}** summons **{n} Mumm{'y' if n==1 else 'ies'}**.",
            f"â€¢ Joined initiative: {', '.join(names)}",
            "â€¢ Persistent minions (no duration). Use your dismissal/cleanup tools when done.",
        ]

    def _effect_symbolofpain(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Symbol of Pain â€” Necromancer 5
        Creates a dormant rune (permanent until triggered). When triggered, the symbol is active for
        1 turn/level (60 rounds per level). Creatures within 60' suffer PAIN (âˆ’4 to hit, damage, saves)
        while within range and for 1 hour (600 rounds) after leaving.
        Use `!a symbolofpain ...` to affect creatures that enter the area while the symbol is active.
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        turns = max(1, int(caster_level))
        active_rounds = turns * 60

        lines = ["ðŸª¡ **Symbol of Pain** is inscribed."]

        if bcfg and bcfg.has_section(chan_id):

            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


            for k in (f"{s_me}.sop_ready", f"{s_me}.sop", f"{s_me}.sop_level",
                      f"{s_me}.sop_by"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)


            bcfg.set(chan_id, f"{s_me}.sop_ready", "1")
            bcfg.set(chan_id, f"{s_me}.sop_level", str(int(caster_level)))
            bcfg.set(chan_id, f"{s_me}.sop_by",    caster_name)
            _save_battles(bcfg)

            lines.append(
                f"Rune is **dormant** (permanent) until triggered; upon trigger it remains **active for {turns} turn(s)**."
                " *(Use `!a symbolofpain ...` while itâ€™s active â€” even out of turn.)*"
            )


            bcfg.set(chan_id, f"{s_me}.sop", str(active_rounds))


            bcfg.set(chan_id, f"{s_me}.x_sp_code",  "SP")
            bcfg.set(chan_id, f"{s_me}.x_sp_label", "Symbol of Pain")
            bcfg.set(chan_id, f"{s_me}.x_sp_emoji", "ðŸª¡")
            bcfg.set(chan_id, f"{s_me}.x_sp_n",     str(active_rounds))

            _save_battles(bcfg)


            if tokens:

                bcfg.set(chan_id, f"{s_me}.sop", str(active_rounds))
                _save_battles(bcfg)
                lines.append(f"**Triggered now** â€” duration: **{active_rounds} rounds**.")
                lines.extend(self._apply_symbolofpain_to_targets(chan_id, bcfg, caster_name, caster_level, tokens))
        else:
            lines.append(f"(No active battle found; rune would be **dormant** and upon first trigger last **{active_rounds} rounds**.)")


            if tokens:
                lines.append("â€¢ Applying PAIN (offline mode):")
                for raw in tokens:
                    tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
                    lines.append(f"  â€¢ **{tgt_disp or raw}**: ðŸ˜– PAIN (âˆ’4 to hit/dmg/saves) â€” tail 1 hour after leaving")

        return lines

    def _apply_symbolofpain_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """Apply the PAIN status to targets: âˆ’4 to hit, âˆ’4 damage, âˆ’4 saves, with a 1-hour (600 rounds) tail."""
        lines = []
        tail_rounds = 600

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue


            try:
                t_cfg = read_cfg(tgt_path)
                if _is_undead_cfg(t_cfg, tgt_disp):
                    lines.append(f"â€¢ **{tgt_disp}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass

            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key   = _find_ci_name(names, tgt_disp) or tgt_disp
                s_tgt = self._effect_slot_for(bcfg, chan_id, key)


                bcfg.set(chan_id, f"{s_tgt}.pain_pen",     "-4")
                bcfg.set(chan_id, f"{s_tgt}.pain_dmg_pen", "-4")
                bcfg.set(chan_id, f"{s_tgt}.pain_sv_pen",  "-4")







                cur_tail = bcfg.getint(chan_id, f"{s_tgt}.x_pain_n", fallback=0)
                bcfg.set(chan_id, f"{s_tgt}.x_pain_n", str(max(cur_tail, tail_rounds)))
                bcfg.set(chan_id, f"{s_tgt}.x_pain_by", caster_name)

                _save_battles(bcfg)

                lines.append(f"â€¢ **{tgt_disp}**: ðŸ˜– **PAIN** â€” **âˆ’4** to hit, damage, and saving throws. Tail: **1 hour** after leaving.")
            except Exception:
                lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ error applying effect (GM adjudicates).")

        return lines

    def _effect_symboloffear(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Symbol of Fear â€” Necromancer 6
        Creates a dormant rune (permanent until triggered). When triggered, the symbol is active for
        1 turn/level (60 rounds per level). Each creature within 60' must Save vs Spells or become
        PANICKED for 1 round/level (drops held, flees, cowers if cornered). Panicked creatures suffer
        â€“2 to saving throws while it lasts. On a successful save, the victim is SHAKEN 1 round (â€“2 atk & saves).
        Use `!a symboloffear ...` to affect creatures that enter the area while the symbol is active.
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        turns = max(1, int(caster_level))
        active_rounds = turns * 60

        lines = ["ðŸ˜± **Symbol of Fear** is inscribed."]

        if bcfg and bcfg.has_section(chan_id):

            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


            for k in (f"{s_me}.sof_ready", f"{s_me}.sof", f"{s_me}.sof_level", f"{s_me}.sof_by",
                      f"{s_me}.x_sf_code", f"{s_me}.x_sf_label", f"{s_me}.x_sf_emoji", f"{s_me}.x_sf_n"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)


            bcfg.set(chan_id, f"{s_me}.sof_ready", "1")
            bcfg.set(chan_id, f"{s_me}.sof_level", str(int(caster_level)))
            bcfg.set(chan_id, f"{s_me}.sof_by",    caster_name)
            _save_battles(bcfg)

            lines.append(
                f"Rune is **dormant** (permanent) until triggered; upon trigger it remains **active for {turns} turn(s)**."
                " *(Use `!a symboloffear ...` while itâ€™s active â€” even out of turn.)*"
            )


            if tokens:
                bcfg.set(chan_id, f"{s_me}.sof", str(active_rounds))

                bcfg.set(chan_id, f"{s_me}.x_sf_code",  "SF")
                bcfg.set(chan_id, f"{s_me}.x_sf_label", "Symbol of Fear")
                bcfg.set(chan_id, f"{s_me}.x_sf_emoji", "ðŸ˜±")
                bcfg.set(chan_id, f"{s_me}.x_sf_n",     str(active_rounds))
                _save_battles(bcfg)

                lines.append(f"**Triggered now** â€” duration: **{active_rounds} rounds**.")
                lines.extend(self._apply_symboloffear_to_targets(chan_id, bcfg, caster_name, caster_level, tokens))
        else:
            lines.append(f"(No active battle found; rune would be **dormant** and upon first trigger last **{active_rounds} rounds**.)")


            if tokens:
                rounds = max(1, int(caster_level))
                lines.append("â€¢ Applying FEAR (offline mode):")
                for raw in tokens:
                    tgt_disp, _ = self._resolve_char_ci_local(raw)
                    pretty = tgt_disp or raw
                    lines.append(f"  â€¢ **{pretty}**: ðŸ˜µ **PANICKED** for **{rounds} rounds** *(drops held; flees/cowers; âˆ’2 to saves while panicked)*")

        return lines

    def _apply_symboloffear_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Apply Symbol of Fear to targets:
          â€¢ Save vs Spells.
              - FAIL: Set fear timer for 1 round/level (FR). Note: âˆ’2 to all saves while panicked.
                      (Optionally add a PANIC x-tag.)
              - SUCCESS: SHAKEN for 1 round (â€“2 atk & saves) as a reminder x-tag.
        """
        lines = []
        rounds = max(1, int(caster_level or 1))

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)

            fear_mod = self._fear_save_mod_for_slot(bcfg, chan_id, s_tgt)
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=(-fear_mod))

            if sv_ok:

                slot = self._effect_slot_for(bcfg, chan_id, pretty)

                bcfg.set(chan_id, f"{slot}.x_shk_n",     "1")
                bcfg.set(chan_id, f"{slot}.x_shk_code",  "SHK")
                bcfg.set(chan_id, f"{slot}.x_shk_label", "Shaken")
                bcfg.set(chan_id, f"{slot}.x_shk_by",    caster_name)
                _save_battles(bcfg)

                lines.append(f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** â†’ **SHAKEN 1 round** *(â€“2 atk & saves)*")
                continue


            slot = self._effect_slot_for(bcfg, chan_id, pretty)


            bcfg.set(chan_id, f"{slot}.fear",     str(rounds))
            bcfg.set(chan_id, f"{slot}.fear_src", "symboloffear")
            bcfg.set(chan_id, f"{slot}.fear_by",  caster_name)


            bcfg.set(chan_id, f"{slot}.x_pnc_n",     str(rounds))
            bcfg.set(chan_id, f"{slot}.x_pnc_code",  "PNC")
            bcfg.set(chan_id, f"{slot}.x_pnc_label", "Panic")
            bcfg.set(chan_id, f"{slot}.x_pnc_by",    caster_name)

            _save_battles(bcfg)

            lines.append(
                f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ **FAIL** â†’ ðŸ˜µ **PANICKED** for **{rounds} rounds** â€” "
                f"drops held, flees (cowers if cornered). *While panicked: âˆ’2 to all saving throws.*"
            )

        return lines

    def _effect_symbolofdeath(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Symbol of Death â€” Necromancer 7
        Creates a dormant rune (permanent until triggered). When triggered, active for 1 turn/level (60 rounds per).
        Each creature within 60' must Save vs Spells or **die**. On success, they will not re-save unless they
        leave and re-enter while the symbol is still active. Use `!a symbolofdeath ...` while active to apply.
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        turns = max(1, int(caster_level))
        active_rounds = turns * 60
        lines = ["ðŸ’€ **Symbol of Death** is inscribed."]

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)

            
            for k in (f"{s_me}.sod_ready", f"{s_me}.sod", f"{s_me}.sod_level", f"{s_me}.sod_by",
                      f"{s_me}.x_sd_code", f"{s_me}.x_sd_label", f"{s_me}.x_sd_emoji", f"{s_me}.x_sd_n"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)

            bcfg.set(chan_id, f"{s_me}.sod_ready", "1")
            bcfg.set(chan_id, f"{s_me}.sod_level", str(int(caster_level)))
            bcfg.set(chan_id, f"{s_me}.sod_by",    caster_name)
            _save_battles(bcfg)

            lines.append(
                f"Rune is **dormant** (permanent) until triggered; upon trigger it remains **active for {turns} turn(s)**."
                " *(Use `!a symbolofdeath ...` while itâ€™s active â€” even out of turn.)*"
            )

            if tokens:
                bcfg.set(chan_id, f"{s_me}.sod", str(active_rounds))
                bcfg.set(chan_id, f"{s_me}.x_sd_code",  "SD")
                bcfg.set(chan_id, f"{s_me}.x_sd_label", "Symbol of Death")
                bcfg.set(chan_id, f"{s_me}.x_sd_emoji", "ðŸ’€")
                bcfg.set(chan_id, f"{s_me}.x_sd_n",     str(active_rounds))
                _save_battles(bcfg)

                lines.append(f"**Triggered now** â€” duration: **{active_rounds} rounds**.")
                lines.extend(self._apply_symbolofdeath_to_targets(chan_id, bcfg, caster_name, caster_level, tokens))
        else:
            lines.append(f"(No active battle found; rune would be **dormant** and upon first trigger last **{active_rounds} rounds**.)")
            if tokens:
                lines.append("â€¢ Applying DEATH (offline mode):")
                for raw in tokens:
                    tgt_disp, _ = self._resolve_char_ci_local(raw)
                    pretty = tgt_disp or raw
                    lines.append(f"  â€¢ **{pretty}**: Save vs **Spells** or **die**.")
        return lines

    def _apply_symbolofdeath_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]) -> list[str]:
        """
        Apply Symbol of Death to targets:
          â€¢ If already marked SDOK (prior success) while active â†’ skip re-save.
          â€¢ Else Save vs Spells or die.
          â€¢ On success (or PFED), stamp SDOK with countdown matching the symbolâ€™s remaining duration.
        """
        lines = []
        names, _ = _parse_combatants(bcfg, chan_id)

        me_key = _find_ci_name(names, caster_name) or caster_name
        s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
        sod_left = max(
            0,
            bcfg.getint(chan_id, f"{s_me}.sod",    fallback=0),
            bcfg.getint(chan_id, f"{s_me}.x_sd_n", fallback=0),
        )

        for raw in (tokens or []):
            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            
            try:
                t_cfg = read_cfg(tgt_path)
                if _is_undead_cfg(t_cfg, pretty):
                    lines.append(f"â€¢ **{pretty}**: â˜ ï¸ Undead â€” **no effect**.")
                    continue
            except Exception:
                pass

            try:
                s_tgt = self._effect_slot_for(bcfg, chan_id, pretty)
                if bcfg.getint(chan_id, f"{s_tgt}.x_sdok_n", fallback=0) > 0:
                    lines.append(f"â€¢ **{pretty}**: Already **resisted this symbol** â€” no further effect (until they leave & re-enter).")
                    continue
            except Exception:
                pass

            t_cfg = read_cfg(tgt_path)
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)

            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                sv_ok = False

            if sv_ok:
                
                s_tgt = self._effect_slot_for(bcfg, chan_id, pretty)
                if sod_left > 0:
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_n",     str(sod_left))
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_code",  "SDOK")
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_label", "Saved vs Symbol (Death)")
                    bcfg.set(chan_id, f"{s_tgt}.x_sdok_by",    caster_name)
                    _save_battles(bcfg)
                lines.append(f"â€¢ **{pretty}**: Save vs **Spells** {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** *(wonâ€™t save again unless they leave & re-enter)*")
                continue

            
            used, pfed_note = _pfed_try_absorb_sp(t_cfg, tgt_path, tag="death")
            if used:
                try:
                    s_tgt = self._effect_slot_for(bcfg, chan_id, pretty)
                    if sod_left > 0:
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_n",     str(sod_left))
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_code",  "SDOK")
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_label", "Saved vs Symbol (Death)")
                        bcfg.set(chan_id, f"{s_tgt}.x_sdok_by",    caster_name)
                        _save_battles(bcfg)
                except Exception:
                    pass
                lines.append(f"â€¢ **{pretty}**: {pfed_note} *(wonâ€™t save again unless they leave & re-enter)*")
                continue

            
            died_text = "â˜ ï¸ **DEAD!**"
            if old_hp is None:
                lines.append(f"â€¢ **{pretty}**: Save vs **Spells** â†’ **FAIL** â€” {died_text}")
            else:
                t_cfg.setdefault("cur", {})
                t_cfg["cur"]["hp"] = "0"
                write_cfg(tgt_path, t_cfg)

                try:
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
                    before = _life_bar(old_hp, mhp, width=10)
                    after  = _life_bar(0, mhp, width=10)
                    lines.append(f"â€¢ **{pretty}**: Save vs **Spells** {sv_roll} vs {sv_dc} â†’ **FAIL**\n{before} â†’ **{after}** {died_text}")
                except Exception:
                    lines.append(f"â€¢ **{pretty}**: Save vs **Spells** {sv_roll} vs {sv_dc} â†’ **FAIL**\nHP {old_hp} â†’ **0** {died_text}")

                
                try:
                    is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
                except Exception:
                    is_mon = False
                if is_mon and bcfg and bcfg.has_section(chan_id):
                    try:
                        names2, scores2 = _parse_combatants(bcfg, chan_id)
                        key2 = _find_ci_name(names2, pretty) or pretty
                        if key2 in names2:
                            names2 = [n for n in names2 if n != key2]
                            if bcfg.has_option(chan_id, key2):
                                bcfg.remove_option(chan_id, key2)
                            s2 = _slot(key2)
                            for suf in (
                                ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                ".paralyzed",".blind",".blind_src",".blind_by",
                                ".cc_blind_pending",".cs_blind_pending",
                                ".cc",".cc_by",".cc_level",
                                ".ck",".ck_by",".ck_level",
                                ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                            ):
                                opt = f"{s2}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                            _write_combatants(bcfg, chan_id, names2, scores2)
                            cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                            if cur_turn == key2:
                                ents = _sorted_entries(bcfg, chan_id)
                                bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                            _save_battles(bcfg)
                    except Exception:
                        pass
                    try:
                        os.remove(os.path.abspath(tgt_path))
                    except Exception:
                        pass

        return lines


    async def _cast_insectplague(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Insect Plague (300 ft + 30/level): summons 1 swarm/3 levels (max 6). Stationary. Duration 1 round/level.
        Usage:
          !cast insectplague
          !cast insectplague -n 4    (spawn fewer swarms if desired)
          !cast insectplague n3
        Notes:
          â€¢ Swarms are stationary (move=0).
          â€¢ Duration tracked with x_swarm (rounds left); auto-despawn at 0.
        """


        want = None
        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]
        for t in list(toks):
            m = re.fullmatch(r"(?:-n|n)(\d+)", t)
            if m:
                want = int(m.group(1))
                toks.remove(t)


        base_n = max(0, caster_level // 3)
        cap = min(6, base_n)
        if cap <= 0:
            return ["âŒ **Insect Plague**: caster level too low (need 3rd level+)."]

        if want is not None:
            if want <= 0:
                return ["âŒ **Insect Plague**: number of swarms must be â‰¥1."]
            if want > cap:
                return [f"âŒ **Insect Plague**: you can summon at most **{cap}** swarms right now."]
            count = want
        else:
            count = cap


        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel) if "_section_id" in globals() else str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!battle` first."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        tpl = _load_monster_template("insectswarm")
        if not tpl:
            return ["âŒ Missing monster template: need `/monsters/insectswarm.ini`."]


        def _spawn_swarms(n: int):
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)
            created = []

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 3))
            hpmod  = int(tpl.get("hpmod", 0))
            move   = 0
            saveas = str(tpl.get("saveas", "Fighter 1"))
            immune = str(tpl.get("immune", "")).strip()


            damage_default = str(tpl.get("damage", "1d3"))
            attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
            atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
            attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list


            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", hd

            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = "IN"
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}

            for _ in range(n):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)

                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": "insectswarm",
                    "battle_chan": chan_id,
                    "controller": caster_name,
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}

                stats = {"ac": str(ac), "ab": "", "move": str(move), "type": "",
                         "immune": immune, "resist": "", "reduce1": ""}


                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:

                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip() or "1d3"
                        stats[f"atk_{an}"] = spec
                        if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or damage_default
                else:
                    stats["damage"] = damage_default


                special = str(tpl.get("special", "") or "").strip()
                if special:
                    stats["special"] = special

                coe["stats"]  = stats
                coe["base"]   = dict(stats)
                coe["saves"]  = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)

                s = _slot(mon)

                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s}."):
                        bcfg.remove_option(chan_id, opt_key)
                    if bcfg.has_option(chan_id, mon):
                        bcfg.remove_option(chan_id, mon)


                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s}.join", str(join_seq))
                bcfg.set(chan_id, f"{s}.disp", mon)


                rounds = max(1, int(caster_level or 1))
                bcfg.set(chan_id, f"{s}.x_swarm", str(rounds))
                bcfg.set(chan_id, f"{s}.x_swarm_code", "SWARM")
                bcfg.set(chan_id, f"{s}.x_swarm_label", "Insect Swarm")
                bcfg.set(chan_id, f"{s}.x_swarm_emoji", "ðŸª°")


                bcfg.set(chan_id, f"{s}.swarm_stationary", "1")
                _save_battles(bcfg)

                created.append((mon, d6, hp, rounds))

            return created

        made = _spawn_swarms(count)
        if not made:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        lines = [f"ðŸž **{caster_name}** casts **Insect Plague**."]
        lines.append(f"Summoned **{len(made)}** swarm(s). Duration: **{caster_level}** round(s).")
        lines.append("Swarms are **stationary** and **always hit**; GM uses `!aoo` for round-by-round damage.")
        return lines

    async def _cast_controlundead(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Control Undead (60 ft)
          â€¢ Control up to **3 HD Ã— level** total (this casting).
          â€¢ Intelligent undead: Save vs **Spells** (hostile +5). On fail â†’ **complete control** for **6 rounds/level**.
            They will remember once control ends.
          â€¢ Unintelligent undead (skeletons/zombies): **no save**; **permanent** control transfer.
            These **count against Reanimation control cap** (6Ã—level HD).
          â€¢ Verbal orders required (any language is understood); if communication isnâ€™t possible, they still wonâ€™t attack.
        Usage:
          !cast controlundead <target [target ...]> [-h|-hostile | -nh|-nonhostile]
        """


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        raw_names: list[str] = []
        force_hostile = None
        for t in toks:
            tl = t.lower()
            if tl in ("-h","-hostile","+5","hostile"):
                force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"):
                force_hostile = False
            else:
                raw_names.append(t)


        seen = set()
        names_ordered = []
        for n in raw_names:
            k = n.lower()
            if k not in seen:
                seen.add(k)
                names_ordered.append(n)
        raw_names = names_ordered

        if not raw_names:
            return [
                "âŒ **Control Undead**: add at least one undead target.",
                "Example: `!cast controlundead ghoul wight` or `!cast controlundead zo1 sk2 -h`"
            ]


        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel) if "_section_id" in globals() else str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!battle` first."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            for fnm in os.listdir("."):
                if fnm.lower() == base:
                    path = fnm
                    try:
                        c = read_cfg(path)
                        real = get_compat(c, "info", "name", fallback=None)
                        return (real or fnm[:-4].replace("_", " ")), path
                    except Exception:
                        return fnm[:-4].replace("_", " "), path
            return None, None


        def _is_undead(rcfg) -> bool:
            ty = (str(get_compat(rcfg, "stats", "type", fallback="")) or
                  str(get_compat(rcfg, "info", "type", fallback=""))).lower()
            return "undead" in ty

        def _is_unintelligent_undead(rcfg) -> bool:

            mt = (str(get_compat(rcfg, "info", "monster_type", fallback="")) or "").lower()
            nm = (str(get_compat(rcfg, "info", "name", fallback="")) or "").lower()
            if any(k in mt for k in ("skeleton", "zombie")):
                return True
            if re.match(r"^(sk|zo)\d+$", nm):
                return True
            return False

        def _slot_for(name: str) -> str:
            try:
                return _slot(name)
            except Exception:
                return name.replace(" ", "_")


        def _sum_controlled(owner_id: str, controller_name: str) -> int:
            names, _ = _parse_combatants(bcfg, chan_id)
            total = 0
            for n in names:
                fn = f"{n}.coe"
                if not os.path.exists(fn):
                    continue
                rc = read_cfg(fn)
                if str(get_compat(rc, "info", "owner_id", fallback="")) != str(owner_id):
                    continue
                if str(get_compat(rc, "info", "controller", fallback="")).strip().lower() != caster_name.strip().lower():
                    continue
                if str(get_compat(rc, "stats", "type", fallback="")).strip().lower() != "undead":
                    continue
                hd_now = getint_compat(rc, "cur", "level", fallback=1)
                total += max(1, int(hd_now))
            return total


        hostile_bonus_default = False
        try:
            if force_hostile is None and bcfg.getint(chan_id, "round", fallback=0) >= 1:
                hostile_bonus_default = True
        except Exception:
            pass
        hostile_bonus_flag = force_hostile if force_hostile is not None else hostile_bonus_default
        hostile_bonus_val = 5 if hostile_bonus_flag else 0


        level = max(1, int(caster_level or 1))
        hd_budget_total = 3 * level
        hd_budget_used  = 0

        control_cap = 6 * level
        control_used = _sum_controlled(caster_owner_id, caster_name)


        rounds_ctrl = 6 * level

        lines: list[str] = [f"ðŸª€ **Control Undead**  â€¢  Duration (intelligent): **{rounds_ctrl} rounds**"]
        changed_any = False

        for raw in raw_names:
            disp, path = _resolve_any_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            tcfg = read_cfg(path)
            if not _is_undead(tcfg):
                lines.append(f"â€¢ **{pretty}**: âŒ not undead (no effect).")
                continue

            hd = self._hd_or_level_from_cfg(tcfg)
            unintelligent = _is_unintelligent_undead(tcfg)
            slot = _slot_for(pretty)


            if hd_budget_used + hd > hd_budget_total:
                lines.append(f"â€¢ **{pretty}** (HD {hd}): âŒ over budget "
                             f"(used **{hd_budget_used} / {hd_budget_total} HD** for this cast).")
                continue

            if unintelligent:

                if control_used + hd > control_cap:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): âŒ exceeds control cap "
                                 f"(**{control_used} / {control_cap} HD**).")
                    continue


                tcfg.set("info", "owner_id", str(caster_owner_id))
                tcfg.set("info", "controller", caster_name)
                tcfg.set("info", "battle_chan", chan_id)
                with open(path, "w", encoding="utf-8") as f:
                    tcfg.write(f)


                bcfg.set(chan_id, f"{slot}.hostile", "0")
                bcfg.set(chan_id, f"{slot}.minion_by", caster_name)
                bcfg.set(chan_id, f"{slot}.minion_type", "controlundead_perm")

                control_used += hd
                hd_budget_used += hd
                changed_any = True
                lines.append(f"â€¢ **{pretty}** (HD {hd}): ðŸ§¿ **PERMANENT CONTROL** â€” no save. "
                             f"Control cap: **{control_used} / {control_cap} HD**. "
                             f"(Cast budget: **{hd_budget_used} / {hd_budget_total} HD**)")

            else:

                used_vs = "Spells"
                sv_dc = None; sv_roll = None
                for vs_key in ("spell", "sp", "spells"):
                    try:
                        ok, r, dc, pen = self._roll_save(tcfg, vs=vs_key, penalty=0)
                        if dc is not None:
                            sv_roll, sv_dc = r, dc
                            used_vs = "Spells"
                            break
                    except Exception:
                        pass
                if sv_dc is None:

                    sv_dc, sv_roll = 15, random.randint(1, 20)

                adj = (sv_roll or 0) + hostile_bonus_val
                d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
                pass_save = adj >= sv_dc

                if pass_save:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}): Save vs {used_vs} {d20_face}"
                                 f"{' + 5' if hostile_bonus_val else ''} = ``{adj}`` vs **{sv_dc}** â†’ âŒ **RESISTS**.")
                    continue


                hd_budget_used += hd


                bcfg.set(chan_id, f"{slot}.hostile", "0")
                bcfg.set(chan_id, f"{slot}.minion_by", caster_name)
                bcfg.set(chan_id, f"{slot}.minion_type", "controlundead_temp")


                bcfg.set(chan_id, f"{slot}.x_ctrlu", str(rounds_ctrl))
                bcfg.set(chan_id, f"{slot}.x_ctrlu_code", "CTRLU")
                bcfg.set(chan_id, f"{slot}.x_ctrlu_label", "Control Undead")
                bcfg.set(chan_id, f"{slot}.x_ctrlu_emoji", "ðŸ•¯ï¸")

                bcfg.set(chan_id, f"{slot}.x_ctrlu_caster", caster_name)

                changed_any = True
                note = ("**Controlled** â€” follows your commands for the duration (any language understood). "
                        "If orders canâ€™t be communicated, it **will not attack**. The undead will **remember** afterward.")
                lines.append(f"â€¢ **{pretty}** (HD {hd}): Save vs {used_vs} {d20_face}"
                             f"{' + 5' if hostile_bonus_val else ''} = ``{adj}`` vs **{sv_dc}** â†’ **CONTROLLED** "
                             f"for **{rounds_ctrl} rounds**. {note} "
                             f"(Cast budget: **{hd_budget_used} / {hd_budget_total} HD**)")


        if changed_any:
            try:
                _save_battles(bcfg)
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


        lines.append("â€”")
        lines.append("â€¢ **Per cast**: up to **3 HD/level** of undead may be controlled (mix of intelligent/unintelligent).")
        lines.append("â€¢ **Intelligent**: Save vs *Spells* (hostile +5); on fail you have **complete control** for **6 rounds/level**; they **remember**.")
        lines.append("â€¢ **Unintelligent**: **No save**; **permanent** control; counts against **Reanimation** cap (**6Ã—level HD**).")

        return lines

    async def _effect_eyebite(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Eyebite (Nec 6) â€” 60 ft; Duration: 1 round/3 levels (window).
        Each round while active, target one living creature:
          â€¢ HD 10+: Sickened (â€“2 atk/dmg/saves) for 1 turn/level.
          â€¢ HD 5â€“9: Panicked 1d4 rnds AND Sickened (as above).
          â€¢ HD â‰¤4: Comatose 1 turn/level AND Panicked 1d4 rnds AND Sickened (as above).
        Save vs Death Ray avoids the worst effect only (lesser effects still apply).
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        rounds_active = max(1, int(caster_level // 3))

        lines = ["ðŸ‘ï¸ **Eyebite** takes hold."]
        if bcfg and bcfg.has_section(chan_id):

            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            s_me   = self._effect_slot_for(bcfg, chan_id, me_key)


            bcfg.set(chan_id, f"{s_me}.eb",        str(rounds_active))
            bcfg.set(chan_id, f"{s_me}.eb_by",     caster_name)
            bcfg.set(chan_id, f"{s_me}.eb_level",  str(int(caster_level)))

            self._clear_code_badges(bcfg, chan_id, s_me, "EB")
            base = f"{s_me}.x_eyebite"
            bcfg.set(chan_id, base,                 str(rounds_active))
            bcfg.set(chan_id, f"{base}_label",      "Eyebite")
            bcfg.set(chan_id, f"{base}_code",       "EB")
            bcfg.set(chan_id, f"{base}_emoji",      "ðŸ‘ï¸")
            bcfg.set(chan_id, f"{base}_by",         caster_name)
            _save_battles(bcfg)

            lines.append(
                f"Lingers on **{caster_name}** for **{rounds_active} round(s)**. "
                "*(Use `!a eyebite <target>` each round while it lasts â€” one creature per round; requires your action.)*"
            )
        else:
            lines.append(f"Would linger for **{rounds_active} round(s)** (no active battle here, wonâ€™t auto-tick).")


        if tokens:

            applied, out = self._apply_eyebite_to_targets(chan_id, bcfg, caster_name, caster_level, tokens)
            lines.extend(out)
            if applied and bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    me_key = _find_ci_name(names, caster_name) or caster_name
                    s_me   = self._effect_slot_for(bcfg, chan_id, me_key)
                    cur_rd = bcfg.getint(chan_id, "round", fallback=0)
                    bcfg.set(chan_id, f"{s_me}.eb_last_round", str(cur_rd))
                    _save_battles(bcfg)
                except Exception:
                    pass


        try:
            if bcfg and bcfg.has_section(chan_id):
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        return lines

    def _apply_eyebite_to_targets(self, chan_id: str, bcfg, caster_name: str, caster_level: int, tokens: list[str]):

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rcfg = read_cfg(path)
                            real = get_compat(rcfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        def _is_nonliving(rcfg) -> bool:
            ty = (str(get_compat(rcfg, "stats", "type", fallback="")) or
                  str(get_compat(rcfg, "info", "type",  fallback=""))).lower()

            return any(k in ty for k in ("undead","construct","ooze","slime","golem"))

        def _roll_death_save(t_cfg):

            for tag in ("death","dr","deathray","death_ray"):
                ok, roll, dc, pen = self._roll_save(t_cfg, vs=tag, penalty=0)
                if dc is not None:
                    return ok, roll, dc, pen
            return self._roll_save(t_cfg, vs="poi", penalty=0)

        sick_rounds = max(1, int(caster_level) * 60)
        coma_rounds = sick_rounds
        lines = []
        applied_any = False

        for raw in tokens or []:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            pretty = tgt_disp or raw
            if not tgt_path or not os.path.exists(tgt_path):
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)
            if _is_nonliving(t_cfg):
                lines.append(f"â€¢ **{pretty}**: âŒ Non-living (undead/construct/ooze) â€” **no effect**.")
                continue


            s_tgt = None
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    s_tgt = self._effect_slot_for(bcfg, chan_id, key)
                except Exception:
                    s_tgt = None

            hd = self._hd_or_level_from_cfg(t_cfg)


            worst = None
            tier = ""
            if hd >= 10:
                tier = "â‰¥10 HD"
                worst = "sickened"
            elif 5 <= hd <= 9:
                tier = "5â€“9 HD"
                worst = "panicked"
            else:
                tier = "â‰¤4 HD"
                worst = "comatose"


            sv_ok, sv_roll, sv_dc, _ = _roll_death_save(t_cfg)
            show_roll = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
            avoided = sv_ok


            apply_sick = False
            apply_panic = False
            apply_coma = False

            if hd >= 10:

                apply_sick = not avoided
            elif 5 <= hd <= 9:

                apply_sick = True
                apply_panic = not avoided
            else:

                apply_sick = True
                apply_panic = True
                apply_coma = not avoided


            notes = []
            if apply_coma and bcfg and bcfg.has_section(chan_id) and s_tgt:
                prev = bcfg.getint(chan_id, f"{s_tgt}.paralyzed", fallback=0)
                newv = max(prev, int(coma_rounds))
                if newv > 0:
                    bcfg.set(chan_id, f"{s_tgt}.paralyzed", str(newv))
                    bcfg.set(chan_id, f"{s_tgt}.paralyzed_by", "eyebite")

                self._clear_code_badges(bcfg, chan_id, s_tgt, "COMA")
                base = f"{s_tgt}.x_coma"
                bcfg.set(chan_id, base,               str(coma_rounds))
                bcfg.set(chan_id, f"{base}_label",    "Comatose")
                bcfg.set(chan_id, f"{base}_code",     "COMA")
                bcfg.set(chan_id, f"{base}_emoji",    "ðŸ’¤")
                bcfg.set(chan_id, f"{base}_by",       caster_name)
                notes.append(f"ðŸ’¤ **COMATOSE** for **{coma_rounds} rounds**.")

            if apply_panic and bcfg and bcfg.has_section(chan_id) and s_tgt:
                s, rolls, _ = roll_dice("1d4")
                fr = max(0, int(s))
                if fr > 0:
                    bcfg.set(chan_id, f"{s_tgt}.fear",     str(fr))
                    bcfg.set(chan_id, f"{s_tgt}.fear_src", "eyebite")
                    bcfg.set(chan_id, f"{s_tgt}.fear_by",  caster_name)
                    notes.append(f"ðŸ˜± **PANICKED** for **{fr} rounds** ({', '.join(str(r) for r in rolls)}).")
                else:
                    notes.append("ðŸ˜± **PANICKED** (brief).")

            if apply_sick and bcfg and bcfg.has_section(chan_id) and s_tgt:

                bcfg.set(chan_id, f"{s_tgt}.stench_pen", "-2")
                bcfg.set(chan_id, f"{s_tgt}.stench_label", "Sickened")
                bcfg.set(chan_id, f"{s_tgt}.stench_emoji", "ðŸ¤¢")
                base = f"{s_tgt}.x_stenchn"
                bcfg.set(chan_id, base,               str(sick_rounds))
                bcfg.set(chan_id, f"{base}_label",    "Sickened")
                bcfg.set(chan_id, f"{base}_code",     "SIC")
                bcfg.set(chan_id, f"{base}_emoji",    "ðŸ¤¢")
                bcfg.set(chan_id, f"{base}_by",       caster_name)
                notes.append(f"ðŸ¤¢ **SICKENED** for **{sick_rounds} rounds** (â€“2 atk/dmg/saves).")

            if notes:
                applied_any = True


            if sv_dc is not None:
                if avoided:
                    if worst == "sickened":

                        lines.append(f"â€¢ **{pretty}** (HD {hd}, {tier}): Save vs Death {show_roll} vs {sv_dc} â†’ âœ… avoids **Sickened**.")
                    else:
                        lines.append(f"â€¢ **{pretty}** (HD {hd}, {tier}): Save vs Death {show_roll} vs {sv_dc} â†’ âœ… avoids **{worst.upper()}**.")
                else:
                    lines.append(f"â€¢ **{pretty}** (HD {hd}, {tier}): Save vs Death {show_roll} vs {sv_dc} â†’ **FAIL**.")
            else:
                lines.append(f"â€¢ **{pretty}** (HD {hd}, {tier}): *(no save table â€” treating as failed)*")

            if notes:
                lines.append("  " + " ".join(notes))

            if bcfg and bcfg.has_section(chan_id) and s_tgt:
                _save_battles(bcfg)


        if applied_any:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    self._update_tracker_message

            except Exception:
                pass

        return applied_any, lines

    async def _cast_undeath(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Undeath (touch): Returns a dead PC as an undead form (Ghoul/Ghast/Mummy/Spectre/Vampire/Wight/Wraith/Ghost/Other).
          â€¢ Most souls resist: Save vs *Spells* to REFUSE (spell fails). Evil/willing souls typically **donâ€™t** resist.
          â€¢ Target becomes **Undead**; level/HD **â€“1** (real loss).
          â€¢ Keep INT/WIS/CHA; re-roll STR/DEX/CON (3d6).
          â€¢ HP = max( class HP at new level, undeadâ€™s normal HD Ã— d8 ) (undead HP ignores CON).
          â€¢ Gains the formâ€™s traits (movement, immunities, natural attacks) at GMâ€™s discretion; no special control.
          â€¢ Casting takes 1 hour; result is permanent (instantaneous).
        Usage:
          !cast undeath <target>
          !cast undeath <target> <form>           # ghoul|ghast|mummy|spectre|vampire|wight|wraith|ghost|other
          !cast undeath <target> -willing        # skip â€œsoul refusesâ€ save (eager/evil target)
        """


        def _norm(s: str) -> str:
            return re.sub(r"[^\w]+", "", (s or "").lower())

        def _resolve_pc_ci(name: str):

            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            c = read_cfg(path)
                            real = get_compat(c, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        def _is_pc_file(path: str) -> bool:
            return not _is_monster_file(path)

        undead_alias = {
            "ghoul":"Ghoul","ghast":"Ghast","mummy":"Mummy","spectre":"Spectre","specter":"Spectre",
            "vampire":"Vampire","wight":"Wight","wraith":"Wraith","ghost":"Ghost","other":"Other"
        }


        def _roll_undead_form(n: int) -> str:
            if 1 <= n <= 25:  return "Ghoul"
            if 26 <= n <= 40: return "Ghast"
            if 41 <= n <= 50: return "Mummy"
            if 51 <= n <= 55: return "Spectre"
            if 56 <= n <= 60: return "Vampire"
            if 61 <= n <= 75: return "Wight"
            if 76 <= n <= 84: return "Wraith"
            if 85 <= n <= 90: return "Ghost"
            return "Other"

        def _abil_mod(score: int) -> int:
            if score <= 3: return -3
            if score <= 5: return -2
            if score <= 8: return -1
            if score <= 12: return 0
            if score <= 15: return 1
            if score <= 17: return 2
            return 3

        def _roll_3d6():
            rolls = [random.randint(1,6) for _ in range(3)]
            return sum(rolls), rolls


        toks: list[str] = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t) for t in targets if str(t).strip()]
        else:
            toks = [t for t in re.split(r"\s+", str(targets or "").strip()) if t]

        if not toks:
            return ["âŒ Usage: `!cast undeath <target> [form] [-willing]`"]

        want_name = toks[0]
        want_form = None
        willing = False
        for t in toks[1:]:
            k = _norm(t)
            if k in undead_alias:
                want_form = undead_alias[k]
            elif k in {"willing","voluntary"} or t.lower() in {"-willing","-w"}:
                willing = True


        tgt_name, tgt_path = _resolve_pc_ci(want_name)
        if not tgt_path:
            return [f"âŒ Target '{want_name}' not found."]
        if not _is_pc_file(tgt_path):
            return [f"âŒ **{tgt_name}** is a monster/NPC record. **Undeath** here is intended for PCs."]

        tcfg = read_cfg(tgt_path)


        old_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_hp != 0:
            return [f"âŒ **{tgt_name}** is not at 0 HP. Undeath requires a deceased target (0 HP)."]


        cur_type = (get_compat(tcfg, "stats", "type", fallback="") or get_compat(tcfg, "info", "type", fallback="")).lower()
        if "undead" in cur_type:
            return [f"âŒ **{tgt_name}** is already undead."]


        race_now = (get_compat(tcfg, "info", "race", fallback="") or "").lower()
        block_terms = {"construct","golem","elemental","ooze","slime"}
        if any(term in cur_type for term in block_terms) or any(term in race_now for term in block_terms):
            return [f"âŒ **{tgt_name}**â€™s essence cannot be made undead (construct/elemental/ooze)."]



        align = (get_compat(tcfg, "info", "alignment", fallback="") or get_compat(tcfg, "info", "align", fallback="") or "").lower()
        soul_willing = willing or ("evil" in align)

        lines: list[str] = [f"ðŸ•¯ï¸ **Undeath** ritual begins. A black hourglass emptiesâ€¦"]
        sv_txt = None

        if not soul_willing:
            ok, roll, dc, _ = self._roll_save(tcfg, vs="spell", penalty=0)
            if dc is None:
                ok, roll, dc, _ = self._roll_save(tcfg, vs="spells", penalty=0)
            if dc is None:

                roll = random.randint(1,20); dc = 11; ok = (roll >= dc)
            if ok:
                sv_txt = f"â€¢ **Soulâ€™s Choice**: Save vs Spells {roll} vs {dc} â†’ âœ… **REFUSES**. The spirit will not return."
                lines.append(sv_txt)
                lines.append("The magic sputters and fades. *(Spell slot is spent.)*")
                return lines
            else:
                sv_txt = f"â€¢ **Soulâ€™s Choice**: Save vs Spells {roll} vs {dc} â†’ âŒ **FAILS**. The spirit is **drawn back**â€¦"
                lines.append(sv_txt)
        else:
            lines.append("â€¢ **Soulâ€™s Choice**: The spirit is **willing** (or wicked) â€” no save to refuse.")


        d100 = random.randint(1,100)
        rolled_form = _roll_undead_form(d100)
        final_form = want_form or rolled_form
        form_key = _norm(final_form)
        lines.append(f"â€¢ d100 **{d100}** â†’ **{rolled_form}**" + (f" â†’ **{final_form}**" if want_form else ""))


        old_stats = {
            "str": getint_compat(tcfg, "stats", "str", fallback=10),
            "dex": getint_compat(tcfg, "stats", "dex", fallback=10),
            "con": getint_compat(tcfg, "stats", "con", fallback=10),
            "int": getint_compat(tcfg, "stats", "int", fallback=10),
            "wis": getint_compat(tcfg, "stats", "wis", fallback=10),
            "cha": getint_compat(tcfg, "stats", "cha", fallback=10),
        }
        new_str, str_rolls = _roll_3d6()
        new_dex, dex_rolls = _roll_3d6()
        new_con, con_rolls = _roll_3d6()

        new_mods = {
            "str_modifier": _abil_mod(new_str),
            "dex_modifier": _abil_mod(new_dex),
            "con_modifier": _abil_mod(new_con),
            "int_modifier": _abil_mod(old_stats["int"]),
            "wis_modifier": _abil_mod(old_stats["wis"]),
            "cha_modifier": _abil_mod(old_stats["cha"]),
        }


        lvl_before = max(1, getint_compat(tcfg, "cur", "level", fallback=1))
        lvl_after  = max(1, lvl_before - 1)

        cls = (get_compat(tcfg, "info", "class", fallback="") or "").strip().lower()
        hd_map = {
            "magic-user": 4, "illusionist": 4, "thief": 4, "assassin": 4,
            "cleric": 6, "druid": 6, "scout": 6,
            "necromancer": 4, "spellcrafter": 4,
            "fightermage": 6, "magethief": 4,
            "fighter": 8, "paladin": 8, "ranger": 8, "barbarian": 10,
        }
        class_die = hd_map.get(cls, 6)

        def _roll_hp_levels(n_levels: int, die: int, con_mod: int):
            rolls = [random.randint(1, die) for _ in range(max(0, n_levels))]
            total = sum(rolls) + con_mod * max(0, n_levels)
            return max(1, total), rolls

        class_hp, class_hp_rolls = _roll_hp_levels(lvl_after, class_die, new_mods["con_modifier"])


        undead_hd = self._monster_hd_for(form_key) or 0
        undead_hp = 0
        undead_hp_rolls = []
        if undead_hd > 0:
            undead_hp, undead_hp_rolls = _roll_hp_levels(undead_hd, 8, 0)

        final_max_hp = max(class_hp, undead_hp or 0)
        final_cur_hp = final_max_hp




        if not tcfg.has_section("stats"): tcfg.add_section("stats")
        if not tcfg.has_section("info"):  tcfg.add_section("info")
        if not tcfg.has_section("cur"):   tcfg.add_section("cur")
        if not tcfg.has_section("base"):  tcfg.add_section("base")


        tcfg["stats"]["type"] = "undead"
        tcfg["info"]["race"] = f"{final_form}"
        tcfg["cur"]["level"] = str(lvl_after)


        if not tcfg.has_section("stats"): tcfg.add_section("stats")
        tcfg["stats"]["str"] = str(new_str)
        tcfg["stats"]["dex"] = str(new_dex)
        tcfg["stats"]["con"] = str(new_con)
        tcfg["stats"]["int"] = str(old_stats["int"])
        tcfg["stats"]["wis"] = str(old_stats["wis"])
        tcfg["stats"]["cha"] = str(old_stats["cha"])
        for k, v in new_mods.items():
            tcfg["stats"][k] = str(v)


        if not tcfg.has_section("base"): tcfg.add_section("base")
        tcfg["base"]["str"] = str(new_str)
        tcfg["base"]["dex"] = str(new_dex)
        tcfg["base"]["con"] = str(new_con)
        tcfg["base"]["str_modifier"] = str(new_mods["str_modifier"])
        tcfg["base"]["dex_modifier"] = str(new_mods["dex_modifier"])
        tcfg["base"]["con_modifier"] = str(new_mods["con_modifier"])


        if not tcfg.has_section("max"): tcfg.add_section("max")
        if not tcfg.has_section("cur"): tcfg.add_section("cur")
        tcfg["max"]["hp"] = str(final_max_hp)
        tcfg["cur"]["hp"] = str(final_cur_hp)


        if undead_hd > 0:
            tcfg["stats"]["undead_hd"] = str(undead_hd)
        immun = self._monster_immunities_for(form_key)
        if immun:

            prev = (get_compat(tcfg, "stats", "immune", fallback="") or "").strip()
            merged = (prev + (" " if prev and immun else "") + immun).strip()
            tcfg["stats"]["immune"] = merged


        tcfg["cur"]["neg_levels"] = "0"
        tcfg["cur"]["neg_hp_loss_total"] = "0"

        write_cfg(tgt_path, tcfg)


        added_attacks, graft_notes = self._graft_undead_attacks_and_specials(tcfg, form_key, form_label=final_form)
        write_cfg(tgt_path, tcfg)


        if graft_notes:
            lines.extend(graft_notes)


        try:
            bcfg = _load_battles()
            chan_id = _section_id(ctx.channel)
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_name) or tgt_name
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")
                for suf in (".paralyzed",".blind",".oil",".acpen",".holds",".heldby",
                            ".inv",".inv_by",".inv_type",".inv_gid",".inv_leader",".inv_perm",
                            ".gas",".stoneskin",".disease",".fear",".x_shk",".x_pnc",".coma",".comatose"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)
        except Exception:
            pass


        rolls_txt = lambda rs: "[" + ", ".join(str(r) for r in rs) + "]"
        sub_lines = []
        sub_lines.append(f"â€¢ Form: **{final_form}**")
        sub_lines.append(f"â€¢ STR {old_stats['str']} â†’ **{new_str}** {rolls_txt(str_rolls)}  "
                         f"DEX {old_stats['dex']} â†’ **{new_dex}** {rolls_txt(dex_rolls)}  "
                         f"CON {old_stats['con']} â†’ **{new_con}** {rolls_txt(con_rolls)}")
        sub_lines.append(f"â€¢ INT/WIS/CHA **unchanged** ({old_stats['int']}/{old_stats['wis']}/{old_stats['cha']}).")
        lvl_line = f"â€¢ Level {lvl_before} â†’ **{lvl_after}**"
        if undead_hd > 0:
            lvl_line += f"; Undead HD **{undead_hd}**"
        sub_lines.append(lvl_line)

        hp_bits = [f"class HP **{class_hp}** {rolls_txt(class_hp_rolls)}"]
        if undead_hd > 0:
            hp_bits.append(f"undead HP **{undead_hp}** {rolls_txt(undead_hp_rolls)}")
        sub_lines.append(f"â€¢ HP = max({'; '.join(hp_bits)}) â†’ **{final_max_hp}** (now fully â€œvitalâ€).")


        sub_lines.append("â€¢ The body reforms over **1 hour**. The caster gains **no control**.")
        sub_lines.append("â€¢ Gains undead traits/compulsions per form (GM adjudicates). "
                         "Refusing a ghoul/ghast/wightâ€™s hunger may impose **âˆ’6 INT/WIS** while starved.")
        sub_lines.append("â€¢ Class abilities remain where sensible (e.g., ghostly forms may not climb normally).")

        return ["ðŸ©¸ **Undeath** completes â€” a new undead rises: **{0}**.".format(tgt_name)] + sub_lines

    def _graft_undead_attacks_and_specials(self, tcfg, form_key: str, form_label: str | None = None):
        """
        Copy natural attacks/specs (e.g., 'touch = 1d6 drain') from the monster template's [base]
        into the PC sheet under [stats]. Also merge 'special', 'immune', 'resist'.
        Returns (added_attack_names, summary_lines).
        """


        DEFAULT_UNDEAD_KIT = {
            "ghoul":   {"attacknames": "claw bite", "atk_claw": "1d3",        "atk_bite": "1d3",         "special": "paralysis", "immune": "nonmagical"},
            "ghast":   {"attacknames": "claw bite", "atk_claw": "1d4",        "atk_bite": "1d4",         "special": "stench paralysis", "immune": "nonmagical"},
            "mummy":   {"attacknames": "slam",      "atk_slam": "1d12 rot",   "immune": "nonmagical"},
            "spectre": {"attacknames": "touch",     "atk_touch": "drain",     "immune": "nonmagical"},
            "vampire": {"attacknames": "bite",      "atk_bite": "1d3 drain heal", "immune": "nonmagical"},
            "wight":   {"attacknames": "touch",     "atk_touch": "drain",     "immune": "nonmagical"},
            "wraith":  {"attacknames": "touch",     "atk_touch": "1d6 drain", "immune": "nonmagical"},
            "ghost":   {"attacknames": "touch",     "atk_touch": "aging",     "immune": "nonmagical"},
            "other":   {"attacknames": "",          "special": "",            "immune": ""},
        }

        tpl = self._monster_template(form_key)
        has_base = bool(tpl and hasattr(tpl, "has_section") and tpl.has_section("base"))

        def B(k: str, fb: str = "") -> str:
            return self._monster_text_from_base(tpl, k, fb) if has_base else fb


        if not tcfg.has_section("stats"):
            tcfg.add_section("stats")


        names_raw = (B("attacknames") or B("attacks"))
        if not names_raw and has_base:
            common = ("claw", "bite", "gore", "slam", "tail", "sting", "touch", "tentacle")
            present = [k for k in common if B(k)]
            names_raw = " ".join(present)

        def _parse_names(txt: str):
            raw = [n.strip().lower() for n in re.split(r"[,\s]+", txt or "") if n.strip()]
            out, seen = [], set()
            for n in raw:
                if n not in seen:
                    seen.add(n); out.append(n)
            return out

        t_atks = _parse_names(names_raw)


        kit_used = None
        if not has_base or not t_atks:
            kit_used = DEFAULT_UNDEAD_KIT.get(form_key)
            if kit_used:
                t_atks = _parse_names(kit_used.get("attacknames", ""))


        cur_names_raw = tcfg.get("stats", "attacknames", fallback="").strip()
        cur_names = _parse_names(cur_names_raw) if cur_names_raw else []
        merged = cur_names[:]

        added, descs = [], []

        for an in t_atks:
            if an not in merged:
                merged.append(an)


            spec = (B(f"atk_{an}") or B(an) or B(f"dmg_{an}") or B(f"{an}_dmg")).strip()
            if not spec and kit_used:
                spec = kit_used.get(f"atk_{an}", "").strip()
            if spec:
                tcfg.set("stats", f"atk_{an}", spec)
                added.append(an)
                descs.append(f"{an} = {spec}")

        if merged:
            tcfg.set("stats", "attacknames", " ".join(merged))


        def _merge_text(key: str, from_tpl: bool = True, from_kit: bool = True):
            pieces = []
            src = B(key).strip() if (has_base and from_tpl) else ""
            if src:
                pieces.append(src)
            if kit_used and from_kit:
                extra = kit_used.get(key, "").strip()
                if extra:
                    pieces.append(extra)
            if not pieces:
                return ""
            prev = tcfg.get("stats", key, fallback="").strip()
            new = "; ".join([p for p in pieces if p])
            if not prev:
                tcfg.set("stats", key, new)
            elif new.lower() not in prev.lower():
                tcfg.set("stats", key, f"{prev}; {new}")
            return new

        special = _merge_text("special")
        immune  = _merge_text("immune")
        resist  = _merge_text("resist")

        notes = []
        if added:
            notes.append("â€¢ Natural/unique attacks gained: " + ", ".join(descs))
        if special:
            notes.append(f"â€¢ Special: {special}")
        if immune:
            notes.append(f"â€¢ Immunities merged: {immune}")
        if resist:
            notes.append(f"â€¢ Resistances merged: {resist}")
        if not has_base and not kit_used:
            notes.append(f"â€¢ (No template found for **{form_label or form_key}** â€” nothing to graft.)")

        return added, notes

    def _monster_template(self, form_key: str):
        """
        Return a ConfigParser for the monster 'form_key'.
        Tries project helpers (polymorph loader) first; then scans common folders.
        """

        norm = re.sub(r"[^\w]+", "", (form_key or "").lower())


        try:
            if "_load_monster_form" in globals():
                _pretty, tpl = _load_monster_form(form_key)
                if tpl:
                    return tpl
        except Exception:
            pass


        try:
            if "_load_monster_template" in globals():
                tpl2 = _load_monster_template(form_key)
                if tpl2:
                    return tpl2
        except Exception:
            pass


        search_roots = ["monsters", "Monsters", "data/monsters", "data/Monsters", "."]
        try:
            for root in search_roots:
                if not os.path.isdir(root):
                    continue
                for fn in os.listdir(root):
                    base, _ext = os.path.splitext(fn)
                    if re.sub(r"[^\w]+", "", base.lower()) == norm:
                        return read_cfg(os.path.join(root, fn))
        except Exception:
            pass

        return None

    def _monster_text_from_base(self, tpl, key: str, fallback: str = "") -> str:
        """Safely read `[base] key` text from a monster template."""
        try:
            return (get_compat(tpl, "base", key, fallback=fallback) or "").strip()
        except Exception:
            return fallback

    def _monster_hd_for(self, form_key: str) -> int:
        """Read HD from the monster template's [base].hd (0 if not found)."""
        tpl = self._monster_template(form_key)
        if not tpl:
            return 0
        try:
            return max(0, getint_compat(tpl, "base", "hd", fallback=0))
        except Exception:
            return 0

    def _monster_immunities_for(self, form_key: str) -> str:
        """Return the 'immune' text from the monster template's [base] section."""
        tpl = self._monster_template(form_key)
        if not tpl:
            return ""
        try:
            val = (
                get_compat(tpl, "base", "immune",   fallback="")
                or get_compat(tpl, "base", "immunity", fallback="")
            )
            if not val:
                try:
                    val = (tpl.get("immune", fallback="") or "")
                except Exception:
                    val = ""
            return val.strip()
        except Exception:
            return ""

    def _effect_undeathtodeath(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Undeath to Death
        â€¢ Functions exactly like Death Spell, except it affects **undead** rather than living.
        â€¢ Kills up to 3d12 HD worth of **undead** (order = the order you list them).
        â€¢ Non-undead creatures are unaffected.
        â€¢ Undead with HD/level >= 8 are immune.
        â€¢ Affected undead get Save vs Death; fail â†’ destroyed (HP set to 0).
        â€¢ Excess HD, if any, is lost.
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _is_undead_any(rcfg, tgt_disp: str = "") -> bool:

            try:
                if "_is_undead_cfg" in globals():
                    return bool(_is_undead_cfg(rcfg, tgt_disp))
            except Exception:
                pass

            ty = (str(get_compat(rcfg, "stats", "type", fallback="")) or
                  str(get_compat(rcfg, "info",  "type", fallback=""))).lower()
            tags = (str(get_compat(rcfg, "base",  "tags", fallback="")) or
                    str(get_compat(rcfg, "stats", "tags", fallback=""))).lower()
            return ("undead" in ty) or ("undead" in tags)


        rolls = [random.randint(1, 12) for _ in range(3)]
        pool  = sum(rolls)
        lines = [
            "â˜ ï¸ **Undeath to Death**",
            f"Kill capacity vs **undead**: 3d12 â†’ {rolls} = **{pool} HD**.",
            "*(Targets are checked in the order listed.)*",
        ]

        if not tokens:
            lines.append("â€¢ *(No targets provided.)*")
            return lines

        for raw in tokens:

            tgt_disp, tgt_path = self._resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(tgt_path)


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
            if old_hp is None:
                lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
                continue
            if old_hp <= 0:
                lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
                continue


            if not _is_undead_any(t_cfg, tgt_disp):
                lines.append(f"â€¢ **{tgt_disp}**: not undead â€” **no effect**.")
                continue


            hd = max(1, int(self._hd_or_level_from_cfg(t_cfg)))
            if hd >= 8:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): HD â‰¥ 8 â€” **immune**.")
                continue


            if pool < hd:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Remaining pool **{pool}** < **{hd}** â€” **unaffected**.")
                continue

            pool -= hd


            sv_ok, sv_roll, sv_dc, _ = self._roll_death_save(t_cfg)
            if sv_dc is not None:
                if sv_ok:
                    lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): Save vs Death {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED** (pool left: {pool})")
                    continue
                note = f"Save vs Death {sv_roll} vs {sv_dc} â†’ **FAIL**"
            else:
                note = "*(no death save table â€” treating as failed)*"


            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = "0"
            write_cfg(tgt_path, t_cfg)


            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False

            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (
                            ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                            ".paralyzed",".blind",".blind_src",".blind_by",
                            ".cc_blind_pending",".cs_blind_pending",
                            ".cc",".cc_by",".cc_level",
                            ".ck",".ck_by",".ck_level",
                            ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                            ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                        ):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)

                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass


                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass


            try:
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(0,    mhp, width=10)
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note}\n{before} â†’ **{after}** â˜ ï¸ **DESTROYED!** (pool left: {pool})")
            except Exception:
                lines.append(f"â€¢ **{tgt_disp}** (HD {hd}): {note}\nHP {old_hp} â†’ **0** â˜ ï¸ **DESTROYED!** (pool left: {pool})")

        if pool > 0:
            lines.append(f"Excess effectiveness is lost: **{pool} HD** unused.")
        return lines

    async def _cast_callhorseman(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Call Horseman (Necromancer 7)
          â€¢ Summons a Headless Horseman to perform a task.
          â€¢ HD = max(7, min(caster_level, skull_level_if_given))
          â€¢ Remains until the task is complete or sunrise, or it is slain.
          â€¢ Control is maintained while the caster possesses the skull (RP/GM hook).
        Usage:
          !cast callhorseman [-skull N] [task text...]
        Examples:
          !cast callhorseman -skull 14 slay the baron
          !cast callhorseman bring me the emerald diadem
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        skull_cap = None
        task_words = []

        if isinstance(targets, (list, tuple, set)):
            raw_toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            raw_toks = [t for t in re.split(r"\s+", targets.strip()) if t]
        else:
            raw_toks = []

        i = 0
        while i < len(raw_toks):
            t = raw_toks[i]
            tl = t.lower()
            if tl in ("-skull", "-s", "-cap"):
                if i + 1 < len(raw_toks):
                    try:
                        skull_cap = max(1, int(raw_toks[i + 1]))
                        i += 2
                        continue
                    except Exception:
                        pass

            m = re.fullmatch(r"(\d{1,3})", t)
            if skull_cap is None and m:
                try:
                    skull_cap = max(1, int(m.group(1)))
                    i += 1
                    continue
                except Exception:
                    pass
            task_words.append(t)
            i += 1

        task_text = " ".join(task_words).strip()


        tpl = (_load_monster_template("headlesshorseman")
               or _load_monster_template("headless_horseman")
               or _load_monster_template("headless-horseman"))
        if not tpl:
            return ["âŒ Monster template not found for **headlesshorseman** (try `headlesshorseman.ini`)."]



        ac     = int(tpl.get("ac", 17))
        tpl_hd = int(tpl.get("hd", 7))
        hpmod  = int(tpl.get("hpmod", 0))
        move   = int(tpl.get("move", 90))
        saveas = str(tpl.get("saveas", f"Fighter {max(7, tpl_hd)}"))

        attacknames_raw = str(tpl.get("attacknames", "")).strip()
        damage_fallback = str(tpl.get("damage", "1d8+2"))



        skull_eff = int(skull_cap) if skull_cap is not None else int(caster_level or tpl_hd or 7)
        hd = max(7, min(int(caster_level or 7), skull_eff))


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1)
        else:
            save_class = "Fighter"
        save_level = max(1, min(20, int(hd)))


        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        i = 1
        while f"HE{i}" in existing:
            i += 1
        mon = f"HE{i}"


        hp = sum(random.randint(1, 8) for _ in range(hd)) + hpmod
        hp = max(1, hp)


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        coe = configparser.ConfigParser()
        coe.optionxform = str
        coe["version"] = {"current": "08082018"}
        coe["info"] = {
            "race": "Monster", "class": "Monster", "sex": "",
            "name": mon, "owner_id": str(caster_owner_id),
            "monster_type": "headlesshorseman",
            "battle_chan": chan_id,
            "controller": caster_name,
            "summoned": "callhorseman",
            "task": task_text,


        }
        coe["max"] = {"hp": str(hp)}
        coe["cur"] = {
            "hp": str(hp), "level": str(hd),
            "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""
        }


        stats = {
            "ac": str(ac),
            "ab": "",
            "move": str(move),
            "type": str(tpl.get("type", "undead")).strip() or "undead",
            "resist": str(tpl.get("resist", "")).strip(),
            "reduce1": str(tpl.get("reduce1", "")).strip(),
            "immune": str(tpl.get("immune", "")).strip(),
            "weak": str(tpl.get("weak", "")).strip(),
        }


        import re as _re
        attack_list = [a for a in _re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else []
        if attack_list:
            stats["attacknames"] = " ".join(attack_list)
            first_spec = None
            for an in attack_list:
                spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                            tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                if spec:
                    stats[f"atk_{an}"] = spec
                    if first_spec is None:
                        first_spec = spec
            stats["damage"] = first_spec or damage_fallback or "1d8+2"
        else:
            stats["damage"] = damage_fallback or "1d8+2"

        coe["stats"] = stats
        coe["base"]  = dict(stats)
        coe["saves"] = saves_out
        coe["thief_mods"] = {}
        coe["banned_weapons"] = {"list": ""}
        coe["skills"] = {"list": ""}

        with open(f"{mon}.coe", "w", encoding="utf-8") as f:
            coe.write(f)


        names, scores = _parse_combatants(bcfg, chan_id)
        d6 = random.randint(1, 6)
        if mon not in names:
            names.append(mon)
        scores[mon] = d6
        _write_combatants(bcfg, chan_id, names, scores)


        try:
            s_el = _slot(mon)
        except Exception:
            s_el = mon.replace(" ", "_")
        bcfg.set(chan_id, f"{s_el}.disp", mon)
        bcfg.set(chan_id, f"{s_el}.hostile", "0")
        bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
        bcfg.set(chan_id, f"{s_el}.minion_type", "callhorseman")


        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
        bcfg.set(chan_id, "join_seq", str(join_seq))
        bcfg.set(chan_id, f"{s_el}.join", str(join_seq))

        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        cap_note = f" (capped by skull level {skull_eff})" if skull_cap is not None else ""
        task_note = f"\nâ€¢ **Task**: {task_text}" if task_text else ""
        return [
            f"ðŸŽƒ **{caster_name}** calls forth a **Headless Horseman**!",
            f"â€¢ **{mon}** (HD **{hd}**{cap_note}, {hp} hp) joins initiative (1d6 â†’ **{d6}**)."
            f"{task_note}",
            "It obeys while you **possess the skull**; it remains until the **task is complete** or **sunrise**, or it is **slain**."
        ]

    def _effect_fingerofdeath(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Finger of Death (Necromancer 7)
          â€¢ One living creature: Save vs Death or die.
          â€¢ On a successful save (or PFED intercept): 3d6 + 1/level damage.
          â€¢ Undead/constructs/golems/oozes unaffected.
        """
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines = ["ðŸ‘‰ **Finger of Death**"]
        if not tokens:
            lines.append("â€¢ *(No target provided.)*")
            return lines

        raw0 = tokens[0]
        if len(tokens) > 1:
            others = ", ".join(tokens[1:])
            lines.append(f"*(Single-target â€” only **{raw0}** is affected; ignoring: {others})*")

        tgt_disp, tgt_path = self._resolve_char_ci_local(raw0)
        if not tgt_path:
            lines.append(f"â€¢ **{raw0}**: âŒ *(not found)*")
            return lines

        t_cfg = read_cfg(tgt_path)
        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp)
        if old_hp is None:
            lines.append(f"â€¢ **{tgt_disp}**: âš ï¸ No HP field â€” cannot resolve.")
            return lines
        if old_hp <= 0:
            lines.append(f"â€¢ **{tgt_disp}**: already â˜ ï¸ **dead**.")
            return lines

        
        def _nonliving_for_fod(rcfg, disp: str):
            try:
                if _is_undead_cfg(rcfg, disp):
                    return True, "Undead â€” no effect"
            except Exception:
                pass
            hay = " ".join([
                get_compat(rcfg, "info", "class", fallback=""),
                get_compat(rcfg, "info", "race",  fallback=""),
                get_compat(rcfg, "base", "type",  fallback=""),
                get_compat(rcfg, "base", "tags",  fallback=""),
                get_compat(rcfg, "stats","type",  fallback=""),
            ]).lower()
            for kw in ("construct", "golem", "animated", "ooze"):
                if kw in hay:
                    return True, "Construct/Golem â€” no effect"
            return False, ""
        immune, why = _nonliving_for_fod(t_cfg, tgt_disp)
        if immune:
            lines.append(f"â€¢ **{tgt_disp}**: {why}.")
            return lines

        
        sv_ok, sv_roll, sv_dc, _ = self._roll_death_save(t_cfg)
        saved = False
        note = ""
        if sv_dc is not None:
            if sv_ok:
                saved = True
                note = f"Save vs Death {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED**"
            else:
                note = f"Save vs Death {sv_roll} vs {sv_dc} â†’ **FAIL**"
        else:
            note = "*(no death save table â€” treating as failed)*"

        
        if not saved:
            used, pfed_note = _pfed_try_absorb_sp(t_cfg, tgt_path, tag="death")
            if used:
                lines.append(f"â€¢ **{tgt_disp}**: {pfed_note}")
                saved = True
                

        if not saved:
            
            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = "0"
            write_cfg(tgt_path, t_cfg)

            
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                    ".paralyzed",".blind",".blind_src",".blind_by",
                                    ".cc_blind_pending",".cs_blind_pending",
                                    ".cc",".cc_by",".cc_level",
                                    ".ck",".ck_by",".ck_level",
                                    ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                    ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass

            try:
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp)
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(0,    mhp, width=10)
                lines.append(f"â€¢ **{tgt_disp}**: {note}\n{before} â†’ **{after}** â˜ ï¸ **DEAD!**")
            except Exception:
                lines.append(f"â€¢ **{tgt_disp}**: {note}\nHP {old_hp} â†’ **0** â˜ ï¸ **DEAD!**")
            return lines

        
        try:
            total, rolls, flat = roll_dice("3d6")
            base = int(total + flat)
            rolls_txt = "[" + ", ".join(str(r) for r in rolls) + "]"
        except Exception:
            rolls = [random.randint(1, 6) for _ in range(3)]
            base = sum(rolls)
            rolls_txt = str(rolls)
        lvl = max(0, int(caster_level or 0))
        raw_damage = base + lvl

        final, mit_note = _apply_mitigation(raw_damage, weapon_name="Finger of Death", weapon_type="unholy", t_cfg=t_cfg)
        old_hp2 = getint_compat(t_cfg, "cur", "hp", fallback=old_hp)
        new_hp = max(0, int(old_hp2) - int(final))
        if not t_cfg.has_section("cur"):
            t_cfg.add_section("cur")
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, t_cfg)

        
        if new_hp <= 0:
            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False
            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                                    ".paralyzed",".blind",".blind_src",".blind_by",
                                    ".cc_blind_pending",".cs_blind_pending",
                                    ".cc",".cc_by",".cc_level",
                                    ".ck",".ck_by",".ck_level",
                                    ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                                    ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass

        try:
            mhp = getint_compat(t_cfg, "max", "hp", fallback=max_hp or old_hp2)
            before = _life_bar(old_hp2, mhp, width=10)
            after  = _life_bar(new_hp,  mhp, width=10)
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            dmg_line = f"**Damage on save:** 3d6{f' {rolls_txt}' if rolls_txt else ''} + {lvl} = **{raw_damage}**"
            if mit_note:
                dmg_line += f" â†’ **{final}** ({mit_note})"
            lines.append(f"â€¢ **{tgt_disp}**: {note}\n{dmg_line}\n{before} â†’ {after}{dead_note}")
        except Exception:
            dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            dmg_line = f"**Damage on save:** 3d6{f' {rolls_txt}' if rolls_txt else ''} + {lvl} = **{raw_damage}**"
            if mit_note:
                dmg_line += f" â†’ **{final}** ({mit_note})"
            lines.append(f"â€¢ **{tgt_disp}**: {note}\n{dmg_line}\nHP {old_hp2} â†’ **{new_hp}**{dead_note}")

        return lines


    async def _precast_spellscroll(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        spell_name: str,
        sid_override: str | None,
    ):
        """
        SpellScroll preflight for !cast -s/-scroll.

        - Finds a carried SpellScroll that matches spell + class
        - Enforces read magic for arcane scrolls
        - Computes failure chance per BFRPG
        - Rolls failure and consumes the spell regardless
        - Sends the scroll embed
        - Returns dict on success, False on failure (already messaged)
        """

        import random
        import nextcord

        reader_class = (get_compat(caster_cfg, "info", "class", fallback="") or "").strip()
        reader_equiv = self._scroll_class_equiv(reader_class, ctx.channel)
        is_arc_reader = self._is_arcane_class(reader_equiv)

        # ---- find scroll record (carried) ----
        chosen_token = None
        rec = None

        if sid_override:
            # NO carry check: just treat the token as the scroll id token
            chosen_token = f"SpellScroll@{sid_override}"

            rec = self._read_scroll_rec(caster_cfg, sid_override)
            if not rec:
                await ctx.send(f"âŒ Scroll **@{sid_override}** not found.")
                return False

            # must contain unspent spell
            want_spell = self._norm(spell_name)
            ok_contains = any(
                self._norm(sp) == want_spell and int(used) == 0
                for sp, used in zip(rec.get("spells", []), rec.get("spent", []))
            )
            if not ok_contains:
                await ctx.send(f"âŒ Scroll **@{sid_override}** does not contain an unused **{spell_name}**.")
                return False

        else:
            # ALSO no carry check when auto-selecting:
            picked = self._pick_carried_scroll_with_spell(
                caster_cfg,
                want_cls=reader_equiv,
                want_spell=spell_name,
                require_readmagic=True,
                carried_only=False,   # <-- change from True to False
            )
            if not picked:
                await ctx.send("âŒ No SpellScroll contains that spell (or it isnâ€™t deciphered).")
                return False
            chosen_token, rec = picked
            sid_override = self._scroll_id_from_token(chosen_token)

            sid_override = self._scroll_id_from_token(chosen_token)

        scroll_cls = rec.get("class", "?")
        scroll_list_class = self._scroll_class_equiv(scroll_cls, ctx.channel)

        # ---- enforce Read Magic (arcane only) ----
        if self._is_arcane_class(scroll_list_class) and not rec.get("readmagic"):
            await ctx.send(f"âŒ Arcane scroll @{sid_override} isnâ€™t deciphered. Use `!readmagic {sid_override}` first.")
            return False

        # ---- compute spell level + failure chance ----
        lvl = None
        try:
            lvl_raw = self._find_spell_level(scroll_list_class, spell_name)
            lvl = self._as_int(lvl_raw)
        except Exception:
            lvl = None

        max_lvl = self._max_spell_level_for_class(caster_cfg, reader_equiv)

        fail = 0
        if is_arc_reader:
            knows = False
            try:
                knows = bool(self._pc_knows_spell(caster_cfg, reader_class, spell_name))
            except Exception:
                knows = False
            if not knows:
                fail += 10

        if lvl is not None and max_lvl is not None and lvl > max_lvl:
            fail += 10 * (lvl - max_lvl)

        roll = random.randint(1, 100)
        ok = (roll > fail)  # fails on â‰¤ fail

        # minimum effective caster level for scroll scaling (classic 2*L-1)
        eff_level = int(getint_compat(caster_cfg, "cur", "level", fallback=1))
        if isinstance(lvl, int) and lvl > 0:
            eff_level = max(eff_level, (2 * lvl) - 1)

        # ---- consume spell regardless (wasted on failure) ----
        self._mark_scroll_spell_spent_and_cleanup(caster_cfg, chosen_token, spell_name)
        try:
            _disp, _path = self._resolve_char_ci(caster_name)
            if _path:
                write_cfg(_path, caster_cfg)
        except Exception:
            pass

        # ---- embed ----
        embed = nextcord.Embed(
            title=f"ðŸ“œ Spell Scroll â€” {scroll_cls}",
            description=f"**{caster_name}** attempts **{spell_name}** from **{chosen_token}**.",
            color=(0x55CC77 if ok else 0xCC5555),
        )
        embed.add_field(
            name="Failure chance",
            value=f"**{fail}%** (roll **{roll}**; fails on â‰¤ **{fail}**)",
            inline=True,
        )
        if lvl is not None:
            embed.add_field(
                name="Spell level",
                value=f"**{lvl}** (your max: **{max_lvl if max_lvl is not None else '?'}**)",
                inline=True,
            )

        # crumble notice
        if not self._read_scroll_rec(caster_cfg, sid_override or ""):
            embed.add_field(
                name="Scroll",
                value="All inscribed spells have been used. The scroll crumbles to dust.",
                inline=False,
            )

        await ctx.send(embed=embed)

        if not ok:
            return False

        return {
            "effective_level": eff_level,
            "list_class": scroll_list_class,
            "sid": sid_override,
        }


    def _prepared_spells_for(self, cfg) -> list[tuple[int, str]]:
        """
        Return [(level, spell_name), ...] from the [prepared] section,
        preserving file order and de-duplicating *by (level, name)* only.
        """
        out = []
        if not cfg.has_section("prepared"):
            return out
        for key, val in cfg.items("prepared"):
            key = key.strip().lower()
            if not key.startswith("l") or not key[1:].isdigit():
                continue
            lvl = int(key[1:])
            names = [s for s in re.split(r"\s+", val.strip()) if s]
            for n in names:
                out.append((lvl, n))
        return out

    def _norm_name(self, s: str) -> str:
        return "".join(ch for ch in (s or "") if ch.isalnum()).lower()

    async def _resolve_prepared_spell_from_partial(
        self, ctx, cfg, token: str, author
    ) -> str | None:
        """
        Among **prepared** spells only:
        - exact CI match â†’ pick it,
        - else substring/startswith â†’ if 1, pick; if >1, show the same paginated menu.
        Returns the chosen spell name, or None on cancel/timeout or no matches.
        """
        token = (token or "").strip()
        if not token:
            return None

        prepared = self._prepared_spells_for(cfg)
        if not prepared:
            return None


        display_rows = []
        raw_names = []
        for lvl, name in prepared:
            display_rows.append(f"{name} (L{lvl})")
            raw_names.append(name)


        exact = [n for n in raw_names if self._norm_name(n) == self._norm_name(token)]
        if len(exact) == 1:
            return exact[0]


        t = token.lower()
        def _pick(cands):

            seen = set()
            opts = []
            for lvl, name in prepared:
                if name in cands:
                    disp = f"{name} (L{lvl})"
                    if disp not in seen:
                        seen.add(disp)
                        opts.append(disp)
            return opts

        subs = [n for n in raw_names if t in n.lower()]
        starts = [n for n in raw_names if n.lower().startswith(t)] if not subs else []
        base = subs or starts

        if not base:
            return None
        if len(set(base)) == 1:

            return list({*base})[0]


        options = _pick(base)
        chosen_disp = await self._prompt_paginated_selection(ctx, author, token, options, timeout_sec=10.0)
        if not chosen_disp:
            await ctx.send("Selection timed out or was cancelled.")
            return None


        m = re.match(r"^(.*)\s+\(L\d+\)\s*$", chosen_disp)
        return m.group(1) if m else chosen_disp

    async def _prompt_paginated_selection(self, ctx, author, query: str, options: list[str], timeout_sec: float = 10.0) -> str | None:
        """
        Show a paginated list (10 per page).
        Returns the chosen option string, or None on cancel/timeout.
        """
        page_size = 10
        total_pages = max(1, math.ceil(len(options) / page_size))
        page = 0
        deadline = asyncio.get_event_loop().time() + timeout_sec
        msg = None

        def make_embed():
            start = page * page_size
            chunk = options[start:start + page_size]
            listing = "\n".join(f"[{idx}] - {name}" for idx, name in enumerate(chunk, start=1))
            emb = nextcord.Embed(
                title="Multiple Matches Found",
                description=f"Your input was: `{query}`\nWhich one were you looking for? (Type the number or `c` to cancel)\n`n` for next page, `p` for previous",
                color=0x5865F2
            )
            emb.add_field(name=f"Page {page+1}/{total_pages}", value=listing or "*No items on this page*", inline=False)
            return emb, len(chunk)

        while True:
            remaining = deadline - asyncio.get_event_loop().time()
            if remaining <= 0:
                return None

            embed, count_on_page = make_embed()
            if msg is None:
                msg = await ctx.send(embed=embed)
            else:
                try:
                    await msg.edit(embed=embed)
                except Exception:
                    msg = await ctx.send(embed=embed)

            def check(m: nextcord.Message) -> bool:
                return (m.author.id == author.id) and (m.channel.id == ctx.channel.id)

            try:
                reply: nextcord.Message = await self.bot.wait_for("message", timeout=remaining, check=check)
            except asyncio.TimeoutError:
                return None

            content = reply.content.strip().lower()
            try:
                await reply.delete()
            except Exception:
                pass

            if content in {"c", "cancel"}:
                return None
            if content in {"n", "next"}:
                page = (page + 1) % total_pages
                continue
            if content in {"p", "prev", "previous"}:
                page = (page - 1) % total_pages
                continue
            if content.isdigit():
                n = int(content)
                if 1 <= n <= count_on_page:
                    start = page * page_size
                    return options[start + (n - 1)]


    @commands.command(name="potion", aliases=["drink"])
    async def drink_potion(self, ctx, *, expr: str = ""):
        """
        Drink or administer a potion to a target.
        Usage:
          !potion <Name> [args...] [flags]
        Examples:
          !potion healing
          !potion poison
          !potion polymorphself wolf
          !potion treasurefinding
          !potion invisibility
          !potion gaseousform
          !potion controlhuman goblin        # immediate charm attempt (1 of up to 3)
          !potion controlhuman               # arm the effect; use attempts later
        Flags:
          -i / -ignore-inv   Use without consuming from inventory (GM freebies / testing)
          -t <name>           Administer to a different creature (defaults to self)
        Notes:
          â€¢ All potion durations are 1d6+6 turns (Ã—60 rounds) unless instantaneous.
          â€¢ Many potions just start a timer and show the description (GM adjudicates).
        """

        if not expr.strip():
            await ctx.send("Usage: `!potion <Name> [args...]` â€” e.g., `!potion healing`, `!potion polymorphself wolf`, `!potion treasurefinding`")
            return


        toks = [t for t in re.split(r"\s+", expr.strip()) if t]
        raw_name = toks[0]
        flags = {t.lower() for t in toks if t.startswith("-")}
        pos   = [t for t in toks[1:] if not t.startswith("-")]

        ignore_inv = ("-i" in flags or "-ignore-inv" in flags)


        target_override = None
        for i, t in enumerate(toks):
            if t.lower() in {"-t", "-target"} and i + 1 < len(toks):
                target_override = toks[i + 1]
                break


        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return

        char_disp, char_path = self._resolve_char_ci(char_name)
        if not char_path or not os.path.exists(char_path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(char_path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return


        canon, item = self._item_lookup(raw_name)
        if not item:

            canon, item = self._item_lookup(re.sub(r"^(potion|potionof)\s+", "", raw_name, flags=re.I))

        if not item:
            await ctx.send(f"âŒ Potion **{raw_name}** not found in item list.")
            return
        if str(item.get("type", "")).lower() != "potion":
            await ctx.send(f"âŒ **{canon}** isnâ€™t a potion.")
            return


        imbiber_name = target_override or char_disp


        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        in_initiative = bool(bcfg and bcfg.has_section(chan_id))

        def _resolve_slot(nm: str) -> tuple[str, str]:
            if not in_initiative:
                return nm, nm.replace(" ", "_")
            names, _ = _parse_combatants(bcfg, chan_id)
            ci = _find_ci_name(names, nm) or nm
            try:
                return ci, _slot(ci)
            except Exception:
                return ci, ci.replace(" ", "_")

        imb_disp, imb_slot = _resolve_slot(imbiber_name)


        d6 = random.randint(1, 6)
        dur_turns = d6 + 6
        dur_rounds = dur_turns * 60



        def _storage_remove(_cfg, canon_name: str) -> None:
            """Remove a canonical item name from the space-separated [item].storage line."""
            try:
                storage = get_compat(_cfg, "item", "storage", fallback="").strip()
                names = [s for s in storage.split() if s]
                names2 = [s for s in names if s.lower() != canon_name.lower()]
                if not _cfg.has_section("item"):
                    _cfg.add_section("item")
                _cfg.set("item", "storage", " ".join(names2))
            except Exception:
                pass

        def _is_carried(_cfg, canon_name: str) -> tuple[bool, str | None, int]:
            """
            Is the item in any carry slot?
            Returns (carried?, slot_key_like_'carry1', qty_int)
            If no explicit qty is present for that slot, treat as 1.
            """
            nm_l = (canon_name or "").strip().lower()  # <-- FIX: define nm_l

            max_slots = getint_compat(_cfg, "eq", "carry", fallback=0)
            try:
                max_slots = int(max_slots)
            except Exception:
                max_slots = 0
            if max_slots <= 0:
                max_slots = 32  # safe fallback

            for i in range(1, max_slots + 1):
                slot = f"carry{i}"
                slot_qty = f"carry{i}_qty"
                val = (get_compat(_cfg, "eq", slot, fallback="") or "").strip()
                if not val:
                    continue

                val_norm = val.split(" (", 1)[0].strip().lower()
                if val_norm == nm_l:
                    q_raw = (get_compat(_cfg, "eq", slot_qty, fallback="") or "").strip()
                    try:
                        qty = int(q_raw) if q_raw else 1
                    except Exception:
                        qty = 1
                    return True, slot, max(1, qty)

            return False, None, 0



        def _dec_carry(_cfg, slot: str, current_qty: int) -> None:
            """Decrease the qty in a carry slot; clear the slot if it hits 0."""
            if not _cfg.has_section("eq"):
                _cfg.add_section("eq")
            if current_qty <= 1:

                _cfg.set("eq", slot, "")
                try:

                    _cfg.remove_option("eq", f"{slot}_qty")
                except Exception:
                    pass
            else:
                _cfg.set("eq", f"{slot}_qty", str(current_qty - 1))

        def _inv_has_and_consume(_cfg, canon_name: str) -> bool:
            """
            Return True if present and consume one dose:
              â€¢ Requires the item be in a carry slot (unless -i).
              â€¢ Tries your shared helper with multiple casings/normalizations.
              â€¢ Falls back to a local decrement if needed.
            """
            if ignore_inv:
                return True

            def _norm(s: str) -> str:
                return re.sub(r"[^a-z0-9]+", "", str(s).lower())

            tried = set()
            candidates = [
                canon_name,
                canon_name.lower(),
                _norm(canon_name),
                _norm(raw_name),
                raw_name.lower(),
                raw_name,
            ]


            if hasattr(self, "_consume_one_and_recalc"):
                for cand in candidates:
                    k = cand.strip()
                    if not k or k in tried:
                        continue
                    tried.add(k)
                    try:
                        if self._consume_one_and_recalc(_cfg, k):
                            return True
                    except Exception:
                        pass


            lname = canon_name.lower()
            possible_keys = [lname, _norm(canon_name)]
            for key in possible_keys:
                count = getint_compat(_cfg, "item", key, fallback=None)
                if isinstance(count, int) and count > 0:
                    if not _cfg.has_section("item"):
                        _cfg.add_section("item")
                    _cfg.set("item", key, str(count - 1))


                    carried, slot, qty = _is_carried(_cfg, canon_name)
                    if carried:
                        _dec_carry(_cfg, slot, qty)


                    if count - 1 <= 0:
                        storage = (get_compat(_cfg, "item", "storage", fallback="") or "").split()
                        storage = [t for t in storage if t.lower() != canon_name.lower()]
                        _cfg.set("item", "storage", " ".join(storage))

                    try:
                        self._recalc_carry_weight(_cfg)
                    except Exception:
                        pass
                    return True

            return False

        def _start_timer(
            tag: str,
            label: str,
            code: str,
            emoji: str = "â±ï¸",
            rounds: int | None = None,
            by: str | None = None,
        ) -> bool:
            """
            Start an x_* effect timer on the imbiber's slot (initiative tracker).
            Returns True if the timer was written, False otherwise.
            """
            nonlocal bcfg
            if not in_initiative or not bcfg or not bcfg.has_section(chan_id):
                return False

            try:
                r = int(max(0, rounds if rounds is not None else dur_rounds))
            except Exception:
                r = int(max(0, dur_rounds))

            who = by or char_disp
            try:
                bcfg.set(chan_id, f"{imb_slot}.x_{tag}", str(r))
                bcfg.set(chan_id, f"{imb_slot}.x_{tag}_label", label)
                bcfg.set(chan_id, f"{imb_slot}.x_{tag}_code", code)
                bcfg.set(chan_id, f"{imb_slot}.x_{tag}_emoji", emoji)
                bcfg.set(chan_id, f"{imb_slot}.x_{tag}_by", who)
                _save_battles(bcfg)
                return True
            except Exception:
                return False

        async def _refresh_tracker():
            try:
                if in_initiative and bcfg and bcfg.has_section(chan_id):

                    await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


        if not ignore_inv:
            carried, _, _ = _is_carried(cfg, canon)
            if not carried:
                await ctx.send(f"âŒ You must be **carrying** **{canon}** to drink it. "
                               f"(Put it in a carry slot first.)")
                return


        if not _inv_has_and_consume(cfg, canon):
            await ctx.send(f"âŒ **{canon}** isnâ€™t available to drink. "
                           f"(It must be in a carry slot and present in your inventory. "
                           f"Use `-i` to bypass for DM/testing.)")
            return


        write_cfg(char_path, cfg)


        key = re.sub(r"[^a-z0-9]+", "", canon.lower())


        title = f"{char_disp} drinks **{canon}**!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))

        def _add_desc():
            desc = str(item.get("desc", "")).strip()
            if desc:
                embed.add_field(name="Description", value=(desc[:900] + ("â€¦" if len(desc) > 900 else "")), inline=False)

        timer_started_note = None


        if key == "healing":
            roll = random.randint(1, 6) + 1
            cur = getint_compat(cfg, "cur", "hp", fallback=0)
            mx  = getint_compat(cfg, "max", "hp", fallback=max(1, cur))
            new = min(mx, cur + roll)
            if not cfg.has_section("cur"):
                cfg.add_section("cur")
            cfg.set("cur", "hp", str(new))
            write_cfg(char_path, cfg)
            embed.add_field(name="Effect", value=f"ðŸ’— Heals **{roll}** HP: {cur} â†’ **{new}**.", inline=False)
            _add_desc()
            await ctx.send(embed=embed)
            return

        if key == "poison":
            ok, roll, dc, _ = self._roll_save(cfg, vs="pois", penalty=0)
            face = "**20** ðŸŽ‰" if roll == 20 else ("**1** ðŸ’€" if roll == 1 else str(roll))
            if ok:
                embed.add_field(name="Effect", value=f"â˜ ï¸ Save vs Poison: {face} â‰¥ **{dc}** â†’ **RESISTED**", inline=False)
            else:
                old = getint_compat(cfg, "cur", "hp", fallback=0)
                if not cfg.has_section("cur"):
                    cfg.add_section("cur")
                cfg.set("cur", "hp", "0")
                write_cfg(char_path, cfg)
                embed.add_field(name="Effect", value=f"â˜ ï¸ Save vs Poison: {face} < **{dc}** â†’ **DEAD** (HP {old} â†’ **0**).", inline=False)
            _add_desc()
            await ctx.send(embed=embed)
            return

        if key == "longevity":
            yrs = random.randint(1, 10)
            age_raw = get_compat(cfg, "info", "age", fallback="")
            try:
                age = int(str(age_raw).strip())
            except Exception:
                age = None
            if age is not None:
                new_age = max(1, age - yrs)
                if not cfg.has_section("info"):
                    cfg.add_section("info")
                cfg.set("info", "age", str(new_age))
                write_cfg(char_path, cfg)
                embed.add_field(name="Effect", value=f"â³ Youth returns! **-{yrs} years** â†’ age **{new_age}**.", inline=False)
            else:
                embed.add_field(name="Effect", value=f"â³ Youth returns! **-{yrs} years** (age field not found).", inline=False)
            _add_desc()
            await ctx.send(embed=embed)
            return


        if key == "gaseousform":
            if in_initiative:
                bcfg.set(chan_id, f"{imb_slot}.gas", str(dur_rounds))
                bcfg.set(chan_id, f"{imb_slot}.gas_by", char_disp)
                _save_battles(bcfg)
                timer_started_note = f"[GAS {dur_rounds}] on **{imb_disp}**"
            embed.add_field(name="Effect", value="ðŸŒ«ï¸ Becomes insubstantial mist. (Casting blocked while active.)", inline=False)
            _add_desc()
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return

        if key == "invisibility":
            if in_initiative:
                bcfg.set(chan_id, f"{imb_slot}.inv", str(dur_rounds))
                bcfg.set(chan_id, f"{imb_slot}.inv_type", "norm")
                bcfg.set(chan_id, f"{imb_slot}.inv_by", char_disp)
                _save_battles(bcfg)
                timer_started_note = f"[IV {dur_rounds}] on **{imb_disp}**"
            embed.add_field(name="Effect", value="ðŸ«¥ Turns invisible (normal). Casting ends it.", inline=False)
            _add_desc()
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        if key == "polymorphself":
            if not pos:
                await ctx.send("âŒ Usage: `!potion PolymorphSelf <Form>`")
                return
            form = pos[0]

            lines = self._cast_polymorph(ctx, cfg, char_disp, getint_compat(cfg, "cur", "level", fallback=1), [form], "PolymorphSelf")
            if isinstance(lines, list) and lines and str(lines[0]).startswith("âŒ"):
                await ctx.send("\n".join(lines))
                return
            if in_initiative:
                try:
                    bcfg.set(chan_id, f"{imb_slot}.ps", str(dur_rounds))
                    bcfg.set(chan_id, f"{imb_slot}.ps_by", char_disp)
                    _save_battles(bcfg)
                    timer_started_note = f"[PS {dur_rounds}] on **{imb_disp}**"
                except Exception:
                    pass
            embed.add_field(name="Effect", value=f"âœ¨ Polymorph Self into **{form}**.", inline=False)
            embed.add_field(name="Duration", value=f"**{dur_turns} turns** ({dur_rounds} rounds).", inline=True)
            _add_desc()
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        control_map = {
            "controlhuman":  ("humanoid", 3, "CH"),
            "controlanimal": ("animal",   3, "CA"),
            "controlgiant":  ("giant",    3, "CG"),
            "controldragon": ("dragon",   3, "CD"),
            "controlplant":  ("plant",    3, "CP"),
            "controlundead": ("undead",   3, "CU"),
        }
        if key in control_map:
            kind, charges, code = control_map[key]
            effect_lines = {
                "controlhuman":  ("ðŸ§¿ Grants the power to control **humanoids** by gaze.\n"
                                  "Up to **3 attempts** (this dose) while it lasts.\n"
                                  "Use `!a controlhuman <target>` to attempt control."),
                "controlanimal": ("ðŸ§¿ Grants the power to control **normal, non-magical animals** by gaze.\n"
                                  "Up to **3 attempts** (this dose).\n"
                                  "Use `!a controlanimal <target>` to attempt control."),
                "controlgiant":  ("ðŸ§¿ Grants the power to control **giants** by gaze.\n"
                                  "Up to **3 attempts** (this dose).\n"
                                  "Use `!a controlgiant <target>` to attempt control."),
                "controldragon": ("ðŸ§¿ Grants the power to control **dragons** by gaze.\n"
                                  "Up to **3 attempts** (this dose).\n"
                                  "Use `!a controldragon <target>` to attempt control."),
                "controlplant":  ("ðŸ§¿ Grants the power to command **plant creatures** (save negates).\n"
                                  "Normal plants are GM-adjudicated.\n"
                                  "Up to **3 attempts** (this dose).\n"
                                  "Use `!a controlplant <target>` to attempt control."),
                "controlundead": ("ðŸ§¿ Grants the power to **command undead**.\n"
                                  "Each activation (attempt) rolls a **3d6 HD pool**; saves apply.\n"
                                  "Up to **3 activations** (this dose).\n"
                                  "Use `!a controlundead <targets...>` to attempt control."),
            }

            immediate_txt = ""
            if pos:
                if key == "controlhuman":
                    out = self._effect_charmperson(ctx, cfg, char_disp, getint_compat(cfg, "cur", "level", fallback=1), pos)
                    immediate_txt = "\n".join(out.splitlines()[:10]) if isinstance(out, str) else (str(out) if out else "")
                    charges -= 1
                else:
                    immediate_txt = f"Targets **{pos[0]}**. (Control-{kind.capitalize()} attempt; GM adjudicates.)"
                    charges -= 1

            if in_initiative:
                bcfg.set(chan_id, f"{imb_slot}.x_{key}", str(dur_rounds))
                bcfg.set(chan_id, f"{imb_slot}.x_{key}_label", f"Control {kind.capitalize()}")
                bcfg.set(chan_id, f"{imb_slot}.x_{key}_code", code)
                bcfg.set(chan_id, f"{imb_slot}.x_{key}_emoji", "ðŸ§¿")
                bcfg.set(chan_id, f"{imb_slot}.x_{key}_by", char_disp)
                bcfg.set(chan_id, f"{imb_slot}.{key}_uses", str(max(0, charges)))
                _save_battles(bcfg)
                timer_started_note = f"[{code} {dur_rounds}] on **{imb_disp}** â€” uses left: **{max(0, charges)}**"

            embed.add_field(name="Effect", value=effect_lines[key], inline=False)

            if immediate_txt:
                embed.add_field(name="Attempt", value=immediate_txt[:900], inline=False)
            _add_desc()
            if timer_started_note:
                embed.add_field(name="Timer", value=timer_started_note, inline=False)
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        if key == "treasurefinding":
            started = _start_timer("treasurefinding", "Treasure Finding", "TF", "ðŸ§­")
            embed.add_field(
                name="Effect",
                value="ðŸ§­ Knows the direction & approx. distance to the **largest coin hoard** within 300'.",
                inline=False
            )
            embed.add_field(name="Duration", value=f"**{dur_turns} turns** ({dur_rounds} rounds).", inline=True)
            _add_desc()
            if started:
                embed.add_field(name="Timer", value=f"Started **[TF {dur_rounds}]** on **{imb_disp}**.", inline=False)
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        manual_tags = {
            "clairaudience": ("Clairaudience", "CAU", "ðŸ‘‚"),
            "clairvoyance":  ("Clairvoyance",  "CVY", "ðŸ”®"),
            "coldresistance":("Resist Cold",   "RC",  "ðŸ§Š"),
            "fireresistance":("Resist Fire",   "RF",  "ðŸ”¥"),
            "flying":        ("Fly",           "FL",  "ðŸª½"),
            "levitation":    ("Levitate",      "LV",  "ðŸª„"),
            "mindreading":   ("Mind Reading",  "MR",  "ðŸ§ "),
            "speed":         ("Haste",         "HS",  "ðŸ’¨"),
            "diminution":    ("Diminution",    "DM",  "ðŸ”»"),
            "giantstrength": ("Giant Strength","GS",  "ðŸ’ª"),
            "growth":        ("Growth",        "GR",  "â¬†ï¸"),
            "invulnerability":("Invulnerability","+AC","ðŸ›¡ï¸"),
            "heroism":       ("Heroism",       "HR",  "ðŸ…"),
        }
        if key in manual_tags:
            label, code, emoji = manual_tags[key]
            started = _start_timer(key, f"{label} (Potion)", code, emoji)
            if key == "giantstrength" and in_initiative:
                bcfg.set(chan_id, f"{imb_slot}.gs_bonus", "5")
                _save_battles(bcfg)
            if key == "growth" and in_initiative:
                bcfg.set(chan_id, f"{imb_slot}.growth_bonus", "5")
                _save_battles(bcfg)

            if key == "invulnerability" and in_initiative:

                bcfg.set(chan_id, f"{imb_slot}.pot_ac", "2")
                _save_battles(bcfg)
                embed.add_field(name="Bonus", value="ðŸ›¡ï¸ **+2 AC** (while potion lasts)", inline=False)


            if key == "heroism":

                lvl = getint_compat(cfg, "cur", "level", fallback=1)
                cls = (get_compat(cfg, "info", "class", fallback="") or "").lower()
                is_fighter = "fighter" in cls and "mage" not in cls and "magic" not in cls\
                             and "cleric" not in cls and "thief" not in cls

                if is_fighter and 1 <= lvl <= 3:
                    atk_bonus, thp_dice = 3, (3, 8)
                elif is_fighter and lvl in (4, 5):
                    atk_bonus, thp_dice = 2, (2, 8)
                elif is_fighter and lvl in (6, 7):
                    atk_bonus, thp_dice = 1, (1, 8)
                else:
                    atk_bonus, thp_dice = 1, None

                if in_initiative:
                    bcfg.set(chan_id, f"{imb_slot}.atkmod_heroism", str(atk_bonus))
                    _save_battles(bcfg)


                if thp_dice and in_initiative:
                    n, d = thp_dice
                    thp = sum(random.randint(1, d) for _ in range(n))


                    try:
                        rounds_key, pool_key, by_key = _stone_keys(imb_slot)
                    except Exception:
                        rounds_key = f"{imb_slot}.ss_rounds"
                        pool_key   = f"{imb_slot}.ss_pool"
                        by_key     = f"{imb_slot}.ss_by"


                    replaced = bcfg.has_option(chan_id, pool_key) or bcfg.has_option(chan_id, rounds_key)
                    bcfg.set(chan_id, rounds_key, str(int(dur_rounds)))
                    bcfg.set(chan_id, pool_key,   str(int(thp)))
                    bcfg.set(chan_id, by_key,     char_disp)


                    for alias in (f"{imb_slot}.sspool", f"{imb_slot}.ssbuf", f"{imb_slot}.stoneskin", f"{imb_slot}.ss"):
                        try:
                            bcfg.set(chan_id, alias, str(int(thp)))
                        except Exception:
                            pass

                    _save_battles(bcfg)

                    repl_txt = " Previous buffer **replaced**." if replaced else ""
                    embed.add_field(
                        name="Temp HP",
                        value=f"ðŸª¨ **{thp}** temporary HP *(Stoneskin-style; attacks only)* â€” lasts while **Heroism** lasts.{repl_txt}",
                        inline=False
                    )

                embed.add_field(name="Bonus", value=f"**+{atk_bonus} to attack rolls** (while potion lasts)", inline=False)


            if started:
                timer_started_note = f"Started **[{code} {dur_rounds}]** on **{imb_disp}**."
            embed.add_field(name="Effect", value=f"{emoji} **{label}** is active.", inline=False)
            embed.add_field(name="Duration", value=f"**{dur_turns} turns** ({dur_rounds} rounds).", inline=True)
            _add_desc()
            if timer_started_note:
                embed.add_field(name="Timer", value=timer_started_note, inline=False)
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        tag = re.sub(r"[^a-z0-9]+", "", canon.lower())
        code = _two_letter(canon)
        lbl  = f"{canon} (Potion)"
        started = _start_timer(tag, lbl, code, "â±ï¸")
        embed.add_field(name="Effect", value=f"ðŸ§ª {canon} effect begins.", inline=False)
        embed.add_field(name="Duration", value=f"**{dur_turns} turns** ({dur_rounds} rounds).", inline=True)
        _add_desc()
        if started:
            embed.add_field(name="Timer", value=f"Started **[{code} {dur_rounds}]** on **{imb_disp}**.", inline=False)
        await ctx.send(embed=embed)
        await _refresh_tracker()

    def _item_lookup(self, key: str):
        """
        Return (canon_name, item_dict) or (None, None).
        Tries exact, case-insensitive, and normalized lookups.
        """
        if not key:
            return None, None
        k = key.strip()

        if k in self.items:
            return k, self.items[k]
        for nm in self.items.keys():
            if nm.lower() == k.lower():
                return nm, self.items[nm]

        norm = self._norm(k)
        canon = self._index.get(k) or self._index.get(k.lower()) or self._index.get(norm)
        if canon and canon in self.items:
            return canon, self.items[canon]

        for nm in self.items.keys():
            if self._norm(nm) == norm:
                return nm, self.items[nm]
        return None, None

    def _item_ac(self, item: dict) -> int | None:
        v = item.get("AC") if "AC" in item else item.get("ac")
        if v is None or str(v).strip() == "":
            return None
        try:
            return int(str(v).strip())
        except Exception:
            return None

    def _item_weight(self, item: dict) -> float:
        """Return the item weight as a float. Accepts 'weight', 'wt', or 'w'."""
        for k in ("weight", "wt", "w"):
            if k in item:
                try:
                    return float(str(item[k]).strip())
                except Exception:
                    pass
        return 0.0

    @commands.command(name="read", aliases=["scroll", "use_scroll"])
    async def read_scroll(self, ctx, *, expr: str = ""):
        """
        Read a scroll (consumes it unless -i). These are manual auras the GM adjudicates.
        Usage:
          !read elementalprotectionscroll
          !read protectionfrommagic
          !read undeadprotection -t ally
        Flags:
          -i / -ignore-inv   Do not consume from inventory
          -t <name>           Someone else reads the scroll
        Spell Scrolls: !read <SpellName> [-s <id>] [spell args...]
        Example: !read Haste -s 5    (uses SpellScroll@5)
        If -s omitted and exactly one carried matching scroll exists, system will auto-pick it.
        """

        if not expr.strip():
            await ctx.send("Usage: `!read <ScrollName>` â€” e.g., `!read elementalprotection`, `!read protectionfrommagic`")
            return


        toks = [t for t in re.split(r"\s+", expr.strip()) if t]
        raw_name = toks[0]
        flags = {t.lower() for t in toks if t.startswith("-")}
        pos   = [t for t in toks[1:] if not t.startswith("-")]

        ignore_inv = ("-i" in flags or "-ignore-inv" in flags)


        def _looks_manual_scroll_key(k: str) -> bool:
            k = self._norm(k)
            return k in {
                "elementalprotectionscroll", "lycanthropeprotectionscroll",
                "undeadprotectionscroll", "magicprotectionscroll", "cursedscroll"
            }



        force_spell_mode = any(t.lower() in {"-s", "-scroll"} for t in toks)
        maybe_spell_mode = not _looks_manual_scroll_key(raw_name)


        target_override = None
        for i, t in enumerate(toks):
            if t.lower() in {"-t", "-target"} and i + 1 < len(toks):
                target_override = toks[i + 1]
                break


        char_name = get_active(ctx.author.id)
        if not char_name:
            await ctx.send("âŒ No active character. Use `!char <name>` first.")
            return

        char_disp, char_path = self._resolve_char_ci(char_name)
        if not char_path or not os.path.exists(char_path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(char_path)
        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if owner_id and owner_id != str(ctx.author.id):
            await ctx.send(f"âŒ You do not own **{char_name}**.")
            return

        if force_spell_mode or maybe_spell_mode:
            ok = await self._read_spell_from_scroll(ctx, cfg, char_disp, toks)
            if ok is not None:
                return


        def _norm(s: str) -> str:
            return re.sub(r"[^a-z0-9]+", "", s.lower())


        alias = {
            "elementalprotection":       "ElementalProtectionScroll",
            "elementalprotectionscroll": "ElementalProtectionScroll",
            "protectionfromelementals":  "ElementalProtectionScroll",

            "lycanthropeprotection":       "LycanthropeProtectionScroll",
            "lycanthropeprotectionscroll": "LycanthropeProtectionScroll",
            "protectionfromlycanthropes":  "LycanthropeProtectionScroll",

            "undeadprotection":       "UndeadProtectionScroll",
            "undeadprotectionscroll": "UndeadProtectionScroll",
            "protectionfromundead":   "UndeadProtectionScroll",

            "magicprotection":       "MagicProtectionScroll",
            "magicprotectionscroll": "MagicProtectionScroll",
            "protectionfrommagic":   "MagicProtectionScroll",

            "cursed":       "CursedScroll",
            "cursedscroll": "CursedScroll",
        }
        raw_key = _norm(raw_name)
        canon_guess = alias.get(raw_key)


        canon, item = (None, None)
        if canon_guess:
            canon, item = self._item_lookup(canon_guess)
        if not item:

            canon, item = self._item_lookup(raw_name)
        if not item:
            canon, item = self._item_lookup(re.sub(r"^(scroll|scrollof)\s*", "", raw_name, flags=re.I) + "Scroll")

        if not item:
            await ctx.send(f"âŒ Scroll **{raw_name}** not found in item list.")
            return
        if str(item.get("type", "")).lower() != "scroll":
            await ctx.send(f"âŒ **{canon}** isnâ€™t a scroll.")
            return


        reader_name = target_override or char_disp


        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        in_initiative = bool(bcfg and bcfg.has_section(chan_id))

        def _resolve_slot(nm: str) -> tuple[str, str]:
            if not in_initiative:
                return nm, nm.replace(" ", "_")
            names, _ = _parse_combatants(bcfg, chan_id)
            ci = _find_ci_name(names, nm) or nm
            try:
                return ci, _slot(ci)
            except Exception:
                return ci, ci.replace(" ", "_")

        rd_disp, rd_slot = _resolve_slot(reader_name)

        async def _refresh_tracker():
            try:
                if in_initiative and bcfg and bcfg.has_section(chan_id):
                    await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass



        def _storage_remove(_cfg, canon_name: str):
            try:
                storage = get_compat(_cfg, "item", "storage", fallback="").strip()
                names = [s for s in storage.split() if s]
                names2 = [s for s in names if s.lower() != canon_name.lower()]
                if not _cfg.has_section("item"):
                    _cfg.add_section("item")
                _cfg.set("item", "storage", " ".join(names2))
            except Exception:
                pass

        def _inv_has_and_consume(_cfg, canon_name: str) -> bool:
            """
            Return True if present and consume one dose:
              â€¢ Requires the item be in a carry slot (unless -i).
              â€¢ Tries your shared helper with both casings.
              â€¢ Falls back to a local decrement of [item] and carry slot.
            """
            if ignore_inv:
                return True


            ok = False
            if hasattr(self, "_consume_one_and_recalc"):
                try:
                    ok = bool(self._consume_one_and_recalc(_cfg, canon_name))
                except Exception:
                    ok = False
                if not ok:
                    try:
                        ok = bool(self._consume_one_and_recalc(_cfg, canon_name.lower()))
                    except Exception:
                        ok = False
            if ok:
                return True


            lname = canon_name.lower()
            count = getint_compat(_cfg, "item", lname, fallback=0)
            if count <= 0:
                return False

            if not _cfg.has_section("item"):
                _cfg.add_section("item")

            new_count = count - 1
            _cfg.set("item", lname, str(new_count))


            if new_count <= 0:
                storage = (get_compat(_cfg, "item", "storage", fallback="") or "").split()
                storage = [t for t in storage if t.lower() != canon_name.lower()]
                _cfg.set("item", "storage", " ".join(storage))


            self._consume_carried_item(_cfg, canon_name, qty=1)



            try:
                self._recalc_carry_weight(_cfg)
            except Exception:
                pass

            return True



        if not ignore_inv:
            if not self._consume_one_anywhere_and_recalc(cfg, canon):
                await ctx.send(f"âŒ You donâ€™t have an unused **{canon}** in your inventory.")
                return

        write_cfg(char_path, cfg)


        def _start_timer(tag: str, label: str, code: str, rounds: int, emoji: str = "ðŸ›¡ï¸") -> bool:
            if not in_initiative or not bcfg or not bcfg.has_section(chan_id):
                return False
            try:
                bcfg.set(chan_id, f"{rd_slot}.x_{tag}", str(int(max(0, rounds))))
                bcfg.set(chan_id, f"{rd_slot}.x_{tag}_label", label)
                bcfg.set(chan_id, f"{rd_slot}.x_{tag}_code", code)
                bcfg.set(chan_id, f"{rd_slot}.x_{tag}_emoji", emoji)
                bcfg.set(chan_id, f"{rd_slot}.x_{tag}_by", char_disp)
                _save_battles(bcfg)
                return True
            except Exception:
                return False


        title = f"{rd_disp} reads **{canon}**!"
        embed = nextcord.Embed(title=title, color=random.randint(0, 0xFFFFFF))
        def _add_desc():
            desc = str(item.get("desc", "")).strip()
            if desc:
                embed.add_field(name="Description", value=(desc[:900] + ("â€¦" if len(desc) > 900 else "")), inline=False)


        key = _norm(canon)


        timer_note = None


        if key in {"elementalprotectionscroll", "lycanthropeprotectionscroll", "undeadprotectionscroll"}:
            dur_rounds = 120
            if key == "elementalprotectionscroll":
                started = _start_timer("prot_elementals", "Protection from Elementals (Scroll)", "PE", dur_rounds)
            elif key == "lycanthropeprotectionscroll":
                started = _start_timer("prot_lycan", "Protection from Lycanthropes (Scroll)", "PL", dur_rounds)
            else:
                started = _start_timer("prot_undead", "Protection from Undead (Scroll)", "PU", dur_rounds)

            embed.add_field(name="Effect", value="A 10â€™ radius protection circle surrounds the reader and moves with them. GM adjudicates entry & breaking conditions.", inline=False)
            embed.add_field(name="Duration", value=f"**2 turns** ({dur_rounds} rounds).", inline=True)
            _add_desc()
            if started:
                code = "PE" if "elemental" in key else ("PL" if "lycan" in key else "PU")
                timer_note = f"Started **[{code} {dur_rounds}]** on **{rd_disp}**."
                embed.add_field(name="Timer", value=timer_note, inline=False)
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        if key == "magicprotectionscroll":
            d4 = random.randint(1, 4)
            dur_turns = d4
            dur_rounds = dur_turns * 60
            started = _start_timer("prot_magic", "Protection from Magic (Scroll)", "PM", dur_rounds)
            embed.add_field(name="Effect", value="No magical effects cross the 10â€™ circle in either direction. GM adjudicates.", inline=False)
            embed.add_field(name="Duration", value=f"**{dur_turns} turn(s)** ({dur_rounds} rounds).", inline=True)
            _add_desc()
            if started:
                embed.add_field(name="Timer", value=f"Started **[PM {dur_rounds}]** on **{rd_disp}**.", inline=False)
            await ctx.send(embed=embed)
            await _refresh_tracker()
            return


        if key == "cursedscroll":
            embed.add_field(
                name="Effect",
                value="âš ï¸ A malign enchantment lashes out at the reader. GM applies a fitting curse (usually Save vs Spells allowed).",
                inline=False
            )
            _add_desc()
            await ctx.send(embed=embed)
            return


        dur_rounds = 120
        tag = f"scroll_{_norm(canon)}"
        code = (_norm(canon)[:2] or "SC").upper()
        started = _start_timer(tag, f"{canon} (Scroll)", code, dur_rounds, "ðŸ“œ")
        embed.add_field(name="Effect", value="ðŸ“œ The scrollâ€™s magic takes effect. (GM adjudicates specifics.)", inline=False)
        embed.add_field(name="Duration", value=f"**2 turns** ({dur_rounds} rounds).", inline=True)
        _add_desc()
        if started:
            embed.add_field(name="Timer", value=f"Started **[{code} {dur_rounds}]** on **{rd_disp}**.", inline=False)
        await ctx.send(embed=embed)
        await _refresh_tracker()

    def _recalc_carry_weight(self, cfg) -> float:
        """
        Recompute total weight of everything in carry slots and store it back to cfg.
        Uses your item DB to get per-item weight. Writes [eq].carry_wt (float string).
        """
        total = 0.0
        try:

            for _idx, slot_key, nm, q in self._iter_carried_slots(cfg):
                canon, it = self._item_lookup(nm) if hasattr(self, "_item_lookup") else (nm, None)
                wt = self._item_weight(it) if it else 0.0
                qty = max(1, int(q or 1))
                total += wt * qty
        except Exception:

            for i in range(1, 9):
                nm = (get_compat(cfg, "eq", f"carry{i}", fallback="") or "").strip()
                if not nm:
                    continue
                try:
                    qty = int((get_compat(cfg, "eq", f"carry{i}_qty", fallback="") or "1").strip() or "1")
                except Exception:
                    qty = 1
                canon, it = self._item_lookup(nm) if hasattr(self, "_item_lookup") else (nm, None)
                wt = self._item_weight(it) if it else 0.0
                total += wt * max(1, qty)

        if not cfg.has_section("eq"):
            cfg.add_section("eq")
        cfg.set("eq", "carry_wt", f"{total:.2f}")
        return total

    def _iter_carried_slots(self, cfg):
        """
        Yield (index, slot_key, item_name, qty) for all non-empty carry slots.
        Slots are carry1..carry8 with optional carryX_qty.
        """
        for i in range(1, 9):
            slot = f"carry{i}"
            val = (get_compat(cfg, "eq", slot, fallback="") or "").strip()
            if not val:
                continue
            q_raw = (get_compat(cfg, "eq", f"{slot}_qty", fallback="") or "").strip()
            try:
                qty = int(q_raw) if q_raw else 1
            except Exception:
                qty = 1
            yield (i, slot, val, max(1, qty))


    def _has_item_anywhere(self, cfg, token: str) -> bool:
        """True if token is in counts (either key form), storage, or a carry slot."""

        sid = self._scroll_id_from_token(token)
        if sid:
            sect = f"scroll:{sid}"
            if any(s == sect for s in cfg.sections()):
                return True
        t_norm  = self._norm(token)
        t_lower = (token or "").strip().lower()


        try:
            cnt = int(str(get_compat(cfg, "item", t_lower, fallback="") or "0").strip() or "0")
            if cnt <= 0:
                cnt = int(str(get_compat(cfg, "item", t_norm,  fallback="") or "0").strip() or "0")
        except Exception:
            cnt = 0
        if cnt > 0:
            return True


        storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
        if any(self._norm(s) == t_norm or s.strip().lower() == t_lower for s in storage):
            return True


        for _i, _slot, nm, _q in self._iter_carried_slots(cfg):
            if self._norm(nm) == t_norm or (nm or "").strip().lower() == t_lower:
                return True
        return False

    def _consume_one_anywhere_and_recalc(self, cfg, token: str) -> bool:
        t_norm  = self._norm(token)
        t_lower = (token or "").strip().lower()


        if not self._has_item_anywhere(cfg, token):
            return False


        carried = False
        for _i, _slot, nm, _q in self._iter_carried_slots(cfg):
            if self._norm(nm) == t_norm or (nm or "").strip().lower() == t_lower:
                carried = True
                break
        if carried:
            if hasattr(self, "_consume_carried_item") and callable(self._consume_carried_item):
                self._consume_carried_item(cfg, token, qty=1)
            else:
                self._consume_carried_item_fallback(cfg, token, qty=1)

        if not cfg.has_section("item"):
            cfg.add_section("item")


        raw_lower = str(get_compat(cfg, "item", t_lower, fallback="") or "").strip()
        raw_norm  = str(get_compat(cfg, "item", t_norm,  fallback="") or "").strip()
        key_used  = t_lower if raw_lower else (t_norm if raw_norm else None)
        raw       = raw_lower or raw_norm

        if raw.isdigit():
            n = max(0, int(raw) - 1)
            if n > 0:
                cfg.set("item", key_used, str(n))
            else:
                try: cfg.remove_option("item", key_used)
                except Exception: pass

                storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
                storage = [s for s in storage if self._norm(s) != t_norm and s.strip().lower() != t_lower]
                cfg.set("item", "storage", " ".join(storage))
        else:
            storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
            storage = [s for s in storage if self._norm(s) != t_norm and s.strip().lower() != t_lower]
            cfg.set("item", "storage", " ".join(storage))


        self._recalc_carry_weight(cfg)
        return True

    def _consume_one_and_recalc(self, cfg, canon_name: str) -> bool:
        """
        Consume one carried item named canon_name:
          â€¢ Uses your _consume_carried_item(...) to compact slots
          â€¢ Decrements [item] counts/storage
          â€¢ Recalculates carry weight
        Returns True if successful.
        """

        ok = False
        try:
            ok = self._consume_carried_item(cfg, canon_name, qty=1)
        except Exception:

            ok = False
        if not ok:
            return False


        try:
            if not cfg.has_section("item"):
                cfg.add_section("item")
            k = canon_name.lower()
            if cfg.has_option("item", k):
                try:
                    n = int(str(cfg.get("item", k)).strip())
                except Exception:
                    n = 1
                n = max(0, n - 1)
                if n <= 0:
                    try:
                        cfg.remove_option("item", k)
                    except Exception:
                        pass

                    storage = (get_compat(cfg, "item", "storage", fallback="") or "").strip()
                    names = [s for s in storage.split() if s]
                    names = [s for s in names if s.lower() != canon_name.lower()]
                    cfg.set("item", "storage", " ".join(names))
                else:
                    cfg.set("item", k, str(n))
            else:

                storage = (get_compat(cfg, "item", "storage", fallback="") or "").strip()
                names = [s for s in storage.split() if s]
                if any(s.lower() == canon_name.lower() for s in names):
                    names = [s for s in names if s.lower() != canon_name.lower()]
                    cfg.set("item", "storage", " ".join(names))
        except Exception:
            pass


        try:
            self._recalc_carry_weight(cfg)
        except Exception:
            pass

        return True

    def _consume_carried_item_fallback(self, cfg, canon_name: str, qty: int = 1) -> bool:
        """
        Remove qty of canon_name from carry slots and compact them (fallback impl).
        """
        want = self._norm(canon_name)
        need = max(1, int(qty))
        kept = []
        for _idx, slot_key, nm, q in self._iter_carried_slots(cfg):
            if self._norm(nm) == want and need > 0:
                take = min(q, need)
                q -= take
                need -= take
            if q > 0:
                kept.append((nm, q))
        if need > 0:
            return False

        if not cfg.has_section("eq"):
            cfg.add_section("eq")


        try:
            for opt, _ in list(cfg.items("eq")):
                if opt.startswith("carry"):
                    cfg.remove_option("eq", opt)
        except Exception:
            pass


        i = 1
        for nm, q in kept:
            cfg.set("eq", f"carry{i}", nm)
            if int(q) != 1:
                cfg.set("eq", f"carry{i}_qty", str(int(q)))
            i += 1
        return True


    @commands.command(name="addscroll")
    async def addscroll(self, ctx, who: str, cls: str, *, spells_and_opts: str = ""):
        """
        DM/helper: Create a *unique* Spell Scroll instance and add it to inventory.
        Usage:
          !addscroll <char> <Class> <Spell ...> [-label "text"] [-carry]
        Examples:
          !addscroll testman "Spellcrafter" Haste DispelMagic RetrieveEnergy -label "Lab Notes" -carry
          !addscroll testman Necromancer "CallPoltergeist"
        Flags:
          -carry         put into first empty carry slot
          -label "text"  friendly tag for listing
        """

        if not spells_and_opts.strip():
            return await ctx.send(
                "Usage:\n"
                "`!addscroll <char> <Class> <Spell ...> [-label \"text\"] [-carry]`\n"
                "Example: `!addscroll testman Spellcrafter Haste DispelMagic -label \"Lab Notes\" -carry`"
            )

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rcfg = read_cfg(path)
                            real = get_compat(rcfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        char_name, path = _resolve_char_ci_local(who)
        if not path:
            return await ctx.send(f"âŒ Character '{who}' not found.")
        cfg = read_cfg(path)

        owner_id = get_compat(cfg, "info", "owner_id", fallback="")
        if str(ctx.author.id) != str(owner_id) and not getattr(ctx.author.guild_permissions, "manage_guild", False):
            return await ctx.send("âŒ You must own this character or have Manage Server permission.")


        carry = "-carry" in spells_and_opts.lower()
        m = re.search(r'-label\s+"([^"]+)"|-label\s+\'([^\']+)\'|-label\s+([^\s].*)$', spells_and_opts, flags=re.I)
        label = (m.group(1) or m.group(2) or m.group(3) if m else "").strip()

        toks = [t for t in re.split(r'\s+', re.sub(r'-label\s+("[^"]+"|\'[^\']+\'|[^\s].*)', '', spells_and_opts, flags=re.I)) if t and not t.lower() == "-carry"]

        tokens = [t.strip('"').strip("'") for t in toks if not t.startswith("-")]


        spell_names = [t for t in tokens if t]
        if not spell_names:
            return await ctx.send("âŒ Provide at least one spell on the scroll.")


        sid = str(self._alloc_scroll_id(cfg))
        rec = {"sid": sid, "class": cls, "spells": spell_names, "spent": [0]*len(spell_names), "readmagic": 0, "label": label}
        self._write_scroll_rec(cfg, rec)


        if not cfg.has_section("item"): cfg.add_section("item")
        storage = (get_compat(cfg, "item", "storage", fallback="") or "").strip().split()
        token = f"SpellScroll@{sid}"
        if token not in storage:
            storage.append(token)
        cfg.set("item", "storage", " ".join(storage))
        cfg.set("item", token.lower(), "1")


        if carry:
            if not cfg.has_section("eq"): cfg.add_section("eq")
            placed = False
            for i in range(1, 9):
                if not (get_compat(cfg, "eq", f"carry{i}", fallback="") or "").strip():
                    cfg.set("eq", f"carry{i}", token)
                    cfg.set("eq", f"carry{i}_qty", "1")
                    placed = True
                    break
            if not placed:
                await ctx.send("âš ï¸ No empty carry slot; added to storage only.")


        try: self._recalc_carry_weight(cfg)
        except Exception: pass

        write_cfg(path, cfg)

        cls_short = cls
        spells_txt = ", ".join(spell_names)
        tag = f' â€” "{label}"' if label else ""
        where = " (carried)" if carry else ""
        await ctx.send(f"âœ… Created **Spell Scroll@{sid}** ({cls_short}{tag}) with: {spells_txt}{where}.")

    @commands.command(name="scrolls")
    async def list_scrolls(self, ctx, who: str | None = None):
        """List a characterâ€™s SpellScroll instances and remaining spells.
           Default: show only active (not fully spent). Use `!scrolls -all` for history."""

        show_all = False
        if who is None:
            who = get_active(ctx.author.id)
            if not who:
                return await ctx.send("âŒ No active character. Use `!char <name>` or pass a name.")
        else:
            if who.strip().lower() in {"-all", "-a", "all"}:
                show_all = True
                who = get_active(ctx.author.id)
                if not who:
                    return await ctx.send("âŒ No active character. Use `!char <name>` first.")

        name, path = self._resolve_char_ci(who)
        if not path:
            return await ctx.send(f"âŒ Character '{who}' not found.")
        cfg = read_cfg(path)

        sections = [s for s in cfg.sections() if s.startswith("scroll:")]
        lines = []
        for s in sections:
            sid = s.split(":",1)[1]
            rec = self._read_scroll_rec(cfg, sid) or {}
            if not show_all and self._scroll_all_spent(rec):
                continue

            cls = rec.get("class","?")
            rm = "âœ…" if rec.get("readmagic") else ("â€”" if not self._is_arcane_class(cls) else "âŒ")
            label = f' â€” "{rec.get("label")}"' if rec.get("label") else ""
            pairs = []
            for sp, used in zip(rec.get("spells",[]), rec.get("spent",[])):
                pairs.append(f"{'~~' if used else ''}{sp}{'~~' if used else ''}")

            suffix = " *(spent)*" if show_all and self._scroll_all_spent(rec) else ""
            lines.append(f"**@{sid}** {cls}{label} (ReadMagic: {rm}){suffix}\nâ€¢ " + ", ".join(pairs))

        if not lines:
            which = "active " if not show_all else ""
            return await ctx.send(f"ðŸ“œ **{name}** has no Spell Scrolls.")

        title = f"ðŸ“œ Spell Scrolls â€” {name}" + ("" if not show_all else " (all)")
        embed = nextcord.Embed(title=title, description="\n\n".join(lines), color=0xC9B458)
        await ctx.send(embed=embed)

    @commands.command(name="readmagic")
    async def read_magic_scroll(self, ctx, sid: str | None = None):
        """
        Mark a Spell Scroll as deciphered by Read Magic (arcane only).
        Usage: !readmagic 5
        """
        who = get_active(ctx.author.id)
        if not who:
            return await ctx.send("âŒ No active character. Use `!char <name>` first.")

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rcfg = read_cfg(path)
                            real = get_compat(rcfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        name, path = _resolve_char_ci_local(who)
        if not path:
            return await ctx.send(f"âŒ Character '{who}' not found.")
        if not sid or not sid.isdigit():
            return await ctx.send("Usage: `!readmagic <scroll_id>` â€” see `!scrolls` for IDs.")

        cfg = read_cfg(path)
        rec = self._read_scroll_rec(cfg, sid)
        if not rec:
            return await ctx.send(f"âŒ No scroll @**{sid}**.")
        if not self._is_arcane_class(rec.get("class","")):
            return await ctx.send("â„¹ï¸ Divine scrolls donâ€™t require Read Magic.")
        rec["readmagic"] = 1
        self._write_scroll_rec(cfg, rec)
        write_cfg(path, cfg)
        await ctx.send(f"âœ… Scroll **@{sid}** marked as Read Magic deciphered.")


    async def _read_spell_from_scroll(
        self,
        ctx,
        caster_cfg,
        caster_name: str,
        toks: list[str],
        precast_only: bool = False,
    ) -> bool | dict | None:
        """
        SpellScroll handler.

        When precast_only=False (default):
          - behaves like before: resolves the spell via _cast_spell_by_name and embeds a Result.

        When precast_only=True:
          - shows ONLY the scroll precheck embed (fail chance/roll/etc)
          - consumes the scroll spell (and scroll if empty)
          - returns a dict with:
              {"ok": bool, "effective_level": int, "spell_level": int|None}

        Returns:
          None  -> not a SpellScroll case (caller should fall back)
          False -> handled with an error message
          True  -> handled fully (non-precast mode)
          dict  -> handled (precast_only mode)
        """
        if not toks:
            return False

        spell_name = toks[0]
        snorm = self._norm(spell_name)

        # if this looks like one of the GM/manual scrolls handled by !read, let caller fall back
        if snorm in {
            "elementalprotectionscroll", "lycanthropeprotectionscroll",
            "undeadprotectionscroll", "magicprotectionscroll", "cursedscroll"
        }:
            return None

        # parse optional sid override
        sid_override = None
        for i, t in enumerate(toks):
            if i + 1 >= len(toks):
                continue
            tl = (t or "").lower()
            if tl in {"-s", "-sid", "-scrollid", "-scroll"}:
                try:
                    sid_try = self._scroll_id_from_token(toks[i + 1])
                except Exception:
                    sid_try = None
                if sid_try:
                    sid_override = sid_try
                    break

        # IMPORTANT: if -s was provided but this is NOT the precast-only call,
        # do NOT handle it here (precast already handled/consumed it).
        if sid_override and not precast_only:
            return None


        # identify reader/caster class
        reader_class = (get_compat(caster_cfg, "info", "class", fallback="") or "").strip()

        # choose scroll token + rec
        chosen_token = None
        rec = None

        if sid_override:
            chosen_token = f"SpellScroll@{sid_override}"

            rec = self._read_scroll_rec(caster_cfg, sid_override)
            if not rec:
                await ctx.send(f"âŒ Scroll **@{sid_override}** not found.")
                return False

            # must contain an unspent copy of spell
            found = False
            for s, used in zip(rec.get("spells", []), rec.get("spent", [])):
                if int(used) == 0 and self._norm(s) == snorm:
                    found = True
                    break
            if not found:
                await ctx.send(f"âŒ Scroll **@{sid_override}** does not contain an unused **{spell_name}**.")
                return False


        else:
            picked = self._pick_carried_scroll_with_spell(
                caster_cfg,
                want_cls=reader_class,
                want_spell=spell_name,
                ctx=ctx,
                require_readmagic=False,   # we check below so we can error nicely
                carried_only=False
            )
            if not picked:
                return None
            chosen_token, rec = picked

        # Arcane decipher check (Read Magic)
        is_arcane_scroll = self._is_arcane_class(rec.get("class", ""))
        if is_arcane_scroll and not rec.get("readmagic"):
            sid_now = self._scroll_id_from_token(chosen_token) or rec.get("sid")
            await ctx.send(f"âŒ Arcane scroll **@{sid_now}** isnâ€™t deciphered. Use `!readmagic {sid_now}` first.")
            return False

        # Determine spell level from scroll's spell list class
        scroll_list_class = self._scroll_class_equiv(rec.get("class", ""), ctx.channel) or rec.get("class", "")
        lvl_raw = self._find_spell_level(scroll_list_class, spell_name)
        max_raw = self._max_spell_level_for_class(caster_cfg, reader_class)

        lvl = self._as_int(lvl_raw)
        max_lvl = self._as_int(max_raw)

        # Failure chance per BFRPG
        fail = 0
        if is_arcane_scroll:
            knows = False
            try:
                knows = bool(self._pc_knows_spell(caster_cfg, reader_class, spell_name))
            except Exception:
                knows = False
            if not knows:
                fail += 10

        if lvl is not None and max_lvl is not None and lvl > max_lvl:
            fail += 10 * (lvl - max_lvl)

        roll = random.randint(1, 100)
        ok = (roll > fail)  # fails on <= fail

        # effective level = at least minimum to cast that spell level (2*lvl - 1)
        try:
            eff_level = int(getint_compat(caster_cfg, "cur", "level", fallback=1))
        except Exception:
            eff_level = 1
        if isinstance(lvl, int) and lvl > 0:
            eff_level = max(eff_level, (2 * lvl) - 1)

        # Consume the scroll spell regardless of success (wasted on failure)
        self._mark_scroll_spell_spent_and_cleanup(caster_cfg, chosen_token, spell_name)
        try:
            _disp, _path = self._resolve_char_ci(caster_name)
            if _path:
                write_cfg(_path, caster_cfg)
        except Exception:
            pass

        # Build the scroll precheck embed
        title = f"ðŸ“œ Spell Scroll â€” {rec.get('class','') or 'unknown'}"
        desc  = f"{caster_name} attempts **{spell_name}** from **{chosen_token}**."
        embed = nextcord.Embed(
            title=title,
            description=desc,
            color=(0x55CC77 if ok else 0xCC5555)
        )
        embed.add_field(
            name="Failure chance",
            value=f"**{fail}%** (roll **{roll}**; fails on â‰¤ **{fail}**)",
            inline=True
        )
        if lvl is not None:
            embed.add_field(
                name="Spell level",
                value=f"**{lvl}** (your max: **{max_lvl if max_lvl is not None else '?'}**)",
                inline=True
            )

        # For precast_only: do NOT resolve spell here
        if precast_only:
            embed.add_field(
                name="Outcome",
                value=("âœ… Success â€” proceeding to castâ€¦" if ok else "âŒ Failure â€” the spell fizzles."),
                inline=False
            )
        else:
            # legacy behavior: show a Result line (optional)
            if ok:
                embed.add_field(name="Result", value="âœ… **Spell takes effect.**", inline=False)
            else:
                embed.add_field(name="Result", value="âŒ **Scroll sputters and fails.**", inline=False)

        # Scroll crumble info
        sid_now = self._scroll_id_from_token(chosen_token)
        if sid_now and not self._read_scroll_rec(caster_cfg, sid_now):
            embed.add_field(
                name="Scroll",
                value="All inscribed spells have been used. The scroll crumbles to dust.",
                inline=False
            )

        await ctx.send(embed=embed)

        if precast_only:
            return {"ok": ok, "effective_level": eff_level, "spell_level": lvl}

        return True


    async def _cast_spell_by_name(
        self,
        ctx,
        bcfg,
        caster_name: str,
        spell_name: str,
        spell_args: list[str],
        *,
        caster_cfg=None,
        
        effective_level: int | None = None,
        from_scroll: bool = False,
    ) -> str:
        """
        Minimal internal spell dispatcher used by scroll casting.
        Uses self._spell_handlers (same handlers as normal casting).
        Note: handlers expect the **battle cfg** (from `_load_battles()`), not the caster .coe cfg.
        Returns a string suitable for embedding in the scroll result.
        """
        import inspect

        # Normalize spell name through alias map (same as !cast)
        try:
            spell_name = self._spell_alias_map().get(self._norm(spell_name), spell_name)
        except Exception:
            pass

        key = _norm_alias(spell_name)
        fn = getattr(self, "_spell_handlers", {}).get(key)
        if not fn:
            # fallbacks
            fn = getattr(self, "_spell_handlers", {}).get(self._norm(spell_name))
        if not fn:
            return f"âš ï¸ No automated handler found for **{spell_name}**."

        # Determine caster level for effect scaling
        if effective_level is None:
            try:
                effective_level = int(getint_compat(caster_cfg, "cur", "level", fallback=1))
            except Exception:
                effective_level = 1

        try:
            out = fn(ctx, bcfg, caster_name, int(effective_level), list(spell_args or []))

            if inspect.isawaitable(out):
                out = await out
        except Exception as e:
            return f"âŒ Error while casting **{spell_name}**: `{type(e).__name__}: {e}`"

        # Normalize possible handler output types
        try:
            if "_normalize_effect_output" in globals():
                main, _notes = _normalize_effect_output(out)
                return main or ""
        except Exception:
            pass

        if out is None:
            return ""
        if isinstance(out, (list, tuple)):
            return "\n".join(str(x) for x in out if x is not None)
        return str(out)

    def _as_int(self, v):
        """Best-effort int coercion. Accepts tuples/lists like (5, ...) and returns 5."""
        if v is None:
            return None
        if isinstance(v, (list, tuple)):
            for x in v:
                try:
                    return int(x)
                except Exception:
                    continue
            return None
        try:
            return int(v)
        except Exception:
            return None

    def _scroll_id_from_token(self, token: str | None) -> str | None:
        """
        Extract a numeric SpellScroll id from common user inputs.

        Accepts:
          â€¢ 11
          â€¢ @11 / #11
          â€¢ SpellScroll@11 / spellscr@11 / scroll@11
          â€¢ SpellScroll@11:Fireball  (anything after ':' is ignored)

        Returns the id as a string of digits, or None.
        """
        if token is None:
            return None
        s = str(token).strip()
        if not s:
            return None

        # drop common wrappers and trailing annotations
        s = s.strip()
        s = s.split(":", 1)[0].strip()

        # allow @11 or #11
        if s.startswith("@") or s.startswith("#"):
            s = s[1:].strip()

        # allow SpellScroll@11 (case-insensitive)
        if "@" in s:
            try:
                s = s.split("@", 1)[1].strip()
            except Exception:
                return None

        # final: must be digits
        if s.isdigit():
            return s
        return None
    def _mark_scroll_spell_spent_and_cleanup(
        self,
        cfg,
        token_or_id: str,
        spell_name: str,
        *,
        delete_section_when_empty: bool = True,
    ) -> tuple[bool, bool]:
        """
        Mark one instance of `spell_name` on the given scroll as spent.
        Returns (ok, all_spent_after).

        If all spells are spent and `delete_section_when_empty` is True:
          - removes the scroll token from carry/storage/counts
          - deletes the [scroll:<id>] section
        """
        sid = self._scroll_id_from_token(token_or_id)
        if not sid:
            return (False, False)
        rec = self._read_scroll_rec(cfg, sid)
        if not rec:
            return (False, False)

        want = self._norm(spell_name)
        idx = None
        for i, (sp, used) in enumerate(zip(rec.get("spells", []), rec.get("spent", []))):
            if not used and self._norm(sp) == want:
                idx = i
                break
        if idx is None:
            return (False, False)


        spent = list(rec.get("spent", []))
        spent[idx] = 1
        rec["spent"] = spent
        self._write_scroll_rec(cfg, rec)

        all_spent = all(int(x) for x in spent) if spent else True
        if all_spent:
            token = f"SpellScroll@{sid}"


            try:
                self._consume_carried_item_fallback(cfg, token, qty=1_000_000)
            except Exception:
                pass


            if not cfg.has_section("item"):
                cfg.add_section("item")
            key = token.lower()
            try:
                if cfg.has_option("item", key):
                    try:
                        cfg.remove_option("item", key)
                    except Exception:
                        pass
            except Exception:
                pass
            storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
            storage = [s for s in storage if self._norm(s) != self._norm(token)]
            cfg.set("item", "storage", " ".join(storage))


            try:
                self._recalc_carry_weight(cfg)
            except Exception:
                pass


            if delete_section_when_empty:
                try:
                    cfg.remove_section(f"scroll:{sid}")
                except Exception:
                    pass

        return (True, all_spent)

    @commands.command(name="scribe", aliases=["scribespell"])
    async def scribe_spell_from_scroll(self, ctx, *, expr: str = ""):
        """
        Copy a spell from a Spell Scroll into your spellbook (consumes that spell on the scroll).
        Usage:
          !scribe Disintegrate -s 1
          !scribe Haste              # auto-pick if exactly one matching owned scroll
        """

        if not expr.strip():
            return await ctx.send("Usage: `!scribe <SpellName> [-s <id>]`")

        toks = [t for t in re.split(r"\s+", expr.strip()) if t]
        spell_name = toks[0]
        sid_override = None
        for i, t in enumerate(toks):
            if t.lower() in {"-s","-scroll"} and i+1 < len(toks):
                sid_override = toks[i+1]
                break

        who = get_active(ctx.author.id)
        if not who:
            return await ctx.send("âŒ No active character. Use `!char <name>` first.")
        char_disp, path = self._resolve_char_ci(who)
        if not path:
            return await ctx.send(f"âŒ Character '{who}' not found.")
        cfg = read_cfg(path)


        info_class = get_compat(cfg, "info", "class", fallback="")
        profile = self._caster_profile(info_class, ctx.channel)
        if not profile or not profile.get("book_based"):
            return await ctx.send("âŒ Your class does not use a spellbook.")


        is_arc = True
        chosen_token, rec = None, None


        def _to_spells_list(v):

            if isinstance(v, (list, tuple)):
                return [str(x).strip() for x in v if str(x).strip()]
            s = str(v or "").strip()
            if not s:
                return []

            parts = re.split(r"[|,]", s)
            return [p.strip() for p in parts if p.strip()]

        def _to_spent_list(v, n):

            if isinstance(v, (list, tuple)):
                out = []
                for x in v:
                    try: out.append(int(x))
                    except Exception: out.append(0)
            else:
                s = str(v or "").strip()
                out = []
                if s:
                    for chunk in s.split(","):
                        chunk = chunk.strip()
                        out.append(int(chunk) if chunk.isdigit() else 0)

            if len(out) < n:
                out.extend([0] * (n - len(out)))
            elif len(out) > n:
                out = out[:n]
            return out

        def _class_key(x):

            canon = self._scroll_class_equiv(str(x or ""), ctx.channel)
            return re.sub(r"[^a-z0-9]+", "", canon.lower())

        if sid_override and sid_override.isdigit():
            rec = self._read_scroll_rec(cfg, sid_override)
            if not rec:
                return await ctx.send(f"âŒ No scroll @**{sid_override}**.")
            if self._norm(self._scroll_class_equiv(rec.get("class",""), ctx.channel)) != self._norm(self._scroll_class_equiv(info_class, ctx.channel)):
                return await ctx.send(f"âŒ This scroll is for **{rec['class']}**, not **{info_class}**.")

            if is_arc and not int(rec.get("readmagic", 0)):
                return await ctx.send(f"âŒ Arcane scroll @**{sid_override}** isnâ€™t deciphered. Use `!readmagic {sid_override}` first.")
            chosen_token = f"SpellScroll@{sid_override}"
            if not self._has_item_anywhere(cfg, chosen_token):
                return await ctx.send(f"âŒ You donâ€™t have **{chosen_token}** in your inventory.")
            if not any(self._norm(s)==self._norm(spell_name) and not u for s,u in zip(rec["spells"], rec["spent"])):
                return await ctx.send(f"âŒ Scroll @**{sid_override}** has no unspent **{spell_name}**.")
        else:

            want_cls = self._norm(self._scroll_class_equiv(info_class, ctx.channel))
            want_spell = self._norm(spell_name)
            cands = []
            for sect in cfg.sections():
                if not sect.startswith("scroll:"):
                    continue
                sid = sect.split(":",1)[1]

                rec_full = self._read_scroll_rec(cfg, sid) or {}
                scls   = rec_full.get("class","") or ""
                spells = _to_spells_list(rec_full.get("spells", []))
                spent  = _to_spent_list(rec_full.get("spent",  []), len(spells))
                rm     = int(str(rec_full.get("readmagic", 0) or 0))

                if _class_key(scls) != _class_key(info_class):
                    continue
                if is_arc and not rm:
                    continue

                want_spell = self._norm(spell_name)
                if any(self._norm(sp) == want_spell and int(u) == 0 for sp, u in zip(spells, spent)):
                    tok = f"SpellScroll@{sid}"
                    cands.append((tok, {"id": sid, "class": scls, "spells": spells, "spent": spent, "readmagic": rm}))

            if not cands:
                return await ctx.send(f"âŒ No owned **Spell Scroll** for **{info_class}** with unspent **{spell_name}**.")
            if len(cands) > 1:
                lines = [f"â€¢ `{tok}` â€” " + ", ".join(r["spells"]) for tok, r in cands[:10]]
                more = "â€¦" if len(cands) > 10 else ""
                return await ctx.send("Found multiple matching scrolls. Use `-s <id>`:\n" + "\n".join(lines) + more)
            chosen_token, rec = cands[0]


        level = getint_compat(cfg, "cur", "level", fallback=1)
        await self._cmd_add_to_book(ctx, cfg, path, char_disp, profile, spell_name, level)


        self._mark_scroll_spell_spent_and_cleanup(cfg, chosen_token, spell_name)
        write_cfg(path, cfg)


        embed = nextcord.Embed(
            title="âœï¸ Scribed to Spellbook",
            description=f"{char_disp} copies **{spell_name}** from **{chosen_token}**.",
            color=0x4CAF50
        )
        sid_now = self._scroll_id_from_token(chosen_token)
        if not self._read_scroll_rec(cfg, sid_now or ""):
            embed.add_field(name="Scroll", value="All inscribed spells used; the scroll crumbles to dust.", inline=False)
        await ctx.send(embed=embed)

    def _scroll_all_spent(self, rec) -> bool:
        spells = list(rec.get("spells", []) or [])
        spent  = list(rec.get("spent",  []) or [])
        if not spells:
            return True

        if len(spent) < len(spells):
            return False
        return all(int(x) != 0 for x in spent[:len(spells)])

    def _scroll_class_equiv(self, s: str, channel=None) -> str:
        """
        For scroll *usage* purposes, map hybrids to their parent list.
        Honors HR: magethief_illusionist_list.
        """
        x = (s or "").strip().lower()
        if any(k in x for k in ("fightermage", "fighter-mage", "fighter mage")):
            return "Magic-User"

        if any(k in x for k in ("magethief", "mage-thief", "mage thief", "magic-user/thief")):
            use_illu = self._hr_enabled_proxy(channel, "magethief_illusionist_list", True)
            return "Illusionist" if use_illu else "Magic-User"

        if "paladin" in x:
            return "Cleric"
        return self._canon_class_name(s)


    def _canon_class_name(self, s: str) -> str:
        x = (s or "").strip().lower()
        m = {
            "mu":"Magic-User","magicuser":"Magic-User","magic-user":"Magic-User","mage":"Magic-User","arcane":"arcane",
            "ill":"Illusionist","illusionist":"Illusionist",
            "nec":"Necromancer","necromancer":"Necromancer",
            "sc":"Spellcrafter","spellcrafter":"Spellcrafter",
            "cl":"Cleric","cleric":"Cleric",
            "dr":"Druid","druid":"Druid",
            "pal":"Paladin","paladin":"Paladin",
            "divine":"divine",
        }
        return m.get(x, s.strip())

    @commands.command(name="prunescrolls")
    async def prune_spent_scrolls(self, ctx, who: str | None = None):
        """Delete all fully-spent [scroll:<id>] sections for a character."""
        who = who or get_active(ctx.author.id)
        if not who:
            return await ctx.send("âŒ No active character. Use `!char <name>` or pass a name.")
        name, path = self._resolve_char_ci(who)
        if not path or not os.path.exists(path):
            return await ctx.send(f"âŒ Character '{who}' not found.")
        cfg = read_cfg(path)

        removed = 0
        for sect in list(cfg.sections()):
            if not sect.startswith("scroll:"):
                continue
            sid = sect.split(":",1)[1]
            rec = self._read_scroll_rec(cfg, sid) or {}
            spells = rec.get("spells", []) or []
            spent  = rec.get("spent",  []) or []
            if spells and len(spent) >= len(spells) and all(int(x) != 0 for x in spent[:len(spells)]):
                try:
                    cfg.remove_section(sect)
                    removed += 1
                except Exception:
                    pass

        write_cfg(path, cfg)
        await ctx.send(f"ðŸ§¹ Pruned **{removed}** fully-spent scroll(s) from **{name}**.")

    @commands.command(name="givescroll", aliases=["gscroll"])
    async def givescroll(self, ctx, who: str, token_or_id: str):
        """
        Give a Spell Scroll instance to another character.
        Usage:
          !givescroll <who> SpellScroll@5
          !givescroll <who> @5
          !givescroll <who> 5
        Behavior:
          â€¢ Moves the scrollâ€™s [scroll:<id>] record (spells, spent flags, readmagic)
          â€¢ Allocates a NEW id for the receiver (avoids collisions)
          â€¢ Updates inventory tokens/storage for both
          â€¢ Removes from any carry slot on the giver; optional carry for receiver not set
        """

        def _resolve_char_ci(name: str):
            base = name.replace(" ", "_")
            target = f"{base}.coe".lower()
            for fn in os.listdir("."):
                if fn.lower() == target:
                    path = fn
                    try:
                        cfg2 = read_cfg(path)
                        real = get_compat(cfg2, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_"," ")), path
                    except Exception:
                        return fn[:-4].replace("_"," "), path
            return None, None


        src_name = get_active(ctx.author.id)
        if not src_name:
            return await ctx.send("âŒ No active character. Use `!char <name>` first.")
        src_path = f"{src_name.replace(' ', '_')}.coe"
        if not os.path.exists(src_path):
            return await ctx.send(f"âŒ Character file not found for **{src_name}**.")

        dst_name, dst_path = _resolve_char_ci(who)
        if not dst_path:
            return await ctx.send(f"âŒ Character '{who}' not found.")

        src = read_cfg(src_path)
        dst = read_cfg(dst_path)

        owner_id = get_compat(src, "info", "owner_id", fallback="")
        if owner_id and str(owner_id) != str(ctx.author.id) and not getattr(ctx.author.guild_permissions, "manage_guild", False):
            return await ctx.send(f"âŒ You must own **{src_name}** or have Manage Server to give scrolls.")


        sid_old = self._scroll_id_from_token(token_or_id)
        if not sid_old or not sid_old.isdigit():
            return await ctx.send("âŒ Provide a valid scroll id, e.g., `SpellScroll@5`, `@5`, or `5`.")
        sect = f"scroll:{sid_old}"
        if not any(s == sect for s in src.sections()):
            return await ctx.send(f"âŒ **{src_name}** has no scroll @**{sid_old}**.")

        rec = self._read_scroll_rec(src, sid_old)
        if not rec:
            return await ctx.send(f"âŒ Scroll data for @**{sid_old}** is missing or corrupt.")

        tok_old = f"SpellScroll@{sid_old}"


        try:
            self._consume_carried_item_fallback(src, tok_old, qty=1_000_000)
        except Exception:
            pass


        if not src.has_section("item"): src.add_section("item")
        try:
            if src.has_option("item", tok_old.lower()):
                try: src.remove_option("item", tok_old.lower())
                except Exception: src.set("item", tok_old.lower(), "0")
        except Exception:
            pass
        storage = (get_compat(src, "item", "storage", fallback="") or "").split()
        storage = [s for s in storage if s.strip().lower() != tok_old.lower()]
        src.set("item", "storage", " ".join(storage))


        try:
            src.remove_section(sect)
        except Exception:
            pass


        new_sid = str(self._alloc_scroll_id(dst))
        rec2 = dict(rec)
        rec2["sid"] = new_sid
        self._write_scroll_rec(dst, rec2)

        tok_new = f"SpellScroll@{new_sid}"
        if not dst.has_section("item"): dst.add_section("item")
        dst_storage = (get_compat(dst, "item", "storage", fallback="") or "").split()
        if tok_new not in dst_storage:
            dst_storage.append(tok_new)
            dst.set("item", "storage", " ".join(dst_storage))
        dst.set("item", tok_new.lower(), "1")


        try: self._recalc_carry_weight(src)
        except Exception: pass
        try: self._recalc_carry_weight(dst)
        except Exception: pass
        try: self._recompute_eq_weight(src)
        except Exception: pass
        try: self._recompute_eq_weight(dst)
        except Exception: pass

        write_cfg(src_path, src)
        write_cfg(dst_path, dst)

        await ctx.send(f"ðŸ“œ **{src_name}** gives **{tok_old} â‡’ {tok_new}** to **{dst_name}**.")



    def _prime_striking(self, ctx, caster_name: str, charges: int):
        """
        Spend 1-3 charges now; add Nd6 to the caster's *next* successful melee hit this round.
        Expire after one round if unused.
        """
        charges = max(1, min(3, int(charges)))
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return "âŒ No initiative running here. Use `!init` first."
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, caster_name) or caster_name
        slot = _slot(key) if key else caster_name.replace(" ","_")

        bcfg.set(chan_id, f"{slot}.strike_nd6", str(charges))
        now_round = bcfg.getint(chan_id, "round", fallback=0)
        bcfg.set(chan_id, f"{slot}.strike_expire_round", str(now_round))
        _save_battles(bcfg)
        return f"ðŸ”† Primed **+{charges}d6** to next melee hit (expires end of this round)."




    def _is_arcane(self, caster_cfg) -> bool:
        clz = (str(get_compat(caster_cfg, "info", "class", fallback=""))).lower()
        return any(k in clz for k in ("magic-user","necromancer","illusionist","fightermage","magethief","spellcrafter"))

    def _is_cleric_or_druid(self, caster_cfg) -> bool:
        clz = (str(get_compat(caster_cfg, "info", "class", fallback=""))).lower()
        return ("cleric" in clz) or ("druid" in clz)

    ITEM_POWERS = {
        "wand": {

            "fireball":  {"item": "WandofFireballs", "fn": "_effect_fireball",         "cost": 1, "cl_override": 6, "class": "arcane"},
            "fireballs": {"item": "WandofFireballs", "fn": "_effect_fireball",         "cost": 1, "cl_override": 6, "class": "arcane"},
            "lightning": {"item": "WandofLightningBolts","fn": "_effect_lightningbolt_item","cost": 1, "cl_override": 6, "class": "arcane"},
            "cold":      {"item": "WandofCold",      "fn": "_effect_coneofcold",       "cost": 1, "save_vs":"wand", "dice":"6d8", "cl_override": 0, "class": "arcane"},
            "fear":      {"item": "WandofFear",      "fn": "_cast_cause_fear",         "cost": 1, "class": "arcane"},
            "illusion":  {"item": "WandofIllusion",  "fn": "_cast_phantasmalforce",    "cost": 1, "class": "arcane"},
            "detect":    {"item": "WandofMagicDetection", "fn": "_cast_detectmagic",   "cost": 1, "class": "arcane"},
            "paralysis": {"item": "WandofParalysis", "fn": "_cast_holdperson",         "cost": 1, "class": "arcane"},
            "polymorph": {"item": "WandofPolymorph", "fn": "_cast_polymorph",          "cost": 1, "class": "arcane"},
            "secretdoors":{"item":"WandofSecretDoorDetection","fn":"_cast_detectsecretdoors","cost":1,"class":"arcane"},
            "traps":     {"item": "WandofTrapDetection","fn":"_cast_findtraps",        "cost": 1, "class": "arcane"},
            "enemies":   {"item": "WandofEnemyDetection","fn":"_cast_detectenemies",   "cost": 1, "class": "arcane"},
        },
        "staff": {

            "commanding": {
                "item": "StaffofCommanding", "class": "any",

                "smart": "commanding"
            },

            "healing": {
                "item": "StaffofHealing", "class": "cleric_or_druid",
                "powers": {
                    "default": {"fn":"_effect_curelightwounds", "cost":1},
                    "disease": {"fn":"_cast_curedisease",       "cost":2}
                }
            },

            "power": {
                "item": "StaffofPower", "class": "any",
                "powers": {
                    "fireball":    {"fn":"_effect_fireball",           "cost":1, "cl_override":6},
                    "lightning":   {"fn":"_effect_lightningbolt_item", "cost":1, "cl_override":6},
                    "cold":        {"fn":"_effect_coneofcold",         "cost":1, "dice":"6d6"},
                    "continuallight":{"fn":"_cast_continuallight",     "cost":1},
                    "telekinesis": {"fn":"_cast_telekinesis",          "cost":1, "duration_roll":"1d6 turns"},
                    "retribution": {"special":"retributive"}
                }
            },

            "striking": {
                "item":"StaffofStriking", "class":"cleric_or_spellcrafter",
                "special":"striking"
            },

            "wizardry": {
                "item":"StaffofWizardry", "class":"any",
                "powers": {

                    "fireball":    {"fn":"_effect_fireball",           "cost":1, "cl_override":6},
                    "lightning":   {"fn":"_effect_lightningbolt_item", "cost":1, "cl_override":6},
                    "cold":        {"fn":"_effect_coneofcold",         "cost":1, "dice":"6d6"},
                    "continuallight":{"fn":"_cast_continuallight",     "cost":1},
                    "telekinesis": {"fn":"_cast_telekinesis",          "cost":1, "duration_roll":"1d6 turns"},

                    "invisibility":{"fn":"_cast_invisibility",         "cost":1},
                    "passwall":    {"fn":"_cast_passwall",             "cost":1},
                    "web":         {"fn":"_cast_web",                  "cost":1},
                    "conjureelemental":{"fn":"_cast_conjureelemental", "cost":1},
                }
            },
        }
    }


    def _safe_canon(self, item_name: str, it: dict | None) -> str:
        def _strip(s: str) -> str:
            return (s or "").split("@", 1)[0]
        fn = getattr(self, "_canon", None)
        if callable(fn):
            try:
                v = str(fn(item_name) or "").strip()
                if v:
                    return _strip(v)
            except Exception:
                pass
        if it:
            for k in ("charges_key", "id", "_id", "block", "name", "item_id"):
                v = str(it.get(k, "")).strip()
                if v:
                    return _strip(v)
        return _strip(str(item_name or ""))

    def _item_kind_with_charges(self, item_name: str, it: dict | None) -> str | None:
        ty = str((it or {}).get("type", "")).strip().lower()
        if ty in {"wand", "staff"}:
            return ty
        name_l = self._safe_canon(item_name, it).strip().lower()
        if name_l.startswith("wandof"):  return "wand"
        if name_l.startswith("staffof"): return "staff"
        return None

    def _item_has_charges(self, item_name: str, it: dict | None) -> bool:
        return self._item_kind_with_charges(item_name, it) is not None

    def _charges_key(self, item_name: str, it: dict | None = None) -> str:
        name = str(item_name or "")

        base_name = name.split("@", 1)[0]

        base = self._safe_canon(base_name, it).lower()
        core = "".join(ch for ch in base if ch.isalnum())

        m = re.search(r"@([A-Za-z0-9_-]+)$", name)
        if m:
            suffix = "".join(ch for ch in m.group(1).lower() if ch.isalnum())
            return f"{core}_{suffix}"
        return core

    def _charges_max_for_item(self, name: str, it: dict | None) -> int:

        if it:
            mx = int(it.get("charges_max") or it.get("charges", {}).get("max") or 0)
            if mx:
                return mx

        base = name.split("@", 1)[0].lower()
        if base.startswith("wandof"):
            return 20
        if base.startswith("staffof"):
            return 30
        return 20

    def _get_item_charges(self, cfg, key: str, default_max: int | None = None) -> tuple[int | None, int | None]:
        """
        Reads [charges].<key> as 'cur/max' or legacy 'cur'.
        Returns (cur, max) where either may be None if unset.
        """
        raw = str(get_compat(cfg, "charges", key, fallback="")).strip()
        if raw:
            m = re.match(r"^\s*(\d+)\s*/\s*(\d+)\s*$", raw)
            if m:
                return int(m.group(1)), int(m.group(2))
            try:
                cur = int(raw)
                return cur, (default_max or cur)
            except Exception:
                pass
        return None, default_max

    def _set_item_charges(self, cfg, path: str, key: str, cur: int, maxv: int | None = None) -> None:
        if not cfg.has_section("charges"):
            cfg.add_section("charges")
        if maxv is None:
            _, old_max = self._get_item_charges(cfg, key, default_max=None)
            maxv = old_max if old_max is not None else cur
        cfg.set("charges", key, f"{max(0, int(cur))}/{max(0, int(maxv))}")
        write_cfg(path, cfg)

    def _spend_item_charges(self, cfg, path: str, key: str, cost: int, default_max: int) -> tuple[bool, int, str]:
        """
        Try to spend 'cost' charges. Returns (ok, remaining_after, err_msg_if_any).
        """
        left, mx = self._get_item_charges(cfg, key, default_max)
        left = 0 if left is None else left
        mx = default_max if mx is None else mx
        if cost <= 0:
            return True, left, ""
        if left < cost:
            return False, left, f"âŒ Not enough charges (has **{left}**, needs **{cost}**)."
        self._set_item_charges(cfg, path, key, left - cost, mx)
        return True, left - cost, ""

    def _alloc_item_id(self, n: int = 3) -> str:
        return secrets.token_hex(n)

    def _add_charged_item_instance(self, cfg, char_path: str, canon_name: str, it: dict):
        """
        Create an instance token canon@<id>, put it in storage with qty=1,
        and seed per-instance charges in [charges].
        """
        token = f"{canon_name}@{self._alloc_item_id()}"
        storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
        if token not in storage:
            storage.append(token)
        if not cfg.has_section("item"):
            cfg.add_section("item")
        cfg.set("item", token.lower(), "1")

        cfg.set("item", canon_name.lower(), "0")


        mx = self._charges_max_for_item(canon_name, it)
        self._set_item_charges(cfg, char_path, self._charges_key(token, it), mx, mx)

        cfg.set("item", "storage", " ".join(storage))
        write_cfg(char_path, cfg)
        return token

    def _storage_tokens(self, cfg):
        return [t for t in (get_compat(cfg, "item", "storage", fallback="") or "").split() if t]

    def _pick_wand_instance(self, cfg, prefab_name: str):

        want = self._safe_canon(prefab_name, None)
        want_n = self._norm(want)


        for tok in self._storage_tokens(cfg):
            if "@" in tok and self._norm(tok).startswith(want_n):
                canon, it = self._item_lookup(tok.split("@", 1)[0])
                return tok, it


        canon, it = self._item_lookup(want)
        try:
            from utils.ini import getint_compat
            have = getint_compat(cfg, "item", want.lower(), fallback=0)
        except Exception:
            have = 0
        return (canon, it) if have > 0 else (None, None)

    def _pick_staff_instance(self, cfg, prefab_name: str):

        return self._pick_wand_instance(cfg, prefab_name)



    def _has_ignore_flag(self, flags) -> bool:
        """
        Accepts raw flag tokens (e.g., '-i', '-ignore') or already-normalized tokens.
        Returns True iff user requested to ignore/waive item charges.
        """
        toks = {self._norm(f) for f in (flags or set())}
        return any(x in toks for x in {"i", "ignore", "free"})



    async def _invoke_item(self, ctx, caster_name: str, kind: str, sub: str, args: list[str]):
        """
        Unified item invoker (Wands & Staffs) that:
          â€¢ picks the correct *instanced* item from storage (canon@id)
          â€¢ spends per-instance charges with migration/auto-seed
          â€¢ calls the right effect function and renders our standard embed
        """
        norm = self._norm
        kind = norm(kind)
        sub_key = norm(sub or "")
        reg = self.ITEM_POWERS.get(kind, {})
        if sub_key not in reg:
            await ctx.send(f"âŒ Unknown {kind} power: **{sub}**")
            return

        entry = reg[sub_key]
        prefab = entry.get("item", "")
        if not prefab:
            await ctx.send("âŒ Item is not defined for this power.")
            return


        try:
            cas_disp, cas_path = self._resolve_char_ci(caster_name)
        except Exception:
            cas_disp, cas_path = None, None
        if not cas_path or not os.path.exists(cas_path):
            await ctx.send(f"âŒ Character file for **{caster_name}** not found.")
            return
        cfg = read_cfg(cas_path)
        caster_level = getint_compat(cfg, "cur", "level", fallback=1)


        need = entry.get("class", "any")
        if kind == "wand" and need == "arcane" and not self._is_arcane(cfg):
            await ctx.send(f"âŒ Only arcane casters can use **{prefab}**.")
            return
        if sub_key == "healing" and not self._is_cleric_or_druid(cfg):
            await ctx.send(f"âŒ Only Clerics or Druids can use **{prefab}**.")
            return
        if sub_key == "striking":
            cstr = str(get_compat(cfg, "info", "class", fallback="")).lower()
            if ("cleric" not in cstr) and ("spellcrafter" not in cstr):
                await ctx.send("âŒ Only Clerics or Spellcrafters can use **Staff of Striking**.")
                return


        if kind == "wand":
            owned_name, owned_it = self._pick_wand_instance(cfg, prefab)
            color = getattr(self, "WAND_COLOR", 0x7289DA)
            emoji = "ðŸª„"
            verb = "unleashes"
        else:
            owned_name, owned_it = self._pick_staff_instance(cfg, prefab)
            emoji = "ðŸªµ"
            verb = "invokes"

            _SCOL = {
                "StaffofCommanding": 0xF1C40F,
                "StaffofHealing":    0x2ECC71,
                "StaffofPower":      0xE25822,
                "StaffofStriking":   0x8B4513,
                "StaffofWizardry":   0x7B68EE,
            }
            color = _SCOL.get(prefab, 0x7F8C8D)

        if not owned_it:
            await ctx.send(f"âŒ You donâ€™t have a **{prefab}** in your bag.")
            return


        power = None
        flags: set[str] = set()
        targets: list[str] = []
        for a in (args or []):
            s = str(a).strip()
            ls = s.lower()

            if norm(ls) in {"-break", "-break", "-confirm", "confirm", "break", "retribution", "retributive"}:
                flags.add(norm(ls)); continue
            if s.startswith("-"):
                flags.add(norm(s)); continue
            if (power is None) and isinstance(entry.get("powers"), dict) and norm(s) in entry["powers"]:
                power = norm(s); continue
            targets.append(s)

        ignore = self._has_ignore_flag(flags)


        key_ch = self._charges_key(owned_name, owned_it)
        maxc   = self._charges_max_for_item(owned_name, owned_it)

        try:
            self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
        except Exception:
            pass
        cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
        if cur0 is None or mx0 is None:
            self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
            cur0, mx0 = maxc, maxc


        pretty_item = owned_name
        def _pretty_power_name(default_key: str) -> str:
            return (self._pretty_wand_power_name(default_key, targets) if kind == "wand"
                    else self._pretty_item_power_name(default_key))




        if entry.get("special") == "striking":
            try:
                amt = int(next((t for t in targets if t.isdigit()), "1"))
            except Exception:
                amt = 1
            amt = max(1, min(3, amt))
            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=amt, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return
            primed = self._prime_striking(ctx, caster_name, amt)
            title = f"{caster_name} {verb} **{pretty_item}** â€” Striking!"
            embed = _build_item_embed(
                title,
                header_line="No roll.",
                effect_lines=[f"Target: **{caster_name}**", primed],
                source=f"{emoji} {pretty_item} â€” **{amt}** charge(s)",
                charges_text=(f"**{cur0}/{maxc}** remaining." if ignore
                              else f"**{left_after}/{maxc}** remaining."),
                color=color
            )
            await ctx.send(embed=embed)
            return


        if kind == "staff" and entry.get("smart") == "commanding":

            ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=1, default_max=maxc)
            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=amt, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return

            if any("plant" in t.lower() for t in targets):
                fn = getattr(self, "_cast_controlplants", None) or getattr(self, "_cast_control_plant", None)
                if not fn:

                    self._set_item_charges(cfg, cas_path, key_ch, left_after + 1)
                    await ctx.send("âŒ Control Plant effect not implemented.")
                    return
                out = await _maybe_await(fn(ctx, cfg, caster_name, caster_level, targets))
                header, body = _normalize_effect_output(out)
                title = f"{caster_name} {verb} **{pretty_item}** â€” Control Plants!"
                embed = _build_item_embed(
                    title, header_line=header or "No roll.", effect_lines=body,
                    source=f"{emoji} {pretty_item} â€” 1 charge",
                    charges_text=(f"**{cur0}/{maxc}** remaining." if ignore
                    else f"**{left_after}/{maxc}** remaining."),
                    color=color
                )
                await ctx.send(embed=embed); return


            prefer_person = False
            if targets:
                try:
                    disp, path = self._resolve_char_ci(targets[0])
                    if path:
                        t_cfg = read_cfg(path)
                        prefer_person = self._is_humanoid_cfg(t_cfg, disp or targets[0]) and (self._hd_or_level_from_cfg(t_cfg) <= 4)
                except Exception:
                    pass
            fn = getattr(self, "_effect_charmperson") if prefer_person else getattr(self, "_effect_charmmonster")
            out = await _maybe_await(fn(ctx, cfg, caster_name, caster_level, targets))
            header, body = _normalize_effect_output(out)
            pretty = "Charm Person" if prefer_person else "Charm Monster"
            title = f"{caster_name} {verb} **{pretty_item}** â€” {pretty}!"
            embed = _build_item_embed(
                title, header_line=header or "No roll.", effect_lines=body,
                source=f"{emoji} {pretty_item} â€” 1 charge",
                charges_text=f"**{left_after}/{maxc}** remaining.",
                color=color
            )
            await ctx.send(embed=embed); return


        if (kind == "staff" and sub_key == "power") and (
            ("retribution" in flags) or ("retributive" in flags) or (power in {"retribution","retributive"})
        ):
            if not any(f in flags for f in {"-break","-break","-confirm","confirm","break"}) and not ignore:
                await ctx.send("âš ï¸ Add `-break` to confirm Retributive Strike (this **destroys** the staff).")
                return

            cur_now, mx_now = self._get_item_charges(cfg, key_ch, default_max=maxc)
            cur_now = int(cur_now or 0)
            if cur_now <= 0:
                await ctx.send("âŒ The staff has no charges to release."); return
            out = await self._retributive_strike(ctx, caster_name, cur_now, targets)

            if ignore:

                await ctx.send(f"ðŸª“ **{pretty_item} unleashes a simulated Retributive Strike (âˆ’i)**\n{out}\nCharges: **{cur_now}/{mx_now or maxc}** *(unchanged)*")
            else:

                self._set_item_charges(cfg, cas_path, key_ch, 0, maxv=(mx_now or maxc))
                await ctx.send(f"ðŸª“ **{pretty_item} shatters!**\n{out}\nCharges: **0/{mx_now or maxc}**")
            return




        if isinstance(entry.get("powers"), dict):
            powdef = entry["powers"].get(power or "default")
            if not powdef:
                await ctx.send(f"âŒ Unknown subpower. Try one of: {', '.join(sorted(entry['powers'].keys()))}")
                return
        else:
            powdef = entry


        cost = int(powdef.get("cost", entry.get("cost", 1)))
        if ignore:
            left_after = cur0
        else:
            ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=cost, default_max=maxc)
            if not ok:
                await ctx.send(msg); return

        used = True
        header = ""
        body_lines: list[str] = []


        cl_override = int(powdef.get("cl_override", entry.get("cl_override", 0)) or 0)
        cl_used = (cl_override if cl_override > 0 else caster_level)


        async def _do_call():
            nonlocal used
            k = power or sub_key

            if kind == "wand":
                if k in {"fireball","fireballs","fb"}:
                    return await self._area_damage_simple(ctx, "Wand: Fireball", "6d6", targets, save_pref=("wand","device","spell","spells"), dmg_type="fire")
                if k in {"lightning","bolt","bolts","lightningbolt"}:
                    return await self._effect_lightningbolt_item(ctx, cfg, caster_name, 6, targets, save_as="wand", dice="6d6")
                if k in {"cold","coneofcold","coc"}:
                    return await self._effect_coneofcold_item(ctx, cfg, caster_name, 6, targets, save_as="wand", dice="6d8")
                if k in {"fear","causefear"}:
                    return await self._cast_cause_fear(ctx, cfg, caster_name, 0, targets)
                if k in {"illusion","phantasmalforce"}:
                    return await self._cast_phantasmal_force_item(ctx, cfg, caster_name, targets)
                if k in {"detect","magic","detectmagic","magicdetection"}:
                    return await self._cast_detect_magic_item(ctx, cfg, caster_name, 0, targets)
                if k in {"paralysis","holdperson","para"}:
                    return await self._effect_holdperson(ctx, cfg, caster_name, 0, targets)
                if k in {"secretdoors","secretdoordetection","door","sdd"}:
                    return await self._cast_detect_secret_doors_item(ctx, cfg, caster_name, 0, targets)
                if k in {"traps","trapdetection","trap","findtraps"}:
                    return await self._cast_find_traps_item(ctx, cfg, caster_name, 0, targets)
                if k in {"enemies","enemydetection","enemy"}:
                    return await self._cast_enemy_detection_item(ctx, cfg, caster_name, 0, targets)
                if k in {"polymorph","poly"}:
                    if targets and norm(targets[0]) in {"self","me"}:
                        return await self._cast_polymorph(ctx, cfg, caster_name, 0, targets[1:], "PolymorphSelf")
                    if len(targets) >= 2:
                        return await self._cast_polymorph(ctx, cfg, caster_name, 0, targets, "PolymorphOther")
                    used = False
                    return ["âŒ Usage: `!wand polymorph self <Form>` or `!wand polymorph other <Target> <Form>`"]


            if sub_key in {"power","wizardry"}:

                if k in {"fireball","fb"}:
                    return await _maybe_await(getattr(self, "_effect_fireball")(ctx, cfg, caster_name, 6, targets))
                if k in {"lightning","bolt","bolts","lightningbolt"}:
                    return await self._effect_lightningbolt_item(ctx, cfg, caster_name, 6, targets, save_as="spell", dice="6d6")
                if k in {"cold","coneofcold","coc","cone"}:
                    return await self._effect_coneofcold_item(ctx, cfg, caster_name, 6, targets, save_as="spell", dice="6d6")
                if k in {"light","continual","continuallight"}:
                    return await _maybe_await(getattr(self, "_cast_continuallight")(ctx, cfg, caster_name, 6, targets))
                if k in {"telekinesis","tks","tk"}:
                    return await _maybe_await(getattr(self, "_cast_telekinesis")(ctx, cfg, caster_name, 6, targets, duration_roll="1d6 turns"))
                if k in {"passwall","pw"}:
                    return await _maybe_await(getattr(self, "_cast_passwall")(ctx, cfg, caster_name, 6, targets, duration_roll="1d6 turns"))
                if sub_key == "wizardry":
                    if k in {"invisibility","invis"}:
                        return await _maybe_await(getattr(self, "_cast_invisibility")(ctx, cfg, caster_name, 6, targets))
                    if k in {"web"}:
                        return await _maybe_await(getattr(self, "_cast_web")(ctx, cfg, caster_name, 6, targets))
                    if k in {"conjure","conjureelemental","elemental"}:
                        if not targets:
                            used = False
                            return ["âŒ Usage: `!staff wizardry conjure <air|fire|earth|water|wood|metal|ice|lightning>`"]
                        return await _maybe_await(getattr(self, "_cast_conjureelemental")(ctx, cfg, caster_name, 6, targets, source="staff"))


            fn_name = powdef.get("fn") or entry.get("fn")
            fn = getattr(self, fn_name)
            extra = {}
            if "dice" in powdef:        extra["dice"] = powdef["dice"]
            if "save_vs" in powdef:     extra["save_as"] = ("wand" if str(powdef["save_vs"]).lower() == "wand" else "spell")
            if "duration_roll" in powdef: extra["duration_roll"] = powdef["duration_roll"]
            return await _maybe_await(fn(ctx, cfg, caster_name, cl_used, targets, **extra))


        # If a Spellcrafter is operating a wand/staff right now,
        # apply the rule: targets save at -1 (i.e., +1 penalty in our system).
        sc_item_pen = 1 if _is_spellcrafter(cfg) else 0
        if sc_item_pen:
            self._item_save_penalty = sc_item_pen
        try:
            out = await _do_call()
        finally:
            if hasattr(self, "_item_save_penalty"):
                delattr(self, "_item_save_penalty")



        if not used:
            self._set_item_charges(cfg, cas_path, key_ch, left_after + cost)

            if isinstance(out, (list, tuple)):
                await ctx.send("\n".join(str(x) for x in out))
            else:
                await ctx.send(str(out))
            return


        header, body_lines = _normalize_effect_output(out)


        cl_note = f", caster level **{cl_override}**" if (cl_override and kind == "staff") else ""
        source_txt = f"{emoji} {pretty_item} â€” **{cost}** charge(s){cl_note}"
        charges_text = (f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining.")


        pretty_power = _pretty_power_name(power or sub_key)
        title = f"{caster_name} {verb} **{pretty_item}** â€” {pretty_power}!"

        embed = _build_item_embed(
            title,
            header_line=header or "No roll.",
            effect_lines=body_lines,
            source=source_txt,
            charges_text=charges_text,
            color=color
        )
        await ctx.send(embed=embed)


    def _cls_str(cfg) -> str:
        return str(get_compat(cfg, "info", "class", fallback="")).lower()

    def _is_arcane_user(cfg) -> bool:

        arcane_tokens = {"mage","wizard","magic-user","magic user","illusionist","warlock","sorcerer","spellcrafter","spellsinger"}
        c = _cls_str(cfg)
        return any(tok in c for tok in arcane_tokens)

    def _is_cleric_or_druid(cfg) -> bool:
        c = _cls_str(cfg)
        return ("cleric" in c) or ("druid" in c)

    def _is_spellcrafter(cfg) -> bool:
        return "spellcrafter" in _cls_str(cfg)


    def _norm(self, s: str) -> str:
        """Lowercased, alnum-only normalizer for command keywords and item names."""
        return "".join(ch for ch in (str(s) or "").lower() if ch.isalnum())


    def _resolve_active_caster(self, ctx):
        char_name = get_active(ctx.author.id)
        if not char_name:
            return None, None, None, "âŒ No active character. Use `!char <name>` first."
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            return None, None, None, f"âŒ Character file not found for **{char_name}**."
        cfg = read_cfg(path)
        caster_level = getint_compat(cfg, "cur", "level", fallback=getint_compat(cfg, "base", "level", fallback=1))
        return char_name, path, cfg, None


    def _storage_names(self, cfg):
        line = get_compat(cfg, "item", "storage", fallback="")
        return [s for s in line.split() if s]

    def _find_owned_item_by_predicate(self, cfg, pred):
        """
        Return (display_name, catalog_item_dict) for the first storage item
        satisfying pred(name, item_dict). Otherwise (None, None).
        """
        for nm in self._storage_names(cfg):
            _c, it = self._item_lookup(nm)
            if it and pred(nm, it):
                return nm, it
        return None, None

    def _has_type(self, it: dict, ty: str) -> bool:
        return str(it.get("type", "")).strip().lower() == ty


    async def _retributive_strike(self, ctx, caster_name: str, current_charges: int, targets: list[str]):
        """
        Break the staff; release all charges in 30' radius: 1d6/charge, save vs Spells half.
        If no explicit targets are named, hit everyone on initiative (including the wielder).
        """
        if current_charges <= 0:
            return "âŒ The staff has no charges to release."

        dice_spec = f"{current_charges}d6"
        total, rolls, flat = roll_dice(dice_spec)
        dmg = max(0, total + flat)
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        lines = [f"ðŸ’¥ **Retributive Strike**! **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{dmg}** in a 30' radius."]


        if targets:
            hit_list = list(targets)
        elif bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            hit_list = list(names)
            if caster_name not in hit_list:
                hit_list.append(caster_name)
        else:
            hit_list = [caster_name]

        dead_monsters = []


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in hit_list:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            half = dmg // 2 if ok else dmg
            final, note = _apply_mitigation(half, weapon_name="Retributive Strike", weapon_type="force", t_cfg=t_cfg)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            dflag = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                hp_txt = f"{before} â†’ {after}{dflag}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dflag}"

            res_txt = "**RESIST**" if ok else "**FAIL**"
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            line = f"{pretty}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt} â†’ **{final}** â€¢ {hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur = bcfg.get(chan_id, "turn", fallback="")
                    if cur and cur not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass


        return "\n".join(lines)


    async def _area_damage_simple(self, ctx, weapon_name: str, dmg_spec: str, targets: list[str],
                                  save_pref=("wand","device","spell","spells"),
                                  dmg_type: str | None = None):
        """
        One roll for damage, per-target save for half (with RF/RC +3 and PFF/PFL +4 bonuses),
        then optional PFF/PFL other-mode damage override (0 on save, 1/4 on fail),
        then mitigation & HP, lifebars, prune dead, refresh tracker. Returns a list[str].
        """
        chan_id = str(ctx.channel.id)
        dtype = (dmg_type or "").lower()

        total, rolls, flat = roll_dice(dmg_spec)
        base_dmg = max(0, total + flat)
        head = f"ðŸ’¥ **{weapon_name}** â€” **{dmg_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}**"

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        lines = []
        any_hp_changes = False
        dead_monsters = []

        def _save_line(t_cfg):
            for key in save_pref:
                try:
                    ok, r, dc, pen = self._roll_save(t_cfg, vs=key, penalty=0)
                    if dc is not None:
                        return ok, r, dc, pen
                except Exception:
                    pass
            try:
                ok, r, dc, pen = self._roll_save(t_cfg, vs="spell", penalty=0)
                return ok, r, dc, pen
            except Exception:
                return False, 10, 15, 0

        for raw in (targets or []):
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")
            except Exception:
                pass

            ok, sv_roll, sv_dc, sv_pen = _save_line(t_cfg)
            if sv_dc is None:
                ok = False

            absorbs_fire = (dtype == "fire") and ("fire" in _collect_absorb_types(t_cfg))
            absorbs_elec = (dtype in {"electric","lightning"}) and ("electric" in _collect_absorb_types(t_cfg))
            if absorbs_fire or absorbs_elec:
                ok = False

            bonus = 0
            if dtype == "fire":
                bonus += self._rc_rf_save_bonus(t_cfg, chan_id, pretty, "fire")      # +3 from RF (gear/timer)
                bonus += self._pf_other_save_bonus(chan_id, pretty, "fire")          # +4 from PFF other-mode
            elif dtype in {"electric", "lightning"}:
                bonus += self._pf_other_save_bonus(chan_id, pretty, "electric")      # +4 from PFL other-mode
            elif dtype == "cold":
                bonus += self._rc_rf_save_bonus(t_cfg, chan_id, pretty, "cold")      # +3 from RC (gear/timer)

            if not (absorbs_fire or absorbs_elec):
                try:
                    eff_roll = sv_roll - (sv_pen or 0)
                    if sv_dc is not None and not ok and (eff_roll + bonus) >= sv_dc:
                        ok = True
                except Exception:
                    pass
                    
            override = None
            if dtype == "fire":
                override = self._pf_other_damage_override(base_dmg, ok, chan_id, pretty, "fire")
            elif dtype in {"electric","lightning"}:
                override = self._pf_other_damage_override(base_dmg, ok, chan_id, pretty, "electric")

            pre_mit = override if override is not None else (base_dmg // 2 if ok else base_dmg)

            final, note = _apply_mitigation(pre_mit, weapon_name=weapon_name, weapon_type=dtype,
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            if not t_cfg.has_section("cur"):
                t_cfg.add_section("cur")
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            pen_txt   = f" - {sv_pen}" if sv_pen else ""
            bonus_txt = f" + {bonus}" if bonus else ""
            res_txt   = "**RESIST**" if ok else "**FAIL**"
            auto_txt  = " (auto-fail: absorbs fire)" if absorbs_fire else (" (auto-fail: absorbs electric)" if absorbs_elec else "")
            amt_txt   = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"
            dup_heal  = (final < 0) and note and ("heals" in note.lower())
            amt_part  = "" if dup_heal else f" â†’ {amt_txt}"

            line = f"{pretty}: Save {sv_roll}{pen_txt}{bonus_txt} vs {sv_dc} â†’ {res_txt}{auto_txt}{amt_part}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))

        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur_turn = bcfg.get(chan_id, "turn", fallback="")
                    if cur_turn and cur_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try:
                    os.remove(os.path.abspath(p))
                except Exception:
                    pass

        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2 and bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        return [head] + lines


    def _pretty_wand_power_name(self, key: str, args: list[str]) -> str:
        k = self._norm(key)

        if k == "polymorph":
            if args and self._norm(args[0]) in {"self","me"}:
                return "Polymorph Self"
            if args and self._norm(args[0]) in {"other","target"}:
                return "Polymorph Other"
            return "Polymorph"
        mapping = {
            "fireball": "Fireball", "fireballs": "Fireball", "fb": "Fireball",
            "lightning": "Lightning Bolt", "lightningbolt": "Lightning Bolt", "bolt": "Lightning Bolt", "bolts": "Lightning Bolt",
            "cold": "Cone of Cold", "coneofcold": "Cone of Cold", "coc": "Cone of Cold",
            "fear": "Cause Fear", "causefear": "Cause Fear",
            "illusion": "Phantasmal Force", "phantasmalforce": "Phantasmal Force",
            "magicdetection": "Detect Magic", "detectmagic": "Detect Magic", "dm": "Detect Magic",
            "paralysis": "Hold Person", "holdperson": "Hold Person",
            "secretdoors": "Detect Secret Doors", "secretdoordetection": "Detect Secret Doors", "sdd": "Detect Secret Doors",
            "traps": "Find Traps", "trapdetection": "Find Traps",
            "enemydetection": "Detect Enemies", "enemies": "Detect Enemies",
            "magic": "Detect Magic", "para": "Hold Person", "door": "Detect Secret Doors",
        }
        return mapping.get(k, key.title())


    @commands.command(name="wand")
    async def wand(self, ctx, *, args: str | None = None):
        """
        Use a wand from your bag.
        Examples:
          !wand fireballs or1 or2 or3 or4
          !wand illusion
          !wand lightning wi1
          !wand fear ogre
          !wand polymorph self wolf
          !wand polymorph other bandit wolf
          !wand magic
          !wand trap
          !wand door
        """
        caster_name, cas_path, cfg, err = self._resolve_active_caster(ctx)
        if err:
            await ctx.send(err); return


        cls = str(get_compat(cfg, "info", "class", fallback="")).lower()
        if not any(tok in cls for tok in ("mage","wizard","magic-user","illusionist","warlock","sorcerer","spellcrafter","spellsinger")) and not self._break_ok(ctx, caster_name):
            await ctx.send("âŒ Wands can only be used by **arcane** classes. *(Break Restrictions active bypasses this.)*"); return

      
        words = [w for w in (args or "").split() if w]
        if not words:
            await ctx.send("Usage: `!wand <type> [targets...]`  (e.g., `!wand fireballs gob1 gob2`)"); return

        key = self._norm(words[0])
        raw_rest = words[1:]
        flag_tokens = [w for w in raw_rest if w.startswith("-")]
        rest = [w for w in raw_rest if not w.startswith("-")]
        ignore = self._has_ignore_flag(flag_tokens)

        WMAP = {
            "fireball":"WandofFireballs","fireballs":"WandofFireballs","fb":"WandofFireballs",
            "lightning":"WandofLightningBolts","lightningbolt":"WandofLightningBolts","lightningbolts":"WandofLightningBolts","bolt":"WandofLightningBolts","bolts":"WandofLightningBolts",
            "cold":"WandofCold","coneofcold":"WandofCold","coc":"WandofCold",
            "illusion":"WandofIllusion","phantasmalforce":"WandofIllusion",
            "fear":"WandofFear","causefear":"WandofFear",
            "magicdetection":"WandofMagicDetection","detectmagic":"WandofMagicDetection","magic":"WandofMagicDetection",
            "paralysis":"WandofParalysis","holdperson":"WandofParalysis",
            "para": "WandofParalysis",
            "polymorph":"WandofPolymorph","poly": "WandofPolymorph",
            "secretdoors":"WandofSecretDoorDetection","secretdoordetection":"WandofSecretDoorDetection",
            "sdd":"WandofSecretDoorDetection", "door": "WandofSecretDoorDetection",
            "traps":"WandofTrapDetection","trapdetection":"WandofTrapDetection",
            "trap": "WandofTrapDetection",
            "findtraps":"WandofTrapDetection",
            "enemydetection":"WandofEnemyDetection","enemies":"WandofEnemyDetection",
            "enemy":"WandofEnemyDetection",
        }
        prefab = WMAP.get(key)
        if not prefab:
            await ctx.send(f"âŒ Unknown wand type **{words[0]}**."); return


        owned_name, owned_it = self._pick_wand_instance(cfg, prefab)
        if not owned_it:
            await ctx.send(f"âŒ You donâ€™t have a **{prefab}** in your bag."); return


        key_ch = self._charges_key(owned_name, owned_it)
        maxc   = self._charges_max_for_item(owned_name, owned_it)


        self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)


        cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
        if cur0 is None or mx0 is None:
            self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
            cur0, mx0 = maxc, maxc


        if ignore:
            left_after = cur0
        else:
            ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=1, default_max=maxc)
            if not ok:
                await ctx.send(msg); return

        used = True
        pretty_power = self._pretty_wand_power_name(key, rest)


        out = None
        if prefab == "WandofFireballs":

            out = await self._area_damage_simple(ctx, "Wand: Fireball", "6d6", rest, save_pref=("wand","device","spell","spells"), dmg_type="fire")
        elif prefab == "WandofLightningBolts":

            out = await self._effect_lightningbolt_item(ctx, cfg, caster_name, 6, rest, save_as="wand", dice="6d6")
        elif prefab == "WandofCold":
            out = await self._effect_coneofcold_item(ctx, cfg, caster_name, 6, rest, save_as="wand", dice="6d8")
        elif prefab == "WandofFear":
            out = await self._cast_cause_fear(ctx, cfg, caster_name, 0, rest)
        elif prefab == "WandofEnemyDetection":
            out = await self._cast_enemy_detection_item(ctx, cfg, caster_name, 0, rest)
        elif prefab == "WandofIllusion":
            out = await self._cast_phantasmal_force_item(ctx, cfg, caster_name, rest)
        elif prefab == "WandofMagicDetection":
            out = await self._cast_detect_magic_item(ctx, cfg, caster_name, 0, rest)
        elif prefab == "WandofSecretDoorDetection":
            out = await self._cast_detect_secret_doors_item(ctx, cfg, caster_name, 0, rest)
        elif prefab == "WandofTrapDetection":
            out = await self._cast_find_traps_item(ctx, cfg, caster_name, 0, rest)
        elif prefab == "WandofParalysis":



            out = await self._effect_holdperson(ctx, cfg, caster_name, 0, rest)
        elif prefab == "WandofPolymorph":
            if rest and self._norm(rest[0]) in {"self","me"}:
                out = await self._cast_polymorph(ctx, cfg, caster_name, 0, rest[1:], "PolymorphSelf")
            elif len(rest) >= 2:
                out = await self._cast_polymorph(ctx, cfg, caster_name, 0, rest, "PolymorphOther")
            else:
                used = False
                out = [f"âŒ Usage: `!wand polymorph self <Form>` or `!wand polymorph other <Target> <Form>`"]
        elif prefab in {"WandofIllusion","WandofMagicDetection","WandofParalysis",
                        "WandofSecretDoorDetection","WandofTrapDetection","WandofEnemyDetection"}:
            used = False
            out = [f"âš ï¸ {owned_name}: that effect isnâ€™t implemented yet in this bot. No charge spent."]



        header, body_lines = _normalize_effect_output(out)


        if not used and not ignore:
            self._set_item_charges(cfg, cas_path, key_ch, left_after + 1)
            source_txt   = f"ðŸª„ {owned_name} â€” **no charge spent**"
            charges_text = f"**{left_after + 1}/{maxc}** remaining."
        else:
            if ignore:
                source_txt   = f"ðŸª„ {owned_name} â€” **no charge spent** (âˆ’i)"
                charges_text = f"**{cur0}/{maxc}** remaining."
            else:
                source_txt   = f"ðŸª„ {owned_name} â€” 1 charge"
                charges_text = f"**{left_after}/{maxc}** remaining."

        title = f"{caster_name} unleashes **{self._strip_instance_tag(owned_name)}** â€” {pretty_power}!"

        embed = _build_item_embed(
            title,
            header_line=header or "No roll.",
            effect_lines=body_lines,
            source=source_txt,
            charges_text=charges_text,
            color=WAND_COLOR
        )
        await self._attach_char_identity(embed, cfg, ctx)
        await ctx.send(embed=embed)


    @commands.command(name="staff")
    async def staff(self, ctx, *, args: str | None = None):
        """
        Use a staff from your bag.
        Examples:
          !staff commanding go1
          !staff healing holyman
          !staff healing disease holyman OR !staff healing holyman disease
          !staff power fireball wi1 wi2 wi3
          !staff striking 2
          !staff wizardry conjure air
        """
        caster_name, cas_path, cfg, err = self._resolve_active_caster(ctx)
        if err:
            await ctx.send(err); return

        words = [w for w in (args or "").split() if w]
        if not words:
            await ctx.send("Usage: `!staff <commanding|healing|power|striking|wizardry> ...`"); return

        which = self._norm(words[0])
        raw_rest = words[1:]
        flag_tokens = [w for w in raw_rest if w.startswith("-")]
        rest  = [w for w in raw_rest if not w.startswith("-")]
        ignore = self._has_ignore_flag(flag_tokens)


        if which in {"commanding","cmd"}:
            def pred(nm, it): return self._is_staff_like(nm, it) and ("command" in self._norm(nm))
            owned_name, owned_it = self._pick_staff_instance(cfg, "StaffofCommanding")
            if not owned_it:
                await ctx.send("âŒ You donâ€™t have a **Staff of Commanding**."); return
            if not rest:
                await ctx.send("Usage: `!staff commanding <target(s)>`  (uses Charm Person/Monster automatically)."); return

            clz = str(get_compat(cfg, "info", "class", fallback="")).lower()
            is_arcane = any(tok in clz for tok in (
                "magic-user","illusionist","necromancer","fightermage","magethief","spellcrafter"
            ))
            if not is_arcane and not self._break_ok(ctx, caster_name):
                await ctx.send("âŒ Only **arcane** classes can use a **Staff of Commanding**. *(Break Restrictions active bypasses this.)*")
                return
            key_ch = self._charges_key(owned_name, owned_it)
            maxc   = self._charges_max_for_item(owned_name, owned_it)

            self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
            cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
            if cur0 is None or mx0 is None:
                self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)

            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=1, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return


            target1 = rest[0]
            prefer_person = False
            try:
                disp, path = self._resolve_char_ci(target1)
                if path:
                    t_cfg = read_cfg(path)
                    hd = self._hd_or_level_from_cfg(t_cfg)
                    txt = " ".join([
                        str(get_compat(t_cfg, "stats","type",fallback="")),
                        str(get_compat(t_cfg, "info","monster_type",fallback="")),
                        str(get_compat(t_cfg, "info","name",fallback="")),
                        target1
                    ]).lower()
                    is_hum = any(tok in txt for tok in ("humanoid","human","elf","dwarf","halfling","gnome","orc","goblin","kobold","gnoll","ogre","lizard"))
                    prefer_person = is_hum and (hd <= 4)
            except Exception:
                pass

            out = self._effect_charmperson(ctx, cfg, caster_name, 0, rest) if prefer_person else\
                  self._effect_charmmonster(ctx, cfg, caster_name, 0, rest)


            header, body_lines = _normalize_effect_output(out)
            title_power = "Charm Person" if prefer_person else "Charm Monster"
            embed = _build_item_embed(
                f"{caster_name} invokes **Staff of Commanding** â€” {title_power}!",
                header_line=header or "No roll.",
                effect_lines=body_lines,
                source=f"ðŸªµ {owned_name} â€” 1 charge",
                charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),

                color=0xF1C40F
            )
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)
            return


        if which in {"healing","heal"}:
            def pred(nm, it): return self._is_staff_like(nm, it) and ("healing" in self._norm(nm))
            owned_name, owned_it = self._pick_staff_instance(cfg, "StaffofHealing")
            if not owned_it:
                await ctx.send("âŒ You donâ€™t have a **Staff of Healing**."); return
            clz = str(get_compat(cfg, "info", "class", fallback="")).lower()
            if ("cleric" not in clz) and ("druid" not in clz) and not self._break_ok(ctx, caster_name):
                await ctx.send("âŒ Only a **Cleric or Druid** can use a Staff of Healing."); return


            flag_tokens = {"disease", "curedisease", "-disease", "-d"}
            is_disease = any(self._norm(t) in flag_tokens for t in (rest or []))
            targets = [t for t in (rest or []) if self._norm(t) not in flag_tokens]
            tgt = (targets[0] if targets else caster_name)

            cost = 2 if is_disease else 1

            key_ch = self._charges_key(owned_name, owned_it)
            maxc   = self._charges_max_for_item(owned_name, owned_it)
            self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
            cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
            if cur0 is None or mx0 is None:
                self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                cur0, mx0 = maxc, maxc

            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=cost, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return


            if is_disease:
                embed = _build_item_embed(
                    f"{caster_name} invokes **Staff of Healing** â€” Cure Disease!",
                    header_line="No roll.",
                    effect_lines=[f"Target: **{tgt}**", "Disease is cured."],
                    source=f"ðŸªµ {owned_name} â€” **{cost}** charge(s)",
                    charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),

                    color=0x2ECC71
                )
                await self._attach_char_identity(embed, cfg, ctx)
                await ctx.send(embed=embed)
                return


            tgt = (rest[0] if rest else caster_name)

            def _res(name: str):
                try: return self._resolve_char_ci(name)
                except Exception: return name, None

            disp, path = _res(tgt)
            pretty = disp or tgt
            if not path or not os.path.exists(path):
                embed = _build_item_embed(
                    f"{caster_name} invokes **Staff of Healing** â€” Cure Light Wounds!",
                    header_line="No roll.",
                    effect_lines=[f"Target: **{pretty}** *(not found)*"],
                    source=f"ðŸªµ {owned_name} â€” 1 charge",
                    charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),

                    color=0x2ECC71
                )
                await self._attach_char_identity(embed, cfg, ctx)
                await ctx.send(embed=embed)
                return

            t_cfg = read_cfg(path)
            total, rolls, flat = roll_dice("1d6")
            amount = max(0, total + 1)
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))


            if old_hp <= 0:
                head = f"âœ¨ **1d6+1** [{', '.join(str(r) for r in rolls)}] + 1 = **{amount}**"
                embed = _build_item_embed(
                    f"{caster_name} invokes **Staff of Healing** â€” Cure Light Wounds!",
                    header_line=head,
                    effect_lines=[f"Target: **{pretty}**", "Already **DEAD** â€” cannot be healed."],
                    source="ðŸªµ Staff of Healing â€” 1 charge",
                    charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),
                    color=0x2ECC71
                )
                await ctx.send(embed=embed)
                return


            new_hp = min(max_hp, old_hp + amount)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)


            if _is_monster_file(path):
                before = _life_bar(old_hp, max_hp, width=10)
                after  = _life_bar(new_hp, max_hp, width=10)
                hp_txt = f"{before} â†’ {after}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"

            head = f"âœ¨ **1d6+1** [{', '.join(str(r) for r in rolls)}] + 1 = **{amount}**"
            embed = _build_item_embed(
                f"{caster_name} invokes **Staff of Healing** â€” Cure Light Wounds!",
                header_line=head,
                effect_lines=[f"Target: **{pretty}**", f"**+{amount} HP** â€¢ {hp_txt}"],
                source=f"ðŸªµ {owned_name} â€” 1 charge",
                charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),
                color=0x2ECC71
            )
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)


            try:
                bcfg2 = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg2 and bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

            return


        if which in {"power","pow"}:
            def pred(nm, it): return self._is_staff_like(nm, it) and ("power" in self._norm(nm))
            owned_name, owned_it = self._pick_staff_instance(cfg, "StaffofPower")
            if not owned_it:
                await ctx.send("âŒ You donâ€™t have a **Staff of Power**."); return
            if not rest:
                await ctx.send("Usage: `!staff power <fireball|lightning|cold|light|telekinesis|passwall|retributive -break|striking [1-3] [target]> [...]`"); return

            clz = str(get_compat(cfg, "info", "class", fallback="")).lower()
            is_arcane = any(tok in clz for tok in (
                "magic-user","illusionist","necromancer","fightermage","magethief","spellcrafter"
            ))
            if not is_arcane and not self._break_ok(ctx, caster_name):
                await ctx.send("âŒ Only **arcane** classes can use a **Staff of Power**. *(Break Restrictions active bypasses this.)*")
                return

            sub = self._norm(rest[0]); targs = rest[1:]


            if sub in {"retributive","retributivestrike","break"} or any(tok in {"-break","-break","-confirm"} for tok in rest):

                key_ch = self._charges_key(owned_name, owned_it)
                maxc   = self._charges_max_for_item(owned_name, owned_it)
                self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
                cur, mx = self._get_item_charges(cfg, key_ch, default_max=maxc)
                if cur is None or mx is None:
                    self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                    cur, mx = maxc, maxc

                left_now = int(cur or 0)
                if left_now <= 0:
                    await ctx.send("âŒ The staff has no charges to release."); return
                if not any(tok in {"-break","-break","-confirm"} for tok in rest):
                    await ctx.send("âš ï¸ Add `-break` to confirm Retributive Strike (this **destroys** the staff).")
                    return

                out = await self._retributive_strike(ctx, caster_name, left_now, targs)
                self._set_item_charges(cfg, cas_path, key_ch, 0, maxv=mx)
                await ctx.send("ðŸª“ **The Staff of Power shatters!**\n" + out + f"\nðŸ“‰ **{owned_name}** â€” charges: **0/{mx}**")
                return


            if sub in {"striking", "strike"}:

                n = 1
                tgt = caster_name

                for tok in targs:
                    if tok.isdigit() and 1 <= int(tok) <= 3:
                        n = max(1, min(3, int(tok)))
                    elif tok and tgt == caster_name:
                        tgt = tok

                key_ch = self._charges_key(owned_name, owned_it)
                maxc   = self._charges_max_for_item(owned_name, owned_it)
                self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
                cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
                if cur0 is None or mx0 is None:
                    self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                    cur0, mx0 = maxc, maxc

                if ignore:
                    left_after = cur0
                else:
                    ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=n, default_max=maxc)
                    if not ok:
                        await ctx.send(msg); return

                primed_msg = self._prime_striking(ctx, tgt, n)

                embed = _build_item_embed(
                    f"{caster_name} invokes **Staff of Power** â€” Striking!",
                    header_line="No roll.",
                    effect_lines=[f"Target: **{tgt}**", primed_msg],
                    source=f"ðŸªµ {owned_name} â€” **{n}** charge(s), caster level **6**",
                    charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),

                    color=0xE25822
                )
                await self._attach_char_identity(embed, cfg, ctx)
                await ctx.send(embed=embed)
                return


            key_ch = self._charges_key(owned_name, owned_it)
            maxc   = self._charges_max_for_item(owned_name, owned_it)
            self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
            cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
            if cur0 is None or mx0 is None:
                self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                cur0, mx0 = maxc, maxc

            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=1, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return

            used = True
            header = ""
            body_lines: list[str] = []
            title = f"{caster_name} invokes **Staff of Power** â€” {self._pretty_item_power_name(sub)}!"

            if sub in {"fireball","fb"}:
                out = await _call_effect(self, "_effect_fireball", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"lightning","bolt","bolts","lightningbolt"}:
                out = await self._effect_lightningbolt_item(ctx, cfg, caster_name, 6, targs, save_as="spell", dice="6d6")
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"cold","cone","coneofcold","coc"}:

                out = await self._effect_coneofcold_item(ctx, cfg, caster_name, 6, targs, save_as="spell", dice="6d6")
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"light","continual","continuallight"}:
                out = await _call_effect(self, "_cast_continuallight", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"telekinesis","tks","tk"}:
                out = await _call_effect(self, "_cast_telekinesis", 6, ctx, cfg, caster_name, targs, duration_roll="1d6 turns")
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"passwall","pass","wall"}:
                out = await _call_effect(self, "_cast_passwall", 6, ctx, cfg, caster_name, targs, duration_roll="1d6 turns")
                header, body_lines = _normalize_effect_output(out)

            else:
                used = False

                self._set_item_charges(cfg, cas_path, key_ch, left_after + 1)
                await ctx.send("âŒ Unknown Staff of Power subcommand.")
                return


            source_txt   = f"ðŸªµ {owned_name} â€” 1 charge, caster level **6**"
            charges_text = (f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining.")

            embed = _build_item_embed(
                title,
                header_line=header,
                effect_lines=body_lines,
                source=source_txt,
                charges_text=charges_text,
                color=0xE25822
            )
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)
            return


        if which in {"striking","strike"}:
            def pred(nm, it): return self._is_staff_like(nm, it) and ("striking" in self._norm(nm))
            owned_name, owned_it = self._pick_staff_instance(cfg, "StaffofStriking")
            if not owned_it:
                await ctx.send("âŒ You donâ€™t have a **Staff of Striking**."); return
            clz = str(get_compat(cfg, "info", "class", fallback="")).lower()
            if ("cleric" not in clz) and ("spellcrafter" not in clz) and not self._break_ok(ctx, caster_name):
                await ctx.send("âŒ Only a **Cleric or Spellcrafter** may invoke the striking power."); return


            n = 1
            tgt = caster_name
            for tok in rest or []:
                if tok.isdigit() and 1 <= int(tok) <= 3:
                    n = max(1, min(3, int(tok)))
                elif tok and tgt == caster_name:
                    tgt = tok

            key_ch = self._charges_key(owned_name, owned_it)
            maxc   = self._charges_max_for_item(owned_name, owned_it)

            self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
            cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
            if cur0 is None or mx0 is None:
                self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                cur0, mx0 = maxc, maxc
            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=n, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return


            primed_msg = self._prime_striking(ctx, tgt, n)


            embed = _build_item_embed(
                f"{caster_name} invokes **Staff of Striking** â€” Striking!",
                header_line="No roll.",
                effect_lines=[f"Target: **{tgt}**", primed_msg],
                source=f"ðŸªµ {owned_name} â€” **{n}** charge(s)",
                charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),

                color=0x8B4513
            )
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)
            return


        if which in {"wizardry","wiz"}:
            def pred(nm, it):
                n = self._norm(nm)
                return self._is_staff_like(nm, it) and ("wizardry" in n or "wizard" in n)
            owned_name, owned_it = self._pick_staff_instance(cfg, "StaffofWizardry")
            if not owned_it:
                await ctx.send("âŒ You donâ€™t have a **Staff of Wizardry**."); return
            if not rest:
                await ctx.send("Usage: `!staff wizardry <fireball|lightning|cold|light|telekinesis|invisibility|passwall|web|conjure <type>|striking [1-3] [target]>`")
                return

            clz = str(get_compat(cfg, "info", "class", fallback="")).lower()
            is_arcane = any(tok in clz for tok in (
                "magic-user","illusionist","necromancer","fightermage","magethief","spellcrafter"
            ))
            if not is_arcane and not self._break_ok(ctx, caster_name):
                await ctx.send("âŒ Only **arcane** classes can use a **Staff of Wizardry**. *(Break Restrictions active bypasses this.)*")
                return

            sub = self._norm(rest[0]); targs = rest[1:]


            if sub in {"striking", "strike"}:

                n = 1
                tgt = caster_name
                for tok in targs:
                    if tok.isdigit() and 1 <= int(tok) <= 3:
                        n = max(1, min(3, int(tok)))
                    elif tok and tgt == caster_name:
                        tgt = tok

                key_ch = self._charges_key(owned_name, owned_it)
                maxc   = self._charges_max_for_item(owned_name, owned_it)
                self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
                cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
                if cur0 is None or mx0 is None:
                    self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                    cur0, mx0 = maxc, maxc

                if ignore:
                    left_after = cur0
                else:
                    ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=n, default_max=maxc)
                    if not ok:
                        await ctx.send(msg); return

                primed_msg = self._prime_striking(ctx, tgt, n)

                embed = _build_item_embed(
                    f"{caster_name} invokes **Staff of Wizardry** â€” Striking!",
                    header_line="No roll.",
                    effect_lines=[f"Target: **{tgt}**", primed_msg],
                    source=f"ðŸªµ {owned_name} â€” **{n}** charge(s), caster level **6**",
                    charges_text=(f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining."),

                    color=0x7B68EE
                )
                await self._attach_char_identity(embed, cfg, ctx)
                await ctx.send(embed=embed)
                return


            key_ch = self._charges_key(owned_name, owned_it)
            maxc   = self._charges_max_for_item(owned_name, owned_it)
            self._migrate_legacy_charge_key(cfg, cas_path, owned_name, owned_it)
            cur0, mx0 = self._get_item_charges(cfg, key_ch, default_max=maxc)
            if cur0 is None or mx0 is None:
                self._set_item_charges(cfg, cas_path, key_ch, maxc, maxc)
                cur0, mx0 = maxc, maxc

            if ignore:
                left_after = cur0
            else:
                ok, left_after, msg = self._spend_item_charges(cfg, cas_path, key_ch, cost=1, default_max=maxc)
                if not ok:
                    await ctx.send(msg); return

            used = True
            header = ""
            body_lines: list[str] = []
            title = f"{caster_name} invokes **Staff of Wizardry** â€” {self._pretty_item_power_name(sub)}!"

            if sub in {"fireball","fb"}:
                out = await _call_effect(self, "_effect_fireball", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"lightning","bolt","bolts","lightningbolt"}:
                out = await self._effect_lightningbolt_item(ctx, cfg, caster_name, 6, targs, save_as="spell", dice="6d6")
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"cold","cone","coneofcold","coc"}:
                out = await self._effect_coneofcold_item(ctx, cfg, caster_name, 6, targs, save_as="spell", dice="6d6")
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"light","continual","continuallight"}:
                out = await _call_effect(self, "_cast_continuallight", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"telekinesis","tks","tk"}:
                out = await _call_effect(self, "_cast_telekinesis", 6, ctx, cfg, caster_name, targs, duration_roll="1d6 turns")
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"invisibility","invis"}:
                out = await _call_effect(self, "_cast_invisibility", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"passwall","pw"}:
                out = await _call_effect(self, "_cast_passwall", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"web"}:
                out = await _call_effect(self, "_cast_web", 6, ctx, cfg, caster_name, targs)
                header, body_lines = _normalize_effect_output(out)

            elif sub in {"conjure","conjureelemental","elemental"}:
                if not targs:

                    self._set_item_charges(cfg, cas_path, key_ch, left_after + 1)
                    await ctx.send("âŒ Usage: `!staff wizardry conjure <air|fire|earth|water|wood|metal|ice|lightning>`")
                    return

                out = await _call_effect(self, "_cast_conjureelemental", 6, ctx, cfg, caster_name, targs, source="staff")
                header, body_lines = _normalize_effect_output(out)

            else:
                used = False
                self._set_item_charges(cfg, cas_path, key_ch, left_after + 1)
                await ctx.send("âŒ Unknown Staff of Wizardry subcommand.")
                return

            source_txt   = f"ðŸªµ {owned_name} â€” 1 charge, caster level **6**"
            charges_text = (f"**{cur0}/{maxc}** remaining." if ignore else f"**{left_after}/{maxc}** remaining.")

            embed = _build_item_embed(
                title,
                header_line=header,
                effect_lines=body_lines,
                source=source_txt,
                charges_text=charges_text,
                color=0x7B68EE
            )
            await self._attach_char_identity(embed, cfg, ctx)
            await ctx.send(embed=embed)
            return

    def _is_staff_like(self, nm: str, it: dict | None) -> bool:
        ty = str((it or {}).get("type", "")).strip().lower()
        if ty == "staff":
            return True
        n = self._norm(nm)
        return n.startswith("staffof") or "staff" in n

    def _is_wand_like(self, nm: str, it: dict | None) -> bool:
        ty = str((it or {}).get("type", "")).strip().lower()
        if ty == "wand":
            return True
        n = self._norm(nm)
        return n.startswith("wandof") or "wand" in n

    async def _effect_lightningbolt_item(self, ctx, caster_cfg, caster_name: str, caster_level: int,
                                     targets: list[str], *, save_as: str = "wand", dice: str = "6d6"):
        """
        Lightning Bolt fired from an item. Looks like the spell output, but:
          - locks dice (default 6d6)
          - uses Save vs Wands by default (save_as="wand" | "spell")
        """
        chan_id = str(ctx.channel.id)


        total, rolls, flat = roll_dice(dice)
        base = max(0, total + flat)
        head = f"âš¡ {dice} [{', '.join(str(r) for r in rolls)}] = **{base}**"

        lines = []
        any_hp_changes = False
        dead_monsters = []

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        save_label = "Spells" if save_as == "spell" else "Wands"

        for raw in targets or []:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)
            
            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")
            except Exception:
                pass
                            
            absorbs_electric = ("electric" in _collect_absorb_types(t_cfg))

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None: ok = False

            pfl_bonus = self._pf_other_save_bonus(chan_id, pretty, "electric")
            if absorbs_electric:
                ok = False
            else:
                eff = sv_roll - (sv_pen or 0)
                if sv_dc is not None and not ok and (eff + pfl_bonus) >= sv_dc:
                    ok = True

            override = self._pf_other_damage_override(base, ok, chan_id, pretty, "electric")
            pre_mit  = override if override is not None else (base // 2 if ok else base)

            final, note = _apply_mitigation(pre_mit, weapon_name="Lightning Bolt", weapon_type="electric",
                                            t_cfg=t_cfg, chan_id=chan_id, target_name=pretty, is_magical=True)
                        

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            mhp    = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            new_hp = (max(0, old_hp - final) if final >= 0 else min(mhp, old_hp - final))
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True


            if _is_monster_file(path):
                mhp2 = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp2, width=10)
                after  = _life_bar(new_hp, mhp2, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"


            pen_txt  = f" - {sv_pen}" if sv_pen else ""
            res_txt  = "**RESIST**" if ok else "**FAIL**"
            auto_txt = " (auto-fail: absorbs electric)" if absorbs_electric else ""
            amt_txt  = f"**{final}**" if final >= 0 else f"**heals {abs(final)}**"

            line = f"{pretty}: Save vs. {save_label} {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt}{auto_txt} â†’ {amt_txt}\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur_turn = bcfg.get(chan_id, "turn", fallback="")
                    if cur_turn and cur_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception: pass

        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2 and bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


        return head + "\n" + "\n".join(lines)

    def _pretty_item_power_name(self, sub: str) -> str:
        k = self._norm(sub)
        mapping = {
            "fireball": "Fireball",
            "fb": "Fireball",
            "lightning": "Lightning Bolt",
            "bolt": "Lightning Bolt",
            "bolts": "Lightning Bolt",
            "lightningbolt": "Lightning Bolt",
            "cold": "Cone of Cold",
            "cone": "Cone of Cold",
            "coneofcold": "Cone of Cold",
            "coc": "Cone of Cold",
            "light": "Continual Light",
            "continual": "Continual Light",
            "continuallight": "Continual Light",
            "telekinesis": "Telekinesis",
            "tks": "Telekinesis",
            "tk": "Telekinesis",
            "retributive": "Retributive Strike",
            "retributivestrike": "Retributive Strike",
            "break": "Retributive Strike",
        }
        return mapping.get(k, sub.title())

    async def _effect_coneofcold_item(self, ctx, caster_cfg, caster_name: str, caster_level: int,
                                      targets: list[str], *, save_as: str = "spell", dice: str = "6d6"):
        """
        Cone of Cold from an item (wand/staff):
          - shows full dice list in the header
          - save_as: "spell" for staffs (BFRPG), "wand" for wands
          - dice: e.g., "6d6" (staff) or "6d8" (wand of cold)
        """
        chan_id = str(ctx.channel.id)

        total, rolls, flat = roll_dice(dice)
        base = max(0, total + flat)
        head = f"â„ï¸ {dice} [{', '.join(str(r) for r in rolls)}] = **{base}**"

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        save_label = "Spells" if save_as == "spell" else "Magic Wands"
        save_key   = "spell" if save_as == "spell" else "wand"

        for raw in (targets or []):
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)

            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty)
                if cleared:
                    lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by area effect.")
            except Exception:
                pass

            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs=save_key, penalty=0)
            dmg = base // 2 if ok else base

            final, note = _apply_mitigation(dmg, weapon_name="Cone of Cold", weapon_type="cold", t_cfg=t_cfg, chan_id=str(ctx.channel.id), target_name=pretty, is_magical=True)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True

            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            pen_txt = f" - {sv_pen}" if sv_pen else ""
            res_txt = "**RESIST**" if ok else "**FAIL**"
            line = f"{pretty}: Save vs. {save_label} {sv_roll}{pen_txt} vs {sv_dc} â†’ {res_txt} â†’ **{final}**\n{hp_txt}"
            if note:
                line += f" ({note})"
            lines.append(line)

            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))

        if dead_monsters:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex",".join",".disp",".oil",".acpen",".holds",".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)
                    cur_turn = bcfg.get(chan_id, "turn", fallback="")
                    if cur_turn and cur_turn not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass
            for _, p in dead_monsters:
                try: os.remove(os.path.abspath(p))
                except Exception:
                    pass

        if any_hp_changes:
            try:
                bcfg2 = _load_battles()
                if bcfg2 and bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        return head + "\n" + "\n".join(lines)

    def _start_item_timer_on_caster(self, ctx, caster_name: str, *, label: str, alias_key: str, rounds: int, emoji: str = "â±ï¸"):
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        code = self._two_letter_code_from_name(label, alias_key)

        if not bcfg or not bcfg.has_section(chan_id) or rounds is None:
            return f"Started **[{code} {int(rounds or 0)}]** on **{caster_name}** *(no initiative running; remember manually).*"

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, caster_name) or caster_name
        slot = _resolve_effect_slot(bcfg, chan_id, key) if '_resolve_effect_slot' in globals() else _slot(key)

        base_key = f"x_{alias_key}"
        bcfg.set(chan_id, f"{slot}.{base_key}",       str(int(rounds)))
        bcfg.set(chan_id, f"{slot}.{base_key}_code",  code)
        bcfg.set(chan_id, f"{slot}.{base_key}_label", label)
        bcfg.set(chan_id, f"{slot}.{base_key}_emoji", emoji)
        bcfg.set(chan_id, f"{slot}.{base_key}_by",    caster_name)
        _save_battles(bcfg)

        return f"Started timer **[{code} {int(rounds)}]** on **{caster_name}**."

    async def _cast_telekinesis(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str],
                                *, duration_roll: str | None = None):
        """
        Manual TK for items: roll duration (e.g., '1d6 turns'), start x_TE on caster, return header+lines.
        """

        rolled_txt = ""
        if duration_roll:

            dice_spec = str(duration_roll).split()[0]
            total, rolls, flat = roll_dice(dice_spec)
            turns = max(0, total + flat)


            rounds = turns * 60

            turn_word = "turn" if turns == 1 else "turns"
            rolled_txt = f"{dice_spec} [{', '.join(str(r) for r in rolls)}] = {turns} {turn_word} â†’ **{rounds}** rounds"
        else:

            dur_raw = ""
            sec = "Telekinesis"
            if self._spell_cp.has_section(sec) and self._spell_cp.has_option(sec, "duration"):
                dur_raw = self._spell_cp.get(sec, "duration", fallback="").strip()
            rounds = self._duration_to_rounds(dur_raw or "1 turn", caster_level) or 60
            rolled_txt = f"{dur_raw or '1 turn'} â†’ **{rounds}** rounds"


        line = self._start_item_timer_on_caster(ctx, caster_name,
                label="Telekinesis", alias_key="telekinesis", rounds=rounds, emoji="ðŸŒ€")
        await _refresh_tracker_message(ctx)

        head = f"ðŸŒ€ {rolled_txt}"
        return head + "\n" + line

    async def _cast_passwall(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str],
                             *, duration_roll: str | None = None):
        """
        Manual Passwall for items: compute duration (from roll or spells.lst), start x_PW on caster.
        """

        rolled_txt = ""
        if duration_roll:

            dice_spec = str(duration_roll).split()[0]
            total, rolls, flat = roll_dice(dice_spec)
            turns = max(0, total + flat)


            rounds = turns * 60

            turn_word = "turn" if turns == 1 else "turns"
            rolled_txt = f"{dice_spec} [{', '.join(str(r) for r in rolls)}] = {turns} {turn_word} â†’ **{rounds}** rounds"
        else:

            dur_raw = ""
            sec = "Passwall"
            if self._spell_cp.has_section(sec) and self._spell_cp.has_option(sec, "duration"):
                dur_raw = self._spell_cp.get(sec, "duration", fallback="").strip()
            rounds = self._duration_to_rounds(dur_raw or "1 turn", caster_level) or 60
            rolled_txt = f"{dur_raw or '1 turn'} â†’ **{rounds}** rounds"

        line = self._start_item_timer_on_caster(ctx, caster_name,
                label="Passwall", alias_key="passwall", rounds=rounds, emoji="ðŸšª")
        await _refresh_tracker_message(ctx)

        head = f"ðŸšª {rolled_txt}"
        return head + "\n" + line



    async def _cast_continuallight(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        """
        Staff/Wizardry item version of Continual Light.
        Uses the shared core, then refreshes the initiative tracker.
        Returns a single string: <header>\n<effect lines...> for your embed normalizer.
        """

        out = self._effect__continual_lod(ctx, caster_cfg, caster_name, caster_level, targets, is_dark=False)


        lines = out if isinstance(out, list) else [str(out)]


        try:

            await _refresh_tracker_message(ctx)
        except Exception:
            pass


        head = "ðŸ’¡ No roll."
        return head + "\n" + "\n".join(lines)


    async def _cast_continualdarkness(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        out = self._effect__continual_lod(ctx, caster_cfg, caster_name, caster_level, targets, is_dark=True)
        lines = out if isinstance(out, list) else [str(out)]
        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass
        head = "ðŸŒ‘ No roll."
        return head + "\n" + "\n".join(lines)

    async def _cast_web(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        """
        Staff of Wizardry â€” Web (item version).
        - No dice roll; header says "No roll."
        - Delegates the mechanics to `_effect_web` (unique Web rules you wrote).
        - Returns a single string: "<header>\n<effect lines...>" for your embed normalizer.
        """

        try:
            out = await self._effect_web(ctx, caster_cfg, caster_name, caster_level, targets)
        except TypeError:

            out = self._effect_web(ctx, caster_cfg, caster_name, caster_level, targets)


        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass


        body = "\n".join(out) if isinstance(out, (list, tuple)) else str(out)
        head = "ðŸ•¸ï¸ No roll."
        return head + "\n" + body

    async def _cast_enemy_detection_item(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        """
        Wand of Enemy Detection â€” reveal enemies within 60' for 1 round.
        Starts x_timer on the caster: [WED 1]
        """

        line = self._start_item_timer_on_caster(
            ctx, caster_name,
            label="Enemy Detection", alias_key="wed", rounds=1, emoji="ðŸ‘ï¸"
        )

        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass


        head = "ðŸ‘ï¸ No roll."
        body = [
            "Radius: **60'** centered on the user.",
            "All **enemies** glow greenish-white for **1 round** "
            "(even hidden/invisible if in sight; not through solid walls).",
            line,
        ]
        return head + "\n" + "\n".join(body)

    async def _cast_phantasmal_force_item(self, ctx, caster_cfg, caster_name: str, args: list[str], **_):
        """
        Wand of Illusion â€” Phantasmal Force (concentration).
        Starts x_phantasmalforce on the CASTER with 0 rounds (concentration marker).
        """

        note = self._start_item_timer_on_caster(
            ctx, caster_name,
            label="Phantasmal Force",
            alias_key="phantasmalforce",
            rounds=0,
            emoji="ðŸŽ­"
        )

        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass


        head = "ðŸŽ­ No roll."
        body = [
            "Purely **visual** illusion (no other senses).",
            "Area up to **20â€™Ã—20â€™Ã—20â€™**; may be **animated** within the area.",
            "Persists **while you concentrate**. End early with `!conc drop`.",
            "If emulating creatures: **AC 11**; illusion **disappears if hit**.",
            "Damage/effects are **not real** â€” those â€˜downedâ€™ revive in **2d8 rounds**.",
            "If projecting **more creatures than your level**, observers of â‰¥ average INT get an **immediate Save vs Spells** to disbelieve.",
            "GM may grant extra saves for improbable/poorly-conceived illusions.",
            note,
        ]
        return head + "\n" + "\n".join(body)

    async def _cast_detect_magic_item(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        """
        Wand of Magic Detection â€” Detect Magic.
        Duration: 2 turns (120 rounds). Range: 60'.
        Starts x_detectmagic on the caster.
        """
        rounds = 2 * 60
        note = self._start_item_timer_on_caster(
            ctx, caster_name,
            label="Detect Magic", alias_key="detectmagic", rounds=rounds, emoji="ðŸ”"
        )
        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass

        head = "ðŸ” No roll."
        body = [
            "Range: **60'**. Duration: **2 turns** (**120 rounds**).",
            "Only **you** see the glow around enchanted things.",
            "Invisible targets are not revealed directly, but their magic shows as an **amorphous glowing fog**.",
            "You may attack that fog at **-2 to hit**.",
            note,
        ]
        return head + "\n" + "\n".join(body)

    async def _cast_find_traps_item(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        """
        Wand of Trap Detection â€” Find Traps.
        Duration: 3 turns (180 rounds). Range: 30'.
        Starts x_findtraps on the caster.
        """
        rounds = 3 * 60
        note = self._start_item_timer_on_caster(
            ctx, caster_name,
            label="Find Traps", alias_key="findtraps", rounds=rounds, emoji="ðŸª¤"
        )
        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass

        head = "ðŸª¤ No roll."
        body = [
            "Range: **30'**. Duration: **3 turns** (**180 rounds**).",
            "Traps (mechanical or magical) within range glow with a faint **greenish-blue** aura **to you**.",
            "Does **not** reveal natural hazards (quicksand, sinkholes, unstable natural rock, etc.).",
            "Does **not** tell the trapâ€™s nature or how to disarm it.",
            note,
        ]
        return head + "\n" + "\n".join(body)

    async def _cast_detect_secret_doors_item(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str], **_):
        """
        Wand of Secret Door Detection â€” like Find Traps but for secret doors.
        Duration: 3 turns (180 rounds). Range: 30'.
        Starts x_detectsecretdoors on the caster.
        """
        rounds = 3 * 60
        note = self._start_item_timer_on_caster(
            ctx, caster_name,
            label="Detect Secret Doors", alias_key="detectsecretdoors", rounds=rounds, emoji="ðŸšª"
        )
        try:
            await _refresh_tracker_message(ctx)
        except Exception:
            pass

        head = "ðŸšª No roll."
        body = [
            "Range: **30'**. Duration: **3 turns** (**180 rounds**).",
            "Secret doors, panels, and concealed passages within range are **revealed to you**.",
            "Modeled on *Find Traps*: highlights locations, not mechanisms or methods of opening.",
            note,
        ]
        return head + "\n" + "\n".join(body)

    def _create_spell_scroll_instance(self, char_path: str, cls: str, spells: list[str], label: str = "", carry: bool = False) -> str:
        cfg = read_cfg(char_path)
        sid = str(self._alloc_scroll_id(cfg))
        rec = {"sid": sid, "class": cls, "spells": spells, "spent": [0]*len(spells), "readmagic": 0, "label": label}
        self._write_scroll_rec(cfg, rec)

        if not cfg.has_section("item"): cfg.add_section("item")
        token = f"SpellScroll@{sid}"
        storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
        if token not in storage:
            storage.append(token)
        cfg.set("item", "storage", " ".join(storage))
        cfg.set("item", token.lower(), "1")

        if carry:
            if not cfg.has_section("eq"): cfg.add_section("eq")
            placed = False
            for i in range(1, 9):
                if not (get_compat(cfg, "eq", f"carry{i}", fallback="") or "").strip():
                    cfg.set("eq", f"carry{i}", token)
                    cfg.set("eq", f"carry{i}_qty", "1")
                    placed = True
                    break


        try: self._recalc_carry_weight(cfg)
        except Exception: pass

        write_cfg(char_path, cfg)
        return token

    def _migrate_legacy_charge_key(self, cfg, path: str, item_name: str, it: dict | None):

        new_key = self._charges_key(item_name, it)


        base = self._safe_canon(item_name, it).lower()
        core = "".join(ch for ch in base if ch.isalnum())
        m = re.search(r"@([A-Za-z0-9_-]+)$", str(item_name) or "")
        if m:
            suf = "".join(ch for ch in m.group(1).lower() if ch.isalnum())
            old_no_us = f"{core}{suf}"
            bug_double = f"{core}{suf}_{suf}"
        else:
            old_no_us = core
            bug_double = None


        def _read(key):
            raw = (get_compat(cfg, "charges", key, fallback="") or "").strip()
            if not raw: return None, None
            if "/" in raw:
                a,b = raw.split("/",1)
                return int(a), int(b)
            try:
                a = int(raw); return a, None
            except: return None, None

        cur_best, max_best = _read(new_key)
        for k in (old_no_us, bug_double):
            if not k: continue
            c, mmax = _read(k)
            if c is None and mmax is None: continue

            if cur_best is None or (c is not None and c < cur_best): cur_best = c
            if max_best is None or (mmax is not None and mmax > max_best): max_best = mmax

        if cur_best is not None or max_best is not None:
            if not cfg.has_section("charges"): cfg.add_section("charges")

            if max_best is None:
                max_best = self._charges_max_for_item(item_name, it)
            self._set_item_charges(cfg, path, new_key, cur_best if cur_best is not None else max_best, max_best)


        for k in (old_no_us, bug_double):
            try:
                if k and k != new_key:
                    cfg.remove_option("charges", k)
            except Exception:
                pass
        write_cfg(path, cfg)


    def iter_item_defs(self):


        if isinstance(self.items, dict):
            for name, data in self.items.items():
                yield name, data
        else:
            return

    def _strip_instance_tag(self, token: str) -> str:
        """Return the display name without an instance suffix like @558a0e."""
        try:
            return re.sub(r'@[\da-fA-F]+$', '', str(token))
        except Exception:
            return str(token).split('@', 1)[0]

    def _has_timer_code(self, ctx, who_name: str, code: str) -> bool:
        bcfg = _load_battles()
        chan = self._battle_section_id(ctx)
        if not bcfg or not bcfg.has_section(chan):
            return False
        slot = self._slot(ctx, who_name)
        if not slot:
            return False


        if code.upper() == "BR" and bcfg.getint(chan, f"{slot}.x_break", fallback=0) > 0:
            return True


        for opt, val in bcfg.items(chan):
            if opt.startswith(f"{slot}.x_") and opt.endswith("_code"):
                if (val or "").strip().upper() == code.upper():
                    rounds_key = opt[:-5]
                    if bcfg.getint(chan, rounds_key, fallback=0) > 0:
                        return True
        return False

    def _break_ok(self, ctx, who_name: str) -> bool:
        return self._has_timer_code(ctx, who_name, "BR")

    def _slot_in_channel(self, ctx, who_name: str, chan_id: str) -> str | int:
        """Find the initiative slot key for a name in a specific section."""
        bcfg = _load_battles()
        if not bcfg or not bcfg.has_section(chan_id):
            return 0

        def norm(s: str) -> str:
            return "".join(ch.lower() for ch in (s or "") if ch.isalnum())

        want = (who_name or "").strip()
        want_n = norm(want)


        names_line = bcfg.get(chan_id, "list", fallback="")
        keys = [n for n in names_line.split() if n]
        best_partial = None
        for key in keys:
            disp = bcfg.get(chan_id, f"{key}.disp", fallback=key)
            if norm(key) == want_n or norm(disp) == want_n:
                return key
            if not best_partial and norm(disp).startswith(want_n):
                best_partial = key


        cand = None
        for opt, val in bcfg.items(chan_id):
            if opt.endswith(".disp") or opt.endswith(".name"):
                slot = opt.split(".", 1)[0]
                v = (val or "").strip()
                if norm(v) == want_n:
                    return slot
                if not cand and norm(v).startswith(want_n):
                    cand = slot


        guess = want.replace(" ", "_")
        if bcfg.has_option(chan_id, f"{guess}.disp") or guess in keys:
            return guess

        return best_partial or cand or 0

    def _slot(self, ctx, who_name: str) -> str | int:
        """Convenience: resolve using this ctxâ€™s battle section."""
        return self._slot_in_channel(ctx, who_name, self._battle_section_id(ctx))

    def _battle_section_id(self, ctx):
        """Use the same section id logic as initiative; fall back to channel.id."""
        try:
            return _section_id(ctx.channel)
        except Exception:
            return str(ctx.channel.id)

    async def _cast_breakrestrictions(self, ctx, cfg, caster_name: str, level: int, args: list[str]):

        target_in = (args[0] if args else caster_name)
        try:
            target_disp, _ = self._resolve_char_ci(target_in)
        except Exception:
            target_disp = target_in
        target = target_disp or target_in


        bcfg = _load_battles()
        chan_id = self._battle_section_id(ctx)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]


        slot = self._slot(ctx, target)


        def _slot_exists(bcfg, sec, s) -> bool:
            if not s:
                return False
            pref = f"{s}."
            for opt, _ in bcfg.items(sec):
                if opt.startswith(pref):
                    return True
            return False

        if not _slot_exists(bcfg, chan_id, slot):
            return [f"âŒ {target} isnâ€™t in initiative here."]


        rounds = max(1, 60 * max(1, level))


        await self._apply_custom_timer(
            ctx, chan_id, str(slot),
            tag="break",
            label="Break Restrictions",
            rounds=rounds,
            by=caster_name,
            emoji="ðŸ”“"
        )


        disp = (
            bcfg.get(chan_id, f"{slot}.disp", fallback="") or
            bcfg.get(chan_id, f"{slot}.name", fallback="") or
            str(target)
        )
        turns_txt = "turn" if level == 1 else "turns"
        return [
            f"Target: **{disp}**",
            f"ðŸ”“ Break Restrictions active for **{level} {turns_txt}** (**{rounds} rounds**)."
        ]

    async def _cast_enhancearmor(self, ctx, cfg, caster_name: str, level: int, args: list[str]):
        """Spellcrafter L1: +1 AC (touched armor or shield), 1 turn (60 rounds)."""
        target_in = (args[0] if args else caster_name)
        try:
            target_disp, _ = self._resolve_char_ci(target_in)
        except Exception:
            target_disp = target_in
        target = target_disp or target_in

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]


        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, target) or target
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")

        rounds = 60



        try:
            cur = bcfg.getint(chan_id, f"{slot}.enharmor", fallback=0)
        except Exception:
            cur = 0
        bcfg.set(chan_id, f"{slot}.enharmor", str(max(cur, rounds)))
        _save_battles(bcfg)


        await self._apply_custom_timer(
            ctx, chan_id, str(slot),
            "label",
            label="EA",
            rounds=rounds,
            by=caster_name,
            emoji="ðŸ›¡ï¸"
        )

        pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=target)
        return [f"Target: **{pretty}**", f"ðŸ›¡ï¸ AC **+1** for **{rounds}** rounds."]

    async def _cast_weakenarmor(self, ctx, cfg, caster_name: str, level: int, args: list[str]):
        """
        Weaken Armor (reverse): touch attack required (d20 + AB + INT mod vs target AC).
        On hit, target saves vs Spells; on FAIL, targetâ€™s armor is weakened (AC âˆ’1) for 1 turn (60 rd).
        """

        if not args:
            return ["âŒ Usage: `!cast WeakenArmor <target>`"]


        target_in = args[0]
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_in)
        except Exception:
            tgt_disp, tgt_path = target_in, None
            base = f"{target_in.replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_in}** not found."]

        t_cfg = read_cfg(tgt_path)


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_disp) or tgt_disp
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")


        ab = self._get_attack_bonus(cfg)
        int_mod = self._abil_mod(cfg, "int") or 0

        target_ac, *_ = self._defender_ac_with_buffs(bcfg, chan_id, tgt_disp, want_oil=False, atk_type="melee")
        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + int_mod
        hit = (d20 == 20) or (total_to_hit >= target_ac)

        lines = [
            f"ðŸŽ¯ **Touch attack** on **{tgt_disp}**",
            f"Attack roll: {d20} + {ab:+} + {int_mod:+} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")
        ]
        if not hit:
            lines.append("No effect on a miss.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
        lines.append(f"Save vs Spells: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
        if sv_ok:
            lines.append("No effect (save succeeded).")
            return lines


        rounds = 60
        try:
            bcfg.set(chan_id, f"{slot}.x_weakenarmor", str(rounds))
            bcfg.set(chan_id, f"{slot}.weakarmor",     str(rounds))
            _save_battles(bcfg)
        except Exception:
            pass


        try:
            await self._apply_custom_timer(
                ctx, chan_id, str(slot),
                "label", label="WA", rounds=rounds, by=caster_name, emoji="ðŸª“"
            )
        except Exception:
            pass

        pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=tgt_disp)
        lines.append(f"ðŸª“ **{pretty}**: AC **âˆ’1** for **{rounds}** rounds.")
        return lines

    async def _cast_enhanceweapon(self, ctx, cfg, caster_name: str, level: int, args: list[str]):
        """
        Enhance Weapon: +1 to hit & damage for 1 turn (60 rounds), character-wide (no weapon pin).
        """
        target_in = (args[0] if args else caster_name)
        try:
            target_disp, _ = self._resolve_char_ci(target_in)
        except Exception:
            target_disp = target_in
        target = target_disp or target_in

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, target) or target
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")

        rounds = 60


        bcfg.set(chan_id, f"{slot}.enhwep", str(rounds))

        if bcfg.has_option(chan_id, f"{slot}.enhwep_name"):
            bcfg.remove_option(chan_id, f"{slot}.enhwep_name")
        _save_battles(bcfg)


        await self._apply_custom_timer(
            ctx, chan_id, str(slot),
            "label",
            label="EW",
            rounds=rounds,
            by=caster_name,
            emoji="âš”ï¸"
        )

        pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=target)
        return [
            f"{caster_name} casts **Enhance Weapon**!",
            f"Target: **{pretty}**",
            "Effect: **+1 to hit & damage** for **60** rounds."
        ]

    async def _cast_weakenweapon(self, ctx, cfg, caster_name: str, level: int, args: list[str]):
        """
        Weaken Weapon: Requires a touch attack (d20 + AB + INT mod vs target AC).
        On hit, target saves vs Spells; on FAIL, target suffers âˆ’1 to hit & âˆ’1 damage (all weapons) for 1 turn (60 rd).
        """

        if not args:
            return ["âŒ Usage: `!cast WeakenWeapon <target>`"]


        target_in = args[0]
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_in)
        except Exception:
            tgt_disp, tgt_path = target_in, None
            base = f"{target_in.replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_in}** not found."]

        t_cfg = read_cfg(tgt_path)


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_disp) or tgt_disp
        try:
            slot = _slot(key)
        except Exception:
            slot = key.replace(" ", "_")


        ab = self._get_attack_bonus(cfg)
        int_mod = self._abil_mod(cfg, "int") or 0

        target_ac, *_ = self._defender_ac_with_buffs(bcfg, chan_id, tgt_disp, want_oil=False, atk_type="melee")
        d20 = random.randint(1, 20)
        total_to_hit = d20 + ab + int_mod
        hit = (d20 == 20) or (total_to_hit >= target_ac)

        lines = [
            f"ðŸŽ¯ **Touch attack** on **{tgt_disp}**",
            f"Attack roll: {d20} + {ab:+} + {int_mod:+} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")
        ]
        if not hit:
            lines.append("No effect on a miss.")
            return lines


        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
        lines.append(f"Save vs Spells: {sv_roll} vs {sv_dc} â†’ **{'RESISTED' if sv_ok else 'FAIL'}**")
        if sv_ok:
            lines.append("No effect (save succeeded).")
            return lines


        rounds = 60
        bcfg.set(chan_id, f"{slot}.weakwep", str(rounds))
        if bcfg.has_option(chan_id, f"{slot}.weakwep_name"):
            bcfg.remove_option(chan_id, f"{slot}.weakwep_name")

        bcfg.set(chan_id, f"{slot}.x_weakenweapon", str(rounds))
        _save_battles(bcfg)


        try:
            await self._apply_custom_timer(
                ctx, chan_id, str(slot),
                "label", label="WW", rounds=rounds, by=caster_name, emoji="ðŸ—¡ï¸"
            )
        except Exception:
            pass

        pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=tgt_disp)
        lines.append(f"ðŸ—¡ï¸ **{pretty}**: **âˆ’1 to hit & damage** for **{rounds}** rounds.")
        return lines

    async def _effect_heatmetal(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Heat Metal (auto-success; no save, no attack)
        Applies staged fire damage to a single creature holding/wearing ferrous metal:
          R2-3: 1d4, R4-5: 2d4, R6: 1d4 (R1 & R7: no damage). Ticks at start of target's turn.
        """

        target_raw = (targets[0] if targets else "")
        if not target_raw:
            return "â™¨ï¸ **Heat Metal**: *(no target)*"

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"â™¨ï¸ **Heat Metal**: {pretty}: *(not found)*"



        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)


            names, _ = _parse_combatants(bcfg, chan_id)
            key_in_init = _find_ci_name(names, pretty) or _find_ci_name(names, target_raw) or pretty
            slot = _slot(key_in_init)

            bcfg.set(chan_id, f"{slot}.x_heatmetal", "1")
            _save_battles(bcfg)
        except Exception:
            pass


        await ctx.send(embed=nextcord.Embed(
            title="â™¨ï¸ Heat Metal",
            description=(f"Target: **{pretty}**\n"
                         "The item becomes **warm** now (no damage). "
                         "At the start of their turns:\n"
                         "â€¢ Rounds 2â€“3: **1d4 fire**\n"
                         "â€¢ Rounds 4â€“5: **2d4 fire**\n"
                         "â€¢ Round 6: **1d4 fire**\n"
                         "â€¢ Round 7: **fades**"),
            color=random.randint(0, 0xFFFFFF)
        ))


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return f"â™¨ï¸ **Heat Metal** on **{pretty}**: staged effect applied."

    async def _effect_chillmetal(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Chill Metal (reverse of Heat Metal). Same schedule, **cold** damage.
        """
        target_raw = (targets[0] if targets else "")
        if not target_raw:
            return "â„ï¸ **Chill Metal**: *(no target)*"

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"â„ï¸ **Chill Metal**: {pretty}: *(not found)*"

        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)

            names, _ = _parse_combatants(bcfg, chan_id)
            key_in_init = _find_ci_name(names, pretty) or _find_ci_name(names, target_raw) or pretty
            slot = _slot(key_in_init)

            bcfg.set(chan_id, f"{slot}.x_chillmetal", "1")
            _save_battles(bcfg)
        except Exception:
            pass

        await ctx.send(embed=nextcord.Embed(
            title="â„ï¸ Chill Metal",
            description=(f"Target: **{pretty}**\n"
                         "The item becomes **chilly** now (no damage). "
                         "At the start of their turns:\n"
                         "â€¢ Rounds 2â€“3: **1d4 cold**\n"
                         "â€¢ Rounds 4â€“5: **2d4 cold**\n"
                         "â€¢ Round 6: **1d4 cold**\n"
                         "â€¢ Round 7: **fades**"),
            color=random.randint(0, 0xFFFFFF)
        ))

        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content=content)
        except Exception:
            pass

        return f"â„ï¸ **Chill Metal** on **{pretty}**: staged effect applied."



    async def _cast_channelblast(self, ctx, caster_cfg, caster_name: str, caster_level: int, args: list[str] | None):
        """
        ChannelBlast (Spellcrafter 3): drain a charged/one-use magic item to fire a 60' cone.
        We *don't* manipulate inventory hereâ€”call with a dice amount or a type token and targets.

        Syntax:
          !cast channelblast <N | Nd6 | potion | scroll[<L>] | wand | staff | rod | ring | misc> <targets...>

        Examples:
          !cast channelblast 3 or1 or2 or3       -> 3d6
          !cast channelblast wand ogre troll     -> 4d6
          !cast channelblast staff orc1 orc2     -> 5d6
          !cast channelblast rod kob1 kob2       -> 6d6
          !cast channelblast scroll5 sk1 sk2     -> 5d6 (spell scroll level 5)
          !cast channelblast scroll gob1 gob2    -> 3d6 (non-spell scroll)
          !cast channelblast potion gob1         -> 3d6
          !cast channelblast misc gob1 gob2      -> 4d6
        """

        toks = [t for t in (args or []) if t]
        if not toks:
            return ["âŒ Usage: `!cast channelblast <Xd6 | N | wand|staff|rod|ring|potion|scroll[<L>]|misc> <targets...>`"]

        n_d6: int | None = None
        targets: list[str] = []


        def _maybe_parse_dice(tok: str) -> int | None:
            m = re.fullmatch(r"\s*(\d+)\s*(?:d\s*6)?\s*", tok, flags=re.I)
            return max(1, min(20, int(m.group(1)))) if m else None


        first = toks[0].lower()


        n_d6 = _maybe_parse_dice(first)


        if n_d6 is None:

            m = re.fullmatch(r"(?:scroll|s)\s*(\d+)", first, flags=re.I)
            if m:
                n_d6 = max(1, min(20, int(m.group(1))))
            else:

                mapping = {
                    "potion": 3,
                    "pot": 3,
                    "scroll": 3,
                    "wand": 4,
                    "staff": 5,
                    "rod": 6,
                    "ring": 6,
                    "misc": 4,
                    "other": 4,
                    "weapon": 4,
                    "armor": 4,
                }
                n_d6 = mapping.get(first)


        targets = toks[1:] if n_d6 is not None else toks

        if n_d6 is None:
            return ["âŒ Couldnâ€™t parse the damage. Try `!cast channelblast 4 gob1 gob2` or `!cast channelblast wand gob1`."]

        dice_spec = f"{n_d6}d6"

        return await self._area_damage_simple(
            ctx,
            "ChannelBlast (60' cone)",
            dice_spec,
            targets,
            save_pref=("spell","spells"),
            dmg_type="force"
        )


    @commands.command(name="removescroll", aliases=["delscroll","rmscroll"])
    async def remove_scroll_instance(self, ctx, sid_or_token: str | None = None):
        """
        Remove a Spell Scroll instance from your character (deletes the [scroll:<id>] record
        and removes the token from inventory/carry). Does not care whether it is 'spent'.

        Usage:
          !removescroll 5
          !removescroll @5
          !removescroll SpellScroll@5
        """

        who = get_active(ctx.author.id)
        if not who:
            return await ctx.send("âŒ No active character. Use `!char <name>` first.")
        name, path = self._resolve_char_ci(who)
        if not path or not os.path.exists(path):
            return await ctx.send(f"âŒ Character '{who}' not found.")
        cfg = read_cfg(path)

        if not sid_or_token:
            return await ctx.send("Usage: `!removescroll <id|@id|SpellScroll@id>` â€” see `!scrolls` for IDs.")

        sid = self._scroll_id_from_token(sid_or_token)
        if not sid:
            return await ctx.send("âŒ That doesnâ€™t look like a scroll id. Try `!removescroll 5` (see `!scrolls`).")

        rec = self._read_scroll_rec(cfg, sid)
        if not rec:
            return await ctx.send(f"âŒ No scroll @**{sid}**.")

        token = f"SpellScroll@{sid}"


        try:
            self._consume_carried_item_fallback(cfg, token, qty=1_000_000)
        except Exception:
            pass


        if not cfg.has_section("item"):
            cfg.add_section("item")
        storage = (get_compat(cfg, "item", "storage", fallback="") or "").split()
        storage = [s for s in storage if self._norm(s) != self._norm(token)]
        cfg.set("item", "storage", " ".join(storage))
        try:
            if cfg.has_option("item", token.lower()):
                cfg.remove_option("item", token.lower())
        except Exception:
            pass


        try:
            cfg.remove_section(f"scroll:{sid}")
        except Exception:
            pass


        try:
            self._recalc_carry_weight(cfg)
        except Exception:
            pass
        write_cfg(path, cfg)

        await ctx.send(f"ðŸ—‘ï¸ Removed **SpellScroll@{sid}** from **{name}**.")



    async def _effect_repair(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Repair (Spellcrafter 1)
        Heals a *construct* for 1d6+1 HP. Touch, instant.
        No effect on non-constructs.
        """
        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **Repair**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        if not _is_construct_cfg(t_cfg, pretty):
            return f"âœ¨ **Repair**: {pretty}: âŒ **No effect** â€” target is not a construct."


        dice_spec = "1d6+1"
        total, rolls, flat = roll_dice("1d6")
        amount = max(0, total + (flat or 0) + 1)
        head = f"âœ¨ **{dice_spec}** [{', '.join(str(r) for r in rolls)}] + 1 = **{amount}**"


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
        if old_hp <= 0:
            return head + "\n" + f"{pretty}: already **DESTROYED** â€” cannot be repaired by this spell."

        new_hp = min(max_hp, old_hp + amount)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, width=10)
            after  = _life_bar(new_hp, max_hp, width=10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        return head + "\n" + f"{pretty}: **+{amount} HP** â€¢ {hp_txt}"


    async def _effect_seriousrepair(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        SeriousRepair (Spellcrafter 3)
        Heals a *construct* for 2d6+1 HP. Touch, instant.
        No effect on non-constructs.
        """
        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **SeriousRepair**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        if not _is_construct_cfg(t_cfg, pretty):
            return f"âœ¨ **SeriousRepair**: {pretty}: âŒ **No effect** â€” target is not a construct."


        total, rolls, flat = roll_dice("2d6")
        amount = max(0, total + (flat or 0) + 1)
        head = f"âœ¨ **2d6+1** [{', '.join(str(r) for r in rolls)}] + 1 = **{amount}**"

        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
        if old_hp <= 0:
            return head + "\n" + f"{pretty}: already **DESTROYED** â€” cannot be repaired by this spell."

        new_hp = min(max_hp, old_hp + amount)
        t_cfg["cur"]["hp"] = str(new_hp)
        write_cfg(path, t_cfg)


        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, width=10)
            after  = _life_bar(new_hp, max_hp, width=10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        return head + "\n" + f"{pretty}: **+{amount} HP** â€¢ {hp_txt}"



    async def _effect_holdconstruct(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Hold Construct (Spellcrafter 3)
          â€¢ Single target â†’ Save vs Spells at â€“2.
          â€¢ Group cast (2+ names) â†’ roll 1d4; only that many are *affected* (each gets a normal save).
          â€¢ Only constructs (e.g., golems, automatons, animated objects, vehicles, etc.).
          â€¢ On failed save: PARALYZED for 2d8 *turns* (== turns*60 rounds).
          â€¢ Range/Durations are handled by table rules; range isnâ€™t enforced here.
        """


        resolved: list[tuple[str, str, str | None]] = []
        for raw in (targets or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            resolved.append((raw, (disp or raw), path))

        if not any(p for _, _, p in resolved):
            return "ðŸ§¿ **Hold Construct** â€” _(no valid targets found)_"


        group_mode = (len([1 for _, _, p in resolved if p]) >= 2)

        chosen = []
        roll_note = ""
        if group_mode:
            d, rolls, flat = roll_dice("1d4")
            k = min(d + flat, len([1 for _, _, p in resolved if p]))
            pool = [(r, d, p) for (r, d, p) in resolved if p]
            random.shuffle(pool)
            chosen = pool[:k]
            roll_note = f" â€” group cast: 1d4 â†’ **{k}**"
        else:
            for tup in resolved:
                if tup[2]:
                    chosen = [tup]
                    break

        lines = []
        for raw, disp, path in chosen:
            pretty_up = (disp or raw).upper()
            if not path:
                lines.append(f"{pretty_up}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            try:
                is_construct = _is_construct_cfg(t_cfg, disp)
            except Exception:

                ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
                      str(get_compat(t_cfg, "info",  "race", fallback="")) or
                      str(get_compat(t_cfg, "info",  "monster_type", fallback=""))).lower()
                is_construct = any(tok in ty for tok in ("construct","golem","automaton","clockwork","animated","vehicle","robot","android"))
            if not is_construct:
                lines.append(f"{pretty_up}: not a construct (no effect)")
                continue


            too_large = False
            try:
                too_large = self._too_large_for_hold(t_cfg, disp)
            except Exception:
                sz = str(get_compat(t_cfg, "stats", "size", fallback="")).lower()
                too_large = any(k in sz for k in ("huge","gargantuan","colossal","enormous"))
            if too_large:
                lines.append(f"{pretty_up}: too large (larger than ogre) â€” no effect")
                continue


            penalty = 2 if not group_mode else 0
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=penalty)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            if ok:
                lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **RESISTED**")
                continue


            t_sum, t_rolls, t_flat = roll_dice("2d8")
            turns = t_sum + t_flat
            rounds = turns * 60
            try:
                self._set_status_rounds(ctx, disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ ðŸ§Š **PARALYZED** *(for {turns} turns)*")

        head = f"ðŸ§¿ **Hold Construct**{roll_note}"
        return head + "\n" + "\n".join(lines)




    async def _effect_overtakeitem(self, ctx, caster_cfg, caster_name: str, caster_level: int, args: list[str]) -> str:
        """
        Overtake Item
          â€¢ If a target is named and found: target rolls Save vs Spells.
              - On FAIL: display that their magic item activates (GM adjudicates the effect).
              - On SUCCESS: resisted; no effect.
            Optional item label: any extra words after the target name are shown in the message.
          â€¢ If no valid target is given: treat the args (if any) as an unattended item label and
            display that it activates. If no args at all: generic unattended activation message.

          Notes: Range (30 ft) and line-of-sight are not enforced here; GM adjudicates.
        """

        head = "ðŸª„ **Overtake Item**"


        if not (args or []):
            return f"{head}\nAn unattended magic item **activates**."


        target_tok = args[0]
        item_label = " ".join(args[1:]).strip()

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_"," ")), path
                        except Exception:
                            return fn[:-4].replace("_"," "), path
                return None, None

        disp, path = _resolve_char_ci(target_tok)


        if not path:
            label = " ".join(args).strip()
            label_txt = f"**{label}** " if label else ""
            return f"{head}\n{label_txt}(unattended) **activates**."


        t_cfg = read_cfg(path)
        pretty_up = (disp or target_tok).upper()

        ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
        pen_txt = f" - {sv_pen}" if sv_pen else ""
        label_txt = f" **({item_label})**" if item_label else ""

        if ok:

            return (
                f"{head}\n"
                f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **RESISTED**{label_txt}\n"
                f"*(the item does not activate)*"
            )


        return (
            f"{head}\n"
            f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **FAIL**{label_txt}\n"
            f"âœ… The magic item **activates**! *(GM adjudicates the specific effect.)*"
        )



    async def _effect_stoneshape(self, ctx, caster_cfg, caster_name: str, caster_level: int, args: list[str]) -> str:
        """
        Stone Shape
          â€¢ Shapes an existing piece of stone into a simple form.
          â€¢ Capacity: 10 cu ft + 1 cu ft per caster level.
          â€¢ If '-fine' is present (moving/mechanical parts), roll 1d6:
              - On 1â€“2: the mechanical parts do not function.
              - On 3â€“6: they work.
          â€¢ No targets; GM adjudicates range (Touch) & LoS and the exact geometry.
        """


        flags = {self._norm(a) for a in (args or []) if str(a).startswith("-")}
        fine = any(f in {"-fine","-fine","fine"} for f in (args or [])) or ("fine" in flags)


        desc_words = [a for a in (args or []) if not str(a).startswith("-")]
        description = " ".join(desc_words).strip()


        vol_cf = max(0, 10 + int(caster_level or 0))
        approx_area_sqft_at_1ft = vol_cf

        head = "ðŸª¨ **Stone Shape**"
        lines = [
            f"Capacity: **{vol_cf} cu ft** *(10 + level {caster_level})*"
            f" â€” â‰ˆ **{approx_area_sqft_at_1ft} sq ft** at 1-ft thickness.",
        ]
        if description:
            lines.append(f"Form: *{description}*")


        if fine:
            total, rolls, flat = roll_dice("1d6")
            r = max(1, total + flat)
            works = (r >= 3)
            roll_txt = f"**1d6** [{', '.join(str(x) for x in rolls)}] = **{r}**"
            if works:
                lines.append(f"Fine mechanics check: {roll_txt} â†’ âœ… **mechanical parts function**.")
            else:
                lines.append(f"Fine mechanics check: {roll_txt} â†’ âŒ **mechanical parts do not function**.")

        return head + "\n" + "\n".join(lines)


    async def _cast_slow(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Slow
          â€¢ Each named target: Save vs Spells.
              - FAIL: apply a visible [SLOW N] tag for N = caster level rounds.
                      GM adjudication: half movement; half attacks (typically act every other round).
                      If the target is Hasted, Haste is dispelled instead of applying Slow.
              - SUCCESS: no effect.
          â€¢ Range/area: GM adjudicated; rules say 30 ft + 10/level, Duration: 1 round/level.
        """
        chan_id = str(ctx.channel.id)
        rounds = max(1, int(caster_level or 1))
        rng = 30 + 10 * max(0, int(caster_level or 0))


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rcfg = read_cfg(path)
                            real = get_compat(rcfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        names = []
        if isinstance(targets, (list, tuple, set)):
            names = [t for t in targets if isinstance(t, str) and t.strip()]
        elif isinstance(targets, str):
            names = [t.strip() for t in targets.split() if t.strip()]

        if not names:
            return [f"Usage: `!cast slow <t1> <t2> ...`  _(Range {rng} ft; Duration {rounds} rounds)_"]

        lines = [f"ðŸ¢ **{caster_name}** casts **Slow** _(Range {rng} ft; Duration {rounds} rounds)_"]
        any_changes = False

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        for raw in names:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path or not os.path.exists(path):
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(path)


            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)

            if sv_ok:
                lines.append(f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ âœ… **RESISTED**")
                continue



            dispelled_haste = False
            if bcfg and bcfg.has_section(chan_id):
                slot = self._effect_slot_for(bcfg, chan_id, pretty)


                cleared = False
                for key in ("x_hst", "x_haste", "haste"):
                    opt = f"{slot}.{key}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                        cleared = True

                for key in ("x_hst_label","x_hst_code","x_hst_by","haste_by","haste_src"):
                    opt = f"{slot}.{key}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                        cleared = True

                if cleared:
                    _save_battles(bcfg)
                    dispelled_haste = True
                    any_changes = True

            if dispelled_haste:
                lines.append(
                    f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ **FAIL** â†’ âœ¨ **Haste dispelled** (no Slow applied)."
                )
                continue


            if bcfg and bcfg.has_section(chan_id):
                slot = self._effect_slot_for(bcfg, chan_id, pretty)


                bcfg.set(chan_id, f"{slot}.x_slw",        str(rounds))
                bcfg.set(chan_id, f"{slot}.x_slw_label",  "Slow")
                bcfg.set(chan_id, f"{slot}.x_slw_code",   "SLO")
                bcfg.set(chan_id, f"{slot}.x_slw_by",     caster_name)
                _save_battles(bcfg)
                any_changes = True

                lines.append(
                    f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ **FAIL** â†’ ðŸ¢ **SLOWED** for **{rounds} rounds** â€” "
                    f"half move; half attacks *(generally act every other round)*."
                )
            else:
                lines.append(
                    f"â€¢ **{pretty}**: Save {sv_roll} vs {sv_dc} â†’ **FAIL** â†’ **SLOWED {rounds} rounds** "
                    f"(half move; half attacks; no active battle, wonâ€™t auto-tick)."
                )


        if any_changes:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass


        lines.append("_Note: Haste and Slow donâ€™t stack; they counter/dispel each other._")
        return lines


    async def _effect_charmconstructs(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Charm Constructs (Spellcrafter 4)
          â€¢ Single target within 30 ft. Save vs Spells negates.
          â€¢ Only affects constructs (golems, clockworks, animated objects, vehicles, etc.).
          â€¢ Control is LIMITED as Charm Person (GM adjudicates reasonableness).
          â€¢ Target gets a NEW saving throw EACH DAY to break free.
          â€¢ On breaking free: unintelligent returns to prior directives; intelligent knows it was controlled.

        Flags (same as Charm Person for table consistency):
          -h / -hostile      â†’ apply +5 to the target's save (threatened/hostile)
          -nh / -nonhostile  â†’ do NOT apply the +5 bonus
        """

        chan_id = str(ctx.channel.id)
        head = "ðŸª„ **Charm Constructs** â€” a binding command resonates through stone and steelâ€¦ *(Range 30 ft)*"


        raw_names: list[str] = []
        force_hostile = None
        for t in (tokens or []):
            if not t: continue
            tl = str(t).strip().lower()
            if tl in ("-h","-hostile","+5","hostile"):
                force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"):
                force_hostile = False
            else:
                raw_names.append(t)

        if not raw_names:
            return head + "\n*(Add a construct target, e.g., `!cast charmconstructs iron golem`.)*"


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None

        tgt_disp, tgt_path = _resolve_any_ci(raw_names[0])
        extras = [n for n in raw_names[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        if not tgt_path:
            return head + f"\n**{raw_names[0]}**: âŒ *(not found)*" + extra_note

        t_cfg = read_cfg(tgt_path)


        if not _is_construct_cfg(t_cfg, tgt_disp):
            return head + f"\n**{tgt_disp}**: not a construct â€” no effect." + extra_note


        hostile_bonus = False
        if force_hostile is not None:
            hostile_bonus = bool(force_hostile)
        else:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    if bcfg.getint(chan_id, "round", fallback=0) >= 1:
                        hostile_bonus = True
            except Exception:
                pass


        used_vs = "Spells"
        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
        if sv_dc is None:

            sv_dc = 15
            sv_ok, sv_roll = False, 10

        bonus = 5 if hostile_bonus else 0
        adj_roll = (sv_roll or 0) + bonus
        d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
        bonus_txt = f" + {bonus}" if bonus else ""
        passed = adj_roll >= sv_dc

        line = f"**{tgt_disp}** â€” Save vs {used_vs}: {d20_face}{bonus_txt} = ``{adj_roll}`` vs **{sv_dc}** â†’ "
        if passed:
            return head + "\n" + line + "âŒ **RESISTS**" + extra_note


        charm_note = (
            "ðŸ§© **CONTROL ESTABLISHED** â€” The construct obeys as with *Charm Person* (no suicidal/self-destructive orders). "
            "The target attempts a new save **each day** to break free. "
            "On success: unintelligent constructs resume prior directives; intelligent constructs know they were controlled."
        )

        return head + "\n" + line + charm_note + extra_note


    async def _cast_massarmorenhancement(self, ctx, cfg, caster_name: str, level: int, args: list[str]):
        """
        Mass Armor Enhancement (Spellcrafter 4)
          â€¢ Affect up to 3 targets (range adjudicated by DM; you name whoâ€™s in 30 ft).
          â€¢ Each target gets an AC bonus of +1 per 3 caster levels (min +1).
          â€¢ Duration: 1 turn (60 rounds).
          â€¢ Works like EnhanceArmor but applies to the CHARACTER, not a specific item.
        Usage:
          !cast massarmorenhancement A B C
          !cast mae tank1 tank2
        """

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]


        raw_names = [a for a in (args or []) if isinstance(a, str) and a.strip()]
        if not raw_names:
            raw_names = [caster_name]
        chosen = raw_names[:3]
        ignored = raw_names[3:]


        bonus = max(1, int(level // 3))
        rounds = 60

        lines = [f"ðŸ›¡ï¸ **Mass Armor Enhancement** â€” +{bonus} AC for {rounds} rounds (up to 3 targets)."]
        if ignored:
            lines.append(f"*(Ignoring extra names: {', '.join(ignored)})*")


        def _resolve_disp(name: str) -> tuple[str, str]:
            try:
                disp, path = self._resolve_char_ci(name)
            except Exception:
                disp, path = (name, None)
            return (disp or name), path

        names, _scores = _parse_combatants(bcfg, chan_id)

        any_applied = False
        for nm in chosen:
            disp, _path = _resolve_disp(nm)
            key = _find_ci_name(names, disp) or disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")


            cur = bcfg.getint(chan_id, f"{slot}.enharmor", fallback=0)
            bcfg.set(chan_id, f"{slot}.enharmor", str(max(cur, rounds)))


            cur_bonus = bcfg.getint(chan_id, f"{slot}.enharmor_bonus", fallback=0)
            bcfg.set(chan_id, f"{slot}.enharmor_bonus", str(max(cur_bonus, bonus)))

            _save_battles(bcfg)
            any_applied = True


            label = f"EA+{bonus}" if bonus > 1 else "EA"
            await self._apply_custom_timer(
                ctx, chan_id, str(slot),
                "label",
                label=label,
                rounds=rounds,
                by=caster_name,
                emoji="ðŸ›¡ï¸"
            )

            pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=disp)
            lines.append(f"â€¢ **{pretty}**: AC **+{bonus}** for **{rounds}** rounds.")

        if not any_applied:
            lines.append("*(No valid targets found in the current battle.)*")

        return lines

    async def _cast_massweaponenhancement(self, ctx, cfg, caster_name: str, level: int, args: list[str]):
        """
        Mass Weapon Enhancement (Spellcrafter 4)
          â€¢ Affect up to 3 targets you name (GM adjudicates 30 ft range).
          â€¢ Each target gains +B to hit & damage, where B = max(1, floor(level/3)).
          â€¢ Duration: 1 turn (60 rounds).
          â€¢ Works like EnhanceWeapon but applies to the CHARACTER (no weapon pin).
        Usage:
          !cast massweaponenhancement a b c
          !cast mwe tank1 tank2
        """

        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ Not currently in combat. Start initiative first."]


        raw_names = [a for a in (args or []) if isinstance(a, str) and a.strip()]
        if not raw_names:
            raw_names = [caster_name]
        chosen = raw_names[:3]
        ignored = raw_names[3:]

        bonus  = max(1, int(level // 3))
        rounds = 60

        lines = [f"âš”ï¸ **Mass Weapon Enhancement** â€” **+{bonus}** to hit & damage for {rounds} rounds (up to 3 targets)."]
        if ignored:
            lines.append(f"*(Ignoring extra names: {', '.join(ignored)})*")


        def _resolve_disp(name: str) -> tuple[str, str | None]:
            try:
                disp, path = self._resolve_char_ci(name)
            except Exception:
                disp, path = (name, None)
            return (disp or name), path

        names_in_battle, _ = _parse_combatants(bcfg, chan_id)
        any_applied = False

        for nm in chosen:
            disp, _ = _resolve_disp(nm)
            key = _find_ci_name(names_in_battle, disp) or disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")


            cur = bcfg.getint(chan_id, f"{slot}.enhwep", fallback=0)
            bcfg.set(chan_id, f"{slot}.enhwep", str(max(cur, rounds)))


            cur_bonus = bcfg.getint(chan_id, f"{slot}.enhwep_bonus", fallback=0)
            bcfg.set(chan_id, f"{slot}.enhwep_bonus", str(max(cur_bonus, bonus)))


            for k in (f"{slot}.enhwep_name", f"{slot}.enh_wep_name"):
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)

            _save_battles(bcfg)
            any_applied = True


            label = f"EW+{bonus}" if bonus > 1 else "EW"
            await self._apply_custom_timer(
                ctx, chan_id, str(slot),
                "label",
                label=label,
                rounds=rounds,
                by=caster_name,
                emoji="âš”ï¸"
            )

            pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=disp)
            lines.append(f"â€¢ **{pretty}**: to-hit & damage **+{bonus}** for **{rounds}** rounds.")

        if not any_applied:
            lines.append("*(No valid targets found in the current battle.)*")

        return lines


    async def _effect_starlightblade(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]):
        """
        StarlightBlade (Spellcrafter 5) â€” character buff (as an effect).
        - Duration/Timer is handled by !cast auto-timer: x_starlightblade, code "SB"
        - !a: add +1d6+1 holy vs undead while timer > 0
        - !turn: allow/boost to 5th-level Cleric while timer > 0
        This function only prepares embed lines and (optionally) seeds the timer if missing.
        """

        tgt_name = caster_name
        for t in (targets or []):
            if isinstance(t, str) and t.strip() and not t.strip().startswith("-"):
                tgt_name = t.strip()
                break

        lines = []
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)


            pretty = tgt_name
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_name) or tgt_name
                try:
                    slot = _slot(key)
                except Exception:
                    slot = key.replace(" ", "_")


                cur = bcfg.getint(chan_id, f"{slot}.x_starlight", fallback=0)
                if cur <= 0:
                    rounds = max(1, int(caster_level))
                    bcfg.set(chan_id, f"{slot}.x_starlight",        str(rounds))
                    bcfg.set(chan_id, f"{slot}.x_starlight_code",   "SB")
                    bcfg.set(chan_id, f"{slot}.x_starlight_label",  "StarlightBlade")
                    bcfg.set(chan_id, f"{slot}.x_starlight_emoji",  "âœ¨")
                    bcfg.set(chan_id, f"{slot}.x_starlight_by",     caster_name)
                    _save_battles(bcfg)

                pretty = bcfg.get(chan_id, f"{slot}.disp", fallback=key)


            if pretty != caster_name:
                lines.append(f"Target: **{pretty}**")

        except Exception:

            pass

        lines += [
            "ðŸŽ‡ **Starlight Blade**",
            "â€¢ Weapon attacks vs **undead** deal **+1d6+1 holy** (applied in `!a`).",
            "â€¢ You may use `!turn` as a **5th-level Cleric**.",
            "â€¢ The weapon glows silver and sheds star-motes on each strike.",
        ]
        return lines

    async def _effect_dominateconstruct(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Dominate Construct (Spellcrafter 7) â€” Range 30 ft â€” Duration: Special
          â€¢ Take absolute control of a **construct**; you can order even self-destructive actions.
          â€¢ Use `-un` to mark an **unintelligent** construct â†’ **no save**, **permanent**.
          â€¢ Otherwise treated as **intelligent** â†’ Save vs **Spells** to resist; GM handles daily re-saves.
          â€¢ Only one construct can be controlled at a time â€” casting again **releases** the prior one automatically.
          â€¢ `-release` drops your current dominated construct without picking a new target.

        Flags:
          -un / -unintelligent  : target is mindless/unintelligent (no save; permanent)
          -h / -hostile         : (optional) give target +5 to its save (table consistency with Charm)
          -nh / -nonhostile     : do NOT apply the +5 (default)
          -release              : release your current dominated construct (no target needed)
        """
        chan_id = str(ctx.channel.id)
        head = "ðŸ§  **Dominate Construct** â€” *(Range 30 ft)*"


        raw_names: list[str] = []
        want_release = False
        unintelligent = False
        force_hostile = None
        for t in (tokens or []):
            if not t: continue
            tl = str(t).strip().lower()
            if   tl in ("-release","release","-r"):          want_release = True
            elif tl in ("-un","-unintelligent","mindless"):  unintelligent = True
            elif tl in ("-h","-hostile","+5","hostile"):     force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm"):       force_hostile = False
            else:
                raw_names.append(t)


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None


        bcfg = _load_battles()
        names = []
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
        def _canon_key(nm: str) -> str:
            return (_find_ci_name(names, nm) or nm) if names else nm


        if want_release and bcfg and bcfg.has_section(chan_id):
            caster_key = _canon_key(caster_name) or caster_name
            try:
                s_cast = _slot(caster_key)
            except Exception:
                s_cast = caster_key.replace(" ","_")
            if bcfg.has_option(chan_id, f"{s_cast}.domcon"):
                _unlink_domcon(bcfg, chan_id, caster_key)
                _save_battles(bcfg)

                try:
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
                except Exception: pass
                return head + "\nControl **released**."
            else:
                return head + "\nYou have no dominated construct to release."


        if not raw_names:
            return head + "\n*(Add a construct target, e.g., `!cast dominateconstruct iron golem`.)*"

        tgt_disp, tgt_path = _resolve_any_ci(raw_names[0])
        extras = [n for n in raw_names[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        if not tgt_path:
            return head + f"\n**{raw_names[0]}**: âŒ *(not found)*" + extra_note

        t_cfg = read_cfg(tgt_path)


        if not _is_construct_cfg(t_cfg, tgt_disp):
            return head + f"\n**{tgt_disp}**: not a construct â€” no effect." + extra_note


        line = f"**{tgt_disp}** â€” "

        if unintelligent:

            line += "unintelligent/mindless â€” **no save** â†’ ðŸ§· **CONTROL ESTABLISHED (permanent)**"
            controlled = True
        else:

            hostile_bonus = bool(force_hostile) if (force_hostile is not None) else False
            sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            if sv_dc is None:
                sv_dc, sv_ok, sv_roll = 15, False, 10
            bonus = 5 if hostile_bonus else 0
            adj = (sv_roll or 0) + bonus
            d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
            line += f"Save vs Spells: {d20_face}{(' + 5' if bonus else '')} = ``{adj}`` vs **{sv_dc}** â†’ "
            if adj >= sv_dc:
                return head + "\n" + line + "âŒ **RESISTS**" + extra_note
            line += "ðŸ§· **CONTROL ESTABLISHED**"
            controlled = True


        caster_key = _canon_key(caster_name) or caster_name
        tgt_key    = _canon_key(tgt_disp)    or tgt_disp

        prev_note = ""
        if controlled and bcfg and bcfg.has_section(chan_id):
            try:
                s_cast = _slot(caster_key)
            except Exception:
                s_cast = caster_key.replace(" ","_")
            prev = bcfg.get(chan_id, f"{s_cast}.domcon", fallback="").strip()
            if prev:
                _unlink_domcon(bcfg, chan_id, caster_key, prev)
                prev_note = f"\nðŸ” Previous control on **{prev}** is **released**."

            try:
                s_tgt = _slot(tgt_key)
            except Exception:
                s_tgt = tgt_key.replace(" ","_")
            bcfg.set(chan_id, f"{s_cast}.domcon", tgt_key)
            bcfg.set(chan_id, f"{s_tgt}.domby",  caster_key)

            if unintelligent:
                bcfg.set(chan_id, f"{s_tgt}.domcon_perm", "1")
                bcfg.set(chan_id, f"{s_tgt}.domcon_un",   "1")
            _save_battles(bcfg)


            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass


        daily_note = (
            "\nðŸ—“ï¸ Intelligent construct: the GM may grant a **new save each day** to break free (on success, it knows it was controlled)."
            if not unintelligent else
            "\nâ™¾ï¸ Unintelligent construct: control is **permanent** until released, dispelled, or the caster dies."
        )

        return head + "\n" + line + daily_note + prev_note + extra_note

    async def _effect_virtue(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Virtue (Cleric/Druid Cantrip)
          â€¢ Single target within 60 ft (not enforced here).
          â€¢ Target gains **1 temporary HP** (Stoneskin-style buffer).
          â€¢ Duration: **1 turn (10 minutes)** or until depleted.
          â€¢ Does **not** overwrite a higher existing temp HP/Stoneskin buffer.

        Usage:
          !cast virtue                # self
          !cast virtue <ally>         # name or monster id
        """


        target_raw = (targets[0] if (targets and len(targets) > 0) else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"âœ¨ **Virtue** â€” {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        if old_hp <= 0:
            return f"âœ¨ **Virtue** â€” {pretty}: already **DEAD** â€” cannot benefit."


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        chan_id = str(ctx.channel.id)
        if not (bcf := bcfg) or not bcfg.has_section(chan_id):

            return ("âœ¨ **Virtue** â€” grants **1 temporary HP** (1 turn) "
                    f"to **{pretty}**.\n*(No active initiative; track this manually.)*")


        try:
            slot_t = _resolve_effect_slot(bcfg, chan_id, pretty)
        except Exception:
            try:
                slot_t = _slot(pretty)
            except Exception:
                slot_t = str(pretty).replace(" ", "_")


        try:
            rounds_key, pool_key, by_key = _stone_keys(slot_t)
        except Exception:
            rounds_key = f"{slot_t}.ss_rounds"
            pool_key   = f"{slot_t}.ss_pool"
            by_key     = f"{slot_t}.ss_by"

        aliases = (f"{slot_t}.sspool", f"{slot_t}.ssbuf", f"{slot_t}.stoneskin", f"{slot_t}.ss")


        def _read_int(opt: str, dflt: int = 0) -> int:
            try:
                return int(str(bcfg.get(chan_id, opt, fallback=str(dflt))).strip() or dflt)
            except Exception:
                return dflt

        existing = max(
            _read_int(pool_key, 0),
            *[_read_int(a, 0) for a in aliases]
        )
        existing = max(0, existing)

        head = "âœ¨ **Virtue** â€” a fleeting blessing steels the body *(Range 60 ft)*"

        if existing > 0:
            return head + f"\n{pretty}: already has a temporary HP/Stoneskin buffer (**{existing}**) â€” **no effect**."


        try:
            TURN = TURN_ROUNDS
        except Exception:
            TURN = 60

        bcfg.set(chan_id, rounds_key, str(int(TURN)))
        bcfg.set(chan_id, pool_key,   "1")
        bcfg.set(chan_id, by_key,     caster_name)
        for a in aliases:
            try: bcfg.set(chan_id, a, "1")
            except Exception: pass
        try: bcfg.set(chan_id, f"{slot_t}.disp", pretty)
        except Exception: pass

        _save_battles(bcfg)


        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        return head + f"\n{pretty}: gains **1** temporary HP â€¢ Duration: **1 turn** (60 rounds). Tracker tag: **[SS 1]**."

    async def _effect_censure(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Censure (Cleric 1)
          â€¢ Range 30 ft (GM-adjudicated; optional check stub below).
          â€¢ One living creature, ineffective vs 7+ HD/levels.
          â€¢ Make a to-hit roll: d20 + WIS mod + Attack Bonus vs AC. On a hit, roll 1d6:
                1 â†’ Stunned (treat as Paralyzed) 1d4+1 rounds
                2â€“3 â†’ Paralyzed 1d4+1 rounds
                4â€“5 â†’ Slowed (move halved) 1d4+1 rounds
                6 â†’ Attacks halved 1d4+1 rounds
          â€¢ Uses existing 'paralyzed' status; adds x_slow / x_halfatk timers with codes SL / HA.
        """

        head = "âœï¸ **Censure**"
        chan_id = str(ctx.channel.id)


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _norm(n: str) -> str: return (n or "").strip().lower()

        def _wis_mod(cfg) -> int:
            try:
                s = getint_compat(cfg, "stats", "wis", fallback=10)
            except Exception:
                s = 10

            if s <= 3: return -3
            if s <= 5: return -2
            if s <= 8: return -1
            if s <= 12: return 0
            if s <= 15: return +1
            if s <= 17: return +2
            return +3

        def _read_ac(t_cfg) -> int:
            try:
                v = getint_compat(t_cfg, "cur", "ac", fallback=None)
                if v is None:
                    v = getint_compat(t_cfg, "base", "ac", fallback=10)
                return int(v)
            except Exception:
                return 10

        def _hd_or_level(t_cfg) -> int:
            try:
                hd_val = getint_compat(t_cfg, "base", "hd", fallback=None)
                if isinstance(hd_val, int) and hd_val > 0:
                    return hd_val
            except Exception:
                pass
            try:
                raw_hd = (get_compat(t_cfg, "base", "hd", fallback="") or "").strip()
                if raw_hd:
                    m = re.match(r"\s*(\d+)", raw_hd)
                    if m:
                        return int(m.group(1))
            except Exception:
                pass
            try:
                lvl = getint_compat(t_cfg, "cur", "level", fallback=None)
                if isinstance(lvl, int) and lvl > 0:
                    return lvl
            except Exception:
                pass
            return 1

        def _slot_ci(name: str):
            try:
                return _slot(name)
            except Exception:
                return name.replace(" ", "_")


        target_disp, target_path = None, None
        for raw in (tokens or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            if path:
                target_disp, target_path = (disp or raw), path
                break

        if not target_path:
            return f"{head} â€” _(no valid target found)_"

        t_cfg = read_cfg(target_path)
        pretty = (target_disp or "").upper()






        try:
            if _is_undead_cfg(t_cfg, target_disp):
                return f"{head}\nâ€¢ {pretty}: â˜ ï¸ Undead â€” **no effect**."
        except Exception:
            pass


        wis_m = _wis_mod(caster_cfg)
        ab    = self._get_attack_bonus(caster_cfg)
        d_sum, d_rolls, _ = roll_dice("1d20")
        total = d_sum + wis_m + ab

        ac_val = _read_ac(t_cfg)
        hit = (total >= ac_val)

        atk_line = (f"â€¢ Attack roll: {d_rolls[0]} "
                    f"+ {wis_m} + {ab} = **{total}** â†’ "
                    f"{'**HIT**' if hit else '**MISS**'}")


        if not hit:
            return f"{head}\n{atk_line}\nâ€¢ {pretty}: The condemnation fails to take hold."


        hd = _hd_or_level(t_cfg)
        if hd >= 7:
            return f"{head}\n{atk_line}\nâ€¢ {pretty}: **unaffected** (HD/Level {hd} â‰¥ 7)."


        try:
            bcfg_local = _load_battles()
            if bcfg_local and bcfg_local.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, [target_disp])
        except Exception:
            pass


        out_sum, out_rolls, _ = roll_dice("1d6")
        dur_sum, dur_rolls, _ = roll_dice("1d4+1")
        rounds = max(0, int(dur_sum))


        slot = None
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, target_disp) or target_disp
            slot = _slot_ci(key)


        applied_line = ""
        if out_sum == 1:

            try:
                self._set_status_rounds(ctx, target_disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            applied_line = (f"â€¢ {pretty}: **STUNNED** *(treated as Paralyzed)* "
                            f"for **{rounds} rounds** (1d4+1 = {', '.join(map(str, dur_rolls))}).")

        elif out_sum in (2, 3):
            try:
                self._set_status_rounds(ctx, target_disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            applied_line = (f"â€¢ {pretty}: **PARALYZED** for **{rounds} rounds** "
                            f"(1d4+1 = {', '.join(map(str, dur_rolls))}).")

        elif out_sum in (4, 5):

            if bcfg and bcfg.has_section(chan_id):
                prev = bcfg.getint(chan_id, f"{slot}.x_slow", fallback=0) if slot else 0
                newv = max(prev, rounds)
                if slot:
                    bcfg.set(chan_id, f"{slot}.x_slow", str(newv))
                    bcfg.set(chan_id, f"{slot}.x_slow_code", "SL")
                    bcfg.set(chan_id, f"{slot}.x_slow_by", caster_name)
                    _save_battles(bcfg)
            applied_line = (f"â€¢ {pretty}: **SLOWED** (movement halved) for **{rounds} rounds** "
                            f"(1d4+1 = {', '.join(map(str, dur_rolls))}).")

        else:

            if bcfg and bcfg.has_section(chan_id):
                prev = bcfg.getint(chan_id, f"{slot}.x_halfatk", fallback=0) if slot else 0
                newv = max(prev, rounds)
                if slot:
                    bcfg.set(chan_id, f"{slot}.x_halfatk", str(newv))
                    bcfg.set(chan_id, f"{slot}.x_halfatk_code", "HA")
                    bcfg.set(chan_id, f"{slot}.x_halfatk_by", caster_name)
                    _save_battles(bcfg)
            applied_line = (f"â€¢ {pretty}: **ATTACKS HALVED** for **{rounds} rounds** "
                            f"(1d4+1 = {', '.join(map(str, dur_rolls))}).")


        try:
            if bcfg and bcfg.has_section(chan_id):
                await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        table = {
            1: "Stunned (paralyzed)",
            2: "Paralyzed",
            3: "Paralyzed",
            4: "Slowed (move halved)",
            5: "Slowed (move halved)",
            6: "Attacks halved",
        }
        outcome_text = table.get(out_sum, "?")
        oline = f"â€¢ Effect roll: 1d6 = **{out_sum}** â†’ **{outcome_text}**"

        return f"{head}\n{atk_line}\n{oline}\n{applied_line}"

    async def _effect_command(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Command (Cleric 1)
          â€¢ Range 10 ft (GM-adjudicated; optional check stub below).
          â€¢ One target; the command must be a single word the target understands.
          â€¢ Undead: unaffected.
          â€¢ Save vs Spells allowed only if (INT â‰¥ 13) or (HD/Level â‰¥ 6). Otherwise no save.
          â€¢ Duration: 1 round (we set an x_command timer label, code CM).
          â€¢ The actual behavior (halt/flee/drop/etc.) is GM adjudicated.
        """

        head = "ðŸ—£ï¸ **Command**"
        chan_id = str(ctx.channel.id)


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _hd_or_level(t_cfg) -> int:
            try:
                hd_val = getint_compat(t_cfg, "base", "hd", fallback=None)
                if isinstance(hd_val, int) and hd_val > 0:
                    return hd_val
            except Exception:
                pass
            try:
                raw_hd = (get_compat(t_cfg, "base", "hd", fallback="") or "").strip()
                if raw_hd:
                    m = re.match(r"\s*(\d+)", raw_hd)
                    if m:
                        return int(m.group(1))
            except Exception:
                pass
            try:
                lvl = getint_compat(t_cfg, "cur", "level", fallback=None)
                if isinstance(lvl, int) and lvl > 0:
                    return lvl
            except Exception:
                pass
            return 1


        target_disp, target_path = None, None
        for raw in (tokens or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            if path:
                target_disp, target_path = (disp or raw), path
                break

        if not target_path:
            return f"{head} â€” _(no valid target found)_"

        t_cfg = read_cfg(target_path)
        pretty = (target_disp or "").upper()






        try:
            if _is_undead_cfg(t_cfg, target_disp):
                return f"{head}\nâ€¢ {pretty}: â˜ ï¸ Undead â€” **no effect**."
        except Exception:
            pass





        int_stat = None
        try:
            int_stat = getint_compat(t_cfg, "stats", "int", fallback=None)
            if int_stat is None:
                int_stat = getint_compat(t_cfg, "base", "int", fallback=None)
        except Exception:
            int_stat = None

        hd_or_lv = _hd_or_level(t_cfg)
        allow_save = (isinstance(int_stat, int) and int_stat >= 13) or (hd_or_lv >= 6)


        try:
            bcfg_local = _load_battles()
            if bcfg_local and bcfg_local.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, [target_disp])
        except Exception:
            pass


        save_line = ""
        resisted = False
        if allow_save:

            sv_ok = None; sv_roll = None; sv_dc = None
            for vs_key in ("spell", "spells", "spl"):
                try:
                    ok0, r, dc, _ = self._roll_save(t_cfg, vs=vs_key, penalty=0)
                    if dc is not None:
                        sv_ok, sv_roll, sv_dc = ok0, r, dc
                        break
                except Exception:
                    pass
            if sv_dc is None:

                sv_dc, sv_roll, sv_ok = 15, 10, False
            resisted = bool(sv_ok)
            save_line = f"\nâ€¢ Save vs Spells: {sv_roll} vs **{sv_dc}** â†’ " + ("**RESISTS**" if resisted else "**FAILS**")

        if resisted:
            return f"{head}\nâ€¢ {pretty}: The target keeps its wits and ignores the command.{save_line}"


        rounds = 1
        if bcfg and bcfg.has_section(chan_id):

            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, target_disp) or target_disp
            except Exception:
                key = target_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            prev = bcfg.getint(chan_id, f"{slot}.x_command", fallback=0)
            newv = max(prev, rounds)
            bcfg.set(chan_id, f"{slot}.x_command", str(newv))
            bcfg.set(chan_id, f"{slot}.x_command_code", "CM")
            bcfg.set(chan_id, f"{slot}.x_command_by", caster_name)
            _save_battles(bcfg)
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        note = "*(GM adjudicates the one-word command; target must understand the language.)*"
        gate_note = " *(no save)*" if not allow_save else ""
        return f"{head}\nâ€¢ {pretty}: **OBEYS for 1 round**{gate_note}.{save_line}\n{note}"

    async def _effect_bless(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]):
        """
        Bless â€” allies gain +1 to attack rolls, +1 to morale checks,
        and +1 to saves vs magical fear. At CL7+, attack & fear save
        bonuses are +2 instead (morale stays +1).
        Duration: 6 rounds/level (use this in spells.lst so auto-timer fires).
        Targets: named tokens; if none, default to self.
        """
        ch = str(ctx.channel.id)


        raw = []
        if isinstance(targets, (list, tuple, set)):
            raw = [t for t in targets if isinstance(t, str) and t.strip()]
        elif isinstance(targets, str) and targets.strip():
            raw = [targets.strip()]
        if not raw:
            raw = [caster_name]


        ok, miss = [], []
        for name in raw:
            try:
                disp, path = self._resolve_char_ci(name)
            except Exception:
                disp, path = str(name), None
                base = f"{str(name).replace(' ', '_')}.coe"
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        path = fn; break
            (ok if path else miss).append(disp)

        lines = [f"âœ¨ **Bless** â€” {caster_name} invokes favor upon: " + (", ".join(ok) if ok else "â€”")]
        if miss:
            lines.append("*(Not found: " + ", ".join(miss) + ")*")


        bcfg = _load_battles()
        if not (bcfg and bcfg.has_section(ch)):
            lines.append("ðŸ“Œ *No active battle here â€” it wonâ€™t auto-track.*")
            return lines


        atk_bonus = 2 if max(1, int(caster_level or 1)) >= 7 else 1
        fear_bonus = atk_bonus
        morale_bonus = 1

        names, _ = _parse_combatants(bcfg, ch)

        def _slot_ci(nm: str) -> str:
            k = _find_ci_name(names, nm) or nm
            try: return _slot(k)
            except Exception: return k.replace(" ", "_")


        for disp in ok:
            s = _slot_ci(disp)

            bcfg.set(ch, f"{s}.bless_hit",   str(atk_bonus))
            bcfg.set(ch, f"{s}.bless_fear",  str(fear_bonus))
            bcfg.set(ch, f"{s}.morale_bless", "1")
        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                awaitable = ini._update_tracker_message(ctx, bcfg, ch)
                if hasattr(awaitable, "__await__"):
                    await awaitable
        except Exception:
            pass

        lines.append(f"**Bonuses:** +{atk_bonus} to hit, +{fear_bonus} vs **fear**; +1 morale.")
        return lines

    async def _effect_bane(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]):
        """
        Bane â€” enemies suffer âˆ’1 to attack rolls, âˆ’1 to morale checks,
        and âˆ’1 to saves vs magical fear. At CL7+, attack & fear penalties
        become âˆ’2 (morale stays âˆ’1).
        Duration: 6 rounds/level (use this in spells.lst so auto-timer fires).
        No save. Targets: named tokens (enemies).
        """
        ch = str(ctx.channel.id)

        raw = []
        if isinstance(targets, (list, tuple, set)):
            raw = [t for t in targets if isinstance(t, str) and t.strip()]
        elif isinstance(targets, str) and targets.strip():
            raw = [targets.strip()]
        if not raw:
            return "â˜ ï¸ **Bane** â€” *(add at least one target, e.g., `!cast bane orc1 orc2`)*"

        ok, miss = [], []
        for name in raw:
            try:
                disp, path = self._resolve_char_ci(name)
            except Exception:
                disp, path = str(name), None
                base = f"{str(name).replace(' ', '_')}.coe"
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        path = fn; break
            (ok if path else miss).append(disp)

        lines = [f"â˜ ï¸ **Bane** â€” {caster_name} sows dread upon: " + (", ".join(ok) if ok else "â€”")]
        if miss:
            lines.append("*(Not found: " + ", ".join(miss) + ")*")

        bcfg = _load_battles()
        if not (bcfg and bcfg.has_section(ch)):
            lines.append("ðŸ“Œ *No active battle here â€” it wonâ€™t auto-track.*")
            return lines

        pen = 2 if max(1, int(caster_level or 1)) >= 7 else 1
        names, _ = _parse_combatants(bcfg, ch)

        def _slot_ci(nm: str) -> str:
            k = _find_ci_name(names, nm) or nm
            try: return _slot(k)
            except Exception: return k.replace(" ", "_")

        for disp in ok:
            s = _slot_ci(disp)

            bcfg.set(ch, f"{s}.bane_hit",   str(pen))
            bcfg.set(ch, f"{s}.bane_fear",  str(pen))
            bcfg.set(ch, f"{s}.morale_bane","1")
        _save_battles(bcfg)

        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                awaitable = ini._update_tracker_message(ctx, bcfg, ch)
                if hasattr(awaitable, "__await__"):
                    await awaitable
        except Exception:
            pass

        lines.append(f"**Penalties:** âˆ’{pen} to hit, âˆ’{pen} vs **fear**; âˆ’1 morale.")
        return lines

    def _fear_save_mod_for_slot(self, bcfg, chan_id: str, slot: str) -> int:
        """Return a net Â±N to apply to *fear* saves for this slot (only while timers > 0)."""
        mod = 0
        try:
            if bcfg.getint(chan_id, f"{slot}.x_bless", fallback=0) > 0:
                mod += max(1, bcfg.getint(chan_id, f"{slot}.bless_fear", fallback=1))
            if bcfg.getint(chan_id, f"{slot}.x_bane",  fallback=0) > 0:
                mod -= max(1, bcfg.getint(chan_id, f"{slot}.bane_fear",  fallback=1))
        except Exception:
            pass
        return mod

    async def _effect_charmanimal(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> dict:
        """
        Charm Animal (Cleric 2, Druid 2)
          â€¢ Range 60 ft (GM adjudicated).
          â€¢ You may charm multiple ANIMALS up to a total of 1 HD per caster level.
          â€¢ Caster chooses order; if a named targetâ€™s HD exceeds remaining budget, itâ€™s ignored
            (excess HD of effect is lost).
          â€¢ No save for normal/giant animals. Creatures of more fantastic nature get a Save vs Spells.
          â€¢ Duration: (Level + 1d4) rounds â€” we set a tracker timer on each charmed target.
          â€¢ Does NOT grant communication. (Combine with *Speak with Animals* for orders.)

        Flags:
          -f / -fantastic   â†’ treat ALL named targets as â€œfantasticâ€ (they get a save)
          name!              â†’ mark one target as â€œfantasticâ€ (per-target override)
          -h / -hostile     â†’ apply +5 to those saves (mirrors Charm Person)
          -nh / -nonhostile â†’ do NOT apply the +5 bonus
        """

        head = "ðŸ¾ **Charm Animal** â€” a soothing cadence calms wild beastsâ€¦"
        chan_id = str(ctx.channel.id)


        fantastic_all = False
        force_hostile = None
        raw_names: list[str] = []
        for t in (tokens or []):
            if not t: continue
            tl = str(t).strip().lower()
            if tl in ("-f","-fantastic"):
                fantastic_all = True
            elif tl in ("-h","-hostile","+5","hostile"):
                force_hostile = True
            elif tl in ("-nh","-nonhostile","-calm","nonhostile"):
                force_hostile = False
            else:
                raw_names.append(str(t).strip())

        if not raw_names:
            return {"text": head + "\n*(Add animal targets, e.g., `!cast charmanimal wolf wolf boar`.)*"}


        def _resolve_any_ci(name: str):
            fn = getattr(self, "_resolve_char_ci", None)
            if callable(fn):
                try:
                    return fn(name)
                except Exception:
                    pass
            base = name.replace(" ", "_").lower() + ".coe"
            try:
                for fnm in os.listdir("."):
                    if fnm.lower() == base:
                        path = fnm
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fnm[:-4].replace("_", " ")), path
                        except Exception:
                            return fnm[:-4].replace("_", " "), path
            except Exception:
                pass
            return None, None


        hostile_bonus = False
        if force_hostile is not None:
            hostile_bonus = bool(force_hostile)
        else:
            try:
                bcfg = _load_battles()
                if bcfg and bcfg.has_section(chan_id):
                    if bcfg.getint(chan_id, "round", fallback=0) >= 1:
                        hostile_bonus = True
            except Exception:
                pass


        budget = max(1, int(caster_level or 1))
        d_sum, d_rolls, _ = roll_dice("1d4")
        rounds = max(1, int(caster_level or 1) + int(d_sum))
        rounds_txt = f"{caster_level} + 1d4[{', '.join(map(str, d_rolls))}] = **{rounds}**"


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        try:
            if bcfg and bcfg.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, list(raw_names))
        except Exception:
            pass


        lines = [head, f"â€¢ **HD budget:** {budget}  â€¢ **Duration:** {rounds_txt} rounds"]
        used = 0
        charmed_any = False

        for raw in raw_names:

            req_save = fantastic_all or raw.endswith("!")
            name_token = raw[:-1] if raw.endswith("!") else raw

            disp, path = _resolve_any_ci(name_token)
            pretty = disp or name_token
            if not path:
                lines.append(f"â€¢ **{pretty}**: âŒ *(not found)*")
                continue

            t_cfg = read_cfg(path)


            if not _is_animal_cfg(t_cfg, pretty):
                lines.append(f"â€¢ **{pretty}**: not an **animal** â€” no effect.")
                continue


            hd = 1
            try:
                hd = max(1, int(self._hd_or_level_from_cfg(t_cfg)))
            except Exception:
                pass

            if used + hd > budget:
                lines.append(f"â€¢ **{pretty}** (HD {hd}): exceeds remaining budget ({budget - used}) â€” **ignored**.")
                continue


            if req_save:
                used_vs = "Spells"
                try:
                    sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
                except Exception:
                    sv_ok, sv_roll, sv_dc = False, 10, 15
                bonus = 5 if hostile_bonus else 0
                adj = (sv_roll or 0) + bonus
                d20_face = "**20** ðŸŽ‰" if sv_roll == 20 else ("**1** ðŸ’€" if sv_roll == 1 else str(sv_roll))
                bonus_txt = f" + {bonus}" if bonus else ""
                if adj >= sv_dc:
                    lines.append(f"â€¢ **{pretty}** â€” Save vs {used_vs}: {d20_face}{bonus_txt} = ``{adj}`` vs **{sv_dc}** â†’ âŒ **RESISTS**.")
                    continue
                else:
                    lines.append(f"â€¢ **{pretty}** â€” Save vs {used_vs}: {d20_face}{bonus_txt} = ``{adj}`` vs **{sv_dc}** â†’ âœ… **CHARMED**.")
            else:
                lines.append(f"â€¢ **{pretty}**: âœ… **CHARMED** *(no save for normal/giant animals)*.")


            charmed_any = True
            used += hd
            if bcfg and bcfg.has_section(chan_id):
                try:

                    try:
                        names, _ = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, pretty) or pretty
                    except Exception:
                        key = pretty
                    try:
                        slot = _slot(key)
                    except Exception:
                        slot = key.replace(" ", "_")

                    base_key = "x_charmanimal"
                    bcfg.set(chan_id, f"{slot}.{base_key}",          str(int(rounds)))
                    bcfg.set(chan_id, f"{slot}.{base_key}_code",     "CA")
                    bcfg.set(chan_id, f"{slot}.{base_key}_label",    "Charm Animal")
                    bcfg.set(chan_id, f"{slot}.{base_key}_emoji",    "ðŸ¾")
                    bcfg.set(chan_id, f"{slot}.{base_key}_by",       caster_name)
                    _save_battles(bcfg)
                except Exception:
                    pass


        try:
            if charmed_any and bcfg and bcfg.has_section(chan_id):
                await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        lines.append("â€”")
        lines.append("_This spell doesnâ€™t grant communication; combining it with **Speak with Animals** is much more effective._")


        return {"text": "\n".join(lines), "suppress_timer": True}

    async def _effect_causeblindness(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Cause Blindness (reverse of Cure Blindness) â€” Cleric 3
          â€¢ Range: Touch
          â€¢ Attack: d20 + STR mod + Attack Bonus vs AC (no save)
          â€¢ Effect: Target is **blind** permanently until cured (matches your CL/CD permanence model).
        """

        head = "ðŸ™ˆ **Cause Blindness**"
        chan_id = str(ctx.channel.id)
        PERM_ROUNDS = 10_000_000


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None


        def _read_ac(t_cfg) -> int:
            try:
                v = getint_compat(t_cfg, "cur", "ac", fallback=None)
                if v is None:
                    v = getint_compat(t_cfg, "base", "ac", fallback=10)
                return int(v)
            except Exception:
                return 10

        def _str_mod(cfg) -> int:
            try:
                s = getint_compat(cfg, "stats", "str", fallback=10)
            except Exception:
                s = 10
            if s <= 3: return -3
            if s <= 5: return -2
            if s <= 8: return -1
            if s <= 12: return 0
            if s <= 15: return +1
            if s <= 17: return +2
            return +3

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        if not tokens:
            return f"{head} â€” _(Usage: `!cast causeblindness <target>` â€” touch attack, no save.)_"

        tgt_disp, tgt_path = _resolve_ci(tokens[0])
        extras = [t for t in tokens[1:]]
        extra_note = (f"\n*(Single-target; ignoring: {', '.join(extras)})*" if extras else "")

        if not tgt_path:
            return f"{head}\nâ€¢ **{tokens[0]}**: âŒ not found.{extra_note}"

        t_cfg = read_cfg(tgt_path)
        pretty = (tgt_disp or "").upper()


        try:
            if _is_undead_cfg(t_cfg, tgt_disp):
                return f"{head}\nâ€¢ {pretty}: â˜ ï¸ Undead â€” **no effect**.{extra_note}"
        except Exception:
            pass


        str_m = _str_mod(caster_cfg)
        ab    = self._get_attack_bonus(caster_cfg)
        d_sum, d_rolls, _ = roll_dice("1d20")
        total = d_sum + str_m + ab
        ac_val = _read_ac(t_cfg)
        hit = (total >= ac_val)
        atk_line = (f"â€¢ Attack roll: {d_rolls[0]} + {str_m} + {ab} = **{total}** â†’ "
                    f"{'**HIT**' if hit else '**MISS**'}")

        if not hit:
            return f"{head}\n{atk_line}\nâ€¢ {pretty}: The touch fails to connect.{extra_note}"


        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            return (f"{head}\n{atk_line}\n"
                    f"â€¢ Mirror Image: a figment is struck and shatters. Images remaining: **{left_imgs}**."
                    f"{extra_note}")


        try:
            bcfg_local = _load_battles()
            if bcfg_local and bcfg_local.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, [tgt_disp])
        except Exception:
            pass


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = (_choose_slot_for_effects(bcfg, chan_id, key)
                        if '_choose_slot_for_effects' in globals() else _slot(key))
            except Exception:
                slot = key.replace(" ", "_")


            for opt in (f"{slot}.blind", f"{slot}.blind_level"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)

            bcfg.set(chan_id, f"{slot}.blind",      str(PERM_ROUNDS))
            bcfg.set(chan_id, f"{slot}.blind_perm", "1")
            bcfg.set(chan_id, f"{slot}.blind_src",  "causeblindness")
            bcfg.set(chan_id, f"{slot}.blind_by",   caster_name)
            bcfg.set(chan_id, f"{slot}.blind_level", str(int(caster_level)))
            _save_battles(bcfg)

            try:
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

            note = ("**BLINDED** (permanent until cured). While blind: surprised on **1â€“4** on d6; "
                    "attack rolls **âˆ’4**; AC **âˆ’4**; initiative **âˆ’2**.")
            return f"{head}\n{atk_line}\nâ€¢ {pretty}: {note}{extra_note}"

        return (f"{head}\n{atk_line}\nâ€¢ {pretty}: **BLINDED** (permanent) â€” "
                "No active battle here, so it wonâ€™t auto-track until combat starts."
                f"{extra_note}")

    async def _effect_cureblindness(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Cure Blindness â€” Cleric 3 (Touch â€¢ Instantaneous)
          â€¢ Frees a touched creature from blindness (injury or magic, including Light/Continual Light/Continual Darkness/Cause Blindness).
          â€¢ Does NOT remove blindness caused by a **curse** (use Remove Curse).
        Usage:
          !cast cureblindness <target [target ...]>
        """

        def _resolve_char_ci_local(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base_coe = name.replace(" ", "_") + ".coe"
            base_ini = name.replace(" ", "_") + ".ini"
            for fn in os.listdir("."):
                if fn.lower() in {base_coe.lower(), base_ini.lower()}:
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None

        lines = [f"ðŸ‘ï¸ **Cure Blindness**: {caster_name} invokes restoring grace."]
        if not tokens:
            lines.append("*(Usage: `!cast cureblindness <target [target ...]>`)*")
            return lines

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)

        changed_any = False

        for raw in tokens:
            tgt_disp, tgt_path = _resolve_char_ci_local(raw)
            if not tgt_path:
                lines.append(f"â€¢ **{raw}**: âŒ not found.")
                continue


            slot = (tgt_disp or raw).replace(" ", "_")
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    slot = (_choose_slot_for_effects(bcfg, chan_id, key)
                            if '_choose_slot_for_effects' in globals() else _slot(key))
                except Exception:
                    pass


            blind_left = 0
            blind_perm = 0
            src = ""
            if bcfg and bcfg.has_section(chan_id):
                try: blind_left = bcfg.getint(chan_id, f"{slot}.blind", fallback=0)
                except Exception: blind_left = 0
                try: blind_perm = bcfg.getint(chan_id, f"{slot}.blind_perm", fallback=0)
                except Exception: blind_perm = 0
                try: src = (bcfg.get(chan_id, f"{slot}.blind_src", fallback="") or "").lower()
                except Exception: src = ""

            if (blind_left <= 0) and (blind_perm <= 0):
                lines.append(f"â€¢ **{tgt_disp}**: no tracked **Blindness** â€” **no effect**.")
                continue


            is_cursed = ("curse" in src) or (bcfg and bcfg.has_option(chan_id, f"{slot}.blind_curse") and bcfg.getint(chan_id, f"{slot}.blind_curse", fallback=0) > 0)
            if is_cursed:
                lines.append(f"â€¢ **{tgt_disp}**: Blindness is a **curse** â€” **no effect** (use *Remove Curse*).")
                continue


            if bcfg and bcfg.has_section(chan_id):
                for key in (f"{slot}.blind", f"{slot}.blind_src", f"{slot}.blind_by", f"{slot}.blind_level", f"{slot}.blind_perm"):
                    if bcfg.has_option(chan_id, key):
                        bcfg.remove_option(chan_id, key)
                _save_battles(bcfg)


                try:
                    ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                    if ini and hasattr(ini, "_update_tracker_message"):
                        await ini._update_tracker_message(ctx, bcfg, chan_id)
                except Exception:
                    pass

            changed_any = True
            detail = []
            if blind_left and blind_left > 0: detail.append(f"was **{blind_left} rounds**")
            if blind_perm and blind_perm > 0: detail.append("was **permanent**")
            suffix = f" ({'; '.join(detail)})" if detail else ""
            lines.append(f"â€¢ **{tgt_disp}**: **Blindness cured**{suffix}.")

        return lines

    async def _effect_growthofanimals(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Growth of Animals (Cleric 3, Druid 5)
        Range: 60 ft + 10/level â€¢ Duration: 1 turn/level
        Target animal doubles in size/weight. **+2 natural AC** and **Ã—2 damage** with physical attacks.
        Unfriendly animals may Save vs Spells (use `-un` to require the save).
        """

        head = "ðŸ¦¬ **Growth of Animals**"
        if not tokens:
            return [f"{head}: *(usage)* `!cast growthofanimals <animal> [-un]`"]


        want_save = False
        raw_target = None
        for t in tokens:
            tl = str(t).strip().lower()
            if tl in {"-un","-unfriendly","unfriendly","hostile"}:
                want_save = True
            elif raw_target is None:
                raw_target = t


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(raw_target)
        except Exception:
            tgt_disp, tgt_path = raw_target, None
            base = (raw_target or "").replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn; break
        if not tgt_path:
            return [f"{head}\nâ€¢ **{raw_target}**: âŒ not found."]

        t_cfg = read_cfg(tgt_path)


        if not _is_animal_cfg(t_cfg):
            return [f"{head}\nâ€¢ **{tgt_disp}**: not an **animal** â€” **no effect**."]


        lines = [f"{head}: **{caster_name}** invokes primal vigor upon **{tgt_disp}**."]
        if want_save:
            ok, roll, dc, _ = self._roll_save(t_cfg, vs="sp", penalty=0)
            if dc is None:
                ok, roll, dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            lines.append(f"Save vs Spells: {roll} vs {dc} â†’ **{'RESISTED' if ok else 'FAIL'}**")
            if ok:
                lines.append("The creature shakes off the magic.")
                return lines


        turns = max(1, int(caster_level))
        rounds = turns * 60


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)

        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")


            prev = bcfg.getint(chan_id, f"{slot}.x_growanimal", fallback=0)
            bcfg.set(chan_id, f"{slot}.x_growanimal", str(max(prev, rounds)))
            bcfg.set(chan_id, f"{slot}.x_growanimal_code", "GA")
            bcfg.set(chan_id, f"{slot}.growanimal_by", caster_name)
            bcfg.set(chan_id, f"{slot}.growanimal_level", str(int(caster_level)))


            bcfg.set(chan_id, f"{slot}.growanimal_ac_bonus", "2")
            bcfg.set(chan_id, f"{slot}.growanimal_dmg_mult", "2")
            _save_battles(bcfg)


            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

            lines.append(f"â€¢ **{tgt_disp}** swells to titanic size for **{turns} turn{'s' if turns!=1 else ''}** ({rounds} rounds).")
            lines.append("â€¢ Benefits: **+2 AC (natural)**; **Ã—2 damage with physical attacks**.")
            lines.append("â€¢ Items enlarge while worn; removing them returns them to normal. No control over the animal.")
        else:
            lines.append(f"No active battle here â€” effect wonâ€™t tick automatically, but lasts **{turns} turn(s)**.")

        return lines

    async def _cast_striking(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Striking (Touch): the touched creature's one weapon deals +1d6 damage on each successful melee hit.
        Duration: 1 round/level.
        """


        if isinstance(targets, (list, tuple, set)):
            target_name = next((t for t in targets if isinstance(t, str) and t.strip()), None)
        elif isinstance(targets, str):
            target_name = targets.strip() or None
        else:
            target_name = None
        if not target_name:
            target_name = caster_name


        try:
            tgt_disp, tgt_path = self._resolve_char_ci(target_name)
        except Exception:
            tgt_disp, tgt_path = str(target_name), None
            base = f"{str(target_name).replace(' ', '_')}.coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    tgt_path = fn
                    break
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"âŒ Target **{target_name}** not found."]


        ROUNDS = max(1, int(caster_level))

        lines: list[str] = []
        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)


        if bcfg and bcfg.has_section(chan_id):

            names, _ = _parse_combatants(bcfg, chan_id)
            key  = _find_ci_name(names, tgt_disp or target_name) or (tgt_disp or target_name)
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            now_r = bcfg.getint(chan_id, "round", fallback=0)


            bcfg.set(chan_id, f"{slot}.strike_spell_until", str(now_r + ROUNDS - 1))
            bcfg.set(chan_id, f"{slot}.strike_spell_nd6", "1")


            bcfg.set(chan_id, f"{slot}.strike_nd6", "1")
            bcfg.set(chan_id, f"{slot}.strike_expire_round", str(now_r))


            for suf in ("strike_weapon", "strike_weapon_key"):
                opt = f"{slot}.{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)

            _save_battles(bcfg)


            timer_line = self._start_item_timer_on_caster(
                ctx, tgt_disp or target_name, label="Striking", alias_key="st", rounds=ROUNDS, emoji="ðŸ”†"
            )
            lines.append(f"Target: **{tgt_disp or target_name}**")
            lines.append("â€¢ +1d6 to your **next melee hit each round** while the spell lasts.")
            lines.append("â€¢ No attack bonus. Vs creatures hit only by magical weapons: **only the +1d6** applies.")
            lines.append(timer_line)


            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        else:

            lines.append(f"Target: **{tgt_disp or target_name}**")
            lines.append(f"â€¢ **+1d6 damage** on each successful melee hit for **{ROUNDS} round{'s' if ROUNDS != 1 else ''}**.")
            lines.append("*No active battle here â€” it wonâ€™t auto-prime each round until you `!init`.*")

        return lines

    async def _cast_poisontouch(self, ctx, cfg, caster_name: str, caster_level: int, tokens: list[str], *_extra, **_kw):
        """
        Poison Touch â€” C4 / D3 / SC4
          â€¢ Range: Touch
          â€¢ Attack: d20 + STR mod + Attack Bonus vs AC
          â€¢ Effect on hit: Target must Save vs Poison or die (instant).
          â€¢ Duration: 1 round/level, or until discharged (one creature max).
        """
        head = "ðŸ§ª **Poison Touch**"
        chan_id = str(ctx.channel.id)


        ROUNDS = max(1, int(caster_level))


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        lines: list[str] = []


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")

            now_r = bcfg.getint(chan_id, "round", fallback=0)


            bcfg.set(chan_id, f"{s_me}.pt_until", str(now_r + ROUNDS - 1))
            bcfg.set(chan_id, f"{s_me}.pt_by", caster_name)
            bcfg.set(chan_id, f"{s_me}.pt_level", str(int(caster_level)))
            _save_battles(bcfg)


            lines.append(self._start_item_timer_on_caster(ctx, caster_name, label="Poison Touch", alias_key="pt", rounds=ROUNDS, emoji="ðŸ§ª"))


            if tokens:
                target = tokens[0]
                more = [t for t in tokens[1:]]
                if more:
                    lines.append(f"*(Single target; ignoring: {', '.join(more)})*")
                attempt = await self._poison_touch_attempt(ctx, cfg, caster_name, target, bcfg=bcfg, chan_id=chan_id, caster_slot=s_me)
                lines.extend(attempt or [])
            else:
                lines.append("â€¢ Your hand is **poisoned**. Use `!a touch <target>` before the duration ends.")


            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        else:

            lines.append(f"â€¢ Charged for **{ROUNDS} round{'s' if ROUNDS != 1 else ''}**.")
            if tokens:

                attempt = await self._poison_touch_attempt(ctx, cfg, caster_name, tokens[0], bcfg=None, chan_id=chan_id, caster_slot=None)
                lines.extend(attempt or [])
            else:
                lines.append("*No active battle here â€” charge wonâ€™t auto-expire until you start `!init`.*")
                lines.append("Use `!a touch <target>` when youâ€™re ready to deliver it.")

        return [head] + lines

    async def _poison_touch_attempt(self, ctx, caster_cfg, caster_name: str, target_raw: str,
                                    *, bcfg=None, chan_id: str, caster_slot: str | None):
        """
        Performs one Poison Touch attempt:
          â€¢ Rolls touch attack (STR mod + AB).
          â€¢ On a real hit (not an image), target saves vs Poison or dies.
          â€¢ Discharges the spell on any real hit (save success or fail).
          â€¢ If the attack misses or hits a Mirror Image, the charge persists.
        """


        def _read_ac(t_cfg) -> int:
            try:
                v = getint_compat(t_cfg, "cur", "ac", fallback=None)
                if v is None: v = getint_compat(t_cfg, "base", "ac", fallback=10)
                return int(v)
            except Exception:
                return 10

        def _str_mod(cfg) -> int:
            try: s = getint_compat(cfg, "stats", "str", fallback=10)
            except Exception: s = 10
            if s <= 3: return -3
            if s <= 5: return -2
            if s <= 8: return -1
            if s <= 12: return 0
            if s <= 15: return +1
            if s <= 17: return +2
            return +3

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    path = fn
                    try:
                        cfg = read_cfg(path)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), path
                    except Exception:
                        return fn[:-4].replace("_", " "), path
            return name, None


        tgt_disp, tgt_path = _resolve_ci(target_raw)
        if not tgt_path or not os.path.exists(tgt_path):
            return [f"â€¢ **{target_raw}**: âŒ *(not found)*"]

        t_cfg = read_cfg(tgt_path)
        pretty = (tgt_disp or target_raw).upper()


        try:
            if _is_undead_cfg(t_cfg, tgt_disp):
                return [f"â€¢ {pretty}: â˜ ï¸ Undead â€” **no effect**."]
        except Exception:
            pass
        try:
            if self._poison_immune(t_cfg):
                return [f"â€¢ {pretty}: ðŸ§ª Poison-immune â€” **no effect**."]
        except Exception:
            pass


        str_m = _str_mod(caster_cfg)
        ab    = self._get_attack_bonus(caster_cfg)
        d_sum, d_rolls, _ = roll_dice("1d20")
        total = d_sum + str_m + ab
        ac_val = _read_ac(t_cfg)
        hit = (total >= ac_val)
        atk_line = f"â€¢ Attack roll: {d_rolls[0]} + {str_m} + {ab} = **{total}** â†’ {'**HIT**' if hit else '**MISS**'}"


        if not hit:
            return [atk_line, "â€¢ The poisonous touch **misses**. Charge **persists**."]


        try:
            consumed, left_imgs = self._mi_consume_if_present(ctx, tgt_disp)
        except Exception:
            consumed, left_imgs = (False, 0)
        if consumed:
            msg = f"â€¢ Mirror Image: a figment is struck and shatters (images left: **{left_imgs}**)."
            return [atk_line, msg, "â€¢ The poisonous touch **persists**."]


        try:
            bc2 = _load_battles()
            if bc2 and bc2.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, [tgt_disp])
        except Exception:
            pass


        sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0)
        if sv_dc is None:
            sv_ok = False

        note = f"Save vs Poison {sv_roll} vs {sv_dc} â†’ {'âœ… **RESISTED**' if sv_ok else 'âŒ **FAIL**'}"

        out: list[str] = [atk_line, f"â€¢ {pretty}: {note}"]


        if bcfg and caster_slot:
            for suf in ("pt_until","pt","pt_by","pt_level"):
                opt = f"{caster_slot}.{suf}"
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
            _save_battles(bcfg)


        if not sv_ok:
            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=None)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=old_hp if old_hp is not None else 1)
            if old_hp is None: old_hp = max_hp
            t_cfg.setdefault("cur", {})
            t_cfg["cur"]["hp"] = "0"
            write_cfg(tgt_path, t_cfg)


            try:
                is_mon = (get_compat(t_cfg, "info", "class", fallback="").strip().lower() == "monster")
            except Exception:
                is_mon = False

            if is_mon and bcfg and bcfg.has_section(chan_id):
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, tgt_disp) or tgt_disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s = _slot(key)
                        for suf in (
                            ".dex",".join",".disp",".oil",".acpen",".holds",".heldby",
                            ".paralyzed",".blind",".blind_src",".blind_by",
                            ".cc_blind_pending",".cs_blind_pending",
                            ".cc",".cc_by",".cc_level",".ck",".ck_by",".ck_level",
                            ".ghh",".ghf",".sph",".sph_bonus",".mi",".mi_images",
                            ".light",".light_by",".light_level",".darkness",".dark_level",".dark_by"
                        ):
                            opt = f"{s}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        cur_turn = (bcfg.get(chan_id, "turn", fallback="") or "").strip()
                        if cur_turn == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                except Exception:
                    pass
                try:
                    os.remove(os.path.abspath(tgt_path))
                except Exception:
                    pass


            try:
                before = _life_bar(old_hp, max_hp, width=10)
                after  = _life_bar(0, max_hp, width=10)
                out.append(f"{before} â†’ **{after}** â˜ ï¸ **DEAD!**")
            except Exception:
                out.append(f"HP {old_hp} â†’ **0** â˜ ï¸ **DEAD!**")

        else:
            out.append("â€¢ The poison is delivered but **resisted**. The charge is **discharged**.")


        try:
            if bcfg and bcfg.has_section(chan_id):
                await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return out

    async def _cast_stickstosnakes(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Sticks to Snakes (Cleric 4)
          â€¢ Range: 120 ft (table choice; not enforced here)
          â€¢ Duration: 6 turns (360 rounds)
          â€¢ Effect: Transforms sticks into **normal snakes** totaling **1d4 HD per 4 caster levels**.
                    Snakes obey the caster; on expiry/dispelling/slain they revert to sticks.
          â€¢ Allowed snake types (normal only): pitviper (1 HD), spittingcobra (2 HD), seasnake (3 HD), python (5 HD).
          â€¢ Giant Pit Viper is *not* allowed.

        Usage:
          !cast stickstosnakes
          !cast stickstosnakes python cobra cobra                  # preference order (greedy)
          !cast stickstosnakes -py 1 -sc 2 -ss 1                   # explicit counts
          !cast stickstosnakes py1 sc2 ss1                         # compact counts
          !cast stickstosnakes -fallback seasnake                 # change fallback (default pitviper)

        Notes:
          â€¢ If a requested snake doesn't fit remaining HD, we fall back (default pitviper).
          â€¢ Any leftover HD after requests are filled will be spent on the fallback automatically.
          â€¢ Tags set on minions: hostile=0, minion_by=<caster>, minion_type=<kind>, summon_left=360,
            summon_src=stickstosnakes, expire_cb=stickstosnakes, summoned=stickstosnakes
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]

        L = max(1, int(caster_level or 1))
        rounds_total = 6 * 60


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]


        ALIAS = {
            "pitviper": "pitviper", "pv": "pitviper", "pit": "pitviper", "viper": "pitviper",
            "spittingcobra": "spittingcobra", "sc": "spittingcobra", "cobra": "spittingcobra", "spit": "spittingcobra",
            "seasnake": "seasnake", "ss": "seasnake", "sea": "seasnake",
            "python": "python", "py": "python",
            "giantpitviper": "giantpitviper", "gpv": "giantpitviper",

            "pitvipers": "pitviper", "spittingcobras": "spittingcobra", "seasnakes": "seasnake", "pythons": "python",
        }
        COST = {"pitviper": 1, "spittingcobra": 2, "seasnake": 3, "python": 5}
        ORDER_DEFAULT_PREF = ["python", "seasnake", "spittingcobra", "pitviper"]
        PREF_NAMES = {"pitviper": "Pit Viper", "spittingcobra": "Spitting Cobra", "seasnake": "Sea Snake", "python": "Python"}
        PREFIX = {"pitviper": "PV", "spittingcobra": "SC", "seasnake": "SS", "python": "PY"}


        fallback_kind = "pitviper"
        def _take_after(flagset):
            nonlocal toks
            for i in range(len(toks) - 1):
                if toks[i] in flagset and toks[i+1]:
                    val = toks[i+1]
                    toks[i] = ""; toks[i+1] = ""
                    return val
            return None
        fb_raw = _take_after({"-fallback", "-fb"})
        if fb_raw:
            fallback_kind = ALIAS.get(fb_raw.lower(), fallback_kind)
            if fallback_kind not in COST:
                fallback_kind = "pitviper"


        counts = {"pitviper": 0, "spittingcobra": 0, "seasnake": 0, "python": 0}
        def _take_int_after(flag_words, key):
            nonlocal toks
            for i in range(len(toks)-1):
                if toks[i] in flag_words and re.fullmatch(r"\d+", toks[i+1] or ""):
                    v = int(toks[i+1]); toks[i] = ""; toks[i+1] = ""
                    counts[key] += v
                    break
        _take_int_after({"-pv","-pv","-pitviper","-viper"}, "pitviper")
        _take_int_after({"-sc","-sc","-spittingcobra","-cobra"}, "spittingcobra")
        _take_int_after({"-ss","-ss","-seasnake"}, "seasnake")
        _take_int_after({"-py","-py","-python"}, "python")


        for t in list(toks):
            m = re.fullmatch(r"(pitviper|pv|viper|pit|spittingcobra|sc|cobra|seasnake|ss|sea|python|py)(\d+)", t)
            if m:
                k = ALIAS.get(m.group(1), None)
                if k in counts:
                    counts[k] += int(m.group(2))
                    toks.remove(t)


        prefs = []
        ignored_giant = False
        for t in toks:
            if not t:
                continue
            k = ALIAS.get(t, None)
            if k == "giantpitviper":
                ignored_giant = True
                continue
            if k in COST and k not in prefs:
                prefs.append(k)

        if not prefs:
            prefs = ORDER_DEFAULT_PREF[:]


        explicit_mode = any(v > 0 for v in counts.values())



        groups = max(1, L // 4)
        grp_rolls = [random.randint(1, 4) for _ in range(groups)]
        total_hd = sum(grp_rolls)

        if total_hd <= 0:
            return [f"âŒ **Sticks to Snakes**: HD pool rolled to zero. (Groups: {groups}; rolls: {grp_rolls})"]


        def _first_that_fits(rem_hd, candidates):
            for c in candidates:
                if c in COST and COST[c] <= rem_hd:
                    return c
            return None

        allocated = []
        rem = total_hd

        if explicit_mode:

            order = [k for k in prefs if counts.get(k, 0) > 0]

            if not order:
                order = [k for k in ORDER_DEFAULT_PREF if counts.get(k, 0) > 0]

            for k in order:
                n = counts.get(k, 0)
                for _ in range(n):
                    cost = COST[k]
                    if rem >= cost:
                        allocated.append(k); rem -= cost
                    else:

                        chain = [fallback_kind, "pitviper", "spittingcobra", "seasnake", "python"]
                        chain = [c for c in chain if c in COST]
                        sub = _first_that_fits(rem, chain)
                        if not sub:
                            break
                        allocated.append(sub); rem -= COST[sub]


            while rem >= 1:
                sub = _first_that_fits(rem, [fallback_kind, "pitviper", "spittingcobra", "seasnake", "python"])
                if not sub: break
                allocated.append(sub); rem -= COST[sub]

        else:

            while rem >= 1:
                k = _first_that_fits(rem, prefs)
                if not k:
                    k = _first_that_fits(rem, [fallback_kind, "pitviper", "spittingcobra", "seasnake", "python"])
                if not k:
                    break
                allocated.append(k); rem -= COST[k]


        if not allocated:
            return [f"âš ï¸ **Sticks to Snakes**: allocation failed with **{total_hd} HD** (rolls {grp_rolls})."]


        def _tpl(kind: str):
            return (_load_monster_template(kind)
                    or _load_monster_template(kind + ".ini")
                    or None)

        needed_kinds = sorted(set(allocated))
        templates = {k: _tpl(k) for k in needed_kinds}
        missing = [k for k, t in templates.items() if not t]
        if missing:
            nice = ", ".join(PREF_NAMES.get(k, k) for k in missing)
            return [f"âŒ Missing monster templates for: {nice} (e.g., `{missing[0]}.ini`)."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        def _spawn_batch(kind: str, tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 1))
            hpmod  = int(tpl.get("hpmod", 0))
            move   = int(tpl.get("move", 30))
            saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
            damage = str(tpl.get("damage", "1d4"))
            resist  = str(tpl.get("resist",  "")).strip()
            reduce1 = str(tpl.get("reduce1", "")).strip()
            immune  = str(tpl.get("immune",  "")).strip()
            weak    = str(tpl.get("weak",    "")).strip()


            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", max(1, hd)
            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = PREFIX.get(kind, re.sub(r"[^A-Za-z]", "", kind).upper()[:2] or "SN")
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            made = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)


                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": kind, "battle_chan": chan_id,
                    "controller": caster_name,
                    "summoned": "stickstosnakes",
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


                stats = {"ac": str(ac), "ab": "", "move": str(move),
                         "type": str(tpl.get("type", "animal")).strip(),
                         "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
                         "special": str(tpl.get("special", "")).strip()}
                attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
                atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
                attack_list = [a for a in re.split(r"[,\s]+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or (damage or "1d4")
                else:
                    stats["damage"] = damage or "1d4"
                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)


                try:
                    s = _slot(mon)
                except Exception:
                    s = mon.replace(" ", "_")


                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s}."):
                        bcfg.remove_option(chan_id, opt_key)
                if bcfg.has_option(chan_id, mon):
                    bcfg.remove_option(chan_id, mon)

                bcfg.set(chan_id, f"{s}.disp", mon)
                bcfg.set(chan_id, f"{s}.hostile", "0")
                bcfg.set(chan_id, f"{s}.minion_by", caster_name)
                bcfg.set(chan_id, f"{s}.minion_type", kind)

                bcfg.set(chan_id, f"{s}.summon_left", str(rounds_total))
                bcfg.set(chan_id, f"{s}.summon_src", "stickstosnakes")
                bcfg.set(chan_id, f"{s}.expire_cb", "stickstosnakes")

                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s}.join", str(join_seq))

                made.append((mon, d6, hp, hd, s))

            _save_battles(bcfg)
            return made



        want_by_kind = {"pitviper": 0, "spittingcobra": 0, "seasnake": 0, "python": 0}
        for k in allocated:
            want_by_kind[k] += 1

        created = []
        for k, n in want_by_kind.items():
            if n <= 0: continue
            created += _spawn_batch(k, templates[k], n)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        if not created:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        lines = [f"ðŸ **{caster_name}** casts **Sticks to Snakes**."]
        lines.append(f"â€¢ HD pool: { ' + '.join(str(r) for r in grp_rolls) } = **{total_hd} HD** (1d4 Ã— {groups}).")


        by_kind_names = {"pitviper": [], "spittingcobra": [], "seasnake": [], "python": []}
        for (n, _i, _hp, _hd, _s) in created:

            kind = "pitviper"
            if   n.upper().startswith("SC"): kind = "spittingcobra"
            elif n.upper().startswith("SS"): kind = "seasnake"
            elif n.upper().startswith("PY"): kind = "python"
            elif n.upper().startswith("PV"): kind = "pitviper"
            by_kind_names[kind].append(n)

        for k in ["python","seasnake","spittingcobra","pitviper"]:
            if by_kind_names[k]:
                names_list = ", ".join(by_kind_names[k])
                lines.append(f"â€¢ {PREF_NAMES[k]}{'s' if len(by_kind_names[k])!=1 else ''}: **{len(by_kind_names[k])}** â†’ {names_list}")

        lines.append(f"â€¢ Duration: **6 turns** (**{rounds_total} rounds**).")
        if ignored_giant:
            lines.append("â€¢ Note: Giant Pit Viper is **not allowed** by this spell â€” ignored.")


        lines.append("â€¢ The snakes obey your commands. On expiry/dispelling/death, they revert to sticks.")
        if fallback_kind != "pitviper":
            lines.append(f"â€¢ Fallback used: **{PREF_NAMES.get(fallback_kind, fallback_kind)}** when requested choices didnâ€™t fit.")

        return lines

    async def _cast_raisedead(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Raise Dead (touch): Returns a dead *humanoid* PC to life, losing one level.
          â€¢ Works only if target is a PC at **0 HP**.
          â€¢ Target must be humanoid (as per Charm Person), not undead, not dead of old age, and willing; spirit must not be trapped.
          â€¢ Must have been dead â‰¤ caster level **days** (pass the days as the 2nd token).
          â€¢ On success:
              â€“ Level reduced by **1** (minimum 1).
              â€“ XP set to **minimum for the new level** (from class.lst).
              â€“ Max HP reduced by last levelâ€™s HP gain (pre-10: 1d(HD die)+CON mod; post-9: flat after9 amount).
              â€“ Current HP = **1 per current level** (minimum 1).
              â€“ Normal poison/disease cured (best-effort). *Magical diseases/curses not removed.*
              â€“ Prepared spells cleared (best-effort).
        Usage:
          !cast raisedead <target> [daysdead] [-trapped] [-oldage] [-unwilling]
        """


        def _norm(s: str) -> str:
            return re.sub(r"[^\w]+", "", (s or "").lower())

        def _min_xp_for_level(class_name: str, level: int) -> int:
            """Return the minimum XP for 'level' from class.lst (xp2..xp20). Level 1 â†’ 0."""
            if level <= 1:
                return 0
            key = f"xp{int(level)}"

            try:
                if hasattr(self, "_class_cp") and self._class_cp is not None:
                    sec = None
                    for s in self._class_cp.sections():
                        if s.strip().lower() == (class_name or "").strip().lower():
                            sec = s
                            break
                    if sec and self._class_cp.has_option(sec, key):
                        v = self._class_cp.get(sec, key).strip()
                        if v.lstrip("-").isdigit():
                            return int(v)
            except Exception:
                pass

            try:
                sec = (_CLASS_CACHE.get(class_name, {})
                       or _CLASS_CACHE.get((class_name or "").title(), {})
                       or _CLASS_CACHE.get((class_name or "").lower(), {}))
                v = (sec or {}).get(key)
                if isinstance(v, int):
                    return v
                if isinstance(v, str) and v.strip().lstrip("-").isdigit():
                    return int(v.strip())
            except Exception:
                pass

            return 0


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t) for t in targets if str(t).strip()]
        else:
            toks = [t for t in re.split(r"\s+", str(targets or "").strip()) if t]

        if not toks:
            return ["âŒ Usage: `!cast raisedead <target> [daysdead] [-trapped] [-oldage] [-unwilling]`"]

        want_name = toks[0]
        days_dead = None
        trapped = False
        oldage = False
        unwilling = False

        for t in toks[1:]:
            tt = _norm(t)
            if tt.isdigit():
                try: days_dead = int(tt)
                except Exception: pass
            elif tt in {"trapped","trap","bound","soulcage","soulbind"}:
                trapped = True
            elif tt in {"old","oldage","age"}:
                oldage = True
            elif tt in {"unwilling","refuse","no"}:
                unwilling = True


        try:
            bcfg = _load_battles()
            chan_id = _section_id(ctx.channel)
        except Exception:
            bcfg = None
            chan_id = str(ctx.channel.id)


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rc = read_cfg(path)
                            real = get_compat(rc, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_name, tgt_path = _resolve_char_ci(want_name)
        if not tgt_path:
            return [f"âŒ Target '{want_name}' not found."]
        if _is_monster_file(tgt_path):
            return [f"âŒ **{tgt_name}** is a monster/NPC record. Raise Dead here is intended for PCs only."]

        tcfg = read_cfg(tgt_path)


        old_cur_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_cur_hp != 0:
            return [f"âŒ **{tgt_name}** is not at 0 HP. Raise Dead requires a deceased target (0 HP)."]


        t_type = (get_compat(tcfg, "stats", "type", fallback="") or "").lower()
        t_race = (get_compat(tcfg, "info",  "race", fallback="") or "").lower()
        if "undead" in t_type or "undead" in t_race:
            return [f"âŒ Undead are not affected by Raise Dead. (**{tgt_name}** appears undead)."]


        is_humanoid = True
        try:
            if hasattr(self, "_is_charm_person_eligible"):
                is_humanoid = bool(self._is_charm_person_eligible(tcfg, tgt_name))
            elif hasattr(self, "_is_person_like"):
                is_humanoid = bool(self._is_person_like(tcfg, tgt_name))
        except Exception:
            is_humanoid = True
        if not is_humanoid:
            return [f"âŒ **{tgt_name}** is not a valid *humanoid* target for Raise Dead (per Charm Person)."]


        if days_dead is not None and days_dead > max(1, int(caster_level or 1)):
            return [f"âŒ Too long dead: **{days_dead} days** > caster level **{caster_level}**."]


        if trapped:
            return [f"âŒ The spirit of **{tgt_name}** is trapped/contained. Raise Dead fails."]
        if oldage:
            return [f"âŒ **{tgt_name}** died of old age. The body has no life left to restore."]
        if unwilling:
            return [f"âŒ **{tgt_name}** is unwilling to return. The spell fails."]


        lvl_before = max(1, getint_compat(tcfg, "cur", "level", fallback=1))
        lvl_after  = max(1, lvl_before - 1)

        char_class = (get_compat(tcfg, "info", "class", fallback="") or "").strip()
        race_name  = (get_compat(tcfg, "info", "race",  fallback="") or "").strip()
        con_score  = getint_compat(tcfg, "stats", "con", fallback=10)
        con_mod    = osr_mod(con_score)

        max_hp_before = getint_compat(tcfg, "max", "hp", fallback=1)


        if lvl_before >= 10:
            hp_loss = int(self._hp_flat_after9(char_class))
            hp_loss_token = f"flat{hp_loss}"
        else:
            hd_die = int(self._hit_die_for(char_class, race_name))
            roll = random.randint(1, max(4, hd_die))
            hp_loss = max(1, roll + int(con_mod))
            hp_loss_token = f"d{hd_die}â†’{roll}{'+'+str(con_mod) if con_mod else ''}"

        max_hp_after = max(lvl_after, max(1, max_hp_before - hp_loss))
        cur_hp_after = max(1, lvl_after)


        new_xp = _min_xp_for_level(char_class, lvl_after)


        if not tcfg.has_section("cur"): tcfg.add_section("cur")
        if not tcfg.has_section("max"): tcfg.add_section("max")
        tcfg["cur"]["level"] = str(lvl_after)
        tcfg["cur"]["hp"]    = str(cur_hp_after)
        tcfg["cur"]["xp"]    = str(new_xp)
        tcfg["max"]["hp"]    = str(max_hp_after)


        try:
            if hasattr(self, "_clear_prepared_spells"):
                self._clear_prepared_spells(tcfg)
            elif hasattr(self, "_clear_memorized_spells"):
                self._clear_memorized_spells(tcfg)
            else:
                for sec in ("spells","memorized","prepared","cur"):
                    if tcfg.has_section(sec):
                        for k in list(tcfg[sec].keys()):
                            if re.search(r"(mem|prep|spellslot|slot|prepared)", k, flags=re.I):
                                tcfg[sec][k] = ""
        except Exception:
            pass


        try:
            for sec in ("cur","stats"):
                if tcfg.has_section(sec):
                    for k in ("poison","poisoned","disease","diseased"):
                        if tcfg.has_option(sec, k):
                            tcfg.remove_option(sec, k)
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_name) or tgt_name
                try: slot = _slot(key)
                except Exception: slot = key.replace(" ", "_")
                for suf in (".disease",".poison",".pois",".ill",".dead"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)
        except Exception:
            pass


        try:
            tcfg["cur"]["raised_by"]  = caster_name
            tcfg["cur"]["raised_src"] = "raisedead"
        except Exception:
            pass

        write_cfg(tgt_path, tcfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        lines = [
            f"âœ¨ **Raise Dead!** {tgt_name} returns to life.",
            (f"â€¢ Days dead: **{days_dead}** (limit: caster level **{caster_level}**)."
             if days_dead is not None else "â€¢ Days dead: *(not specified; assumed within limit)*"),
            f"â€¢ Level: {lvl_before} â†’ **{lvl_after}**.",
            f"â€¢ XP set to **{new_xp}** (minimum for level {lvl_after}).",
            f"â€¢ Max HP: {max_hp_before} â†’ **{max_hp_after}** (lost **{hp_loss}**; last-level token: *{hp_loss_token}*).",
            f"â€¢ Current HP set to **{cur_hp_after}** (1 per level).",
            "â€¢ Normal poison/disease cured; magical diseases/curses **not** removed.",
            "â€¢ Prepared spells cleared.",
            "_Missing limbs remain missing; all wounds otherwise healed._",
        ]
        if lvl_before == 1:
            lines.append("â„¹ï¸ At level 1, no further level loss is possible; XP is **0** by definition.")

        return lines

    def _hp_flat_after9(self, char_class: str) -> int:
        cls = (char_class or "").strip()
        sec = _CLASS_CACHE.get(cls, {}) or _CLASS_CACHE.get(cls.title(), {}) or _CLASS_CACHE.get(cls.lower(), {})
        try:
            hp20 = sec.get("hp20")
            if isinstance(hp20, int):
                return hp20
            if isinstance(hp20, str) and hp20.strip().lstrip("-").isdigit():
                return int(hp20.strip())
        except Exception:
            pass
        c = cls.lower()
        if c in {"fighter","paladin","ranger","barbarian"}: return 2
        if c in {"cleric","druid","scout"}: return 1
        return 1

    async def _effect_ringoflesserhealing(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Ring of Lesser Healing
          â€¢ Heals the caster + âŒŠlevel/3âŒ‹ others in 15' (you pass the names).
          â€¢ Amount: 1d6+1 (rolled once, applied to all affected).
          â€¢ Undead: Save vs Spells to completely resist; on fail, take holy damage = amount.
          â€¢ If a living target is at 0 HP: can't be healed.
          â€¢ Extras beyond capacity are ignored.
        Usage: !cast ringoflesserhealing <name1> <name2> ...
        """


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        L = max(1, int(caster_level or 1))
        extra_cap = L // 3


        want = [caster_name] + [t for t in (targets or []) if str(t).strip()]
        seen = set()
        def _norm(s): return re.sub(r"\s+", " ", (s or "").strip().lower())
        ordered = []
        for w in want:
            k = _norm(w)
            if not k or k in seen: continue
            seen.add(k); ordered.append(w)


        chosen = []
        others = []
        for w in ordered:
            if _norm(w) == _norm(caster_name):
                chosen.append(w)
            else:
                others.append(w)
        chosen += others[:extra_cap]
        ignored = others[extra_cap:]


        dice_spec = "1d6+1"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)


        lines = [f"âšª **Ring of Lesser Healing** â€” **{dice_spec}** â†’ [{', '.join(str(r) for r in rolls)}]{'+'+str(flat) if flat else ''} = **{amount}**",
                 f"â€¢ Affects: **{len(chosen)}** (caster + up to âŒŠL/3âŒ‹ others = **{extra_cap}**)"]
        if ignored:
            lines.append("â€¢ Ignored extras: " + ", ".join(ignored))

        changed_any = False

        for raw in chosen:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*"); continue

            t_cfg = read_cfg(path)


            if _is_undead_cfg(t_cfg, pretty):
                ok, roll, dc, _pen = self._roll_save(t_cfg, vs="spell", penalty=0)
                if dc is None:

                    ok, roll, dc, _pen = self._roll_save(t_cfg, vs="wand", penalty=0)
                if dc is None:

                    ok, dc = True, "â€”"

                if ok:
                    lines.append(f"{pretty}: Save vs **Spells** {roll} vs {dc} â†’ **RESISTED**")
                    continue

                final, note = _apply_mitigation(amount, weapon_name="Ring of Lesser Healing", weapon_type="holy", t_cfg=t_cfg)
                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                new_hp = max(0, old_hp - final)
                t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg); changed_any = True

                if _is_monster_file(path):
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                    hp_txt = f"{_life_bar(old_hp, mhp, 10)} â†’ {_life_bar(new_hp, mhp, 10)}"
                else:
                    hp_txt = f"{old_hp} â†’ **{new_hp}**"

                death_note = ""
                if new_hp <= 0 and _is_monster_file(path):
                    death_note = " â˜ ï¸ **DESTROYED!**"
                    try: self._kill_remove_from_initiative(ctx, pretty, path)
                    except Exception: pass

                lines.append(f"{pretty}: Save vs **Spells** {roll} vs {dc} â†’ **FAIL** â€” **holy damage {final}**"
                             + (f" ({note})" if note else "") + f" â€¢ {hp_txt}{death_note}")
                continue


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            if old_hp <= 0:
                lines.append(f"{pretty}: already **DEAD** â€” cannot be healed by this spell.")
                continue

            new_hp = min(max_hp, old_hp + amount)
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg); changed_any = True

            if _is_monster_file(path):
                hp_txt = f"{_life_bar(old_hp, max_hp, 10)} â†’ {_life_bar(new_hp, max_hp, 10)}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"
            lines.append(f"{pretty}: **+{amount} HP** â€¢ {hp_txt}")


        if changed_any:
            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

        return "\n".join(lines)

    async def _effect_ringofgreaterhealing(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Ring of Greater Healing
          â€¢ Heals the caster + âŒŠlevel/3âŒ‹ others in 15'.
          â€¢ Amount: 3d6+3 (rolled once, applied to all affected).
          â€¢ Undead: Save vs Spells to completely resist; on fail, take holy damage = amount.
          â€¢ Living with Mummy Rot: no effect (like Cure Serious Wounds).
          â€¢ If a living target is at 0 HP: can't be healed.
          â€¢ Extras beyond capacity are ignored.
        Usage: !cast ringofgreaterhealing <name1> <name2> ...
        """

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        L = max(1, int(caster_level or 1))
        extra_cap = L // 3

        want = [caster_name] + [t for t in (targets or []) if str(t).strip()]
        seen = set()
        def _norm(s): return re.sub(r"\s+", " ", (s or "").strip().lower())
        ordered = []
        for w in want:
            k = _norm(w)
            if not k or k in seen: continue
            seen.add(k); ordered.append(w)

        chosen = []
        others = []
        for w in ordered:
            if _norm(w) == _norm(caster_name):
                chosen.append(w)
            else:
                others.append(w)
        chosen += others[:extra_cap]
        ignored = others[extra_cap:]

        dice_spec = "3d6+3"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)

        lines = [f"ðŸ”µ **Ring of Greater Healing** â€” **{dice_spec}** â†’ [{', '.join(str(r) for r in rolls)}]{'+'+str(flat) if flat else ''} = **{amount}**",
                 f"â€¢ Affects: **{len(chosen)}** (caster + up to âŒŠL/3âŒ‹ others = **{extra_cap}**)"]
        if ignored:
            lines.append("â€¢ Ignored extras: " + ", ".join(ignored))

        changed_any = False

        for raw in chosen:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*"); continue
            t_cfg = read_cfg(path)


            if _is_undead_cfg(t_cfg, pretty):
                ok, roll, dc, _pen = self._roll_save(t_cfg, vs="spell", penalty=0)
                if dc is None:
                    ok, roll, dc, _pen = self._roll_save(t_cfg, vs="wand", penalty=0)
                if dc is None:
                    ok, dc = True, "â€”"

                if ok:
                    lines.append(f"{pretty}: Save vs **Spells** {roll} vs {dc} â†’ **RESISTED**")
                    continue

                final, note = _apply_mitigation(amount, weapon_name="Ring of Greater Healing", weapon_type="holy", t_cfg=t_cfg)
                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                new_hp = max(0, old_hp - final)
                t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg); changed_any = True

                if _is_monster_file(path):
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                    hp_txt = f"{_life_bar(old_hp, mhp, 10)} â†’ {_life_bar(new_hp, mhp, 10)}"
                else:
                    hp_txt = f"{old_hp} â†’ **{new_hp}**"

                death_note = ""
                if new_hp <= 0 and _is_monster_file(path):
                    death_note = " â˜ ï¸ **DESTROYED!**"
                    try: self._kill_remove_from_initiative(ctx, pretty, path)
                    except Exception: pass

                lines.append(f"{pretty}: Save vs **Spells** {roll} vs {dc} â†’ **FAIL** â€” **holy damage {final}**"
                             + (f" ({note})" if note else "") + f" â€¢ {hp_txt}{death_note}")
                continue


            try:
                if _has_mummy_rot(t_cfg):
                    lines.append(f"{pretty}: âŒ **No effect** â€” afflicted with **Mummy Rot**. Magical healing fails until **Cure Disease**.")
                    continue
            except Exception:
                pass

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
            if old_hp <= 0:
                lines.append(f"{pretty}: already **DEAD** â€” cannot be healed by this spell.")
                continue

            new_hp = min(max_hp, old_hp + amount)
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg); changed_any = True

            if _is_monster_file(path):
                hp_txt = f"{_life_bar(old_hp, max_hp, 10)} â†’ {_life_bar(new_hp, max_hp, 10)}"
            else:
                hp_txt = f"{old_hp} â†’ **{new_hp}**"

            lines.append(f"{pretty}: **+{amount} HP** â€¢ {hp_txt}")

        if changed_any:
            try:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

        return "\n".join(lines)

    async def _effect_heal(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Heal â€” Cleric 6 (Touch â€¢ Permanent)
          â€¢ Living target: cures blindness*, deafness, confusion, disease (incl. Mummy Rot), feeblemind,
            choking, nausea, and poison. Restores all but **1d4** HP (never lowers current HP).
            *Cursed blindness is unchanged (use Remove Curse).
          â€¢ Ability losses: fully restores TEMPORARY losses only (per your system). Feeblemind INT/CHA restored.
            (Permanent losses unchanged. Energy drain untouched.)
          â€¢ Undead target: **reversed** â†’ apply Harm (normal touch attack); see Harm logic.
        Usage: !cast heal <target>
        """

        head = "âœ¨ **Heal**"

        if tokens and tokens[0].strip():
            tgt_raw = tokens[0].strip()
        else:
            tgt_raw = caster_name

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None

        tgt_disp, tgt_path = _resolve_ci(tgt_raw)
        if not tgt_path or not os.path.exists(tgt_path):
            return f"{head}\nâ€¢ **{tgt_raw}**: âŒ not found."

        tcfg = read_cfg(tgt_path)
        pretty = tgt_disp


        try:
            if _is_undead_cfg(tcfg, pretty):

                return await self._effect_harm(ctx, caster_cfg, caster_name, caster_level, [tgt_raw])
        except Exception:
            pass


        old_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_hp <= 0:
            return f"{head}\nâ€¢ **{pretty}**: already **DEAD** â€” Heal affects living creatures only."


        try: bcfg = _load_battles()
        except Exception: bcfg = None
        chan_id = str(ctx.channel.id)
        slot = (pretty or "").replace(" ", "_")
        if bcfg and bcfg.has_section(chan_id):
            try:
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, pretty) or pretty
                try:
                    slot = (_choose_slot_for_effects(bcfg, chan_id, key)
                            if '_choose_slot_for_effects' in globals() else _slot(key))
                except Exception:
                    slot = key.replace(" ", "_")
            except Exception:
                pass


        cleared_notes = []


        try:
            blind_left = bcfg.getint(chan_id, f"{slot}.blind", fallback=0) if (bcfg and bcfg.has_section(chan_id)) else 0
            blind_perm = bcfg.getint(chan_id, f"{slot}.blind_perm", fallback=0) if (bcfg and bcfg.has_section(chan_id)) else 0
            blind_src  = (bcfg.get(chan_id, f"{slot}.blind_src", fallback="") or "").lower() if (bcfg and bcfg.has_section(chan_id)) else ""
            is_cursed  = ("curse" in blind_src) or (bcfg and bcfg.has_option(chan_id, f"{slot}.blind_curse") and bcfg.getint(chan_id, f"{slot}.blind_curse", fallback=0) > 0)
            if (blind_left > 0 or blind_perm > 0) and not is_cursed:
                for k in (f"{slot}.blind", f"{slot}.blind_src", f"{slot}.blind_by", f"{slot}.blind_level", f"{slot}.blind_perm", f"{slot}.blind_curse"):
                    if bcfg.has_option(chan_id, k): bcfg.remove_option(chan_id, k)
                _save_battles(bcfg)
                cleared_notes.append("blindness")
        except Exception:
            pass


        cleared_notes.append("deafness")


        try:
            if bcfg and bcfg.has_section(chan_id):
                for suf in (".confuse",".confused",".x_confuse",".x_conf",".x_confuse_code",".x_confuse_label",".x_confuse_by",".x_confuse_emoji"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                        if "confusion" not in cleared_notes: cleared_notes.append("confusion")
        except Exception:
            pass


        try:

            if not tcfg.has_section("cur"): tcfg.add_section("cur")
            had_mrot = getint_compat(tcfg, "cur", "mummyrot", fallback=0) > 0
            tcfg["cur"]["disease"] = "0"
            for k in ("sick_days","sick_turns","sick_exert","sick_block_heal","sick_block_prep","sick_block_run",
                      "mummyrot","mrot_block_heal","mrot_days"):
                if tcfg.has_option("cur", k): tcfg.remove_option("cur", k)
            write_cfg(tgt_path, tcfg)
            cleared_notes.append("disease")
            if had_mrot: cleared_notes.append("mummy rot")


            if bcfg and bcfg.has_section(chan_id):
                for suf in (".sick",".sick_pen",
                            ".x_sick",".x_sick_code",".x_sick_label",".x_sick_emoji",".x_sick_by",
                            ".maggots",".maggots_die",
                            ".x_maggots",".x_maggots_dmg",".x_maggots_label",".x_maggots_emoji",".x_maggots_code",".x_maggots_by",
                            ".mrot",".mrot_block_heal",
                            ".x_mrot",".x_mrot_n",".x_mrot_code",".x_mrot_label",".x_mrot_emoji",".x_mrot_by"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                try:
                    self._tracker_remove_tag(bcfg, chan_id, slot, "DIS")
                    self._tracker_remove_tag(bcfg, chan_id, slot, "MROT")
                except Exception:
                    pass
                _save_battles(bcfg)
        except Exception:
            pass


        try:
            removed_any = False
            if bcfg and bcfg.has_section(chan_id):
                for k in (f"{slot}.feeble", f"{slot}.feeble_perm", f"{slot}.feeble_by", f"{slot}.feeble_note"):
                    if bcfg.has_option(chan_id, k):
                        bcfg.remove_option(chan_id, k); removed_any = True

            tcfg = read_cfg(tgt_path)
            p_int = getint_compat(tcfg, "feeblemind", "prev_int", fallback=None) if tcfg.has_section("feeblemind") else None
            p_cha = getint_compat(tcfg, "feeblemind", "prev_cha", fallback=None) if tcfg.has_section("feeblemind") else None
            if not tcfg.has_section("stats"): tcfg.add_section("stats")
            restored_stats = False
            if p_int is not None: tcfg.set("stats", "int", str(p_int)); restored_stats = True
            if p_cha is not None: tcfg.set("stats", "cha", str(p_cha)); restored_stats = True
            if not restored_stats:
                b_int = getint_compat(tcfg, "base", "int", fallback=None)
                b_cha = getint_compat(tcfg, "base", "cha", fallback=None)
                if b_int is not None: tcfg.set("stats", "int", str(b_int)); restored_stats = True
                if b_cha is not None: tcfg.set("stats", "cha", str(b_cha)); restored_stats = True
            if tcfg.has_section("feeblemind"):
                try: tcfg.remove_section("feeblemind")
                except Exception: pass
            write_cfg(tgt_path, tcfg)
            cleared_notes.append("feeblemind")
        except Exception:
            pass


        try:

            if bcfg and bcfg.has_section(chan_id):
                for suf in (".choke",".choking",".gas",".nausea",".nauseated",
                            ".x_nausea",".x_nausea_code",".x_nausea_label",".x_nausea_by",".x_nausea_emoji",
                            ".poison",".poisoned",".x_poison",".x_poison_code",".x_poison_label",".x_poison_by",".x_poison_emoji"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
                _save_battles(bcfg)

            tcfg = read_cfg(tgt_path)
            if not tcfg.has_section("cur"): tcfg.add_section("cur")
            for k in ("poison","poisoned","venom","choke","choking","nausea","nauseated"):
                if tcfg.has_option("cur", k): tcfg.remove_option("cur", k)
            write_cfg(tgt_path, tcfg)
            cleared_notes.extend([k for k in ("poison","choking","nausea") if k not in cleared_notes])
        except Exception:
            pass



        con_hp_delta_total = 0
        tries = 0
        try:

            while tries < 20:
                tries += 1
                msg, d_hp = self._restore_one_con_point(
                    read_cfg(tgt_path),
                    require_save_for_final=False,
                    owner_for_save_cfg=read_cfg(tgt_path)
                )
                if not msg:
                    break

                if "no temporary" in str(msg).lower():
                    break
                con_hp_delta_total += int(d_hp or 0)

                write_cfg(tgt_path, read_cfg(tgt_path))
        except Exception:
            pass


        tcfg = read_cfg(tgt_path)
        d4 = random.randint(1, 4)
        max_hp = getint_compat(tcfg, "max", "hp", fallback=old_hp)
        new_hp_target = max(1, max_hp - d4)
        new_hp = max(old_hp, new_hp_target)
        if not tcfg.has_section("cur"): tcfg.add_section("cur")

        if tcfg.has_section("cur") and tcfg.has_option("cur", "neg_hp_loss_total"):
            try: tcfg.remove_option("cur", "neg_hp_loss_total")
            except Exception: pass
        tcfg["cur"]["hp"] = str(new_hp)
        write_cfg(tgt_path, tcfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass


        notes = ""
        if cleared_notes:
            notes = "â€¢ Removed: " + ", ".join(sorted(set(cleared_notes))) + "\n"
        hp_txt = f"{old_hp} â†’ **{new_hp}** / {max_hp}  (left at **{max_hp - new_hp}** HP below max; d4={d4})"
        if con_hp_delta_total:
            hp_txt += f"  â€¢  (max HP {'+' if con_hp_delta_total>0 else ''}{con_hp_delta_total} from CON recovery)"
        return f"{head}\nâ€¢ **{pretty}**\n{notes}â€¢ HP: {hp_txt}"

    async def _effect_harm(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Harm â€” Cleric 6 (Touch â€¢ Permanent)
          â€¢ Living target only. Normal attack roll (d20 + STR mod + AB) vs AC.
          â€¢ On HIT: roll **1d4**.
                If target HP > roll â†’ set HP to the roll (â€œleft with only 1d4 HPâ€).
                If target HP â‰¤ roll â†’ target takes **at least 1 damage** (HP âˆ’= 1). This is
                the only case Harm can kill (e.g., victim at 1 HP).
          â€¢ On MISS: no effect (spell wasted).
          â€¢ Mirror Image can intercept the touch.
          â€¢ Undead target: **reversed** â†’ apply Heal (no attack roll); see Heal logic.
        Usage: !cast harm <target>
        """

        head = "ðŸ©¸ **Harm**"
        if not tokens:
            return f"{head}\n*(Usage: `!cast harm <target>` â€” touch attack)*"

        tgt_raw = tokens[0].strip()

        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                pass
            base = name.replace(" ", "_") + ".coe"
            for fn in os.listdir("."):
                if fn.lower() == base.lower():
                    try:
                        cfg = read_cfg(fn)
                        real = get_compat(cfg, "info", "name", fallback=None)
                        return (real or fn[:-4].replace("_", " ")), fn
                    except Exception:
                        return fn[:-4].replace("_", " "), fn
            return name, None

        tgt_disp, tgt_path = _resolve_ci(tgt_raw)
        if not tgt_path or not os.path.exists(tgt_path):
            return f"{head}\nâ€¢ **{tgt_raw}**: âŒ not found."

        tcfg = read_cfg(tgt_path)
        pretty = tgt_disp


        try:
            if _is_undead_cfg(tcfg, pretty):
                return await self._effect_heal(ctx, caster_cfg, caster_name, caster_level, [tgt_raw])
        except Exception:
            pass


        old_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_hp <= 0:
            return f"{head}\nâ€¢ **{pretty}**: already **DEAD** â€” Harm affects living creatures only."


        try: bcfg = _load_battles()
        except Exception: bcfg = None
        chan_id = str(ctx.channel.id)


        def _str_mod(cfg) -> int:
            try:
                v = getint_compat(cfg, "stats", "str", fallback=10)
            except Exception:
                v = 10
            if v <= 3: return -3
            if v <= 5: return -2
            if v <= 8: return -1
            if v <= 12: return 0
            if v <= 15: return +1
            if v <= 17: return +2
            return +3

        ab  = self._get_attack_bonus(caster_cfg)
        stm = _str_mod(caster_cfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                ac, _sh, _acdef, _blind_pen, _ma_bonus, _bs_bonus =\
                    self._defender_ac_with_buffs(bcfg, chan_id, pretty, want_oil=False, atk_type="melee")
            else:
                raise RuntimeError()
        except Exception:
            try:
                ac = getint_compat(tcfg, "stats", "ac", fallback=10)
            except Exception:
                ac = 10


        d20 = random.randint(1, 20)
        total = d20 + ab + stm
        hit = (d20 == 20) or (total >= ac and d20 != 1)
        atk_line = f"â€¢ Attack: d20 **{d20}** + {ab} + {stm} = **{total}** â†’ " + ("âœ… **HIT**" if hit else "âŒ **MISS**")

        if not hit:
            return f"{head}\n{atk_line}\nâ€¢ **{pretty}**: The touch fails."


        try:
            consumed, left = self._mi_consume_if_present(ctx, pretty)
            if consumed:
                return (f"{head}\n{atk_line}\n"
                        f"â€¢ A **Mirror Image** is struck and destroyed (images left: **{left}**). No effect on the real target.")
        except Exception:
            pass


        try:
            bcfg_local = _load_battles()
            if bcfg_local and bcfg_local.has_section(chan_id):
                self._hyp_break_if_targeted(chan_id, [pretty])
        except Exception:
            pass


        roll = random.randint(1, 4)
        old_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_hp > roll:
            new_hp = roll
            note = f"HP set to **{roll}** (left with only **1d4**)."
        else:
            new_hp = max(0, old_hp - 1)
            note = f"Target had â‰¤ **{roll}** HP â†’ suffers **1** damage."
        if not tcfg.has_section("cur"): tcfg.add_section("cur")
        tcfg["cur"]["hp"] = str(new_hp); write_cfg(tgt_path, tcfg)


        dead_note = ""
        if new_hp <= 0 and _is_monster_file(tgt_path):
            dead_note = " â˜ ï¸ **DEAD!**"
            try: self._kill_remove_from_initiative(ctx, pretty, tgt_path)
            except Exception: pass


        try:
            bcfg2 = _load_battles()
            if bcfg2 and bcfg2.has_section(chan_id):
                ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                if ini and hasattr(ini, "_update_tracker_message"):
                    await ini._update_tracker_message(ctx, bcfg2, chan_id)
        except Exception:
            pass


        mhp = getint_compat(tcfg, "max", "hp", fallback=max(1, new_hp))
        if _is_monster_file(tgt_path):
            hp_txt = f"{_life_bar(old_hp, mhp, 10)} â†’ {_life_bar(new_hp, mhp, 10)}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}** / {mhp}"

        return (f"{head}\n{atk_line}\n"
                f"â€¢ **{pretty}**: {note}  (d4 = **{roll}**) â€¢ {hp_txt}{dead_note}")

    async def _effect_regenerate(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Regenerate â€” Cleric 6 / Druid 7 (Touch â€¢ Permanent)
          â€¢ Living target only: heals **3d8** HP.
          â€¢ If the target is **undead**: make an attack roll (d20 + AB + WIS) vs AC.
            On HIT, deal holy damage equal to the roll; on MISS, no effect.
          â€¢ Does NOT raise the dead; if target is at 0 HP, no effect (use Raise Dead/Reincarnate).
          â€¢ Flavor: severed parts reattach in 1 round each; lost parts regrow in 1 turn (GM adjudication).
        Usage:
          !cast regenerate <target>
        """


        target_raw = (targets[0] if targets else caster_name)

        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        disp, path = _resolve_char_ci(target_raw)
        pretty = disp or target_raw
        if not path:
            return f"ðŸ§¬ **Regenerate**: {pretty}: *(not found)*"

        t_cfg = read_cfg(path)


        dice_spec = "3d8"
        total, rolls, flat = roll_dice(dice_spec)
        amount = max(0, total + flat)
        head = f"ðŸ§¬ **Regenerate** â€” **{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{amount}**"


        if _is_undead_cfg(t_cfg, pretty):
            wis_mod = self._abil_mod(caster_cfg, "wis")
            ab = self._get_attack_bonus(caster_cfg)

            try:
                target_ac = self._get_effective_ac(t_cfg)
            except Exception:
                target_ac = 10

            d20 = random.randint(1, 20)
            total_to_hit = d20 + ab + (wis_mod or 0)
            hit = (d20 == 20) or (total_to_hit >= target_ac)

            atk_line = f"Attack roll: {d20} + {ab} + {wis_mod or 0} = ``{total_to_hit}`` â†’ " + ("âœ… **HIT!**" if hit else "âŒ **MISS**")
            if not hit:
                return head + "\n" + f"{pretty}: {atk_line}\n*(no effect on miss)*"

            final, note = _apply_mitigation(amount, weapon_name="Regenerate (reversed)", weapon_type="holy", t_cfg=t_cfg)

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10); after = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            line = f"{pretty}: {atk_line}\n**Holy damage:** **{final}**" + (f" ({note})" if note else "") + f" â€¢ {hp_txt}"


            if new_hp <= 0 and _is_monster_file(path):
                try: self._kill_remove_from_initiative(ctx, pretty, path)
                except Exception: pass


            try:
                bcfg = _load_battles(); chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass


            flavor = ("\n*Ripple of fleshknitting spreads from the touch. Severed parts would reattach in **1 round each**; "
                      "lost parts would regrow in **1 turn**. (GM adjudication.)*")
            return head + "\n" + line + flavor


        old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
        max_hp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))

        if old_hp <= 0:
            return head + "\n" + f"{pretty}: already **DEAD** â€” cannot be healed by this spell."


        try:
            if _has_mummy_rot(t_cfg):
                return (head + "\n" +
                        f"{pretty}: âŒ **No effect** â€” afflicted with **Mummy Rot**. Magical healing fails until **Cure Disease**.")
        except Exception:
            pass

        new_hp = min(max_hp, old_hp + amount)
        t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)


        try:
            bcfg = _load_battles(); chan_id = str(ctx.channel.id)
            if bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        if _is_monster_file(path):
            before = _life_bar(old_hp, max_hp, width=10); after = _life_bar(new_hp, max_hp, width=10)
            hp_txt = f"{before} â†’ {after}"
        else:
            hp_txt = f"{old_hp} â†’ **{new_hp}**"

        flavor = ("\n*Divine regrowth surges: severed parts reattach in **1 round each**; "
                  "lost parts regrow in **1 turn** (60 rounds). (GM adjudication.)*")
        return head + "\n" + f"{pretty}: **+{amount} HP** â€¢ {hp_txt}" + flavor

    async def _effect_restoration(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Restoration â€” Cleric 6 (Touch â€¢ Permanent)
          â€¢ Default: remove negative levels (1; 2 if caster level >= 16). Restores HP from your neg-HP pool.
          â€¢ Ability mode: !cast restoration <target?> <stat> [-perm]
              - Without -perm: restore 2d4 temporary points to that stat (from <stat>_loss_temp).
              - With -perm:    restore 1 permanent point (from <stat>_loss_perm).
          â€¢ Does not restore permanently lost *levels* (e.g., losses due to death).
        """


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        def _norm_stat_key(s: str | None) -> str | None:
            if not s: return None
            k = re.sub(r"[^a-z]", "", str(s).lower())
            m = {
                "str":"str", "strength":"str",
                "dex":"dex", "dexterity":"dex",
                "con":"con", "constitution":"con",
                "int":"int", "intelligence":"int",
                "wis":"wis", "wisdom":"wis",
                "cha":"cha", "charisma":"cha",
            }
            return m.get(k)

        def _effective_cap(cfg):
            try:
                return self._effective_max_hp(cfg)
            except Exception:

                mx = getint_compat(cfg, "max", "hp", fallback=0)
                pool = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
                return max(0, mx - max(0, pool))






        raw_tokens = [t for t in (tokens or []) if str(t).strip()]
        want_perm = any(t.lower() in {"-perm","-p","perm"} for t in raw_tokens)
        raw_tokens = [t for t in raw_tokens if t.lower() not in {"-perm","-p","perm"}]


        stat = _norm_stat_key(raw_tokens[-1]) if raw_tokens else None


        if raw_tokens:
            if stat:

                maybe_target = " ".join(raw_tokens[:-1]).strip() if len(raw_tokens) > 1 else None
            else:
                maybe_target = " ".join(raw_tokens).strip()
        else:
            maybe_target = None

        target_name = (maybe_target or caster_name)
        disp, path = _resolve_char_ci(target_name)
        pretty = disp or target_name
        if not path:
            return f"âœ¨ **Restoration**: {pretty}: *(not found)*"

        cfg = read_cfg(path)


        lines = [f"âœ¨ **Restoration** â€” {pretty}"]


        if stat:

            loss_temp_key = f"{stat}_loss_temp"
            loss_perm_key = f"{stat}_loss_perm"
            if not cfg.has_section("cur"):
                cfg.add_section("cur")
            temp_loss = getint_compat(cfg, "cur", loss_temp_key, fallback=0)
            perm_loss = getint_compat(cfg, "cur", loss_perm_key, fallback=0)

            if want_perm:

                if perm_loss <= 0:
                    lines.append(f"â€¢ No **permanent** {stat.upper()} loss recorded â€” **no effect**.")
                    return "\n".join(lines)
                restore = 1
                cfg["cur"][loss_perm_key] = str(max(0, perm_loss - restore))


                old_val = getint_compat(cfg, "stats", stat, fallback=10)
                new_val = max(1, old_val + restore)
                if not cfg.has_section("stats"): cfg.add_section("stats")
                cfg["stats"][stat] = str(new_val)


                if stat == "con":
                    try:
                        self._apply_con_change_adjust_hp(cfg, old_val, new_val)
                    except TypeError:
                        self._apply_con_change_adjust_hp(cfg, restore)

                write_cfg(path, cfg)


                cfg = read_cfg(path)
                cap = _effective_cap(cfg)
                cur_hp = getint_compat(cfg, "cur", "hp", fallback=0)
                if cur_hp > cap:
                    cfg["cur"]["hp"] = str(cap); write_cfg(path, cfg)

                lines.append(f"â€¢ **Ability**: {stat.upper()} permanent loss **+1 restored** "
                             f"({old_val} â†’ **{new_val}**).")
            else:

                if temp_loss <= 0:
                    lines.append(f"â€¢ No **temporary** {stat.upper()} loss recorded â€” **no effect**.")
                    return "\n".join(lines)

                dsum, rolls, flat = roll_dice("2d4")
                want = dsum + flat
                got = min(want, temp_loss)
                cfg["cur"][loss_temp_key] = str(max(0, temp_loss - got))

                old_val = getint_compat(cfg, "stats", stat, fallback=10)
                new_val = max(1, old_val + got)
                if not cfg.has_section("stats"): cfg.add_section("stats")
                cfg["stats"][stat] = str(new_val)

                if stat == "con":
                    try:
                        self._apply_con_change_adjust_hp(cfg, old_val, new_val)
                    except TypeError:
                        self._apply_con_change_adjust_hp(cfg, (new_val - old_val))

                write_cfg(path, cfg)


                cfg = read_cfg(path)
                cap = _effective_cap(cfg)
                cur_hp = getint_compat(cfg, "cur", "hp", fallback=0)
                if cur_hp > cap:
                    cfg["cur"]["hp"] = str(cap); write_cfg(path, cfg)

                lines.append(f"â€¢ **Ability**: {stat.upper()} temporary loss **+{got}** "
                             f"(rolled 2d4 = {want}: [{', '.join(map(str, rolls))}]) "
                             f"â†’ {old_val} â†’ **{new_val}**.")

            try:
                bcfg = _load_battles(); chan_id = str(ctx.channel.id)
                if bcfg and bcfg.has_section(chan_id):
                    msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg, chan_id)
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass

            lines.append("_This spell cannot restore permanently lost **levels** (e.g., losses due to death)._")
            return "\n".join(lines)



        if not cfg.has_section("cur"):
            cfg.add_section("cur")
        cur_lvls = getint_compat(cfg, "cur", "neg_levels", fallback=0)
        pool     = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
        if cur_lvls <= 0:
            lines.append("â€¢ No **negative levels** present â€” **no effect**.")
            return "\n".join(lines)

        removes_allowed = 2 if int(caster_level or 0) >= 16 else 1
        removed = 0
        heals = []

        for _ in range(removes_allowed):
            lvls_before = getint_compat(cfg, "cur", "neg_levels", fallback=0)
            pool_before = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
            if lvls_before <= 0 or pool_before <= 0:
                break

            heal = int((pool_before / lvls_before) + 0.5)
            heal = max(0, heal)

            new_pool = max(0, pool_before - heal)
            new_lvls = max(0, lvls_before - 1)
            cfg["cur"]["neg_levels"] = str(new_lvls)
            cfg["cur"]["neg_hp_loss_total"] = str(new_pool)
            write_cfg(path, cfg)


            cfg = read_cfg(path)
            cap = _effective_cap(cfg)
            old_hp = getint_compat(cfg, "cur", "hp", fallback=0)
            new_hp = min(cap, old_hp + heal)
            cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, cfg)

            removed += 1
            heals.append(heal)

        if removed <= 0:

            if pool <= 0 and cur_lvls > 0:
                lines.append("â€¢ Negative levels **present**, but the HP loss pool is **0** â€” no HP to restore. "
                             "No levels removed by this casting (house rule).")
            else:
                lines.append("â€¢ No **negative levels** present â€” **no effect**.")
            return "\n".join(lines)


        lines.append(f"â€¢ Removed: **{removed}** negative level{'s' if removed!=1 else ''}.")
        if heals:
            lines.append(f"â€¢ HP restored per level: {', '.join(map(str, heals))} "
                         f"(total **{sum(heals)}**).")


        cfg = read_cfg(path)
        mhp  = getint_compat(cfg, "max", "hp", fallback=0)
        hp   = getint_compat(cfg, "cur", "hp", fallback=0)
        lv   = getint_compat(cfg, "cur", "neg_levels", fallback=0)
        pool = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
        cap  = _effective_cap(cfg)
        lines.append(f"â€¢ Now: HP **{hp}/{mhp}** (cap **{cap}**); Negative Levels **{lv}**; Pool **{pool}**.")


        try:
            bcfg = _load_battles(); chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        lines.append("_This spell cannot restore permanently lost **levels** (e.g., losses due to death)._")
        return "\n".join(lines)

    async def _effect_firestorm(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Fire Storm â€” Cleric 7
          â€¢ 1d6 per caster level (one roll for all).
          â€¢ Save vs Spells for half.
          â€¢ Damage type: **holy** (bypasses fire resistance/immunity).
          â€¢ Consumes any creature slain by the spell, and any corpse already present.
          â€¢ Area/shape ignored here; multi-target like Fireball.

        Notes:
          - Treat as â€œholyâ€ for mitigation so fire res/imm doesnâ€™t reduce damage.
          - AoE clears Mirror Image on affected targets.
          - Lifebars for monsters, numeric for PCs.
          - Removes dead monsters from initiative and deletes their files
            (also deletes monster corpses that were already dead in the area).
        """

        chan_id = str(ctx.channel.id)


        dice_spec = f"{max(1, int(caster_level or 1))}d6"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []
        consumed_corpses: list[tuple[str, str]] = []


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        for raw in (targets or []):
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            dmg = base_dmg
            t_cfg = read_cfg(path)


            cleared = 0
            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty) or 0
            except Exception:
                cleared = 0
            if cleared:
                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by the storm.")


            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            if old_hp <= 0:
                lines.append(f"{pretty}: already dead â€” **consumed to ash**.")
                if _is_monster_file(path):
                    consumed_corpses.append((pretty, path))

                continue



            final, note = _apply_mitigation(
                dmg,
                weapon_name="Fire Storm",
                weapon_type="holy",
                t_cfg=t_cfg
            )


            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"

            lines.append(f"{pretty}: **{final}**{note}\n{hp_txt}")


            if new_hp <= 0 and _is_monster_file(path):
                dead_monsters.append((pretty, path))


        to_delete = consumed_corpses + dead_monsters
        if to_delete:
            try:
                bcfg = _load_battles()
                if bcfg.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg, chan_id)
                    for pretty, path in to_delete:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg.has_option(chan_id, key):
                                bcfg.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg.has_option(chan_id, opt):
                                    bcfg.remove_option(chan_id, opt)
                    _write_combatants(bcfg, chan_id, names, scores)

                    curr = bcfg.get(chan_id, "turn", fallback="")
                    if curr and curr not in names:
                        ents = _sorted_entries(bcfg, chan_id)
                        bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg)
            except Exception:
                pass


            for _, p in to_delete:
                try:
                    if _is_monster_file(p):
                        os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes or to_delete:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    msg_id = bcfg2.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg2, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass


        title = "ðŸ”¥ðŸŒ©ï¸ **FIRE STORM**"
        roll_line = f"**{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}** holy fire"
        return title + "\n" + roll_line + "\n" + "\n".join(lines)

    async def _effect_holyword(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Holy Word â€” Cleric 7
          â€¢ Damage: 1d6 per caster level (one roll for all), **no save**.
          â€¢ Type: **holy** (not fire) â€” bypasses fire resistance/immunity.
          â€¢ Blindness: each surviving target must Save vs Spells or be **permanently blinded**.
          â€¢ Any creature slain is immolated to ash (monster files removed).
          â€¢ AoE ignores precise shape/range here; pass enemies as target list.
          â€¢ Table note: â€œcan hear/see the clericâ€ is assumed true for passed targets.

        Display:
          - Lifebars for monsters, numeric for PCs.
          - AoE clears Mirror Image on affected targets.
        """

        chan_id = str(ctx.channel.id)
        PERM_ROUNDS = 10_000_000


        dice_spec = f"{max(1, int(caster_level or 1))}d6"
        total, rolls, flat = roll_dice(dice_spec)
        base_dmg = max(0, total + flat)

        lines = []
        any_hp_changes = False
        dead_monsters: list[tuple[str, str]] = []


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        have_battle = bool(bcfg and bcfg.has_section(chan_id))

        for raw in (targets or []):
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw
            if not path:
                lines.append(f"{pretty}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            cleared = 0
            try:
                cleared = self._mi_clear_all_if_present(ctx, pretty) or 0
            except Exception:
                cleared = 0
            if cleared:
                lines.append(f"{pretty}: Mirror Image **({cleared})** destroyed by the radiance.")

            old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
            if old_hp <= 0:


                lines.append(f"{pretty}: already dead â€” **no further effect**.")
                continue


            final, note = _apply_mitigation(
                base_dmg,
                weapon_name="Holy Word",
                weapon_type="holy",
                t_cfg=t_cfg
            )

            new_hp = max(0, old_hp - final)
            t_cfg["cur"]["hp"] = str(new_hp)
            write_cfg(path, t_cfg)
            any_hp_changes = True


            if _is_monster_file(path):
                mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                before = _life_bar(old_hp, mhp, width=10)
                after  = _life_bar(new_hp, mhp, width=10)
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{before} â†’ {after}{dead_note}"
            else:
                dead_note = " â˜ ï¸ **DEAD!**" if new_hp <= 0 else ""
                hp_txt = f"{old_hp} â†’ **{new_hp}**{dead_note}"


            if new_hp <= 0:
                lines.append(f"{pretty}: **{final}**{note}\n{hp_txt}\nâ€¢ The body **bursts into holy flame** and **burns to ash**.")
                if _is_monster_file(path):
                    dead_monsters.append((pretty, path))
                continue


            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=0)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            if ok:

                lines.append(f"{pretty}: **{final}**{note}\n{hp_txt}\nSave vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **RESIST BLINDNESS**")
            else:

                if have_battle:
                    try:
                        names, _ = _parse_combatants(bcfg, chan_id)
                        key = _find_ci_name(names, pretty) or pretty
                        try:
                            slot = (_choose_slot_for_effects(bcfg, chan_id, key)
                                    if '_choose_slot_for_effects' in globals() else _slot(key))
                        except Exception:
                            slot = key.replace(" ", "_")


                        for opt in (f"{slot}.blind", f"{slot}.blind_level"):
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)

                        bcfg.set(chan_id, f"{slot}.blind",       str(PERM_ROUNDS))
                        bcfg.set(chan_id, f"{slot}.blind_perm",  "1")
                        bcfg.set(chan_id, f"{slot}.blind_src",   "holyword")
                        bcfg.set(chan_id, f"{slot}.blind_by",    caster_name)
                        bcfg.set(chan_id, f"{slot}.blind_level", str(int(caster_level)))
                        _save_battles(bcfg)


                        try:
                            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
                            if ini and hasattr(ini, "_update_tracker_message"):
                                await ini._update_tracker_message(ctx, bcfg, chan_id)
                        except Exception:
                            pass
                    except Exception:
                        pass
                    lines.append(
                        f"{pretty}: **{final}**{note}\n{hp_txt}\n"
                        f"Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ ðŸ™ˆ **BLINDED (permanent)**"
                    )
                else:
                    lines.append(
                        f"{pretty}: **{final}**{note}\n{hp_txt}\n"
                        f"Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ ðŸ™ˆ **BLINDED (permanent)** â€” "
                        f"No active battle here, so it wonâ€™t auto-track."
                    )


        if dead_monsters:
            try:
                bcfg2 = _load_battles()
                if bcfg2.has_section(chan_id):
                    names, scores = _parse_combatants(bcfg2, chan_id)
                    for pretty, path in dead_monsters:
                        key = _find_ci_name(names, pretty) or pretty
                        if key in names:
                            names = [n for n in names if n != key]
                            if bcfg2.has_option(chan_id, key):
                                bcfg2.remove_option(chan_id, key)
                            slot = _slot(key)
                            for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                                opt = f"{slot}{suf}"
                                if bcfg2.has_option(chan_id, opt):
                                    bcfg2.remove_option(chan_id, opt)
                    _write_combatants(bcfg2, chan_id, names, scores)

                    curr = bcfg2.get(chan_id, "turn", fallback="")
                    if curr and curr not in names:
                        ents = _sorted_entries(bcfg2, chan_id)
                        bcfg2.set(chan_id, "turn", ents[0]["name"] if ents else "")
                    _save_battles(bcfg2)
            except Exception:
                pass


            for _, p in dead_monsters:
                try:
                    if _is_monster_file(p):
                        os.remove(os.path.abspath(p))
                except Exception:
                    pass


        if any_hp_changes or dead_monsters:
            try:
                bcfg3 = _load_battles()
                if bcfg3.has_section(chan_id):
                    msg_id = bcfg3.getint(chan_id, "message_id", fallback=0)
                    if msg_id:
                        block = _format_tracker_block(bcfg3, chan_id)
                        content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                        msg = await ctx.channel.fetch_message(msg_id)
                        await msg.edit(content=content)
            except Exception:
                pass

        title = "âœï¸ðŸ”Š **HOLY WORD**"
        roll_line = f"**{dice_spec}** [{', '.join(str(r) for r in rolls)}] = **{base_dmg}** holy damage"
        return title + "\n" + roll_line + "\n" + "\n".join(lines)

    async def _effect_windwalk(self, ctx, caster_cfg, caster_name, caster_level, targets):
        """
        Wind Walk â€” Cleric 7
          â€¢ Mechanics: Multi-target Gaseous Form with long duration.
          â€¢ Duration: 1 hour/level â†’ 600 rounds/level.
          â€¢ Participants: caster + up to âŒŠlevel/3âŒ‹ additional creatures.
          â€¢ Sets: GAS + INW timers (GAS blocks !a and !cast per your rules).

        RP notes (summary only):
          â€¢ Can fly (slow 10 ft; or up to ~600 ft/rd as a wafting wind with poor maneuverability).
          â€¢ Targets can swap physical â†” vapor at will (each change takes 5 rounds).
          â€¢ In last minute of duration, vapor form auto-descends ~60 ft/rd (warning the end is near).
        """

        bcfg = _load_battles()
        chan = str(ctx.channel.id)
        if not (bcfg and bcfg.has_section(chan)):
            return "âš ï¸ No battle running here."


        lvl = max(1, int(caster_level or 1))
        rounds = lvl * 360
        hours_txt = f"{lvl} hour{'s' if lvl != 1 else ''}"


        try:
            names, _ = _parse_combatants(bcfg, chan)
        except Exception:
            names = []

        def _ci(nm: str) -> str:
            try:
                return _find_ci_name(names, nm) or nm
            except Exception:
                return nm

        allowed_others = lvl // 3


        final_targets = []
        seen = set()
        caster_key = _ci(caster_name)
        seen.add(caster_key.lower())
        final_targets.append(caster_key)


        extras_ignored = []
        for raw in (targets or []):
            key = _ci(str(raw).strip())
            if not key:
                continue
            lk = key.lower()
            if lk in seen:
                continue
            if len(final_targets) - 1 < allowed_others:
                seen.add(lk)
                final_targets.append(key)
            else:
                extras_ignored.append(str(raw))


        applied_to = []
        for tgt in final_targets:
            slot = _resolve_effect_slot(bcfg, chan, tgt)


            bcfg.set(chan, f"{slot}.gas",    str(rounds))
            bcfg.set(chan, f"{slot}.gas_by", caster_name)


            bcfg.set(chan, f"{slot}.inw",    str(rounds))
            bcfg.set(chan, f"{slot}.inw_by", "WindWalk")


            bcfg.set(chan, f"{slot}.gas_ac_hint", "22 (vs magical weapons)")


            bcfg.set(chan, f"{slot}.windwalk", "1")

            applied_to.append(bcfg.get(chan, f"{slot}.disp", fallback=tgt))

        _save_battles(bcfg)


        who_txt = ", ".join(applied_to) if applied_to else "(nobody)"
        cut_txt = (f"\n*(Limit reached: caster + âŒŠL/3âŒ‹ = {1 + allowed_others}; "
                   f"ignored: {', '.join(extras_ignored)})*" if extras_ignored else "")

        summary = (
            "â˜ï¸ **Wind Walk** active: counts as **Gaseous Form** in combat.\n"
            "â€¢ **GAS**: canâ€™t attack/cast; seep through cracks; swap forms at will (each change costs **5 rounds**).\n"
            "â€¢ **INW**: **immune to nonmagical weapons**; **AC 22 vs magical** (hint).\n"
            f"â€¢ **Duration**: {hours_txt} (â‰ˆ **{rounds} rounds**). "
            "Last minute in vapor form auto-descends ~60 ft/round (warning).\n"
            "â€¢ Caster can dismiss the spell (individuals or everyone)."
        )

        return [
            f"ðŸŒ¬ï¸â˜ï¸ Applied **Wind Walk** to **{who_txt}** for **{hours_txt}** ({rounds} rds).{cut_txt}",
            summary,
            {"suppress_timer": True},
        ]

    async def _cast_resurrection(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Resurrection â€” Cleric 7 (Touch)
          â€¢ Returns a deceased PC to life if dead â‰¤ (10 years Ã— caster level), willing, and soul is free.
          â€¢ Works even if the creature had become undead (as long as itâ€™s currently destroyed).
          â€¢ Excludes constructs/elementals; cannot restore death by old age.
          â€¢ On success:
              â€“ If level â‰¥ 2: lose **1 level** (XP set to minimum of new level), Max HP reduced by the last levelâ€™s gain,
                then return at **full HP**.
              â€“ If level = 1: no level loss; instead suffer **â€“1 permanent CON** (fails if this would drop CON â‰¤ 0),
                then return at **full HP** after the CON change.
              â€“ Clears negative levels/pools and ordinary poison/disease. Prepared spells left unchanged.
          â€¢ Usage: !cast resurrection <target> [time_since_death] [-trapped] [-oldage] [-unwilling]
                   time_since_death examples: 3y, 24m, 365d, 2 (years)
        """


        def _norm(s: str) -> str:
            return re.sub(r"[^\w]+", "", (s or "").lower())

        def _parse_age_token(tok: str) -> float:
            """
            Return 'years' as a float. Accepts '10y', '24m', '365d', or bare integer (years).
            """
            t = (tok or "").strip().lower()
            m = re.fullmatch(r"(\d+)([a-z]+)?", t)
            if not m:
                return None
            n = int(m.group(1))
            unit = m.group(2) or "y"
            if unit in {"y","yr","yrs","year","years"}:
                return float(n)
            if unit in {"m","mo","mon","month","months"}:
                return float(n) / 12.0
            if unit in {"d","day","days"}:
                return float(n) / 365.0
            return float(n)

        def _min_xp_for_level(class_name: str, level: int) -> int:
            if level <= 1:
                return 0
            key = f"xp{int(level)}"

            try:
                cp = getattr(self, "_class_cp", None)
                if cp is not None:
                    sec = None
                    for s in cp.sections():
                        if s.strip().lower() == (class_name or "").strip().lower():
                            sec = s; break
                    if sec and cp.has_option(sec, key):
                        v = cp.get(sec, key).strip()
                        if v.lstrip("-").isdigit():
                            return int(v)
            except Exception:
                pass

            try:
                sec = (_CLASS_CACHE.get(class_name, {})
                       or _CLASS_CACHE.get((class_name or "").title(), {})
                       or _CLASS_CACHE.get((class_name or "").lower(), {}))
                v = (sec or {}).get(key)
                if isinstance(v, int): return v
                if isinstance(v, str) and v.strip().lstrip("-").isdigit(): return int(v.strip())
            except Exception:
                pass
            return 0


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t) for t in targets if str(t).strip()]
        else:
            toks = [t for t in re.split(r"\s+", str(targets or "").strip()) if t]

        if not toks:
            return ["âŒ Usage: `!cast resurrection <target> [time_since_death] [-trapped] [-oldage] [-unwilling]`",
                    "   e.g. `!cast resurrection wizard 3y` or `!cast resurrection cleric 365d`"]

        want_name = toks[0]
        years_dead = None
        trapped = False
        oldage = False
        unwilling = False

        for t in toks[1:]:
            tt = _norm(t)
            if re.fullmatch(r"\d+[a-z]*", tt or ""):
                yrs = _parse_age_token(tt)
                if yrs is not None:
                    years_dead = yrs
            elif tt in {"trapped","trap","bound","soulcage","soulbind"}:
                trapped = True
            elif tt in {"old","oldage","age"}:
                oldage = True
            elif tt in {"unwilling","refuse","no"}:
                unwilling = True


        try:
            bcfg = _load_battles()
            chan_id = _section_id(ctx.channel)
        except Exception:
            bcfg = None
            chan_id = str(ctx.channel.id)


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            rc = read_cfg(path)
                            real = get_compat(rc, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        tgt_name, tgt_path = _resolve_char_ci(want_name)
        if not tgt_path:
            return [f"âŒ Target '{want_name}' not found."]
        if _is_monster_file(tgt_path):
            return [f"âŒ **{tgt_name}** is a monster/NPC record. Resurrection here is intended for PCs only."]

        tcfg = read_cfg(tgt_path)


        old_cur_hp = getint_compat(tcfg, "cur", "hp", fallback=0)
        if old_cur_hp != 0:
            return [f"âŒ **{tgt_name}** is not at 0 HP (not deceased)."]


        ty  = (get_compat(tcfg, "stats", "type", fallback="") or "").lower()
        rac = (get_compat(tcfg, "info",  "race", fallback="") or "").lower()
        if any(k in (ty + " " + rac) for k in ("construct","golem","elemental")):
            return [f"âŒ Constructs and elementals cannot be resurrected. (**{tgt_name}** appears to be one.)"]


        if trapped:
            return [f"âŒ The soul of **{tgt_name}** is bound/trapped. Resurrection fails."]
        if oldage:
            return [f"âŒ **{tgt_name}** died of old age. Resurrection cannot restore natural death."]


        if unwilling:
            return [f"âŒ **{tgt_name}** is unwilling to return. The spell fails."]


        if years_dead is not None:
            limit_years = float(max(1, int(caster_level or 1))) * 10.0
            if years_dead > limit_years + 1e-9:
                yrs_txt = f"{years_dead:.2f}".rstrip("0").rstrip(".")
                return [f"âŒ Too long dead: **{yrs_txt} years** > limit **{int(limit_years)} years** (10Ã—caster level)."]


        lvl_before = max(1, getint_compat(tcfg, "cur", "level", fallback=1))
        char_class = (get_compat(tcfg, "info", "class", fallback="") or "").strip()
        race_name  = (get_compat(tcfg, "info", "race",  fallback="") or "").strip()

        max_hp_before = getint_compat(tcfg, "max", "hp", fallback=1)


        level_lost = False
        con_lost   = False
        hp_loss_token = None
        lvl_after = lvl_before
        max_hp_after = max_hp_before
        con_before = getint_compat(tcfg, "stats", "con", fallback=10)

        if lvl_before >= 2:
            level_lost = True
            lvl_after = max(1, lvl_before - 1)


            if lvl_before >= 10:
                hp_loss = int(self._hp_flat_after9(char_class))
                hp_loss_token = f"flat{hp_loss}"
            else:
                hd_die = int(self._hit_die_for(char_class, race_name))

                roll = random.randint(1, max(4, hd_die))
                try:
                    con_mod = osr_mod(getint_compat(tcfg, "stats", "con", fallback=10))
                except Exception:
                    con_mod = 0
                hp_loss = max(1, roll + int(con_mod))
                hp_loss_token = f"d{hd_die}â†’{roll}{'+'+str(con_mod) if con_mod else ''}"

            max_hp_after = max(lvl_after, max(1, max_hp_before - hp_loss))

        else:

            if con_before <= 1:
                return [f"âŒ **{tgt_name}** is level 1 with CON **{con_before}** â€” losing 1 CON would drop to 0. Resurrection cannot proceed."]
            con_lost = True

            try:
                self._apply_conloss_points(tcfg, 1, permanent=True)
            except Exception:

                new_con = max(1, con_before - 1)
                if not tcfg.has_section("stats"): tcfg.add_section("stats")
                tcfg["stats"]["con"] = str(new_con)

            write_cfg(tgt_path, tcfg); tcfg = read_cfg(tgt_path)
            max_hp_after = getint_compat(tcfg, "max", "hp", fallback=max_hp_before)


        if level_lost:
            new_xp = _min_xp_for_level(char_class, lvl_after)
        else:
            new_xp = getint_compat(tcfg, "cur", "xp", fallback=0)


        if not tcfg.has_section("cur"): tcfg.add_section("cur")
        if not tcfg.has_section("max"): tcfg.add_section("max")


        tcfg["cur"]["level"] = str(lvl_after)
        tcfg["cur"]["xp"]    = str(new_xp)


        tcfg["max"]["hp"] = str(max_hp_after)
        tcfg["cur"]["hp"] = str(max_hp_after)


        try:
            tcfg["cur"]["neg_levels"] = "0"
            tcfg["cur"]["neg_hp_loss_total"] = "0"
        except Exception:
            pass


        try:
            for sec in ("cur","stats"):
                if tcfg.has_section(sec):
                    for k in ("poison","poisoned","disease","diseased"):
                        if tcfg.has_option(sec, k):
                            tcfg.remove_option(sec, k)
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, tgt_name) or tgt_name
                try: slot = _slot(key)
                except Exception: slot = key.replace(" ", "_")
                for suf in (".disease",".poison",".pois",".ill",".dead"):
                    opt = f"{slot}{suf}"
                    if bcfg.has_option(chan_id, opt):
                        bcfg.remove_option(chan_id, opt)
        except Exception:
            pass


        try:
            ty_now = (get_compat(tcfg, "stats", "type", fallback="") or "")
            if "undead" in ty_now.lower():
                if not tcfg.has_section("stats"): tcfg.add_section("stats")

                tcfg["stats"]["type"] = ""
        except Exception:
            pass


        try:
            tcfg["cur"]["raised_by"]  = caster_name
            tcfg["cur"]["raised_src"] = "resurrection"
        except Exception:
            pass

        write_cfg(tgt_path, tcfg)


        try:
            if bcfg and bcfg.has_section(chan_id):
                _save_battles(bcfg)
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        parts = [f"âœï¸ **Resurrection!** {tgt_name} is restored to life.",
                 (f"â€¢ Time since death: **{years_dead:.2f} years** (limit: **{10*max(1,int(caster_level or 1))} years**)."
                  if years_dead is not None else "â€¢ Time since death: *(not specified; assumed within limit)*")]

        if level_lost:
            parts.append(f"â€¢ Level: {lvl_before} â†’ **{lvl_after}**; XP set to **{new_xp}** (minimum for level {lvl_after}).")
            parts.append(f"â€¢ Max HP: {max_hp_before} â†’ **{max_hp_after}** (lost last-level HP: *{hp_loss_token}*).")
        else:
            con_after = getint_compat(tcfg, "stats", "con", fallback=con_before)
            parts.append(f"â€¢ Level remains **1**; permanent **âˆ’1 CON** applied ({con_before} â†’ **{con_after}**).")

        parts.append(f"â€¢ Current HP is now **{max_hp_after} / {max_hp_after}** (full).")
        parts.append("â€¢ Negative levels and ordinary poison/disease cleared. Prepared spells left unchanged ("
                     "Resurrection restores spells as at death; not tracked here).")
        parts.append("_Cannot restore creatures that died of old age; constructs/elementals are excluded._")

        return parts

    async def _effect_faeriefire(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Faerie Fire â€” Druid 1
          â€¢ Multi-target: pass any number of names (GM ensures â€œareaâ€ validity).
          â€¢ Duration: 1 minute/level  â†’  6 rounds/level.
          â€¢ On apply: cancels **Blur**, **Displacement**, and **Invisibility** on each target.
          â€¢ While active: targets shed dim light (candle-like); ignore concealment from darkness (table note).
          â€¢ No damage; no save.
          â€¢ Cosmetic: color can be -blue / -green / -violet (default violet).

        Usage:
          !cast faeriefire <t1> <t2> ... [-blue|-green|-violet]
        """
        chan_id = str(ctx.channel.id)


        color = "violet"
        raw_names: list[str] = []
        for t in (targets or []):
            tt = str(t).strip()
            low = tt.lower()
            if low in {"-blue", "-green", "-violet"}:
                color = low[2:]
            elif tt:
                raw_names.append(tt)

        if not raw_names:
            return "âœ¨ **Faerie Fire** â€” *(no valid targets provided)*"


        rounds = max(1, int(caster_level or 1)) * 6


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg2 = read_cfg(path)
                            real = get_compat(cfg2, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if not (bcfg and bcfg.has_section(chan_id)):

            pretty = ", ".join(raw_names)
            return (f"âœ¨ **Faerie Fire** ({color}) on **{pretty}** for **{rounds} rounds**.\n"
                    "â€¢ Cancels Blur/Displacement/Invisibility on application.\n"
                    "_(No active battle here â€” it wonâ€™t auto-tick.)_")

        names, _ = _parse_combatants(bcfg, chan_id)

        def _slot_for(nm: str) -> str:
            key = _find_ci_name(names, nm) or nm
            try:
                return (_choose_slot_for_effects(bcfg, chan_id, key)
                        if '_choose_slot_for_effects' in globals() else _slot(key))
            except Exception:
                return key.replace(" ", "_")


        applied = []
        not_found = []
        for raw in raw_names:
            disp, path = _resolve_char_ci(raw)
            pretty = disp or raw


            key = _find_ci_name(names, pretty) or pretty
            if key not in names:
                not_found.append(pretty)
                continue
            slot = _slot_for(pretty)


            for opt in (f"{slot}.inv", f"{slot}.inv_by", f"{slot}.inv_type"):
                if bcfg.has_option(chan_id, opt):
                    bcfg.remove_option(chan_id, opt)
            for suf in ("", "_code", "_label", "_emoji", "_by"):
                k = f"{slot}.x_blur{suf}"
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)
                k = f"{slot}.x_displacement{suf}"
                if bcfg.has_option(chan_id, k):
                    bcfg.remove_option(chan_id, k)


            bcfg.set(chan_id, f"{slot}.x_ff", str(rounds))
            bcfg.set(chan_id, f"{slot}.x_ff_code", "FF")
            bcfg.set(chan_id, f"{slot}.x_ff_label", "Faerie Fire")
            bcfg.set(chan_id, f"{slot}.x_ff_emoji", "âœ¨")
            bcfg.set(chan_id, f"{slot}.x_ff_by", caster_name)
            bcfg.set(chan_id, f"{slot}.x_ff_color", color)


            bcfg.set(chan_id, f"{slot}.ff_blocks", "1")


            pretty_slot = bcfg.get(chan_id, f"{slot}.disp", fallback=pretty)
            applied.append(pretty_slot)

        _save_battles(bcfg)


        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass


        head = f"âœ¨ **Faerie Fire** â€” {color.title()} glow"
        lines = []
        if applied:
            who = ", ".join(f"**{w}**" for w in applied)
            lines.append(f"{who}: outlined for **{rounds} rounds**.")
            lines.append("â€¢ **Cancels** Blur, Displacement, and Invisibility on application.")
            lines.append("â€¢ While the glow lasts: they shed **dim light**; darkness concealment doesnâ€™t apply. "
                         "(*No extra harm to undead/dark-dwellers.*)")
        if not_found:
            lines.append("*(Not found in this battle: " + ", ".join(not_found) + ")*")
        return head + "\n" + "\n".join(lines)





    async def _effect_produceflamecold(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Produce Flame/Cold â€” Druid 2
          â€¢ Choose element: fire or cold (partial tokens ok: 'fl', 'co', etc.)
          â€¢ Duration: 1 minute/level â†’ 10 rounds/level (tracked on the caster).
          â€¢ While active: sheds torchlight; can attack once each round with !a produce.
          â€¢ Every attack attempt consumes 1 minute (10 rounds) of the remaining duration.
          â€¢ Does not function underwater.
        Usage:
          !cast produceflamecold [flame|cold]
          (Shortcuts like: !cast produce cold)
        Follow-up attacks:
          !a produce <target> [-melee|-throw]
            - -melee : STR mod + AB vs AC (melee touch in spirit; we use normal AC here)
            - -throw : DEX mod + AB vs AC (no range penalty; max 50 ft)  [default]
        """

        chan_id = str(ctx.channel.id)


        want = "fire"
        for t in (tokens or []):
            s = re.sub(r"[^a-z]", "", str(t).lower())
            if s.startswith(("flame","fire","f")):
                want = "fire"
                break
            if s.startswith(("cold","co","ice","c")):
                want = "cold"
                break


        rounds_total = max(1, int(caster_level or 1)) * 10


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        if not (bcfg and bcfg.has_section(chan_id)):

            return (f"ðŸ”¥â„ï¸ **Produce { 'Flame' if want=='fire' else 'Cold' }** on **{caster_name}** "
                    f"for **{rounds_total} rounds**.\n"
                    "Use `!a produce <target> [melee]` to attack (consumes 10 rounds per attack).\n"
                    "_(No active battle here â€” it wonâ€™t auto-tick.)_")


        is_underwater = False
        try:
            if bcfg.getint(chan_id, "underwater", fallback=0) > 0:
                is_underwater = True
        except Exception:
            pass

        names, _ = _parse_combatants(bcfg, chan_id)
        me_key = _find_ci_name(names, caster_name) or caster_name
        try:
            s_me = self._effect_slot_for(bcfg, chan_id, me_key)
        except Exception:
            s_me = me_key.replace(" ", "_")

        if bcfg.getint(chan_id, f"{s_me}.underwater", fallback=0) > 0:
            is_underwater = True

        if is_underwater:
            return f"ðŸŒŠ **Produce { 'Flame' if want=='fire' else 'Cold' }** fizzles â€” it does not function **underwater**."









        bcfg.set(chan_id, f"{s_me}.x_pfc",        str(rounds_total))
        bcfg.set(chan_id, f"{s_me}.x_pfc_code",   "PF" if want == "fire" else "PC")
        bcfg.set(chan_id, f"{s_me}.x_pfc_label",  "Produce Flame" if want == "fire" else "Produce Cold")
        bcfg.set(chan_id, f"{s_me}.x_pfc_emoji",  "ðŸ”¥" if want == "fire" else "â„ï¸")
        bcfg.set(chan_id, f"{s_me}.x_pfc_by",     caster_name)
        bcfg.set(chan_id, f"{s_me}.pfc_elem",     want)
        bcfg.set(chan_id, f"{s_me}.pfc_last_round", "0")

        _save_battles(bcfg)


        try:
            msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
            if msg_id:
                block = _format_tracker_block(bcfg, chan_id)
                msg = await ctx.channel.fetch_message(msg_id)
                await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        color_word = "Flame" if want == "fire" else "Cold"
        return (f"ðŸ”¥â„ï¸ **Produce {color_word}** surrounds **{caster_name}** "
                f"â€” **{rounds_total} rounds**.\n"
                "Sheds torchlight while active. Use `!a produce <target> [-melee|-throw]` once each round.\n"
                "Every attack **consumes 10 rounds** of the remaining duration.")

    async def _effect_barkskin(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Barkskin (Druid 2): Self. Duration 1 turn/level (60 * level rounds).
        Flat +4 AC (doesn't hinder casting).
        """
        duration_rds = max(1, int(caster_level)) * 60

        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
        except Exception:
            _load_battles = _save_battles = _parse_combatants = _write_combatants = _sorted_entries = _find_ci_name = _slot = _format_tracker_block = None

        try:
            if _load_battles:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, caster_name) or caster_name
                    slot = _slot(key) if _slot else key.replace(" ", "_")


                    bcfg.set(chan_id, f"{slot}.barkskin", str(duration_rds))
                    bcfg.set(chan_id, f"{slot}.barkskin_by", caster_name)


                    bcfg.set(chan_id, f"{slot}.x_barkskin",       str(duration_rds))
                    bcfg.set(chan_id, f"{slot}.x_barkskin_code",  "BK")
                    bcfg.set(chan_id, f"{slot}.x_barkskin_label", "Barkskin")
                    bcfg.set(chan_id, f"{slot}.x_barkskin_by",    caster_name)

                    _save_battles(bcfg)


                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass

        return (f"ðŸŒ² **Barkskin** active on **{caster_name}**. AC **+4** to all attacks.\n"
                f"Duration: **{duration_rds} rounds**")

    async def _effect_tree(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Tree (Druid 2): Self. Duration 1 hour/level (360 * level rounds).
        +10 AC. You cannot attack or cast while in Tree form. Dismiss with `!conc drop`.
        """
        duration_rds = max(1, int(caster_level)) * 360

        try:
            _load_battles, _save_battles, _parse_combatants, _write_combatants, _sorted_entries, _find_ci_name, _slot, _format_tracker_block = self._battle_helpers()
        except Exception:
            _load_battles = _save_battles = _parse_combatants = _write_combatants = _sorted_entries = _find_ci_name = _slot = _format_tracker_block = None

        try:
            if _load_battles:
                bcfg = _load_battles()
                chan_id = str(ctx.channel.id)
                if bcfg.has_section(chan_id):
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key  = _find_ci_name(names, caster_name) or caster_name
                    slot = _slot(key) if _slot else key.replace(" ", "_")

                    bcfg.set(chan_id, f"{slot}.tree",       str(duration_rds))
                    bcfg.set(chan_id, f"{slot}.tree_by",    caster_name)
                    bcfg.set(chan_id, f"{slot}.tree_code",  "TREE")
                    bcfg.set(chan_id, f"{slot}.tree_label", "Tree Form")
                    _save_battles(bcfg)


                    try:
                        msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                        if msg_id:
                            block = _format_tracker_block(bcfg, chan_id)
                            content = "**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```"
                            msg = await ctx.channel.fetch_message(msg_id)
                            await msg.edit(content=content)
                    except Exception:
                        pass
        except Exception:
            pass

        hours = max(1, int(caster_level))
        return (f"ðŸŒ³ **Tree** form assumed. AC **+10**.\n"
                f"While treed you **cannot attack or cast**. Dismiss anytime with `!conc drop`.\n"
                f"Duration: **{duration_rds} rounds** ({hours} hour{'s' if hours != 1 else ''}).")

    async def _effect_assumeanimalform(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        AssumeAnimalForm (Druid 3) â€” Self, Duration 1 hour/level (360 rounds/level)
        - Form must be a natural animal (template [base].type == 'animal').
        - Form HD must be â‰¤ caster level.
        - On cast: roll animal HP (HD*d8 + hpmod, min 1) and *replace* the casterâ€™s HP/max HP with that total.
        - Copy animal physical stats (AC/move/type/attacks/attack specs/primary damage/resists).
        - Retain casterâ€™s â€œmindâ€ (we donâ€™t touch saves, class, etc.).
        - While active, you canâ€™t cast (speech/hands issue).
        - If the animal body is slain, revert immediately to original form/HP.
        - You may end early with `!conc drop`.
        Tracker keys (slot):
            .aaf                 = rounds left
            .aaf_by              = caster
            .aaf_form            = pretty form name
            .aaf_prev_hp         = HP to restore on revert
            .aaf_prev_mhp        = Max HP to restore on revert
            .aaf_backup_stats_*  = small stats backup (ac/move/type/attacknames/damage/resist/reduce1/immune)
            .x_aaf + label/code  = pretty tracker pill [ANML]
            .poly                = form label for your existing tracker column
        """

        if not tokens:
            return "âŒ Usage: `!cast AssumeAnimalForm <animal>` (e.g., `pitviper`, `wolf`)"

        form_arg = tokens[0]


        try:
            form_pretty, mcfg = _load_monster_form(form_arg)
        except Exception:
            form_pretty, mcfg = (None, None)
        if not mcfg:
            return f"âŒ Form **{form_arg}** not found in `/monsters`."


        m_type = (get_compat(mcfg, "base", "type", fallback="") or "").strip().lower()
        if m_type != "animal":
            return f"âŒ **{form_pretty or form_arg}** is not a *natural animal*."


        m_hd    = max(1, getint_compat(mcfg, "base", "hd",    fallback=1))
        m_hpmod =      getint_compat(mcfg, "base", "hpmod", fallback=0)
        if int(m_hd) > int(max(1, caster_level)):
            return f"âŒ **{form_pretty}** has **{m_hd} HD**, which exceeds your level **{caster_level}**."


        cas_disp, cas_path = self._resolve_char_ci(caster_name)
        if not cas_path:
            return f"âŒ Character file for **{caster_name}** not found."


        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)


        hp = sum(random.randint(1, 8) for _ in range(m_hd)) + m_hpmod
        hp = max(1, int(hp))


        tcfg = read_cfg(cas_path)
        prev_cur_hp  = getint_compat(tcfg, "cur",  "hp",  fallback=0)
        prev_max_hp  = getint_compat(tcfg, "max",  "hp",  fallback=prev_cur_hp)


        def _gs(key: str) -> str:
            return str(get_compat(tcfg, "stats", key, fallback="") or "")
        stats_backup = {
            "ac": _gs("ac"),
            "move": _gs("move"),
            "type": _gs("type"),
            "attacknames": _gs("attacknames"),
            "damage": _gs("damage"),
            "resist": _gs("resist"),
            "reduce1": _gs("reduce1"),
            "immune": _gs("immune"),
        }


        ac    = getint_compat(mcfg, "base", "ac",    fallback=10)
        move  = getint_compat(mcfg, "base", "move",  fallback=30)
        resist  = (get_compat(mcfg, "base", "resist",  fallback="") or "").strip()
        reduce1 = (get_compat(mcfg, "base", "reduce1", fallback="") or "").strip()
        immune  = (get_compat(mcfg, "base", "immune",  fallback="") or "").strip()


        atknames_raw = (get_compat(mcfg, "base", "attacknames", fallback="") or "").strip()
        atk_list = [a.strip().lower() for a in re.split(r"[,\s]+", atknames_raw) if a.strip()] if atknames_raw else []

        def _monster_spec_for(an: str) -> str:

            for key in (f"atk_{an}", an, f"dmg_{an}", f"{an}_dmg"):
                v = (get_compat(mcfg, "base", key, fallback="") or "").strip()
                if v: return v
            return ""
        primary_spec = None
        for an in atk_list:
            spec = _monster_spec_for(an) or ""
            if spec and not primary_spec:
                primary_spec = spec
        fallback_damage = primary_spec or (get_compat(mcfg, "base", "damage", fallback="1d6") or "1d6")


        if not tcfg.has_section("stats"):
            tcfg.add_section("stats")
        tcfg["stats"]["ac"] = str(ac)
        tcfg["stats"]["move"] = str(move)
        tcfg["stats"]["type"] = "animal"
        tcfg["stats"]["attacknames"] = " ".join(atk_list) if atk_list else ""
        tcfg["stats"]["damage"] = fallback_damage
        if resist:  tcfg["stats"]["resist"]  = resist
        if reduce1: tcfg["stats"]["reduce1"] = reduce1
        if immune:  tcfg["stats"]["immune"]  = immune

        for an in atk_list:
            spec = _monster_spec_for(an)
            if spec:
                tcfg["stats"][f"atk_{an}"] = spec


        if not tcfg.has_section("max"): tcfg.add_section("max")
        if not tcfg.has_section("cur"): tcfg.add_section("cur")
        tcfg["max"]["hp"] = str(hp)
        tcfg["cur"]["hp"] = str(hp)
        write_cfg(cas_path, tcfg)


        rounds = max(1, int(caster_level)) * 360


        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            me_key = _find_ci_name(names, caster_name) or caster_name
            try:
                s_me = _slot(me_key)
            except Exception:
                s_me = me_key.replace(" ", "_")


            try:
                if bcfg.getint(chan_id, f"{s_me}.aaf", fallback=0) > 0:
                    await self._aaf_end(ctx, bcfg, chan_id, caster_name, reason="new form")
            except Exception:
                pass


            bcfg.set(chan_id, f"{s_me}.aaf", str(rounds))
            bcfg.set(chan_id, f"{s_me}.aaf_by", caster_name)
            bcfg.set(chan_id, f"{s_me}.aaf_form", form_pretty)


            bcfg.set(chan_id, f"{s_me}.aaf_prev_hp",  str(prev_cur_hp))
            bcfg.set(chan_id, f"{s_me}.aaf_prev_mhp", str(prev_max_hp))


            for k, v in stats_backup.items():
                bcfg.set(chan_id, f"{s_me}.aaf_backup_stats_{k}", v)


            bcfg.set(chan_id, f"{s_me}.x_aaf", str(rounds))
            bcfg.set(chan_id, f"{s_me}.x_aaf_label", "Animal Form")
            bcfg.set(chan_id, f"{s_me}.x_aaf_code", "ANML")
            bcfg.set(chan_id, f"{s_me}.x_aaf_by", caster_name)
            bcfg.set(chan_id, f"{s_me}.poly", form_pretty)
            _save_battles(bcfg)


            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        return (f"ðŸ¾ **Assume Animal Form**: **{caster_name}** becomes a **{form_pretty}**!\n"
                f"â€¢ New HP: **{hp}** (rolled {m_hd}d8{f'+{m_hpmod}' if m_hpmod else ''})\n"
                f"â€¢ Duration: **{caster_level} hour(s)** ({rounds} rounds)\n"
                f"â€¢ You gain the animalâ€™s AC/move/natural attacks (incl. riders like *poison*), "
                f"but keep your mind. Gear/spells donâ€™t function while shifted.\n"
                f"â€¢ End early with `!conc drop`. If this body is **slain**, you **revert** and restore your prior HP.")

    async def _aaf_end(self, ctx, bcfg, chan_id: str, who_name: str, reason: str = "ended", *, quiet_embed=None):
        """
        Revert a shapeshifted druid back to their original form/hp.
        - Restores max HP & HP from the saved snapshot.
        - Restores small 'stats' backup (ac/move/type/attacknames/damage/resist/reduce1/immune).
        - Clears AAF/x_AAF/poly keys set by the effect.
        - If quiet_embed is provided (an Embed), appends a note instead of sending a new message.
        """

        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, who_name) or who_name
        try:
            s_me = _slot(key)
        except Exception:
            s_me = key.replace(" ", "_")


        if bcfg.getint(chan_id, f"{s_me}.aaf", fallback=0) <= 0:
            return


        disp, path = self._resolve_char_ci(key)
        if not path or not os.path.exists(path):
            return

        cfg = read_cfg(path)


        old_hp  = getint_compat(cfg, "cur", "hp", fallback=0)
        prev_hp   = bcfg.getint(chan_id, f"{s_me}.aaf_prev_hp",  fallback=old_hp)
        prev_mhp  = bcfg.getint(chan_id, f"{s_me}.aaf_prev_mhp", fallback=max(prev_hp, old_hp))
        if not cfg.has_section("max"): cfg.add_section("max")
        if not cfg.has_section("cur"): cfg.add_section("cur")
        cfg["max"]["hp"] = str(prev_mhp)
        cfg["cur"]["hp"] = str(max(0, min(prev_hp, prev_mhp)))


        if not cfg.has_section("stats"): cfg.add_section("stats")
        for k in ("ac","move","type","attacknames","damage","resist","reduce1","immune"):
            v = bcfg.get(chan_id, f"{s_me}.aaf_backup_stats_{k}", fallback=None)
            if v is not None:
                if v == "":

                    try: cfg.remove_option("stats", k)
                    except Exception: cfg["stats"][k] = ""
                else:
                    cfg["stats"][k] = v

        write_cfg(path, cfg)


        for suf in ("aaf","aaf_by","aaf_form","aaf_prev_hp","aaf_prev_mhp"):
            opt = f"{s_me}.{suf}"
            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)
        for suf in ("x_aaf","x_aaf_label","x_aaf_code","x_aaf_by"):
            opt = f"{s_me}.{suf}"
            if bcfg.has_option(chan_id, opt): bcfg.remove_option(chan_id, opt)


        pf = (bcfg.get(chan_id, f"{s_me}.aaf_form", fallback="") or "")
        if pf and (bcfg.get(chan_id, f"{s_me}.poly", fallback="") or "").lower() == pf.lower():
            if bcfg.has_option(chan_id, f"{s_me}.poly"):
                bcfg.remove_option(chan_id, f"{s_me}.poly")

        _save_battles(bcfg)


        try:
            await self._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        msg = f"ðŸ¾ **Animal Form** on **{who_name}** â€” {reason}; original form restored (HP **{prev_hp}/{prev_mhp}**)."
        if quiet_embed is not None:
            quiet_embed.add_field(name="Assume Animal Form", value=msg, inline=False)
        else:
            emb = nextcord.Embed(title="Shapeshift ends", description=msg, color=0x66AA66)
            await ctx.send(embed=emb)

    async def _aaf_revert_if_slain(self, ctx, bcfg, chan_id: str, tgt_name: str, tgt_cfg, tgt_path: str, embed_obj):
        """
        Call this right after you apply damage and compute new_hp.
        If target is a PC with AAF active and HP â‰¤ 0, auto-revert instead of leaving them dead.
        Appends a note into the same embed youâ€™re already sending.
        """
        if _is_monster_file(tgt_path):
            return
        names, _ = _parse_combatants(bcfg, chan_id)
        key = _find_ci_name(names, tgt_name) or tgt_name
        try:
            s_tgt = _slot(key)
        except Exception:
            s_tgt = key.replace(" ", "_")

        if bcfg.getint(chan_id, f"{s_tgt}.aaf", fallback=0) <= 0:
            return


        cur_hp = getint_compat(tgt_cfg, "cur", "hp", fallback=0)
        if cur_hp > 0:
            return

        await self._aaf_end(ctx, bcfg, chan_id, tgt_name, reason="animal body slain", quiet_embed=embed_obj)

    async def _effect_holdanimal(self, ctx, caster_cfg, caster_name: str, caster_level: int, targets: list[str]) -> str:
        """
        Hold Person
          â€¢ Single target â†’ Save vs Spells at â€“2 (harder to resist).
          â€¢ Group cast (2+ names) â†’ roll 1d4; only that many are *affected* (each gets a normal save).
          â€¢ Only living animals. Creatures larger than ogres are unaffected.
          â€¢ On failed save: PARALYZED for 2d8 *turns* (== turns*60 rounds). No change to initiative order here.
        """


        resolved: list[tuple[str, str, str | None]] = []
        for raw in (targets or []):
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = (raw, None)
            resolved.append((raw, (disp or raw), path))

        if not any(p for _, _, p in resolved):
            return "ðŸ§¿ **Hold Animal** â€” _(no valid targets found)_"


        group_mode = (len([1 for _, _, p in resolved if p]) >= 2)

        chosen = []
        roll_note = ""
        if group_mode:
            d, rolls, flat = roll_dice("1d4")
            k = min(d + flat, len([1 for _, _, p in resolved if p]))
            pool = [(r, d, p) for (r, d, p) in resolved if p]
            random.shuffle(pool)
            chosen = pool[:k]
            roll_note = f" â€” group cast: 1d4 â†’ **{k}**"
        else:
            for tup in resolved:
                if tup[2]:
                    chosen = [tup]
                    break

        lines = []
        for raw, disp, path in chosen:
            pretty = (disp or raw)
            pretty_up = pretty.upper()
            if not path:
                lines.append(f"{pretty_up}: *(not found)*")
                continue

            t_cfg = read_cfg(path)


            ty = (str(get_compat(t_cfg, "stats", "type", fallback="")) or
                  str(get_compat(t_cfg, "info",  "type", fallback=""))).lower()


            if not _is_animal_cfg(t_cfg, disp):
                lines.append(f"{pretty_up}: not an **animal** â€” no effect.")
                continue


            too_large = False
            try:
                too_large = self._too_large_for_hold(t_cfg, disp)
            except Exception:

                sz = str(get_compat(t_cfg, "stats", "size", fallback="")).lower()
                too_large = any(k in sz for k in ("huge","gargantuan","colossal","enormous"))
            if too_large:
                lines.append(f"{pretty_up}: too large (larger than ogre) â€” no effect")
                continue


            penalty = 2 if not group_mode else 0
            ok, sv_roll, sv_dc, sv_pen = self._roll_save(t_cfg, vs="spell", penalty=penalty)
            pen_txt = f" - {sv_pen}" if sv_pen else ""
            if ok:
                lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ **RESISTED**")
                continue


            t_sum, t_rolls, t_flat = roll_dice("2d8")
            turns = t_sum + t_flat
            rounds = turns * 60
            try:

                self._set_status_rounds(ctx, disp, "paralyzed", rounds, by=caster_name)
            except Exception:
                pass
            lines.append(f"{pretty_up}: Save vs Spells {sv_roll}{pen_txt} vs {sv_dc} â†’ ðŸ§Š **PARALYZED** *(for {turns} turns)*")

        head = f"ðŸ§¿ **Hold Animal**{roll_note}"
        return head + "\n" + "\n".join(lines)

    async def _effect_restorehealth(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Restore Health â€” Cleric 2 / Druid 2
        Range: Touch â€¢ Duration: Instantaneous

        Removes **temporary** ability score loss (damage) from one chosen ability on the touched target.
        Useful for things like a Shadowâ€™s STR drain. Has **no effect** on permanent ability loss or energy drain.

        Usage:
          !cast restorehealth <target?> <stat>
            <stat> = str|dex|con|int|wis|cha (or long names)
          Examples:
            !cast restorehealth str              # self, STR
            !cast restorehealth Alaric Con      # Alaric, CON
        """


        def _resolve_char_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg = read_cfg(path)
                            real = get_compat(cfg, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None

        def _norm_stat_key(s: str | None) -> str | None:
            if not s: return None
            k = re.sub(r"[^a-z]", "", str(s).lower())
            m = {
                "str":"str", "strength":"str",
                "dex":"dex", "dexterity":"dex",
                "con":"con", "constitution":"con",
                "int":"int", "intelligence":"int",
                "wis":"wis", "wisdom":"wis",
                "cha":"cha", "charisma":"cha",
            }
            return m.get(k)

        def _effective_cap(cfg):
            try:
                return self._effective_max_hp(cfg)
            except Exception:
                mx = getint_compat(cfg, "max", "hp", fallback=0)
                pool = getint_compat(cfg, "cur", "neg_hp_loss_total", fallback=0)
                return max(0, mx - max(0, pool))


        raw = [t for t in (tokens or []) if str(t).strip()]
        if not raw:
            return ("âœ¨ **Restore Health**: choose a target (optional) and an ability, e.g. "
                    "`!cast restorehealth <target?> <str|dex|con|int|wis|cha>`.")


        stat = _norm_stat_key(raw[-1])
        if not stat:
            return ("âœ¨ **Restore Health**: you must specify an ability, e.g. "
                    "`!cast restorehealth <target?> STR`.")


        maybe_target = " ".join(raw[:-1]).strip() if len(raw) > 1 else None
        target_name = (maybe_target or caster_name)

        disp, path = _resolve_char_ci(target_name)
        pretty = disp or target_name
        if not path:
            return f"âœ¨ **Restore Health** â€” {pretty}: *(not found)*"

        cfg = read_cfg(path)
        if not cfg.has_section("cur"):
            cfg.add_section("cur")
        if not cfg.has_section("stats"):
            cfg.add_section("stats")



        loss_key_temp = f"{stat}_loss_temp"
        temp_loss = getint_compat(cfg, "cur", loss_key_temp, fallback=None)
        if temp_loss is None and stat == "str":
            temp_loss = getint_compat(cfg, "cur", "str_loss", fallback=0)
        temp_loss = max(0, int(temp_loss or 0))

        if temp_loss <= 0:
            return (f"âœ¨ **Restore Health** â€” {pretty}\n"
                    f"â€¢ No **temporary** {stat.upper()} loss recorded â€” **no effect**.")


        dsum, rolls, flat = roll_dice("1d4")
        rolled = dsum + flat
        restore = min(rolled, temp_loss)

        old_val = getint_compat(cfg, "stats", stat, fallback=10)
        new_val = max(1, old_val + restore)


        cfg["cur"][loss_key_temp] = str(max(0, temp_loss - restore))
        if stat == "str":

            cfg["cur"]["str_loss"] = cfg["cur"][loss_key_temp]
        cfg["stats"][stat] = str(new_val)


        if stat == "con" and restore:
            try:
                self._apply_con_change_adjust_hp(cfg, old_val, new_val)
            except TypeError:
                self._apply_con_change_adjust_hp(cfg, restore)

        write_cfg(path, cfg)


        if stat == "con" and restore:
            cfg = read_cfg(path)
            cap = _effective_cap(cfg)
            cur_hp = getint_compat(cfg, "cur", "hp", fallback=0)
            if cur_hp > cap:
                cfg["cur"]["hp"] = str(cap)
                write_cfg(path, cfg)


        lines = [f"âœ¨ **Restore Health** â€” {pretty}",
                 f"â€¢ {stat.upper()} temporary loss **+{restore}** "
                 f"(rolled 1d4 = {rolled}: [{', '.join(map(str, rolls))}]) "
                 f"â†’ {old_val} â†’ **{new_val}**."]


        try:
            if stat == "str":
                before_collapse = old_val <= 2
                after_collapse  = new_val <= 2
                if before_collapse and not after_collapse:
                    lines.append("â€¢ Condition: no longer **Collapsed** (STR > 2).")
        except Exception:
            pass


        try:
            bcfg = _load_battles(); chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
        except Exception:
            pass

        lines.append("_This spell does not restore **permanent** ability loss or **negative levels**._")
        return "\n".join(lines)

    async def _cast_callwoodlandbeings(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Call Woodland Beings (Druid 4)
          â€¢ Choose one category to summon:
              - 4 Centaurs
              - 16 Pixies (spawn invisible)
              - 2 Treants
              - 4 Unicorns (with innate spells loaded from template)
          â€¢ Range: 120 ft (not enforced)
          â€¢ Duration: 1 round/level (L rounds)
          â€¢ Environment: only outdoors in a natural location

        Usage:
          !cast callwoodlandbeings centaurs
          !cast callwoodlandbeings pixies
          !cast callwoodlandbeings treants
          !cast callwoodlandbeings unicorns
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]

        L = max(1, int(caster_level or 1))
        rounds_total = L


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]

        force = False
        if "-force" in toks or "-f" in toks:
            force = True
            toks = [t for t in toks if t not in {"-force", "-f"}]

        ALIAS = {
            "centaur":"centaur","centaurs":"centaur","cen":"centaur","ce":"centaur",
            "pixie":"pixie","pixies":"pixie","pix":"pixie","pi":"pixie",
            "treant":"treant","treants":"treant","tre":"treant","tr":"treant",
            "unicorn":"unicorn","unicorns":"unicorn","uni":"unicorn","un":"unicorn",
        }
        choices = [ALIAS[t] for t in toks if t in ALIAS]
        choices = list(dict.fromkeys(choices))

        if not choices:
            return [
                "âŒ Choose one: `centaurs`, `pixies`, `treants`, or `unicorns`.",
                "Example: `!cast callwoodlandbeings pixies`"
            ]
        if len(choices) > 1:
            return ["âŒ Pick **one** type to summon: centaurs **or** pixies **or** treants **or** unicorns."]

        kind = choices[0]
        COUNT = {"centaur": 4, "pixie": 16, "treant": 2, "unicorn": 4}
        PRETTY = {"centaur":"Centaurs","pixie":"Pixies","treant":"Treants","unicorn":"Unicorns"}
        PREFIX = {"centaur":"CE","pixie":"PI","treant":"TR","unicorn":"UN"}


        def _tpl(name: str):
            return (_load_monster_template(name)
                    or _load_monster_template(name + ".ini")
                    or None)

        tpl = _tpl(kind)
        if not tpl:
            return [f"âŒ Monster template not found for **{kind}** (e.g., `{kind}.ini`)."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        def _spawn_batch(kind: str, tpl, count: int):
            if count <= 0: return []
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 1))
            hpmod  = int(tpl.get("hpmod", 0))
            move   = int(tpl.get("move", 30))
            saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
            damage = str(tpl.get("damage", "1d6"))
            resist  = str(tpl.get("resist",  "")).strip()
            reduce1 = str(tpl.get("reduce1", "")).strip()
            immune  = str(tpl.get("immune",  "")).strip()
            weak    = str(tpl.get("weak",    "")).strip()
            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", max(1, hd)
            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = PREFIX.get(kind, re.sub(r"[^A-Za-z]", "", kind).upper()[:2] or "MO")
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
            created = []

            for _ in range(count):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)


                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": kind, "battle_chan": chan_id,
                    "controller": caster_name,
                    "summoned": "callwoodlandbeings",
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


                stats = {"ac": str(ac), "ab": "", "move": str(move),
                         "type": str(tpl.get("type", "")).strip(),
                         "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
                         "special": str(tpl.get("special", "")).strip()}
                attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
                atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
                attack_list = [a for a in re.split(r"[,\s]+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                    tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                        if spec:
                            stats[f"atk_{an}"] = spec
                            if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or (damage or "1d6")
                else:
                    stats["damage"] = damage or "1d6"

                coe["stats"] = stats
                coe["base"]  = dict(stats)
                coe["saves"] = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}


                def _ak(s: str) -> str: return "".join(ch.lower() for ch in str(s) if ch.isalnum())
                spells_line = str(tpl.get("spells", "")).strip()
                if spells_line:
                    mon_magic = {}
                    mon_left  = {}
                    listed = []
                    for tok in re.split(r"\s+", spells_line):
                        if not tok: continue
                        key = _ak(tok)
                        raw_ct = (tpl.get(tok, None) or tpl.get(tok.lower(), None) or tpl.get(key, None))
                        try:
                            count = int(str(raw_ct).strip()) if raw_ct is not None else 1
                        except Exception:
                            count = 1
                        listed.append(key)
                        mon_magic[f"{key}_total"] = str(max(0, count))
                        mon_left[f"{key}_left"]   = str(max(0, count))
                    cl_raw = tpl.get("casterlevel", None) or tpl.get("cl", None)
                    try:
                        caster_level_tpl = int(str(cl_raw).strip()) if cl_raw is not None else int(hd)
                    except Exception:
                        caster_level_tpl = int(hd)
                    mon_magic["list"] = " ".join(listed)
                    mon_magic["caster_level"] = str(caster_level_tpl)
                    mon_magic["source"] = str(tpl.get("name", kind)).strip() or kind
                    coe["mon_spells"] = mon_magic
                    coe["mon_left"]   = mon_left

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)


                try:
                    s = _slot(mon)
                except Exception:
                    s = mon.replace(" ", "_")


                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s}."):
                        bcfg.remove_option(chan_id, opt_key)
                if bcfg.has_option(chan_id, mon):
                    bcfg.remove_option(chan_id, mon)


                bcfg.set(chan_id, f"{s}.disp", mon)
                bcfg.set(chan_id, f"{s}.hostile", "0")
                bcfg.set(chan_id, f"{s}.minion_by", caster_name)
                bcfg.set(chan_id, f"{s}.minion_type", kind)
                bcfg.set(chan_id, f"{s}.summon_left", str(rounds_total))
                bcfg.set(chan_id, f"{s}.summon_src", "callwoodlandbeings")
                bcfg.set(chan_id, f"{s}.expire_cb", "callwoodlandbeings")

                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s}.join", str(join_seq))

                created.append((mon, d6, hp, hd, s))

            _save_battles(bcfg)
            return created

        n = COUNT[kind]
        created = _spawn_batch(kind, tpl, n)
        if not created:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        slot_self = _resolve_effect_slot(bcfg, chan_id, caster_name)

        rounds = max(1, int(caster_level))
        base_key = "x_callwoodlandbeings"
        code = self._two_letter_code_from_name("Call Woodland Beings", "callwoodlandbeings") or "CW"

        bcfg.set(chan_id, f"{slot_self}.{base_key}",          str(rounds))
        bcfg.set(chan_id, f"{slot_self}.{base_key}_label",    "Call Woodland Beings")
        bcfg.set(chan_id, f"{slot_self}.{base_key}_code",     code)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_emoji",    "ðŸŒ²")
        bcfg.set(chan_id, f"{slot_self}.{base_key}_by",       caster_name)

        _save_battles(bcfg)




        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        names = ", ".join(nm for (nm, _i, _hp, _hd, _s) in created)
        pretty = PRETTY[kind]
        lines = [
            f"ðŸŒ² **{caster_name}** calls **Woodland Beings**.",
            f"â€¢ Summoned: **{n} {pretty}** â†’ {names}",
            f"â€¢ Duration: **{L} round{'s' if L != 1 else ''}**.",
        ]
        if kind == "unicorn":
            lines.append("â€¢ Unicorns have **innate spells** (e.g., Cure Light Wounds). Use `!mcast UN# <spell> [targets]`.")
        if kind == "pixie":
            lines.append("â€¢ Pixies can **turn invisible** at will. Use `!invis PI# imp` (pixie invisibility is improved invisbility)")
        lines.append("â€¢ They act on your side and obey if you can communicate with them.")
        return lines

    @commands.command(name="animals")
    async def list_animals(self, ctx, *args):
        """
        List ordinary animals by HD (for Summon Animals).
        Usage:
          !animals                 # all, grouped by HD
          !animals wolf            # search substring (case-insensitive)
          !animals -hd4           # filter: <=4 HD (use -hd8 / -hd12)
        """
        toks = [str(t).strip().lower() for t in args if str(t).strip()]

        max_hd = None
        if "-hd4" in toks: max_hd = 4;  toks.remove("-hd4")
        if "-hd8" in toks: max_hd = 8;  toks.remove("-hd8")
        if "-hd12" in toks: max_hd = 12; toks.remove("-hd12")

        q = " ".join(t for t in toks if not t.startswith("-")).strip()


        items = [(name, hd) for name, hd in ANIMAL_HD.items() if (max_hd is None or hd <= max_hd)]
        items.sort(key=lambda x: (x[1], x[0].lower()))

        embed = nextcord.Embed(
            title="ðŸ¾ Animals by HD",
            description=("These are 'ordinary animals (incl. giant ones)' for **Summon Animals**.\n"
                         "Tip: `!cast summonanimals1 wolves jaguar eagle` (up to **3** choices)."),
            color=random.randint(0, 0xFFFFFF)
        )

        if q:
            qq = q.lower()
            matches = [(n, hd) for (n, hd) in items if qq in n.lower()]
            if not matches:
                await ctx.send(f"âŒ No animals match **{q}**.")
                return
            lines = [f"â€¢ **{n}** â€” {hd} HD" for (n, hd) in matches]
            embed.add_field(name=f"Matches ({len(matches)})", value="\n".join(lines)[:1024], inline=False)
            await ctx.send(embed=embed)
            return


        by_hd = {}
        for n, hd in items:
            by_hd.setdefault(hd, []).append(n)
        for hd in sorted(by_hd.keys()):
            names = ", ".join(sorted(by_hd[hd], key=str.lower))

            chunk = names
            head = f"HD {hd}"
            while chunk:
                if len(chunk) <= 1024:
                    embed.add_field(name=head, value=chunk, inline=False)
                    break

                cut = chunk.rfind(",", 0, 1024)
                cut = cut if cut > 0 else 1024
                embed.add_field(name=head, value=chunk[:cut], inline=False)
                chunk = chunk[cut+1:].lstrip()
                head = f"HD {hd} (cont.)"

        await ctx.send(embed=embed)


    async def _cast_summonanimals1(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_e, **_kw):
        bcfg = _load_battles(); chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t for t in re.split(r"\s+", targets.strip()) if t]

        force = False
        pick  = None
        def _take_after(words):
            nonlocal toks
            for i in range(len(toks)-1):
                if toks[i].lower() in words and toks[i+1]:
                    v = toks[i+1]; toks[i] = ""; toks[i+1] = ""; return v
            return None
        if "-f" in [t.lower() for t in toks] or "-force" in [t.lower() for t in toks]:
            force = True
            toks = [t for t in toks if t.lower() not in {"-f","-force"}]
        pick_raw = _take_after({"-pick","-p"})
        if pick_raw: pick = _canon_animal(pick_raw)


        asked = []
        for t in toks:
            can = _canon_animal(t)
            if can and can not in asked:
                asked.append(can)
            if len(asked) == 3: break
        if not asked:
            return ["âŒ Name **1â€“3 animal types** (ordinary/giant). Example: `!cast summonanimals1 wolf jaguar eagle`"]


        bad = [(a, ANIMAL_HD.get(a, 999)) for a in asked if ANIMAL_HD.get(a, 999) > 4]
        if bad:
            hi = ", ".join(f"**{n}** ({hd} HD)" for n, hd in bad)
            return [f"âŒ **SummonAnimals1** allows only **4 HD or less**. Not allowed: {hi}"]


        choice = None
        if pick and pick in asked:
            choice = pick
        else:
            choice = asked[0]


        count = random.randint(1, 8)
        rounds_total = 360

        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)
        created, err = await self._spawn_animals(ctx, bcfg, chan_id, caster_name, caster_owner_id, choice, count, rounds_total)
        if err: return err


        slot_self = _resolve_effect_slot(bcfg, chan_id, caster_name)

        base_key = "x_summonanimals1"
        label    = "Summon Animals I"
        code     = self._two_letter_code_from_name(label, base_key) or "SA"

        bcfg.set(chan_id, f"{slot_self}.{base_key}",         str(rounds_total))
        bcfg.set(chan_id, f"{slot_self}.{base_key}_label",   label)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_code",    code)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_emoji",   "ðŸ¦Œ")
        bcfg.set(chan_id, f"{slot_self}.{base_key}_by",      caster_name)
        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        names = ", ".join(n for (n, _i, _hp, _hd, _s) in created)
        lines = [f"ðŸ¦Œ **{caster_name}** casts **Summon Animals I**.",
                 f"â€¢ Requested: {', '.join(asked)}",
                 f"â€¢ Found: **{choice}**{' (assumed)' if force else ''}",
                 f"â€¢ Summoned: **{count}Ã— {choice}** â†’ {names}",
                 f"â€¢ Duration: **1 hour** (**{rounds_total} rounds**).",
                 "â€¢ They are friendly and aid your current task; you may dismiss them at any time."]
        return lines


    async def _cast_summonanimals2(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_e, **_kw):
        bcfg = _load_battles(); chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]

        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t for t in re.split(r"\s+", targets.strip()) if t]

        force = False
        prefer = None
        pick  = None
        def _take_after(words):
            nonlocal toks
            for i in range(len(toks)-1):
                if toks[i].lower() in words and toks[i+1]:
                    v = toks[i+1]; toks[i] = ""; toks[i+1] = ""; return v
            return None
        if "-f" in [t.lower() for t in toks] or "-force" in [t.lower() for t in toks]:
            force = True
            toks = [t for t in toks if t.lower() not in {"-f","-force"}]
        if "-hd4" in [t.lower() for t in toks]: prefer = "hd4"; toks = [t for t in toks if t.lower() != "-hd4"]
        if "-hd8" in [t.lower() for t in toks]: prefer = "hd8"; toks = [t for t in toks if t.lower() != "-hd8"]
        pick_raw = _take_after({"-pick","-p"})
        if pick_raw: pick = _canon_animal(pick_raw)

        asked = []
        for t in toks:
            can = _canon_animal(t)
            if can and can not in asked:
                asked.append(can)
            if len(asked) == 3: break
        if not asked:
            return ["âŒ Name **1â€“3 animal types**. Example: `!cast summonanimals2 jaguar wolf -hd4`"]


        max_req = max(ANIMAL_HD.get(a, 999) for a in asked)
        path = prefer or ("hd8" if max_req > 4 else "hd4")
        if path == "hd4":

            bad = [(a, ANIMAL_HD.get(a, 999)) for a in asked if ANIMAL_HD.get(a, 999) > 4]
            if bad:
                hi = ", ".join(f"**{n}** ({hd} HD)" for n, hd in bad)
                return [f"âŒ With **-hd4**, all choices must be **â‰¤4 HD**. Not allowed: {hi}"]
            dice, faces = 3, 4
            hd_cap = 4
            pretty_mode = "3d4 of â‰¤4 HD"
        else:

            bad = [(a, ANIMAL_HD.get(a, 999)) for a in asked if ANIMAL_HD.get(a, 999) > 8]
            if bad:
                hi = ", ".join(f"**{n}** ({hd} HD)" for n, hd in bad)
                return [f"âŒ **SummonAnimals2** (â‰¤8 HD path) canâ€™t call: {hi}"]
            dice, faces = 1, 6
            hd_cap = 8
            pretty_mode = "1d6 of â‰¤8 HD"


        choice = None
        if pick and pick in asked:
            choice = pick
        else:
            choice = asked[0]


        count = sum(random.randint(1, faces) for _ in range(dice))
        rounds_total = 8640

        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)
        created, err = await self._spawn_animals(ctx, bcfg, chan_id, caster_name, caster_owner_id, choice, count, rounds_total)
        if err: return err


        slot_self = _resolve_effect_slot(bcfg, chan_id, caster_name)

        base_key = "x_summonanimals2"
        label    = "Summon Animals II"
        code     = self._two_letter_code_from_name(label, base_key) or "SA"

        bcfg.set(chan_id, f"{slot_self}.{base_key}",         str(rounds_total))
        bcfg.set(chan_id, f"{slot_self}.{base_key}_label",   label)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_code",    code)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_emoji",   "ðŸ¦Œ")
        bcfg.set(chan_id, f"{slot_self}.{base_key}_by",      caster_name)
        _save_battles(bcfg)

        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        names = ", ".join(n for (n, _i, _hp, _hd, _s) in created)
        lines = [f"ðŸ¦Œ **{caster_name}** casts **Summon Animals II** ({pretty_mode}).",
                 f"â€¢ Requested: {', '.join(asked)}",
                 f"â€¢ Found: **{choice}**{' (assumed)' if force else ''}",
                 f"â€¢ Summoned: **{count}Ã— {choice}** â†’ {names}",
                 f"â€¢ Duration: **1 day** (**{rounds_total} rounds**).",
                 "â€¢ They are friendly and aid your current task; you may dismiss them at any time."]
        return lines


    async def _cast_summonanimals3(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_e, **_kw):
        bcfg = _load_battles(); chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]

        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t for t in re.split(r"\s+", targets.strip()) if t]

        force = False
        prefer = None
        pick  = None
        def _take_after(words):
            nonlocal toks
            for i in range(len(toks)-1):
                if toks[i].lower() in words and toks[i+1]:
                    v = toks[i+1]; toks[i] = ""; toks[i+1] = ""; return v
            return None
        if "-f" in [t.lower() for t in toks] or "-force" in [t.lower() for t in toks]:
            force = True
            toks = [t for t in toks if t.lower() not in {"-f","-force"}]
        if "-hd4" in [t.lower() for t in toks]:  prefer = "hd4";  toks = [t for t in toks if t.lower() != "-hd4"]
        if "-hd8" in [t.lower() for t in toks]:  prefer = "hd8";  toks = [t for t in toks if t.lower() != "-hd8"]
        if "-hd12" in [t.lower() for t in toks]: prefer = "hd12"; toks = [t for t in toks if t.lower() != "-hd12"]
        pick_raw = _take_after({"-pick","-p"})
        if pick_raw: pick = _canon_animal(pick_raw)

        asked = []
        for t in toks:
            can = _canon_animal(t)
            if can and can not in asked:
                asked.append(can)
            if len(asked) == 3: break
        if not asked:
            return ["âŒ Name **1â€“3 animal types**. Example: `!cast summonanimals3 narwhal -hd12`"]


        max_req = max(ANIMAL_HD.get(a, 999) for a in asked)
        if prefer:
            path = prefer
        else:
            path = "hd12" if max_req > 8 else ("hd8" if max_req > 4 else "hd4")

        if path == "hd4":
            bad = [(a, ANIMAL_HD.get(a, 999)) for a in asked if ANIMAL_HD.get(a, 999) > 4]
            if bad:
                hi = ", ".join(f"**{n}** ({hd} HD)" for n, hd in bad)
                return [f"âŒ With **-hd4**, all choices must be **â‰¤4 HD**. Not allowed: {hi}"]
            dice, faces, cap = 4, 6, 4
            pretty_mode = "4d6 of â‰¤4 HD"
        elif path == "hd8":
            bad = [(a, ANIMAL_HD.get(a, 999)) for a in asked if ANIMAL_HD.get(a, 999) > 8]
            if bad:
                hi = ", ".join(f"**{n}** ({hd} HD)" for n, hd in bad)
                return [f"âŒ With **-hd8**, choices must be **â‰¤8 HD**. Not allowed: {hi}"]
            dice, faces, cap = 3, 4, 8
            pretty_mode = "3d4 of â‰¤8 HD"
        else:
            bad = [(a, ANIMAL_HD.get(a, 999)) for a in asked if ANIMAL_HD.get(a, 999) > 12]
            if bad:
                hi = ", ".join(f"**{n}** ({hd} HD)" for n, hd in bad)
                return [f"âŒ With **-hd12**, choices must be **â‰¤12 HD**. Not allowed: {hi}"]
            dice, faces, cap = 1, 4, 12
            pretty_mode = "1d4 of â‰¤12 HD"


        choice = pick if (pick and pick in asked) else asked[0]
        count = sum(random.randint(1, faces) for _ in range(dice))
        rounds_total = 8640

        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)
        created, err = await self._spawn_animals(ctx, bcfg, chan_id, caster_name, caster_owner_id, choice, count, rounds_total)
        if err: return err


        slot_self = _resolve_effect_slot(bcfg, chan_id, caster_name)

        base_key = "x_summonanimals3"
        label    = "Summon Animals III"
        code     = self._two_letter_code_from_name(label, base_key) or "SA"

        bcfg.set(chan_id, f"{slot_self}.{base_key}",         str(rounds_total))
        bcfg.set(chan_id, f"{slot_self}.{base_key}_label",   label)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_code",    code)
        bcfg.set(chan_id, f"{slot_self}.{base_key}_emoji",   "ðŸ¦Œ")
        bcfg.set(chan_id, f"{slot_self}.{base_key}_by",      caster_name)
        _save_battles(bcfg)

        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        names = ", ".join(n for (n, _i, _hp, _hd, _s) in created)
        lines = [f"ðŸ¦Œ **{caster_name}** casts **Summon Animals III** ({pretty_mode}).",
                 f"â€¢ Requested: {', '.join(asked)}",
                 f"â€¢ Found: **{choice}**{' (assumed)' if force else ''}",
                 f"â€¢ Summoned: **{count}Ã— {choice}** â†’ {names}",
                 f"â€¢ Duration: **1 day** (**{rounds_total} rounds**).",
                 "â€¢ They are friendly and aid your current task; you may dismiss them at any time."]
        return lines

    async def _spawn_animals(self, ctx, bcfg, chan_id, caster_name, caster_owner_id, kind: str, count: int, rounds_total: int):
        """
        Spawns `count` copies of animal `kind` with duration tag.
        Returns list of tuples (name, ini, hp, hd, slot).
        """

        tpl = (_load_monster_template(kind)
               or _load_monster_template(kind + ".ini")
               or None)
        if not tpl:
            return None, [f"âŒ Missing monster template for **{kind}** (e.g., `{kind}.ini`)."]

        names, scores = _parse_combatants(bcfg, chan_id)
        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)

        ac     = int(tpl.get("ac", 10))
        hd     = int(tpl.get("hd", max(1, int(ANIMAL_HD.get(kind, 1)))))
        hpmod  = int(tpl.get("hpmod", 0))
        move   = int(tpl.get("move", 30))
        saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
        damage = str(tpl.get("damage", "1d6"))
        resist  = str(tpl.get("resist",  "")).strip()
        reduce1 = str(tpl.get("reduce1", "")).strip()
        immune  = str(tpl.get("immune",  "")).strip()
        weak    = str(tpl.get("weak",    "")).strip()


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
        else:
            save_class, save_level = "Fighter", max(1, hd)
        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

        prefix = _prefix_from_kind(kind)
        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        created = []

        for _ in range(max(0, int(count))):
            i = 1
            while f"{prefix}{i}" in existing:
                i += 1
            mon = f"{prefix}{i}"
            existing.add(mon)


            hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
            hp = max(1, hp)

            coe = configparser.ConfigParser()
            coe.optionxform = str
            coe["version"] = {"current": "08082018"}
            coe["info"] = {
                "race": "Monster", "class": "Monster", "sex": "",
                "name": mon, "owner_id": str(caster_owner_id),
                "monster_type": kind, "battle_chan": chan_id,
                "controller": caster_name,
                "summoned": "summonanimals",
            }
            coe["max"] = {"hp": str(hp)}
            coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


            stats = {"ac": str(ac), "ab": "", "move": str(move),
                     "type": str(tpl.get("type", "animal")).strip(),
                     "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak,
                     "special": str(tpl.get("special", "")).strip()}
            attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
            atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
            attack_list = [a for a in re.split(r"[,\s]+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
            if attack_list:
                stats["attacknames"] = " ".join(attack_list)
                first_spec = None
                for an in attack_list:
                    spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                               tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                    if spec:
                        stats[f"atk_{an}"] = spec
                        if first_spec is None: first_spec = spec
                stats["damage"] = first_spec or (damage or "1d6")
            else:
                stats["damage"] = damage or "1d6"
            coe["stats"] = stats
            coe["base"]  = dict(stats)
            coe["saves"] = saves_out
            coe["thief_mods"] = {}
            coe["banned_weapons"] = {"list": ""}
            coe["skills"] = {"list": ""}

            with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                coe.write(f)


            d6 = random.randint(1, 6)
            names, scores = _parse_combatants(bcfg, chan_id)
            if mon not in names:
                names.append(mon)
            scores[mon] = d6
            _write_combatants(bcfg, chan_id, names, scores)


            try:
                s = _slot(mon)
            except Exception:
                s = mon.replace(" ", "_")

            for opt_key, _ in list(bcfg.items(chan_id)):
                if opt_key.startswith(f"{s}."): bcfg.remove_option(chan_id, opt_key)
            if bcfg.has_option(chan_id, mon):
                bcfg.remove_option(chan_id, mon)

            bcfg.set(chan_id, f"{s}.disp", mon)
            bcfg.set(chan_id, f"{s}.hostile", "0")
            bcfg.set(chan_id, f"{s}.minion_by", caster_name)
            bcfg.set(chan_id, f"{s}.minion_type", kind)
            bcfg.set(chan_id, f"{s}.summon_left", str(rounds_total))
            bcfg.set(chan_id, f"{s}.summon_src", "summonanimals")
            bcfg.set(chan_id, f"{s}.expire_cb", "summonanimals")

            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
            bcfg.set(chan_id, "join_seq", str(join_seq))
            bcfg.set(chan_id, f"{s}.join", str(join_seq))

            created.append((mon, d6, hp, hd, s))

        _save_battles(bcfg)
        return created, None

    async def _cast_creepingdoom(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Creeping Doom (300 ft + 30/level)
          â€¢ Summons 1 centipede swarm per **2 caster levels** (max **10** at L20).
          â€¢ Swarms can be placed overlapping creatures; adjacency handled on the map.
          â€¢ Centipede swarms: **8 HD**, **2d6** swarm damage, **move 20 ft**, **cannot fly**.
          â€¢ Duration: **1 minute/level** (60Ã—level rounds).

        Usage:
          !cast creepingdoom
          !cast creepingdoom -n 4   # spawn fewer swarms
          !cast creepingdoom n3
        """


        want = None
        toks = []
        if isinstance(targets, (list, tuple, set)):
            toks = [str(t).strip().lower() for t in targets if str(t).strip()]
        elif isinstance(targets, str) and targets.strip():
            toks = [t.strip().lower() for t in re.split(r"\s+", targets.strip()) if t.strip()]
        for t in list(toks):
            m = re.fullmatch(r"(?:-n|n)(\d+)", t)
            if m:
                want = int(m.group(1)); toks.remove(t)


        L = max(1, int(caster_level or 1))
        base_n = L // 2
        cap = min(10, base_n)
        if cap <= 0:
            return ["âŒ **Creeping Doom**: caster level too low (need 2nd level+)."]

        if want is not None:
            if want <= 0:
                return ["âŒ **Creeping Doom**: number of swarms must be â‰¥1."]
            if want > cap:
                return [f"âŒ **Creeping Doom**: you can summon at most **{cap}** swarms right now."]
            count = want
        else:
            count = cap


        bcfg = _load_battles()
        chan_id = _section_id(ctx.channel) if "_section_id" in globals() else str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!battle` first."]


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)


        tpl = _load_monster_template("centipedeswarm")
        if not tpl:
            return ["âŒ Missing monster template: need `/monsters/centipedeswarm.ini`."]

        rounds_total = 60 * L


        def _spawn_cswarm(n: int):
            names, scores = _parse_combatants(bcfg, chan_id)
            join_seq = bcfg.getint(chan_id, "join_seq", fallback=0)
            created = []

            ac     = int(tpl.get("ac", 10))
            hd     = int(tpl.get("hd", 8))
            hpmod  = int(tpl.get("hpmod", 0))
            move   = int(tpl.get("move", 20))
            saveas = str(tpl.get("saveas", "Fighter 8"))
            immune = str(tpl.get("immune", "")).strip()


            damage_default = str(tpl.get("damage", "2d6"))
            attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
            atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
            attack_list = [a for a in re.split(r"\s+", attacknames_raw) if a] if attacknames_raw else atk_pref_list


            m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
            if m:
                save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
            else:
                save_class, save_level = "Fighter", hd
            saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}

            prefix = "CD"
            existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}

            for _ in range(n):
                i = 1
                while f"{prefix}{i}" in existing:
                    i += 1
                mon = f"{prefix}{i}"
                existing.add(mon)

                hp = sum(random.randint(1, 8) for _r in range(hd)) + hpmod
                hp = max(1, hp)

                coe = configparser.ConfigParser()
                coe.optionxform = str
                coe["version"] = {"current": "08082018"}
                coe["info"] = {
                    "race": "Monster", "class": "Monster", "sex": "",
                    "name": mon, "owner_id": str(caster_owner_id),
                    "monster_type": "centipedeswarm",
                    "battle_chan": chan_id,
                    "controller": caster_name,
                }
                coe["max"] = {"hp": str(hp)}
                coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0",
                              "pp": "0", "ep": "0", "sp": "0", "turn": ""}

                stats = {"ac": str(ac), "ab": "", "move": str(move), "type": "",
                         "immune": immune, "resist": "", "reduce1": ""}


                if attack_list:
                    stats["attacknames"] = " ".join(attack_list)
                    first_spec = None
                    for an in attack_list:
                        spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                                   tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip() or damage_default
                        stats[f"atk_{an}"] = spec
                        if first_spec is None: first_spec = spec
                    stats["damage"] = first_spec or damage_default
                else:
                    stats["damage"] = damage_default

                special = str(tpl.get("special", "") or "").strip()
                if special:
                    stats["special"] = special

                coe["stats"]  = stats
                coe["base"]   = dict(stats)
                coe["saves"]  = saves_out
                coe["thief_mods"] = {}
                coe["banned_weapons"] = {"list": ""}
                coe["skills"] = {"list": ""}

                with open(f"{mon}.coe", "w", encoding="utf-8") as f:
                    coe.write(f)


                d6 = random.randint(1, 6)
                names, scores = _parse_combatants(bcfg, chan_id)
                if mon not in names:
                    names.append(mon)
                scores[mon] = d6
                _write_combatants(bcfg, chan_id, names, scores)

                s = _slot(mon)

                for opt_key, _v in list(bcfg.items(chan_id)):
                    if opt_key.startswith(f"{s}."):
                        bcfg.remove_option(chan_id, opt_key)
                if bcfg.has_option(chan_id, mon):
                    bcfg.remove_option(chan_id, mon)


                join_seq += 1
                bcfg.set(chan_id, "join_seq", str(join_seq))
                bcfg.set(chan_id, f"{s}.join", str(join_seq))
                bcfg.set(chan_id, f"{s}.disp", mon)


                bcfg.set(chan_id, f"{s}.x_swarm",        str(rounds_total))
                bcfg.set(chan_id, f"{s}.x_swarm_code",   "CD")
                bcfg.set(chan_id, f"{s}.x_swarm_label",  "Centipede Swarm")
                bcfg.set(chan_id, f"{s}.x_swarm_emoji",  "ðŸ›")


                bcfg.set(chan_id, f"{s}.swarm_stationary", "0")

                _save_battles(bcfg)
                created.append((mon, d6, hp, rounds_total))

            return created

        made = _spawn_cswarm(count)
        if not made:
            return ["âš ï¸ Nothing was created. (Template or write error?)"]


        try:
            slot_self = _resolve_effect_slot(bcfg, chan_id, caster_name)
            base_key  = "x_creepingdoom"
            label     = "Creeping Doom"
            code      = self._two_letter_code_from_name(label, base_key) or "CD"
            bcfg.set(chan_id, f"{slot_self}.{base_key}",         str(rounds_total))
            bcfg.set(chan_id, f"{slot_self}.{base_key}_label",   label)
            bcfg.set(chan_id, f"{slot_self}.{base_key}_code",    code)
            bcfg.set(chan_id, f"{slot_self}.{base_key}_emoji",   "ðŸ›")
            bcfg.set(chan_id, f"{slot_self}.{base_key}_by",      caster_name)
            _save_battles(bcfg)
        except Exception:
            pass


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        lines = [f"ðŸ› **{caster_name}** casts **Creeping Doom**.",
                 f"â€¢ Summoned: **{len(made)}** Centipede Swarm(s).",
                 f"â€¢ Duration: **{L} minute{'s' if L != 1 else ''}** (**{rounds_total} rounds**).",
                 "â€¢ Swarms may **move (20 ft)**, cannot fly, and **always hit**; GM uses `!aoo` for damage each round.",
                 "â€¢ Adjacency/placement is handled on the map."]
        return lines

    async def _cast_changestaff(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Changestaff (Touch)
          â€¢ Transforms a specially prepared staff into a treant-like creature (uses changestaff.ini).
          â€¢ Obeys the caster; cannot speak with treants or animate trees.
          â€¢ If reduced to 0 HP â†’ disintegrates (staff destroyed). On expiry/dismiss â†’ returns to staff.
          â€¢ Duration: 1 hour/level (360Ã—level rounds).
        Usage:
          !cast changestaff
        """


        bcfg = _load_battles()
        chan_id = str(ctx.channel.id)
        if not bcfg or not bcfg.has_section(chan_id):
            return ["âŒ No initiative running here. Use `!init` first."]


        tpl = (_load_monster_template("changestaff")
               or _load_monster_template("changestaff.ini"))
        if not tpl:
            return ["âŒ Monster template not found for **changestaff** (need `changestaff.ini`)."]


        ac     = int(tpl.get("ac", 10))
        hd     = int(tpl.get("hd", 8))
        hpmod  = int(tpl.get("hpmod", 0))
        damage = str(tpl.get("damage", "2d6"))
        move   = int(tpl.get("move", 60))
        saveas = str(tpl.get("saveas", f"Fighter {max(1, hd)}"))
        resist  = str(tpl.get("resist",  "")).strip()
        reduce1 = str(tpl.get("reduce1", "")).strip()
        immune  = str(tpl.get("immune",  "")).strip()
        weak    = str(tpl.get("weak",    "")).strip()


        m = re.match(r"([A-Za-z\-]+)\s+(\d+)", saveas)
        if m:
            save_class = m.group(1); save_level = max(1, min(20, int(m.group(2))))
        else:
            save_class, save_level = "Fighter", max(1, hd)
        saves_out = {k: str(_class_save_target(save_class, save_level, k))
             for k in ("poi", "wand", "para", "breath", "spell")}


        existing = {fn[:-4] for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        i = 1
        while f"CS{i}" in existing:
            i += 1
        mon = f"CS{i}"


        hp = sum(random.randint(1, 8) for _ in range(hd)) + hpmod
        hp = max(1, hp)


        caster_owner_id = get_compat(cfg, "info", "owner_id", fallback=str(ctx.author.id)) or str(ctx.author.id)
        L = max(1, int(caster_level or 1))
        rounds_total = 360 * L


        coe = configparser.ConfigParser()
        coe.optionxform = str
        coe["version"] = {"current": "08082018"}
        coe["info"] = {
            "race": "Monster", "class": "Monster", "sex": "",
            "name": mon, "owner_id": str(caster_owner_id),
            "monster_type": "changestaff",
            "battle_chan": chan_id,
            "controller": caster_name,
            "summoned": "changestaff",
        }
        coe["max"] = {"hp": str(hp)}
        coe["cur"] = {"hp": str(hp), "level": str(hd), "xp": "0", "gp": "0", "pp": "0", "ep": "0", "sp": "0", "turn": ""}


        stats = {"ac": str(ac), "ab": "", "move": str(move),
                 "type": str(tpl.get("type", "")).strip(),
                 "resist": resist, "reduce1": reduce1, "immune": immune, "weak": weak}
        attacknames_raw = str(tpl.get("attacknames", "")).strip().lower()
        atk_pref_list = sorted(k[4:] for k in tpl.keys() if k.lower().startswith("atk_"))
        attack_list = [a for a in re.split(r"[,\s]+", attacknames_raw) if a] if attacknames_raw else atk_pref_list
        if attack_list:
            stats["attacknames"] = " ".join(attack_list)
            first_spec = None
            for an in attack_list:
                spec = (str(tpl.get(f"atk_{an}") or tpl.get(an) or
                            tpl.get(f"dmg_{an}") or tpl.get(f"{an}_dmg") or "")).strip()
                if spec:
                    stats[f"atk_{an}"] = spec
                    if first_spec is None: first_spec = spec
            stats["damage"] = first_spec or damage or "1d6"
        else:
            stats["damage"] = damage or "1d6"
        coe["stats"] = stats
        coe["base"]  = dict(stats)
        coe["saves"] = saves_out
        coe["thief_mods"] = {}
        coe["banned_weapons"] = {"list": ""}
        coe["skills"] = {"list": ""}

        with open(f"{mon}.coe", "w", encoding="utf-8") as f:
            coe.write(f)


        names, scores = _parse_combatants(bcfg, chan_id)
        d6 = random.randint(1, 6)
        if mon not in names:
            names.append(mon)
        scores[mon] = d6
        _write_combatants(bcfg, chan_id, names, scores)


        try:
            s_el = _slot(mon)
        except Exception:
            s_el = mon.replace(" ", "_")


        for opt_key, _v in list(bcfg.items(chan_id)):
            if opt_key.startswith(f"{s_el}."):
                bcfg.remove_option(chan_id, opt_key)
        if bcfg.has_option(chan_id, mon):
            bcfg.remove_option(chan_id, mon)

        bcfg.set(chan_id, f"{s_el}.disp", mon)
        bcfg.set(chan_id, f"{s_el}.hostile", "0")
        bcfg.set(chan_id, f"{s_el}.minion_by", caster_name)
        bcfg.set(chan_id, f"{s_el}.minion_type", "changestaff")


        bcfg.set(chan_id, f"{s_el}.summon_left", str(rounds_total))
        bcfg.set(chan_id, f"{s_el}.summon_src", "changestaff")
        bcfg.set(chan_id, f"{s_el}.expire_cb", "changestaff")


        bcfg.set(chan_id, f"{s_el}.changestaff_note", "treant-like; no treant speech/animate trees; disintegrates at 0 HP")


        join_seq = bcfg.getint(chan_id, "join_seq", fallback=0) + 1
        bcfg.set(chan_id, "join_seq", str(join_seq))
        bcfg.set(chan_id, f"{s_el}.join", str(join_seq))


        try:
            slot_self = _resolve_effect_slot(bcfg, chan_id, caster_name)
            base_key  = "x_changestaff"
            code      = self._two_letter_code_from_name("Change Staff", "changestaff") or "CS"
            bcfg.set(chan_id, f"{slot_self}.{base_key}",         str(rounds_total))
            bcfg.set(chan_id, f"{slot_self}.{base_key}_label",   "Change Staff")
            bcfg.set(chan_id, f"{slot_self}.{base_key}_code",    code)
            bcfg.set(chan_id, f"{slot_self}.{base_key}_emoji",   "ðŸŒ³")
            bcfg.set(chan_id, f"{slot_self}.{base_key}_by",      caster_name)
        except Exception:
            pass

        _save_battles(bcfg)


        try:
            ini = self.bot.get_cog("Initiative") or self.bot.get_cog("InitiativeCog")
            if ini and hasattr(ini, "_update_tracker_message"):
                await ini._update_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return [
            f"ðŸŒ³ **{caster_name}** casts **Changestaff**!",
            f"â€¢ **{mon}** (treant-like) joins initiative (1d6 â†’ **{d6}**).",
            f"â€¢ Duration: **{L} hour{'s' if L != 1 else ''}** (**{rounds_total} rounds**).",
            "â€¢ Obeys your commands; cannot speak with treants or animate trees.",
            "â€¢ At **0 HP** it **disintegrates** (staff destroyed). On expiry/dismissal, it **reverts** to the staff."
        ]



        
        
            

    def _emoji_for_itemname(self, nm: str) -> str:
        s = (nm or "").lower()
        if "horn" in s: return "ðŸ“¯"
        if "drum" in s: return "ðŸ¥"
        if "bell" in s: return "ðŸ””"
        if "ring" in s: return "ðŸ’"
        if "pendant" in s: return "ðŸ“¿"
        if "cloak" in s: return "ðŸ§¥"
        if "belt" in s: return "ðŸ§·"
        if "boots" in s: return "ðŸ‘¢"
        if "lens" in s: return "ðŸ”Ž"
        if "mirror" in s: return "ðŸªž"
        return "âœ¨"

    def _item_source_line(self, owned_item: str, suffix: str = "") -> str:
        nm = self._strip_instance_tag(owned_item) if hasattr(self, "_strip_instance_tag") else (owned_item or "")
        return f"{self._emoji_for_itemname(nm)} {nm}{(' ' + suffix) if suffix else ''}"


    async def _item_blasting(self, ctx, caster_cfg, caster_name: str, caster_level: int,
                             tokens: list[str], owned_item: str | None = None):
        """
        Bell/Drums/Horn of Blasting (10' cone).
          â€¢ 2d6 damage; save vs Death (poi) for half
          â€¢ Deafened 1 turn on fail (1 round on save)
          â€¢ 'structure' token doubles damage and skips save
        """
        if not tokens:
            return "Usage: `!item blasting <targets...>`"

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        chan_id = str(ctx.channel.id)

        effect_lines: list[str] = []
        for raw in tokens:
            is_structure = (str(raw).lower() in {"structure","wall","gate","door","fort","fortification"})
            
            try:
                disp, path = self._resolve_char_ci(raw)
            except Exception:
                disp, path = raw, None
                base = f"{str(raw).replace(' ','_')}.coe"
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        path = fn
                        break
            if not path and not is_structure:
                effect_lines.append(f"â€¢ {raw}: *(not found)*"); continue

            
            dice_spec = "2d6"
            total, rolls, flat = roll_dice(dice_spec)
            dmg = max(0, total + flat)
            if is_structure:
                applied = dmg * 2
                save_line = "(structure: no save)"
            else:
                t_cfg = read_cfg(path)
                try:
                    ok, r, dc, _ = self._roll_save(t_cfg, vs="poi", penalty=0) 
                except Exception:
                    ok, r, dc = False, 10, 15
                applied = dmg // 2 if ok else dmg
                save_line = f"Save vs Death: {r} vs {dc} â†’ **{'RESIST' if ok else 'FAIL'}** â†’ **{applied}**"


            if not is_structure and path:
                t_cfg = read_cfg(path)
                old_hp = getint_compat(t_cfg, "cur", "hp", fallback=0)
                new_hp = max(0, old_hp - applied)
                if not t_cfg.has_section("cur"): t_cfg.add_section("cur")
                t_cfg["cur"]["hp"] = str(new_hp); write_cfg(path, t_cfg)

 
                if _is_monster_file(path):
                    mhp = getint_compat(t_cfg, "max", "hp", fallback=max(1, old_hp))
                    before = _life_bar(old_hp, mhp, width=10)
                    after  = _life_bar(new_hp, mhp, width=10)
                    hp_txt = f"{before} â†’ {after}" + (" â˜ ï¸ **DEAD!**" if new_hp <= 0 else "")
                else:
                    hp_txt = f"{old_hp} â†’ **{new_hp}**" + (" â˜ ï¸ **DEAD!**" if new_hp <= 0 else "")
            else:
                hp_txt = f"**{applied}** structural damage (GM adjudicates)."

            if new_hp <= 0 and _is_monster_file(path) and bcfg:
                try:
                    names, scores = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, disp) or disp
                    if key in names:
                        names = [n for n in names if n != key]
                        if bcfg.has_option(chan_id, key):
                            bcfg.remove_option(chan_id, key)
                        s_dead = _slot(key) if '_slot' in globals() else key.replace(" ", "_")
                        for suf in (".dex", ".join", ".disp", ".oil", ".acpen", ".holds", ".heldby"):
                            opt = f"{s_dead}{suf}"
                            if bcfg.has_option(chan_id, opt):
                                bcfg.remove_option(chan_id, opt)
                        _write_combatants(bcfg, chan_id, names, scores)
                        if bcfg.get(chan_id, "turn", fallback="") == key:
                            ents = _sorted_entries(bcfg, chan_id)
                            bcfg.set(chan_id, "turn", ents[0]["name"] if ents else "")
                        _save_battles(bcfg)
                    try:
                        os.remove(os.path.abspath(path))  
                    except Exception:
                        pass
                except Exception:
                    pass

            try:
                if bcfg and not is_structure and path:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, disp) or disp
                    try: s_tgt = _slot(key)
                    except Exception: s_tgt = key.replace(" ", "_")
                    rounds = 1 if ("Save vs Death" in save_line and "RESIST" in save_line) else 60
                    base = "x_deaf"; label = "Deafened"
                    code = self._two_letter_code_from_name(label, base) or "DF"
                    bcfg.set(chan_id, f"{s_tgt}.{base}",       str(rounds))
                    bcfg.set(chan_id, f"{s_tgt}.{base}_label", label)
                    bcfg.set(chan_id, f"{s_tgt}.{base}_code",  "DEAF")
                    bcfg.set(chan_id, f"{s_tgt}.{base}_emoji", "ðŸ”‡")
                    bcfg.set(chan_id, f"{s_tgt}.{base}_by",    caster_name)
                    _save_battles(bcfg)
            except Exception:
                pass

            rolls_txt = ", ".join(str(r) for r in rolls)
            who = (disp if not is_structure else raw)
            effect_lines.append(
                f"â€¢ **{who}** â€” {dice_spec} [{rolls_txt}] = {dmg}"
                + ("" if is_structure else f" â€¢ {save_line}")
                + (f" â€¢ {hp_txt}")
            )

        try:
            if bcfg and bcfg.has_section(chan_id):
                await self._refresh_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        title = f"{caster_name} plays **{(owned_item or 'Instrument of Blasting')}** â€” Blasting!"
        source = self._item_source_line(owned_item or "InstrumentofBlasting", "â€” âˆž uses")
        header = "No single roll (each target rolls separately)."
        embed = _build_item_embed(  
            title,
            header_line=header,
            effect_lines=effect_lines,
            source=source,
            charges_text=None,
            color=0xE25822  
        )  
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed

    async def _item_panic(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        """Bell/Drums/Horn of Panic â†’ Cause Fear (targets provided manually)."""
        if not tokens:
            return "Usage: `!item panic <targets...>`"
        
        out = await self._cast_cause_fear(ctx, caster_cfg, caster_name, caster_level, list(tokens))
        header, body = _normalize_effect_output(out)  
        title  = f"{caster_name} plays **{owned_item or 'Instrument of Panic'}** â€” Cause Fear!"
        source = self._item_source_line(owned_item or "InstrumentofPanic", "â€” âˆž uses")
        embed = _build_item_embed(title, header_line=header or "No roll.", effect_lines=body,
                                  source=source, charges_text=None, color=0x5865F2)
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed

    async def _item_courage(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        """Bell/Drums/Horn of Courage â†’ Remove Fear on listed friendlies (defaults to self)."""
        targets = list(tokens) if tokens else [caster_name]
        handler = getattr(self, "_effect_removefear", None) or getattr(self, "_cast_remove_fear", None)
        if not handler:
            return "All listed allies are bolstered; any tracked fear tags should be cleared by GM."
        out = await handler(ctx, caster_cfg, caster_name, caster_level, targets)
        header, body = _normalize_effect_output(out)
        title  = f"{caster_name} plays **{owned_item or 'Instrument of Courage'}** â€” Remove Fear!"
        source = self._item_source_line(owned_item or "InstrumentofCourage", "â€” âˆž uses")
        embed = _build_item_embed(title, header_line=header or "No roll.", effect_lines=body,
                                  source=source, charges_text=None, color=0x43B581)
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed

    async def _item_invisibility(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        target = tokens[0] if tokens else caster_name
        h = getattr(self, "_cast_invisibility", None) or getattr(self, "_effect_invisibility", None)
        if not h: return "Invisibility handler not found."
        out = await h(ctx, caster_cfg, caster_name, caster_level, [target])
        header, body = _normalize_effect_output(out)
        title  = f"{caster_name} uses **{owned_item or 'Invisibility Item'}** â€” Invisibility!"
        source = self._item_source_line(owned_item or "RingofInvisibility", "â€” âˆž uses")
        embed = _build_item_embed(title, header_line=header or "No roll.", effect_lines=body,
                                  source=source, charges_text=None, color=0x95A5A6)
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed

    async def _item_levitation(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        rounds = max(1, int(caster_level)) * 60

        primed = self._start_item_timer_on_caster(
            ctx,
            caster_name,
            label="Levitation",
            alias_key="levitation",
            rounds=rounds,
            emoji="ðŸª¶",
        )
        try:
            await self._refresh_tracker_message(ctx)
        except Exception:
            pass

        title  = f"{caster_name} uses **{owned_item or 'Levitation Item'}** â€” Levitation!"
        source = self._item_source_line(owned_item or "RingofLevitation", "â€” âˆž uses")
        effect_lines = [
            f"Target: **{caster_name}**",
            f"Duration: **{rounds} rounds** (level {max(1, int(caster_level))} Ã— 60)",
            primed,
        ]
        embed = _build_item_embed(
            title,
            header_line="No roll.",
            effect_lines=effect_lines,
            source=source,
            charges_text=None,
            color=0x3498DB,
        )
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed


    async def _item_speed(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        char_name = get_active(ctx.author.id)
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        used = _get_idaily(cfg, "speed_rounds_used", 0)
        cap  = 10
        remaining = max(0, cap - used)
        want = next((int(t) for t in tokens if str(t).isdigit()), None)
        spend = remaining if want is None else max(0, min(want, remaining))
        if spend <= 0:
            return f"âš ï¸ **Speed**: daily pool exhausted (**{used}/{cap}** rounds used). Use `!lr` to refresh."
        primed = self._start_item_timer_on_caster(ctx, caster_name, label="Haste",
                                                  alias_key="haste", rounds=spend, emoji="â±ï¸")
        _set_idaily(cfg, "speed_rounds_used", used + spend); write_cfg(path, cfg)
        try: await self._refresh_tracker_message(ctx)
        except Exception: pass

        title  = f"{caster_name} uses **{owned_item or 'Speed Item'}** â€” Haste!"
        source = self._item_source_line(owned_item or "BootsofSpeed")
        charges = f"**{used} â†’ {used+spend}/{cap}** rounds today."
        embed = _build_item_embed(title, header_line="No roll.",
                                  effect_lines=[f"Spent **{spend}** round(s).", primed],
                                  source=source, charges_text=charges, color=0xF1C40F)
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed

    async def _item_trueseeing(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        char_name = get_active(ctx.author.id)
        path = f"{char_name.replace(' ', '_')}.coe"
        if not os.path.exists(path):
            await ctx.send(f"âŒ Character file not found for **{char_name}**.")
            return

        cfg = read_cfg(path)
        used = _get_idaily(cfg, "trueseeing_uses", 0)
        cap  = 3
        if used >= cap:
            return f"âš ï¸ **True Seeing**: daily uses exhausted (**{used}/{cap}**). Use `!lr` to refresh."
        rounds = 60
        primed = self._start_item_timer_on_caster(ctx, caster_name, label="True Seeing",
                                                  alias_key="trueseeing", rounds=rounds, emoji="ðŸ‘ï¸")
        _set_idaily(cfg, "trueseeing_uses", used + 1); write_cfg(path, cfg)
        try: await self._refresh_tracker_message(ctx)
        except Exception: pass
        title  = f"{caster_name} uses **{owned_item or 'True Seeing Item'}** â€” True Seeing!"
        source = self._item_source_line(owned_item or "RingofTrueSeeing")
        charges = f"**{used} â†’ {used+1}/{cap}** uses today."
        embed = _build_item_embed(title, header_line="No roll.",
                                  effect_lines=[f"**{rounds}** rounds.", primed],
                                  source=source, charges_text=charges, color=0x9B59B6)
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed
        
        
        


    def _owns_named_item(self, cfg, canon_names: set[str]):
        """
        Return (display_token, meta) for the first owned item whose *base* name
        (before any @instance) matches one of canon_names, case-insensitively.
        """
        want = {n.lower() for n in canon_names}

        
        for tok in self._storage_tokens(cfg):
            base = tok.split("@", 1)[0].lower()
            if base in want:
                _, meta = self._item_lookup(base)
                return tok, (meta or {})

        if cfg.has_section("item"):
            for k, v in cfg.items("item"):
                if k == "storage":
                    continue
                try:
                    if int(str(v).strip() or "0") <= 0:
                        continue
                except Exception:
                    pass
                base = k.split("@", 1)[0].lower()
                if base in want:
                    _, meta = self._item_lookup(base)
                    return k, (meta or {})

        return None, None




    async def _item_controlhuman(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        """Ring/Pendant of Control Human â†’ cast Charm Person at-will."""
        if not tokens:
            return "Usage: `!item controlhuman <target1> [target2 ...]`"
        h = getattr(self, "_cast_charmperson", None) or getattr(self, "_effect_charmperson", None)
        if not h:
            return "Charm Person handler not found."

        effect_lines = []
        for t in tokens:
            res = h(ctx, caster_cfg, caster_name, caster_level, [t])
            if inspect.iscoroutine(res):
                res = await res
            header, body = _normalize_effect_output(res)
            if header:
                effect_lines.append(header)
            if isinstance(body, list):
                effect_lines.extend(body)
            elif body:
                effect_lines.append(str(body))

        title  = f"{caster_name} uses **{owned_item or 'Control Human Item'}** â€” Charm Person!"
        source = self._item_source_line(owned_item or "RingofControlHuman", "â€” âˆž uses")
        embed  = _build_item_embed(
            title,
            header_line="Targets save vs **Spells** (handled below).",
            effect_lines=effect_lines,
            source=source,
            charges_text=None,
            color=0xC27C0E,
        )
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed


    async def _item_controlanimal(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        """Ring/Pendant of Control Animal â†’ charm animals at-will (uses your animal-charm logic)."""
        if not tokens:
            return "Usage: `!item controlanimal <target1> [target2 ...]`"
        h = getattr(self, "_cast_charmanimal", None) or getattr(self, "_effect_charmanimal", None)
        if not h:
            return "Control Animal handler not found."

        effect_lines = []
        for t in tokens:
            res = h(ctx, caster_cfg, caster_name, caster_level, [t])
            if inspect.iscoroutine(res):
                res = await res
            header, body = _normalize_effect_output(res)
            if header:
                effect_lines.append(header)
            if isinstance(body, list):
                effect_lines.extend(body)
            elif body:
                effect_lines.append(str(body))

        title  = f"{caster_name} uses **{owned_item or 'Control Animal Item'}** â€” Charm Animal!"
        source = self._item_source_line(owned_item or "RingofControlAnimal", "â€” âˆž uses")
        embed  = _build_item_embed(
            title,
            header_line="Targets save per your charm-animal rules.",
            effect_lines=effect_lines,
            source=source,
            charges_text=None,
            color=0x1ABC9C,
        )
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed


    async def _item_controlplant(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        """Ring/Pendant of Control Plant â†’ as Potion of Plant Control, at-will."""
        if not tokens:
            return "Usage: `!item controlplant <target1> [target2 ...]`"
        h = getattr(self, "_cast_plantcontrol", None) or getattr(self, "_effect_plantcontrol", None)
        if not h:
            return "Control Plant handler not found."

        effect_lines = []
        for t in tokens:
            res = h(ctx, caster_cfg, caster_name, caster_level, [t])
            if inspect.iscoroutine(res):
                res = await res
            header, body = _normalize_effect_output(res)
            if header:
                effect_lines.append(header)
            if isinstance(body, list):
                effect_lines.extend(body)
            elif body:
                effect_lines.append(str(body))

        title  = f"{caster_name} uses **{owned_item or 'Control Plant Item'}** â€” Plant Control!"
        source = self._item_source_line(owned_item or "RingofControlPlant", "â€” âˆž uses")
        embed  = _build_item_embed(
            title,
            header_line="Targets save as per Plant Control; effect persists while within 60â€² of wearer.",
            effect_lines=effect_lines,
            source=source,
            charges_text=None,
            color=0x2ECC71,
        )
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed



    @commands.command(name="item")
    async def item(self, ctx, key: str = None, *args):
        """
        Use a magic item that duplicates a spell or creates an AoE.
        Examples:
          !item panic go1 go2 go3
          !item blasting or1 or2 bu1 bu2
          !item speed            # uses your remaining rounds today
          !item speed 3          # spend 3 rounds from today's pool
          !item trueseeing
          !item invisibility
          !item levitation

        The bot verifies you own at least one appropriate item ("of <X>") in your bag.
        """    

        if not key:
            await ctx.send("Usage: `!item <blasting|panic|courage|doom|invisibility|levitation|speed|trueseeing|controlanimal|controlhuman|controlplant|telekinesis> [targets...]`")
            return

        key = re.sub(r"[^a-z]", "", key.lower())
        spec = _ITEM_KEYWORDS.get(key)
        if not spec:
            await ctx.send(f"âŒ Unknown item power '{key}'."); return

        caster_name, path, cfg, err = self._resolve_active_caster(ctx)
        if err:
            await ctx.send(err); return
        cfg = read_cfg(path)

        names = {n for n in spec["names"]}
        owned_name, _meta = self._owns_named_item(cfg, names)  
        
        if not owned_name:
            pretty_list = ", ".join(spec["names"])
            await ctx.send(f"âŒ You don't appear to own any of: {pretty_list}.")
            return

        handler_name = spec["handler"]
        handler = getattr(self, handler_name, None)
        if not handler:
            await ctx.send(f"âš ï¸ Handler '{handler_name}' not implemented."); return

        sc_item_pen = 1 if _is_spellcrafter(cfg) else 0
        if sc_item_pen:
            self._item_save_penalty = sc_item_pen
        try:
            out = await handler(
                ctx, cfg, caster_name,
                self._hd_or_level_from_cfg(cfg),
                list(args),
                owned_item=owned_name
            )
        finally:
            if hasattr(self, "_item_save_penalty"):
                delattr(self, "_item_save_penalty")


        if isinstance(out, nextcord.Embed):
            await ctx.send(embed=out)
        elif isinstance(out, (list, tuple)) and out and isinstance(out[0], nextcord.Embed):
            for em in out:
                await ctx.send(embed=em)
        elif isinstance(out, (list, tuple)):
            await ctx.send("\n".join(str(x) for x in out))
        else:
            await ctx.send(str(out))


    async def _effect_plantcontrol(self, ctx, cfg, caster_name: str, caster_level: int, targets, *_extra, **_kw):
        """
        Control Plant(s)
          â€¢ For *plant creatures*: Save vs Spells negates; on fail the target is Controlled (as charm-monster-like).
          â€¢ For *normal plants* (thickets, trees, etc.): animate; MV 10', obey commands; if ordered to attack,
            largest plants strike at +0 for 1d4 damage (GM adjudicates tokens/placement).
          â€¢ Pendant/Ring at-will version persists while within 60' (we model as a long timer).
          â€¢ Potion/staff callers may override duration via kwarg: rounds=<int>.
        Returns: list[str] for `_normalize_effect_output(...)`.
        """
        chan_id = str(ctx.channel.id)

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        
        if isinstance(targets, str):
            names_in = [targets] if targets.strip() else []
        else:
            names_in = [t for t in (targets or []) if isinstance(t, str) and t.strip()]
        if not names_in:
            return ["Usage: `!cast plantcontrol <target1> [target2 ...]`"]

        rounds = int(_kw.get("rounds", 600_000))

        lines = [f"ðŸ§¿ **{caster_name}** exerts **Control Plant(s)**:"]
        wrote_any_tag = False

        for raw in names_in:
            try:
                tgt_disp, tgt_path = self._resolve_char_ci(raw)
            except Exception:
                tgt_disp, tgt_path = str(raw), None
                base = f"{str(raw).replace(' ', '_')}.coe"
                for fn in os.listdir("."):
                    if fn.lower() == base.lower():
                        tgt_path = fn
                        break

            pretty = tgt_disp or raw

            if not tgt_path or not os.path.exists(tgt_path):
                lines.append(
                    f"â€¢ **{pretty}** â€” normal **plants animate** (MV 10'); obey commands. "
                    "If attacking: +0 to hit, **1d4** damage (GM places tokens)."
                )
                continue

            t_cfg = read_cfg(tgt_path)
            if not _is_plant_cfg(t_cfg, pretty):
                lines.append(f"â€¢ **{pretty}** â€” not a **plant creature** â†’ no effect.")
                continue

            try:
                sv_ok, sv_roll, sv_dc, _ = self._roll_save(t_cfg, vs="spell", penalty=0)
            except Exception:
                sv_ok, sv_roll, sv_dc = False, 10, 15

            if sv_ok:
                lines.append(f"â€¢ **{pretty}** â€” Save vs Spells: {sv_roll} â‰¥ **{sv_dc}** â†’ **RESISTS**")
                continue

            applied = False
            if bcfg and bcfg.has_section(chan_id):
                try:
                    names, _ = _parse_combatants(bcfg, chan_id)
                    key = _find_ci_name(names, pretty) or pretty
                    try:
                        s_tgt = _slot(key)
                    except Exception:
                        s_tgt = key.replace(" ", "_")

                    bcfg.set(chan_id, f"{s_tgt}.x_controlplant", str(rounds))
                    bcfg.set(chan_id, f"{s_tgt}.x_controlplant_label", "Controlled (Plant)")
                    bcfg.set(chan_id, f"{s_tgt}.x_controlplant_code", "CP")
                    bcfg.set(chan_id, f"{s_tgt}.x_controlplant_emoji", "ðŸ§¿")
                    bcfg.set(chan_id, f"{s_tgt}.x_controlplant_by", caster_name)
                    _save_battles(bcfg)
                    applied = True
                    wrote_any_tag = True
                except Exception:
                    applied = False

            lines.append(
                f"â€¢ **{pretty}** â€” Save vs Spells: {sv_roll} < **{sv_dc}** â†’ **CONTROLLED (Plant)**"
                + ("" if not applied else " ã€”tracker set: **CP**ã€•")
            )

        if wrote_any_tag:
            try:
                await self._update_tracker_message(ctx, bcfg, chan_id)
            except Exception:
                pass

        if _kw.get("note_item_range", True):
            lines.append("_Effect persists while the wearer remains within **60â€²** of the plants (GM adjudicates)._")

        return lines


    async def _cast_plantcontrol(self, ctx, cfg, caster_name, caster_level, targets, *_e, **_k):
        return await self._effect_plantcontrol(ctx, cfg, caster_name, caster_level, targets, **_k)

    async def _cast_controlplants(self, ctx, cfg, caster_name, caster_level, targets, *_e, **_k):
        return await self._effect_plantcontrol(ctx, cfg, caster_name, caster_level, targets, **_k)

    async def _cast_control_plant(self, ctx, cfg, caster_name, caster_level, targets, *_e, **_k):
        return await self._effect_plantcontrol(ctx, cfg, caster_name, caster_level, targets, **_k)



    async def _item_doom(self, ctx, caster_cfg, caster_name: str, caster_level: int,
                          tokens: list[str], owned_item: str | None = None):
        """
        Bell/Drums/Horn of Doom â€” Animate Dead (item version)
          â€¢ Up to 3d6 HD of undead animate within 60â€².
          â€¢ You must choose the mix: `skN` for skeletons (1 HD each), `zoN` for zombies (2 HD each).
            Examples: `sk6`, `zo4`, `sk4 zo2`.
          â€¢ Item can be used once per long rest; a given item may have at most 18 HD of undead
            it created existing at one time.
          â€¢ If the user is a spellcaster, the undead are controlled while they retain the device.
            Otherwise they are uncontrolled (hostile to nearby living creatures).
        """

        def _doom_owner_id_from_cfg_or_ctx(cfg, ctx) -> str:
            """Prefer sheet owner_id; fall back to the invoking user id; else 'unknown'."""
            oid = (get_compat(cfg, "info", "owner_id", fallback="") or "").strip()
            if not oid:
                try:
                    oid = str(ctx.author.id)
                except Exception:
                    oid = ""
            return oid or "unknown"

        def _doom_family_key(cfg, ctx) -> str:
            """Unify to a single family tag for all Bell/Drums/Horn of Doom items."""
            return f"doom|{_doom_owner_id_from_cfg_or_ctx(cfg, ctx)}"

        def _doom_variants() -> set[str]:
            """Legacy tag left-sides that weâ€™ll accept & normalize."""
            return {"doom", "instrumentofdoom", "hornofdoom", "drumsofdoom", "bellofdoom"}

        def _retag_legacy_doom_tags(owner_id: str) -> None:
            """Normalize any existing legacy tags for this owner to 'doom|<owner_id>'."""
            want_tag = f"doom|{owner_id}"
            try:
                for fn in os.listdir("."):
                    if not fn.lower().endswith(".coe"):
                        continue
                    try:
                        c = read_cfg(fn)
                    except Exception:
                        continue
                    tag = get_compat(c, "info", "doom_source", fallback="")
                    if not tag or "|" not in tag:
                        continue
                    left, right = tag.split("|", 1)
                    if right == owner_id and left.lower() in _doom_variants() and left.lower() != "doom":
                        if not c.has_section("info"):
                            c.add_section("info")
                        c.set("info", "doom_source", want_tag)
                        write_cfg(fn, c)
            except Exception:
                pass

        def _count_existing_doom_hd_for_owner(owner_id: str) -> int:
            """Count HD of all undead tagged to this owner under any accepted variant; normalize HD."""
            total = 0
            variants = _doom_variants()
            for fn in os.listdir("."):
                if not fn.lower().endswith(".coe"):
                    continue
                try:
                    c = read_cfg(fn)
                except Exception:
                    continue
                tag = get_compat(c, "info", "doom_source", fallback="")
                if not tag or "|" not in tag:
                    continue
                left, right = tag.split("|", 1)
                if right != owner_id:
                    continue
                if left.lower() not in variants:
                    continue
                
                hd = getint_compat(c, "stats", "hd", fallback=0)
                if hd <= 0:
                    up = fn.upper()
                    if up.startswith("SK"):
                        hd = 1
                    elif up.startswith("ZO"):
                        hd = 2
                    else:
                        hd = 1
                total += max(0, int(hd))
            return total

        def _base_item(nm: str) -> str:
            try:
                if hasattr(self, "_strip_instance_tag"):
                    nm = self._strip_instance_tag(nm)
            except Exception:
                pass
            return re.sub(r"[^a-z0-9]+", "", str(nm or "").lower())

        def _doom_source_key(_cfg, nm: str) -> str:
            owner_id = get_compat(_cfg, "info", "owner_id", fallback="") or ""
            return f"{_base_item(nm)}|{owner_id or 'unknown'}"

        def _count_existing_doom_hd(source_key: str) -> int:
            total = 0
            for fn in os.listdir("."):
                if not fn.lower().endswith(".coe"):
                    continue
                try:
                    c = read_cfg(fn)
                except Exception:
                    continue
                tag = get_compat(c, "info", "doom_source", fallback="")
                if tag != source_key:
                    continue
                hd = getint_compat(c, "stats", "hd", fallback=0)
                if hd <= 0:
                    up = fn.upper()
                    if up.startswith("SK"):   hd = 1
                    elif up.startswith("ZO"): hd = 2
                    else:                     hd = 1
                total += max(0, int(hd))
            return total

       
        def _parse_mix(ts: list[str]) -> tuple[int, int]:
            sk = zo = 0
            toks = list(ts or [])
            i = 0
            while i < len(toks):
                t = str(toks[i]).lower()
                m = re.match(r"^(sk|skeletons?|zo|zombie?s?)(\d+)$", t)
                if m:
                    typ, n = m.group(1), int(m.group(2))
                    if typ.startswith("sk"):
                        sk += n
                    else:
                        zo += n
                    i += 1; continue
                if t in {"sk","skeleton","skeletons"} and i+1 < len(toks) and str(toks[i+1]).isdigit():
                    sk += int(toks[i+1]); i += 2; continue
                if t in {"zo","zombie","zombies"} and i+1 < len(toks) and str(toks[i+1]).isdigit():
                    zo += int(toks[i+1]); i += 2; continue
                i += 1
            return max(0, sk), max(0, zo)

        sk_req, zo_req = _parse_mix(tokens)
        if sk_req <= 0 and zo_req <= 0:
            return ("Usage: `!item doom sk<N> [zo<M>]` â€” e.g., `!item doom sk6`, `!item doom sk4 zo2`\n"
                    "Skeletons are **1 HD** each; zombies **2 HD** each (skeletons preferred).")

        
        daily_key  = f"doom_used"  
        used_today = _get_idaily(caster_cfg, daily_key, 0)
        if used_today:
            title = f"{caster_name} plays **{owned_item or 'Doom Item'}** â€” no effect."
            embed = nextcord.Embed(title=title, color=0xAAAAAA)
            embed.add_field(name="Limits", value="This item can be used **once per long rest**.", inline=False)
            embed.add_field(name="Status", value="Already used today.", inline=True)
            await self._attach_char_identity(embed, caster_cfg, ctx)
            return embed

        
        owner_id = _doom_owner_id_from_cfg_or_ctx(caster_cfg, ctx)
        _retag_legacy_doom_tags(owner_id)  
        existing_hd   = _count_existing_doom_hd_for_owner(owner_id)
        remaining_cap = max(0, 18 - existing_hd)
        if remaining_cap <= 0:
            title = f"{caster_name} plays **{owned_item or 'Doom Item'}** â€” no effect."
            embed = nextcord.Embed(title=title, color=0xAAAAAA)
            embed.add_field(name="Limits", value="**18 HD** created by this item already **exist**. "
                                                 "Dismiss/destroy some before using it again.", inline=False)
            embed.add_field(name="Status", value=f"Current created total: **{existing_hd}/18 HD**.", inline=True)
            await self._attach_char_identity(embed, caster_cfg, ctx)
            return embed

        
        d = [random.randint(1, 6) for _ in range(3)]
        cap_roll = sum(d)
        budget   = min(cap_roll, remaining_cap)

        sk_make = min(sk_req, budget); budget -= sk_make
        zo_make = min(zo_req, budget // 2)
        spent_hd = sk_make + zo_make * 2

        title  = f"{caster_name} plays **{owned_item or 'Doom Item'}** â€” Animate Dead!"
        source = self._item_source_line(owned_item or "InstrumentofDoom", "â€” 1/day")

        if spent_hd <= 0:
            embed = nextcord.Embed(title=title, color=0xD35400)
            embed.add_field(name="Roll", value=f"**3d6** [{', '.join(map(str, d))}] = **{cap_roll} HD** â€¢ Item cap remaining: **{remaining_cap}**", inline=False)
            embed.add_field(name="Result", value="No bodies animate.", inline=False)
            embed.add_field(name="How to use", value="Specify a mix: `sk<N>` skeletons, `zo<M>` zombies.\n"
                                                     "Skeletons use **1 HD** each; zombies **2 HD** each.", inline=False)
            await self._attach_char_identity(embed, caster_cfg, ctx)
            return embed

        
        pre = {fn for fn in os.listdir(".") if fn.lower().endswith(".coe")}

        cast_toks = []
        if sk_make: cast_toks.append(f"sk{sk_make}")
        if zo_make: cast_toks.append(f"zo{zo_make}")

        out = await self._cast_animatedead(ctx, caster_cfg, caster_name, max(caster_level, 99), cast_toks)

        post = {fn for fn in os.listdir(".") if fn.lower().endswith(".coe")}
        new_files = sorted(list(post - pre))

        src_key = f"doom|{owner_id}"

        info_class = get_compat(caster_cfg, "info", "class", fallback="")
        is_caster  = bool(self._caster_profile(info_class, ctx.channel))
        for fn in new_files:
            try:
                c = read_cfg(fn)
                if not c.has_section("info"): c.add_section("info")
                c.set("info", "doom_source", src_key)
                if not is_caster and c.has_option("info", "controller"):
                    c.remove_option("info", "controller")
                write_cfg(fn, c)
            except Exception:
                pass

        
        post_cap = _count_existing_doom_hd_for_owner(owner_id)

        
        try:
            header, body = _normalize_effect_output(out)
        except Exception:
            header, body = None, out if isinstance(out, (list, tuple)) else [str(out)]
        effect_lines = [s for s in (body or []) if str(s).strip()]
        effect_lines = [ln for ln in effect_lines if not str(ln).strip().lower().startswith("control:")]

        summary = f"Creates: **{sk_make}** skeleton(s), **{zo_make}** zombie(s) â†’ **{spent_hd} HD**"
        ctrl_txt = "Controlled while the device is held (spellcaster)." if is_caster else "**UNCONTROLLED** (non-spellcaster)."

        
        embed = _build_item_embed(
            title,
            header_line=f"Roll: **3d6** [{', '.join(map(str, d))}] = **{cap_roll} HD** â€¢ Item cap remaining: **{remaining_cap}**",
            effect_lines=[summary] + effect_lines,
            source=source,
            charges_text="Used today: **1/1**",
            color=0x2C3E50
        )
        embed.set_footer(text=f"{ctrl_txt}  â€¢  Item total now: **{post_cap}/18 HD**")
        await self._attach_char_identity(embed, caster_cfg, ctx)

        
        _set_idaily(caster_cfg, daily_key, 1)
        try:
            char_name = get_compat(caster_cfg, "info", "name", fallback=caster_name) or caster_name
            path = f"{char_name.replace(' ', '_')}.coe"
            write_cfg(path, caster_cfg)
        except Exception:
            pass

        
        try:
            bcfg = _load_battles()
            chan_id = str(ctx.channel.id)
            if bcfg and bcfg.has_section(chan_id):
                await self._refresh_tracker_message(ctx, bcfg, chan_id)
        except Exception:
            pass

        return embed


    def _hd_or_level_from_cfg(rcfg, path: str | None = None) -> int:
        """
        PCs/NPCs: return [cur].level if present.
        Monsters: if info.monster_type exists in the .coe, read monsters/<type>.ini [base].hd.
        Fallbacks to [stats].hd in .coe if set; otherwise 1.
        """
        try:
            lvl = getint_compat(rcfg, "cur", "level", fallback=None)
            info_cls = (get_compat(rcfg, "info", "class", fallback="") or "").strip().lower()
            info_race = (get_compat(rcfg, "info", "race", fallback="") or "").strip().lower()
            if lvl and (info_cls not in {"monster"} and info_race not in {"monster"}):
                return max(1, int(lvl))
        except Exception:
            pass

        try:
            mtype = (get_compat(rcfg, "info", "monster_type", fallback="") or "").strip()
            if mtype:
                hd = _monster_hd_from_type(mtype)
                if isinstance(hd, int) and hd > 0:
                    return hd
        except Exception:
            pass

        try:
            hd = getint_compat(rcfg, "stats", "hd", fallback=None)
            if isinstance(hd, int) and hd > 0:
                return hd
        except Exception:
            pass

        return 1


    async def _item_telekinesis(self, ctx, caster_cfg, caster_name, caster_level, tokens, owned_item: str | None = None):
        """
        Ring/Pendant of Telekinesis â€” as the spell, cast at 12th level.
        Optional: pass a custom duration roll like '1d6' or '1d6 turns' (GM tool).
          â€¢ !item telekinesis
          â€¢ !item telekinesis 1d6
          â€¢ !item telekinesis 1d6 turns
        """

        
        duration_roll = None
        if tokens:
            t0 = " ".join(tokens[:2]).strip()   
            m  = re.match(r"^\s*(\d+d\d+)(?:\s*turns?)?\s*$", t0, flags=re.I)
            if m:
                duration_roll = m.group(1) + " turns"

        
        out = await self._cast_telekinesis(
            ctx, caster_cfg, caster_name, 12, [],
            duration_roll=duration_roll
        )

        
        header, body = _normalize_effect_output(out)

        title  = f"{caster_name} uses **{owned_item or 'Telekinesis Item'}** â€” Telekinesis!"
        
        source = self._item_source_line(owned_item or "RingofTelekinesis", "â€” âˆž uses")

        embed = _build_item_embed(
            title,
            header_line=header or "No roll.",
            effect_lines=body or [],
            source=source,
            charges_text=None,            
            color=0x1ABC9C,               
        )
        await self._attach_char_identity(embed, caster_cfg, ctx)
        return embed




    async def _effect_resistcold(self, ctx, cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Resist Cold (Cleric/Druid/Spellcrafter 1)
        Duration: 1 round/level.
        Grants immunity to normal cold; magical/superior cold is halved (or 1/4 on a successful save).
        """
        lvl = max(1, int(caster_level or 1))
        rounds_total = lvl
        target_name = next((t for t in (tokens or []) if t and not t.startswith("-")), None) or caster_name
        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg2 = read_cfg(path)
                            real = get_compat(cfg2, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None
        tgt_disp, tgt_path = _resolve_ci(target_name)
        if not tgt_path:
            return f"â„ï¸ **Resist Cold**: {target_name}: *(not found)*"
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp or target_name) or (tgt_disp or target_name)
            try:
                s_key = _slot(key)
            except Exception:
                s_key = key.replace(" ", "_")
            base = f"{s_key}.x_resistcold"
            bcfg.set(chan_id, base, str(rounds_total))
            bcfg.set(chan_id, f"{base}_label", "Resist Cold")
            bcfg.set(chan_id, f"{base}_code", "RC")
            bcfg.set(chan_id, f"{base}_emoji", "â„ï¸")
            bcfg.set(chan_id, f"{base}_by", caster_name)
            _save_battles(bcfg)
            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
        return f"â„ï¸ **Resist Cold** active on **{tgt_disp or target_name}** â€” duration **{rounds_total} rounds**.\nImmune to *normal* cold; magical cold is **halved**, or **Â¼** on a successful save."

    async def _effect_resistfire(self, ctx, cfg, caster_name: str, caster_level: int, tokens: list[str]) -> str:
        """
        Resist Fire (Cleric/Druid/Spellcrafter 2)
        Duration: 1 round/level.
        Grants immunity to normal fire; magical/superior fire is halved (or 1/4 on a successful save).
        """
        lvl = max(1, int(caster_level or 1))
        rounds_total = lvl
        target_name = next((t for t in (tokens or []) if t and not t.startswith("-")), None) or caster_name
        def _resolve_ci(name: str):
            try:
                return self._resolve_char_ci(name)
            except Exception:
                base = name.replace(" ", "_").lower() + ".coe"
                for fn in os.listdir("."):
                    if fn.lower() == base:
                        path = fn
                        try:
                            cfg2 = read_cfg(path)
                            real = get_compat(cfg2, "info", "name", fallback=None)
                            return (real or fn[:-4].replace("_", " ")), path
                        except Exception:
                            return fn[:-4].replace("_", " "), path
                return None, None
        tgt_disp, tgt_path = _resolve_ci(target_name)
        if not tgt_path:
            return f"ðŸ”¥ **Resist Fire**: {target_name}: *(not found)*"
        chan_id = str(ctx.channel.id)
        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key = _find_ci_name(names, tgt_disp or target_name) or (tgt_disp or target_name)
            try:
                s_key = _slot(key)
            except Exception:
                s_key = key.replace(" ", "_")
            base = f"{s_key}.x_resistfire"
            bcfg.set(chan_id, base, str(rounds_total))
            bcfg.set(chan_id, f"{base}_label", "Resist Fire")
            bcfg.set(chan_id, f"{base}_code", "RF")
            bcfg.set(chan_id, f"{base}_emoji", "ðŸ”¥")
            bcfg.set(chan_id, f"{base}_by", caster_name)
            _save_battles(bcfg)
            try:
                msg_id = bcfg.getint(chan_id, "message_id", fallback=0)
                if msg_id:
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(msg_id)
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
        return f"ðŸ”¥ **Resist Fire** active on **{tgt_disp or target_name}** â€” duration **{rounds_total} rounds**.\nImmune to *normal* fire; magical fire is **halved**, or **Â¼** on a successful save."


    async def _effect_protectionfromfire(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Protection from Fire (Druid 3)
        Self: immune to normal & magical fire; absorbs 12/level magical fire, then ends. Lasts 1 turn/level if pool not used.
        Other: immune to normal fire; +4 to saves vs magical fire; on saveâ†’0 dmg, failâ†’Â¼ dmg. Lasts 1 turn/level.
        """
        tgt_arg = (tokens[0] if tokens else caster_name)
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_arg)
        except Exception:
            tgt_disp, tgt_path = tgt_arg, None
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]

        lvl    = max(1, int(caster_level or 1))
        rounds = 60 * lvl
        self_mode = (tgt_disp.strip().lower() == (caster_name or "").strip().lower())
        lines = [f"ðŸ”¥ **Protection from Fire** on **{tgt_disp}** â€” duration **{rounds} rounds**."]

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        chan_id = str(getattr(ctx.channel, "id", ""))
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key  = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.pff", str(rounds))

            if self_mode:
                pool = 12 * lvl
                bcfg.set(chan_id, f"{slot}.pff_self", "1")
                bcfg.set(chan_id, f"{slot}.pff_pool", str(pool))
                lines.append(f"â€¢ Self mode: **magical fire absorption {pool}**; normal fire **immune**.")
                tag_code = "PF"
                emoji = "ðŸ”¥"
                bcfg.set(chan_id, f"{slot}.x_protectionfromfire", str(rounds))
                bcfg.set(chan_id, f"{slot}.x_protectionfromfire_code",  tag_code)
                bcfg.set(chan_id, f"{slot}.x_protectionfromfire_label", "Protection from Fire")
                bcfg.set(chan_id, f"{slot}.x_protectionfromfire_emoji", emoji)
                bcfg.set(chan_id, f"{slot}.x_protectionfromfire_by",    caster_name)
            else:
                bcfg.set(chan_id, f"{slot}.pff_other", "1")
                lines.append("â€¢ Other mode: **immune to normal fire**; **+4** to saves vs magical fire; "
                             "**0** dmg on save, **Â¼** dmg on fail.")

            _save_battles(bcfg)
            try:
                if bcfg.getint(chan_id, "message_id", fallback=0):
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(bcfg.getint(chan_id, "message_id", fallback=0))
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
        else:
            lines.append("Applied (no active battle to show countdown/tag).")

        return lines


    async def _effect_protectionfromlightning(self, ctx, caster_cfg, caster_name: str, caster_level: int, tokens: list[str]):
        """
        Protection from Lightning (Druid 4 / Spellcrafter 4)
        Same semantics as Protection from Fire, but for lightning/electric.
        """
        tgt_arg = (tokens[0] if tokens else caster_name)
        try:
            tgt_disp, tgt_path = self._resolve_char_ci(tgt_arg)
        except Exception:
            tgt_disp, tgt_path = tgt_arg, None
        if not tgt_path:
            return [f"âŒ Target **{tgt_arg}** not found."]

        lvl    = max(1, int(caster_level or 1))
        rounds = 60 * lvl
        self_mode = (tgt_disp.strip().lower() == (caster_name or "").strip().lower())
        lines = [f"âš¡ **Protection from Lightning** on **{tgt_disp}** â€” duration **{rounds} rounds**."]

        try:
            bcfg = _load_battles()
        except Exception:
            bcfg = None

        chan_id = str(getattr(ctx.channel, "id", ""))
        if bcfg and bcfg.has_section(chan_id):
            names, _ = _parse_combatants(bcfg, chan_id)
            key  = _find_ci_name(names, tgt_disp) or tgt_disp
            try:
                slot = _slot(key)
            except Exception:
                slot = key.replace(" ", "_")

            bcfg.set(chan_id, f"{slot}.pfl", str(rounds))

            if self_mode:
                pool = 12 * lvl
                bcfg.set(chan_id, f"{slot}.pfl_self", "1")
                bcfg.set(chan_id, f"{slot}.pfl_pool", str(pool))
                lines.append(f"â€¢ Self mode: **magical lightning absorption {pool}**; normal lightning **immune**.")
                tag_code = "PL"
                emoji = "âš¡"
                bcfg.set(chan_id, f"{slot}.x_protectionfromlightning", str(rounds))
                bcfg.set(chan_id, f"{slot}.x_protectionfromlightning_code",  tag_code)
                bcfg.set(chan_id, f"{slot}.x_protectionfromlightning_label", "Protection from Lightning")
                bcfg.set(chan_id, f"{slot}.x_protectionfromlightning_emoji", emoji)
                bcfg.set(chan_id, f"{slot}.x_protectionfromlightning_by",    caster_name)
            else:
                bcfg.set(chan_id, f"{slot}.pfl_other", "1")
                lines.append("â€¢ Other mode: **immune to normal lightning**; **+4** to saves vs magical lightning; "
                             "**0** dmg on save, **Â¼** dmg on fail.")

            _save_battles(bcfg)
            try:
                if bcfg.getint(chan_id, "message_id", fallback=0):
                    block = _format_tracker_block(bcfg, chan_id)
                    msg = await ctx.channel.fetch_message(bcfg.getint(chan_id, "message_id", fallback=0))
                    await msg.edit(content="**EVERYONE ROLL FOR INITIATIVE!**\n```text\n" + block + "\n```")
            except Exception:
                pass
        else:
            lines.append("Applied (no active battle to show countdown/tag).")

        return lines


    def _rc_rf_save_bonus(self, t_cfg, chan_id: str, target_name: str, elem: str) -> int:
        """
        +3 to saves vs magical fire/cold when wearing *â€¦ofFireResistance / â€¦ofColdResistance*
        or a timer like x_fireresistance / x_coldresistance is active.
        """
        elem = (elem or "").lower()
        if elem not in {"fire", "cold"}:
            return 0

        try:
            if t_cfg and t_cfg.has_section("eq"):
                for _k, _v in t_cfg.items("eq"):
                    nm = (str(_v) or "").lower().replace(" ", "")
                    if elem == "fire" and "fireresistance" in nm:
                        return 3
                    if elem == "cold" and "coldresistance" in nm:
                        return 3
        except Exception:
            pass

        try:
            bcfg = _load_battles()
            if bcfg and bcfg.has_section(chan_id):
                names, _ = _parse_combatants(bcfg, chan_id)
                key = _find_ci_name(names, target_name) or target_name
                try:
                    s = _slot(key)
                except Exception:
                    s = key.replace(" ", "_")
                for k in (
                    f"{s}.x_{elem}resistance",   
                    f"{s}.x_resist{elem}",       
                ):
                    if bcfg.getint(chan_id, k, fallback=0) > 0:
                        return 3
        except Exception:
            pass

        return 0


    def _pf_other_save_bonus(self, chan_id: str, target_name: str, elem: str) -> int:
        """
        +4 to saves vs magical fire/lightning when under ProtectionFromFire/Lightning (cast on *others*).
        We assume self-mode sets <s>.pff_pool / <s>.pfl_pool and <s>.pff_self / <s>.pfl_self,
        while other-mode sets a rounds counter <s>.pff / <s>.pfl without *_self or *_pool.
        """
        elem = (elem or "").lower()
        if elem not in {"fire", "electric", "lightning"}:
            return 0

        key = "pff" if elem == "fire" else "pfl"
        try:
            bcfg = _load_battles()
            if not (bcfg and bcfg.has_section(chan_id)):
                return 0
            names, _ = _parse_combatants(bcfg, chan_id)
            key_name = _find_ci_name(names, target_name) or target_name
            try:
                s = _slot(key_name)
            except Exception:
                s = key_name.replace(" ", "_")

            rounds = bcfg.getint(chan_id, f"{s}.{key}", fallback=0)
            pool   = bcfg.getint(chan_id, f"{s}.{key}_pool", fallback=0)
            self_f = bcfg.getint(chan_id, f"{s}.{key}_self", fallback=0)

            if rounds > 0 and pool <= 0 and self_f <= 0:
                return 4
        except Exception:
            pass
        return 0


    def _pf_other_damage_override(self, base_dmg: int, save_succeeds: bool,
                                  chan_id: str, target_name: str, elem: str) -> int | None:
        """
        For PFF/PFL in *other-mode*: if save succeeds â†’ 0; if fails â†’ 1/4 damage.
        Return None if the effect isn't active (so caller can apply normal half/whole).
        """
        elem = (elem or "").lower()
        if elem not in {"fire", "electric", "lightning"}:
            return None
        key = "pff" if elem == "fire" else "pfl"
        try:
            bcfg = _load_battles()
            if not (bcfg and bcfg.has_section(chan_id)):
                return None
            names, _ = _parse_combatants(bcfg, chan_id)
            key_name = _find_ci_name(names, target_name) or target_name
            try:
                s = _slot(key_name)
            except Exception:
                s = key_name.replace(" ", "_")

            rounds = bcfg.getint(chan_id, f"{s}.{key}", fallback=0)
            pool   = bcfg.getint(chan_id, f"{s}.{key}_pool", fallback=0)
            self_f = bcfg.getint(chan_id, f"{s}.{key}_self", fallback=0)

            if rounds > 0 and pool <= 0 and self_f <= 0:
                return 0 if save_succeeds else max(0, base_dmg // 4)
        except Exception:
            pass
        return None


def setup(bot):
    bot.add_cog(SpellsCog(bot))
